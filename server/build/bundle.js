/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 80);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = __webpack_require__(90);
} else {
  module.exports = __webpack_require__(91);
}


/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * depd
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var callSiteToString = __webpack_require__(45).callSiteToString
var eventListenerCount = __webpack_require__(45).eventListenerCount
var relative = __webpack_require__(2).relative

/**
 * Module exports.
 */

module.exports = depd

/**
 * Get the path to base files on.
 */

var basePath = process.cwd()

/**
 * Determine if namespace is contained in the string.
 */

function containsNamespace (str, namespace) {
  var vals = str.split(/[ ,]+/)
  var ns = String(namespace).toLowerCase()

  for (var i = 0; i < vals.length; i++) {
    var val = vals[i]

    // namespace contained
    if (val && (val === '*' || val.toLowerCase() === ns)) {
      return true
    }
  }

  return false
}

/**
 * Convert a data descriptor to accessor descriptor.
 */

function convertDataDescriptorToAccessor (obj, prop, message) {
  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)
  var value = descriptor.value

  descriptor.get = function getter () { return value }

  if (descriptor.writable) {
    descriptor.set = function setter (val) { return (value = val) }
  }

  delete descriptor.value
  delete descriptor.writable

  Object.defineProperty(obj, prop, descriptor)

  return descriptor
}

/**
 * Create arguments string to keep arity.
 */

function createArgumentsString (arity) {
  var str = ''

  for (var i = 0; i < arity; i++) {
    str += ', arg' + i
  }

  return str.substr(2)
}

/**
 * Create stack string from stack.
 */

function createStackString (stack) {
  var str = this.name + ': ' + this.namespace

  if (this.message) {
    str += ' deprecated ' + this.message
  }

  for (var i = 0; i < stack.length; i++) {
    str += '\n    at ' + callSiteToString(stack[i])
  }

  return str
}

/**
 * Create deprecate for namespace in caller.
 */

function depd (namespace) {
  if (!namespace) {
    throw new TypeError('argument namespace is required')
  }

  var stack = getStack()
  var site = callSiteLocation(stack[1])
  var file = site[0]

  function deprecate (message) {
    // call to self as log
    log.call(deprecate, message)
  }

  deprecate._file = file
  deprecate._ignored = isignored(namespace)
  deprecate._namespace = namespace
  deprecate._traced = istraced(namespace)
  deprecate._warned = Object.create(null)

  deprecate.function = wrapfunction
  deprecate.property = wrapproperty

  return deprecate
}

/**
 * Determine if namespace is ignored.
 */

function isignored (namespace) {
  /* istanbul ignore next: tested in a child processs */
  if (process.noDeprecation) {
    // --no-deprecation support
    return true
  }

  var str = process.env.NO_DEPRECATION || ''

  // namespace ignored
  return containsNamespace(str, namespace)
}

/**
 * Determine if namespace is traced.
 */

function istraced (namespace) {
  /* istanbul ignore next: tested in a child processs */
  if (process.traceDeprecation) {
    // --trace-deprecation support
    return true
  }

  var str = process.env.TRACE_DEPRECATION || ''

  // namespace traced
  return containsNamespace(str, namespace)
}

/**
 * Display deprecation message.
 */

function log (message, site) {
  var haslisteners = eventListenerCount(process, 'deprecation') !== 0

  // abort early if no destination
  if (!haslisteners && this._ignored) {
    return
  }

  var caller
  var callFile
  var callSite
  var depSite
  var i = 0
  var seen = false
  var stack = getStack()
  var file = this._file

  if (site) {
    // provided site
    depSite = site
    callSite = callSiteLocation(stack[1])
    callSite.name = depSite.name
    file = callSite[0]
  } else {
    // get call site
    i = 2
    depSite = callSiteLocation(stack[i])
    callSite = depSite
  }

  // get caller of deprecated thing in relation to file
  for (; i < stack.length; i++) {
    caller = callSiteLocation(stack[i])
    callFile = caller[0]

    if (callFile === file) {
      seen = true
    } else if (callFile === this._file) {
      file = this._file
    } else if (seen) {
      break
    }
  }

  var key = caller
    ? depSite.join(':') + '__' + caller.join(':')
    : undefined

  if (key !== undefined && key in this._warned) {
    // already warned
    return
  }

  this._warned[key] = true

  // generate automatic message from call site
  var msg = message
  if (!msg) {
    msg = callSite === depSite || !callSite.name
      ? defaultMessage(depSite)
      : defaultMessage(callSite)
  }

  // emit deprecation if listeners exist
  if (haslisteners) {
    var err = DeprecationError(this._namespace, msg, stack.slice(i))
    process.emit('deprecation', err)
    return
  }

  // format and write message
  var format = process.stderr.isTTY
    ? formatColor
    : formatPlain
  var output = format.call(this, msg, caller, stack.slice(i))
  process.stderr.write(output + '\n', 'utf8')
}

/**
 * Get call site location as array.
 */

function callSiteLocation (callSite) {
  var file = callSite.getFileName() || '<anonymous>'
  var line = callSite.getLineNumber()
  var colm = callSite.getColumnNumber()

  if (callSite.isEval()) {
    file = callSite.getEvalOrigin() + ', ' + file
  }

  var site = [file, line, colm]

  site.callSite = callSite
  site.name = callSite.getFunctionName()

  return site
}

/**
 * Generate a default message from the site.
 */

function defaultMessage (site) {
  var callSite = site.callSite
  var funcName = site.name

  // make useful anonymous name
  if (!funcName) {
    funcName = '<anonymous@' + formatLocation(site) + '>'
  }

  var context = callSite.getThis()
  var typeName = context && callSite.getTypeName()

  // ignore useless type name
  if (typeName === 'Object') {
    typeName = undefined
  }

  // make useful type name
  if (typeName === 'Function') {
    typeName = context.name || typeName
  }

  return typeName && callSite.getMethodName()
    ? typeName + '.' + funcName
    : funcName
}

/**
 * Format deprecation message without color.
 */

function formatPlain (msg, caller, stack) {
  var timestamp = new Date().toUTCString()

  var formatted = timestamp +
    ' ' + this._namespace +
    ' deprecated ' + msg

  // add stack trace
  if (this._traced) {
    for (var i = 0; i < stack.length; i++) {
      formatted += '\n    at ' + callSiteToString(stack[i])
    }

    return formatted
  }

  if (caller) {
    formatted += ' at ' + formatLocation(caller)
  }

  return formatted
}

/**
 * Format deprecation message with color.
 */

function formatColor (msg, caller, stack) {
  var formatted = '\x1b[36;1m' + this._namespace + '\x1b[22;39m' + // bold cyan
    ' \x1b[33;1mdeprecated\x1b[22;39m' + // bold yellow
    ' \x1b[0m' + msg + '\x1b[39m' // reset

  // add stack trace
  if (this._traced) {
    for (var i = 0; i < stack.length; i++) {
      formatted += '\n    \x1b[36mat ' + callSiteToString(stack[i]) + '\x1b[39m' // cyan
    }

    return formatted
  }

  if (caller) {
    formatted += ' \x1b[36m' + formatLocation(caller) + '\x1b[39m' // cyan
  }

  return formatted
}

/**
 * Format call site location.
 */

function formatLocation (callSite) {
  return relative(basePath, callSite[0]) +
    ':' + callSite[1] +
    ':' + callSite[2]
}

/**
 * Get the stack as array of call sites.
 */

function getStack () {
  var limit = Error.stackTraceLimit
  var obj = {}
  var prep = Error.prepareStackTrace

  Error.prepareStackTrace = prepareObjectStackTrace
  Error.stackTraceLimit = Math.max(10, limit)

  // capture the stack
  Error.captureStackTrace(obj)

  // slice this function off the top
  var stack = obj.stack.slice(1)

  Error.prepareStackTrace = prep
  Error.stackTraceLimit = limit

  return stack
}

/**
 * Capture call site stack from v8.
 */

function prepareObjectStackTrace (obj, stack) {
  return stack
}

/**
 * Return a wrapped function in a deprecation message.
 */

function wrapfunction (fn, message) {
  if (typeof fn !== 'function') {
    throw new TypeError('argument fn must be a function')
  }

  var args = createArgumentsString(fn.length)
  var deprecate = this // eslint-disable-line no-unused-vars
  var stack = getStack()
  var site = callSiteLocation(stack[1])

  site.name = fn.name

   // eslint-disable-next-line no-eval
  var deprecatedfn = eval('(function (' + args + ') {\n' +
    '"use strict"\n' +
    'log.call(deprecate, message, site)\n' +
    'return fn.apply(this, arguments)\n' +
    '})')

  return deprecatedfn
}

/**
 * Wrap property in a deprecation message.
 */

function wrapproperty (obj, prop, message) {
  if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
    throw new TypeError('argument obj must be object')
  }

  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)

  if (!descriptor) {
    throw new TypeError('must call property on owner object')
  }

  if (!descriptor.configurable) {
    throw new TypeError('property must be configurable')
  }

  var deprecate = this
  var stack = getStack()
  var site = callSiteLocation(stack[1])

  // set site name
  site.name = prop

  // convert data descriptor
  if ('value' in descriptor) {
    descriptor = convertDataDescriptorToAccessor(obj, prop, message)
  }

  var get = descriptor.get
  var set = descriptor.set

  // wrap getter
  if (typeof get === 'function') {
    descriptor.get = function getter () {
      log.call(deprecate, message, site)
      return get.apply(this, arguments)
    }
  }

  // wrap setter
  if (typeof set === 'function') {
    descriptor.set = function setter () {
      log.call(deprecate, message, site)
      return set.apply(this, arguments)
    }
  }

  Object.defineProperty(obj, prop, descriptor)
}

/**
 * Create DeprecationError for deprecation
 */

function DeprecationError (namespace, message, stack) {
  var error = new Error()
  var stackString

  Object.defineProperty(error, 'constructor', {
    value: DeprecationError
  })

  Object.defineProperty(error, 'message', {
    configurable: true,
    enumerable: false,
    value: message,
    writable: true
  })

  Object.defineProperty(error, 'name', {
    enumerable: false,
    configurable: true,
    value: 'DeprecationError',
    writable: true
  })

  Object.defineProperty(error, 'namespace', {
    configurable: true,
    enumerable: false,
    value: namespace,
    writable: true
  })

  Object.defineProperty(error, 'stack', {
    configurable: true,
    enumerable: false,
    get: function () {
      if (stackString !== undefined) {
        return stackString
      }

      // prepare stack trace
      return (stackString = createStackString.call(this, stack))
    },
    set: function setter (val) {
      stackString = val
    }
  })

  return error
}


/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @api private
 */

var Buffer = __webpack_require__(58).Buffer
var contentDisposition = __webpack_require__(59);
var contentType = __webpack_require__(19);
var deprecate = __webpack_require__(5)('express');
var flatten = __webpack_require__(29);
var mime = __webpack_require__(40).mime;
var etag = __webpack_require__(60);
var proxyaddr = __webpack_require__(63);
var qs = __webpack_require__(38);
var querystring = __webpack_require__(26);

/**
 * Return strong ETag for `body`.
 *
 * @param {String|Buffer} body
 * @param {String} [encoding]
 * @return {String}
 * @api private
 */

exports.etag = createETagGenerator({ weak: false })

/**
 * Return weak ETag for `body`.
 *
 * @param {String|Buffer} body
 * @param {String} [encoding]
 * @return {String}
 * @api private
 */

exports.wetag = createETagGenerator({ weak: true })

/**
 * Check if `path` looks absolute.
 *
 * @param {String} path
 * @return {Boolean}
 * @api private
 */

exports.isAbsolute = function(path){
  if ('/' === path[0]) return true;
  if (':' === path[1] && ('\\' === path[2] || '/' === path[2])) return true; // Windows device path
  if ('\\\\' === path.substring(0, 2)) return true; // Microsoft Azure absolute path
};

/**
 * Flatten the given `arr`.
 *
 * @param {Array} arr
 * @return {Array}
 * @api private
 */

exports.flatten = deprecate.function(flatten,
  'utils.flatten: use array-flatten npm module instead');

/**
 * Normalize the given `type`, for example "html" becomes "text/html".
 *
 * @param {String} type
 * @return {Object}
 * @api private
 */

exports.normalizeType = function(type){
  return ~type.indexOf('/')
    ? acceptParams(type)
    : { value: mime.lookup(type), params: {} };
};

/**
 * Normalize `types`, for example "html" becomes "text/html".
 *
 * @param {Array} types
 * @return {Array}
 * @api private
 */

exports.normalizeTypes = function(types){
  var ret = [];

  for (var i = 0; i < types.length; ++i) {
    ret.push(exports.normalizeType(types[i]));
  }

  return ret;
};

/**
 * Generate Content-Disposition header appropriate for the filename.
 * non-ascii filenames are urlencoded and a filename* parameter is added
 *
 * @param {String} filename
 * @return {String}
 * @api private
 */

exports.contentDisposition = deprecate.function(contentDisposition,
  'utils.contentDisposition: use content-disposition npm module instead');

/**
 * Parse accept params `str` returning an
 * object with `.value`, `.quality` and `.params`.
 * also includes `.originalIndex` for stable sorting
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function acceptParams(str, index) {
  var parts = str.split(/ *; */);
  var ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };

  for (var i = 1; i < parts.length; ++i) {
    var pms = parts[i].split(/ *= */);
    if ('q' === pms[0]) {
      ret.quality = parseFloat(pms[1]);
    } else {
      ret.params[pms[0]] = pms[1];
    }
  }

  return ret;
}

/**
 * Compile "etag" value to function.
 *
 * @param  {Boolean|String|Function} val
 * @return {Function}
 * @api private
 */

exports.compileETag = function(val) {
  var fn;

  if (typeof val === 'function') {
    return val;
  }

  switch (val) {
    case true:
      fn = exports.wetag;
      break;
    case false:
      break;
    case 'strong':
      fn = exports.etag;
      break;
    case 'weak':
      fn = exports.wetag;
      break;
    default:
      throw new TypeError('unknown value for etag function: ' + val);
  }

  return fn;
}

/**
 * Compile "query parser" value to function.
 *
 * @param  {String|Function} val
 * @return {Function}
 * @api private
 */

exports.compileQueryParser = function compileQueryParser(val) {
  var fn;

  if (typeof val === 'function') {
    return val;
  }

  switch (val) {
    case true:
      fn = querystring.parse;
      break;
    case false:
      fn = newObject;
      break;
    case 'extended':
      fn = parseExtendedQueryString;
      break;
    case 'simple':
      fn = querystring.parse;
      break;
    default:
      throw new TypeError('unknown value for query parser function: ' + val);
  }

  return fn;
}

/**
 * Compile "proxy trust" value to function.
 *
 * @param  {Boolean|String|Number|Array|Function} val
 * @return {Function}
 * @api private
 */

exports.compileTrust = function(val) {
  if (typeof val === 'function') return val;

  if (val === true) {
    // Support plain true/false
    return function(){ return true };
  }

  if (typeof val === 'number') {
    // Support trusting hop count
    return function(a, i){ return i < val };
  }

  if (typeof val === 'string') {
    // Support comma-separated values
    val = val.split(/ *, */);
  }

  return proxyaddr.compile(val || []);
}

/**
 * Set the charset in a given Content-Type string.
 *
 * @param {String} type
 * @param {String} charset
 * @return {String}
 * @api private
 */

exports.setCharset = function setCharset(type, charset) {
  if (!type || !charset) {
    return type;
  }

  // parse type
  var parsed = contentType.parse(type);

  // set charset
  parsed.parameters.charset = charset;

  // format type
  return contentType.format(parsed);
};

/**
 * Create an ETag generator function, generating ETags with
 * the given options.
 *
 * @param {object} options
 * @return {function}
 * @private
 */

function createETagGenerator (options) {
  return function generateETag (body, encoding) {
    var buf = !Buffer.isBuffer(body)
      ? Buffer.from(body, encoding)
      : body

    return etag(buf, options)
  }
}

/**
 * Parse an extended query string with qs.
 *
 * @return {Object}
 * @private
 */

function parseExtendedQueryString(str) {
  return qs.parse(str, {
    allowPrototypes: true
  });
}

/**
 * Return new empty object.
 *
 * @return {Object}
 * @api private
 */

function newObject() {
  return {};
}


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint-disable node/no-deprecated-api */



var buffer = __webpack_require__(10)
var Buffer = buffer.Buffer

var safer = {}

var key

for (key in buffer) {
  if (!buffer.hasOwnProperty(key)) continue
  if (key === 'SlowBuffer' || key === 'Buffer') continue
  safer[key] = buffer[key]
}

var Safer = safer.Buffer = {}
for (key in Buffer) {
  if (!Buffer.hasOwnProperty(key)) continue
  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue
  Safer[key] = Buffer[key]
}

safer.Buffer.prototype = Buffer.prototype

if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function (value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
    }
    if (value && typeof value.length === 'undefined') {
      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
    }
    return Buffer(value, encodingOrOffset, length)
  }
}

if (!Safer.alloc) {
  Safer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
    var buf = Buffer(size)
    if (!fill || fill.length === 0) {
      buf.fill(0)
    } else if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
    return buf
  }
}

if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength
  } catch (e) {
    // we can't determine kStringMaxLength in environments where process.binding
    // is unsupported, so let's not set it
  }
}

if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  }
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength
  }
}

module.exports = safer


/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("buffer");

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = bytes;
module.exports.format = format;
module.exports.parse = parse;

/**
 * Module variables.
 * @private
 */

var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;

var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;

var map = {
  b:  1,
  kb: 1 << 10,
  mb: 1 << 20,
  gb: 1 << 30,
  tb: ((1 << 30) * 1024)
};

var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb)$/i;

/**
 * Convert the given value in bytes into a string or parse to string to an integer in bytes.
 *
 * @param {string|number} value
 * @param {{
 *  case: [string],
 *  decimalPlaces: [number]
 *  fixedDecimals: [boolean]
 *  thousandsSeparator: [string]
 *  unitSeparator: [string]
 *  }} [options] bytes options.
 *
 * @returns {string|number|null}
 */

function bytes(value, options) {
  if (typeof value === 'string') {
    return parse(value);
  }

  if (typeof value === 'number') {
    return format(value, options);
  }

  return null;
}

/**
 * Format the given value in bytes into a string.
 *
 * If the value is negative, it is kept as such. If it is a float,
 * it is rounded.
 *
 * @param {number} value
 * @param {object} [options]
 * @param {number} [options.decimalPlaces=2]
 * @param {number} [options.fixedDecimals=false]
 * @param {string} [options.thousandsSeparator=]
 * @param {string} [options.unit=]
 * @param {string} [options.unitSeparator=]
 *
 * @returns {string|null}
 * @public
 */

function format(value, options) {
  if (!Number.isFinite(value)) {
    return null;
  }

  var mag = Math.abs(value);
  var thousandsSeparator = (options && options.thousandsSeparator) || '';
  var unitSeparator = (options && options.unitSeparator) || '';
  var decimalPlaces = (options && options.decimalPlaces !== undefined) ? options.decimalPlaces : 2;
  var fixedDecimals = Boolean(options && options.fixedDecimals);
  var unit = (options && options.unit) || '';

  if (!unit || !map[unit.toLowerCase()]) {
    if (mag >= map.tb) {
      unit = 'TB';
    } else if (mag >= map.gb) {
      unit = 'GB';
    } else if (mag >= map.mb) {
      unit = 'MB';
    } else if (mag >= map.kb) {
      unit = 'KB';
    } else {
      unit = 'B';
    }
  }

  var val = value / map[unit.toLowerCase()];
  var str = val.toFixed(decimalPlaces);

  if (!fixedDecimals) {
    str = str.replace(formatDecimalsRegExp, '$1');
  }

  if (thousandsSeparator) {
    str = str.replace(formatThousandsRegExp, thousandsSeparator);
  }

  return str + unitSeparator + unit;
}

/**
 * Parse the string value into an integer in bytes.
 *
 * If no unit is given, it is assumed the value is in bytes.
 *
 * @param {number|string} val
 *
 * @returns {number|null}
 * @public
 */

function parse(val) {
  if (typeof val === 'number' && !isNaN(val)) {
    return val;
  }

  if (typeof val !== 'string') {
    return null;
  }

  // Test if the string passed is valid
  var results = parseRegExp.exec(val);
  var floatValue;
  var unit = 'b';

  if (!results) {
    // Nothing could be extracted from the given string
    floatValue = parseInt(val, 10);
    unit = 'b'
  } else {
    // Retrieve the value and the unit
    floatValue = parseFloat(results[1]);
    unit = results[4].toLowerCase();
  }

  return Math.floor(map[unit] * floatValue);
}


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var deprecate = __webpack_require__(5)('http-errors')
var setPrototypeOf = __webpack_require__(20)
var statuses = __webpack_require__(21)
var inherits = __webpack_require__(88)

/**
 * Module exports.
 * @public
 */

module.exports = createError
module.exports.HttpError = createHttpErrorConstructor()

// Populate exports for all constructors
populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError)

/**
 * Get the code class of a status code.
 * @private
 */

function codeClass (status) {
  return Number(String(status).charAt(0) + '00')
}

/**
 * Create a new HTTP Error.
 *
 * @returns {Error}
 * @public
 */

function createError () {
  // so much arity going on ~_~
  var err
  var msg
  var status = 500
  var props = {}
  for (var i = 0; i < arguments.length; i++) {
    var arg = arguments[i]
    if (arg instanceof Error) {
      err = arg
      status = err.status || err.statusCode || status
      continue
    }
    switch (typeof arg) {
      case 'string':
        msg = arg
        break
      case 'number':
        status = arg
        if (i !== 0) {
          deprecate('non-first-argument status code; replace with createError(' + arg + ', ...)')
        }
        break
      case 'object':
        props = arg
        break
    }
  }

  if (typeof status === 'number' && (status < 400 || status >= 600)) {
    deprecate('non-error status code; use only 4xx or 5xx status codes')
  }

  if (typeof status !== 'number' ||
    (!statuses[status] && (status < 400 || status >= 600))) {
    status = 500
  }

  // constructor
  var HttpError = createError[status] || createError[codeClass(status)]

  if (!err) {
    // create error
    err = HttpError
      ? new HttpError(msg)
      : new Error(msg || statuses[status])
    Error.captureStackTrace(err, createError)
  }

  if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
    // add properties to generic error
    err.expose = status < 500
    err.status = err.statusCode = status
  }

  for (var key in props) {
    if (key !== 'status' && key !== 'statusCode') {
      err[key] = props[key]
    }
  }

  return err
}

/**
 * Create HTTP error abstract base class.
 * @private
 */

function createHttpErrorConstructor () {
  function HttpError () {
    throw new TypeError('cannot construct abstract class')
  }

  inherits(HttpError, Error)

  return HttpError
}

/**
 * Create a constructor for a client error.
 * @private
 */

function createClientErrorConstructor (HttpError, name, code) {
  var className = name.match(/Error$/) ? name : name + 'Error'

  function ClientError (message) {
    // create the error object
    var msg = message != null ? message : statuses[code]
    var err = new Error(msg)

    // capture a stack trace to the construction point
    Error.captureStackTrace(err, ClientError)

    // adjust the [[Prototype]]
    setPrototypeOf(err, ClientError.prototype)

    // redefine the error message
    Object.defineProperty(err, 'message', {
      enumerable: true,
      configurable: true,
      value: msg,
      writable: true
    })

    // redefine the error name
    Object.defineProperty(err, 'name', {
      enumerable: false,
      configurable: true,
      value: className,
      writable: true
    })

    return err
  }

  inherits(ClientError, HttpError)

  ClientError.prototype.status = code
  ClientError.prototype.statusCode = code
  ClientError.prototype.expose = true

  return ClientError
}

/**
 * Create a constructor for a server error.
 * @private
 */

function createServerErrorConstructor (HttpError, name, code) {
  var className = name.match(/Error$/) ? name : name + 'Error'

  function ServerError (message) {
    // create the error object
    var msg = message != null ? message : statuses[code]
    var err = new Error(msg)

    // capture a stack trace to the construction point
    Error.captureStackTrace(err, ServerError)

    // adjust the [[Prototype]]
    setPrototypeOf(err, ServerError.prototype)

    // redefine the error message
    Object.defineProperty(err, 'message', {
      enumerable: true,
      configurable: true,
      value: msg,
      writable: true
    })

    // redefine the error name
    Object.defineProperty(err, 'name', {
      enumerable: false,
      configurable: true,
      value: className,
      writable: true
    })

    return err
  }

  inherits(ServerError, HttpError)

  ServerError.prototype.status = code
  ServerError.prototype.statusCode = code
  ServerError.prototype.expose = false

  return ServerError
}

/**
 * Populate the exports object with constructors for every error class.
 * @private
 */

function populateConstructorExports (exports, codes, HttpError) {
  codes.forEach(function forEachCode (code) {
    var CodeError
    var name = toIdentifier(statuses[code])

    switch (codeClass(code)) {
      case 400:
        CodeError = createClientErrorConstructor(HttpError, name, code)
        break
      case 500:
        CodeError = createServerErrorConstructor(HttpError, name, code)
        break
    }

    if (CodeError) {
      // export the constructor
      exports[code] = CodeError
      exports[name] = CodeError
    }
  })

  // backwards-compatibility
  exports["I'mateapot"] = deprecate.function(exports.ImATeapot,
    '"I\'mateapot"; use "ImATeapot" instead')
}

/**
 * Convert a string of words to a JavaScript identifier.
 * @private
 */

function toIdentifier (str) {
  return str.split(' ').map(function (token) {
    return token.slice(0, 1).toUpperCase() + token.slice(1)
  }).join('').replace(/[^ _0-9a-z]/gi, '')
}


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var typer = __webpack_require__(112)
var mime = __webpack_require__(51)

/**
 * Module exports.
 * @public
 */

module.exports = typeofrequest
module.exports.is = typeis
module.exports.hasBody = hasbody
module.exports.normalize = normalize
module.exports.match = mimeMatch

/**
 * Compare a `value` content-type with `types`.
 * Each `type` can be an extension like `html`,
 * a special shortcut like `multipart` or `urlencoded`,
 * or a mime type.
 *
 * If no types match, `false` is returned.
 * Otherwise, the first `type` that matches is returned.
 *
 * @param {String} value
 * @param {Array} types
 * @public
 */

function typeis (value, types_) {
  var i
  var types = types_

  // remove parameters and normalize
  var val = tryNormalizeType(value)

  // no type or invalid
  if (!val) {
    return false
  }

  // support flattened arguments
  if (types && !Array.isArray(types)) {
    types = new Array(arguments.length - 1)
    for (i = 0; i < types.length; i++) {
      types[i] = arguments[i + 1]
    }
  }

  // no types, return the content type
  if (!types || !types.length) {
    return val
  }

  var type
  for (i = 0; i < types.length; i++) {
    if (mimeMatch(normalize(type = types[i]), val)) {
      return type[0] === '+' || type.indexOf('*') !== -1
        ? val
        : type
    }
  }

  // no matches
  return false
}

/**
 * Check if a request has a request body.
 * A request with a body __must__ either have `transfer-encoding`
 * or `content-length` headers set.
 * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
 *
 * @param {Object} request
 * @return {Boolean}
 * @public
 */

function hasbody (req) {
  return req.headers['transfer-encoding'] !== undefined ||
    !isNaN(req.headers['content-length'])
}

/**
 * Check if the incoming request contains the "Content-Type"
 * header field, and it contains any of the give mime `type`s.
 * If there is no request body, `null` is returned.
 * If there is no content type, `false` is returned.
 * Otherwise, it returns the first `type` that matches.
 *
 * Examples:
 *
 *     // With Content-Type: text/html; charset=utf-8
 *     this.is('html'); // => 'html'
 *     this.is('text/html'); // => 'text/html'
 *     this.is('text/*', 'application/json'); // => 'text/html'
 *
 *     // When Content-Type is application/json
 *     this.is('json', 'urlencoded'); // => 'json'
 *     this.is('application/json'); // => 'application/json'
 *     this.is('html', 'application/*'); // => 'application/json'
 *
 *     this.is('html'); // => false
 *
 * @param {String|Array} types...
 * @return {String|false|null}
 * @public
 */

function typeofrequest (req, types_) {
  var types = types_

  // no body
  if (!hasbody(req)) {
    return null
  }

  // support flattened arguments
  if (arguments.length > 2) {
    types = new Array(arguments.length - 1)
    for (var i = 0; i < types.length; i++) {
      types[i] = arguments[i + 1]
    }
  }

  // request content type
  var value = req.headers['content-type']

  return typeis(value, types)
}

/**
 * Normalize a mime type.
 * If it's a shorthand, expand it to a valid mime type.
 *
 * In general, you probably want:
 *
 *   var type = is(req, ['urlencoded', 'json', 'multipart']);
 *
 * Then use the appropriate body parsers.
 * These three are the most common request body types
 * and are thus ensured to work.
 *
 * @param {String} type
 * @private
 */

function normalize (type) {
  if (typeof type !== 'string') {
    // invalid type
    return false
  }

  switch (type) {
    case 'urlencoded':
      return 'application/x-www-form-urlencoded'
    case 'multipart':
      return 'multipart/*'
  }

  if (type[0] === '+') {
    // "+json" -> "*/*+json" expando
    return '*/*' + type
  }

  return type.indexOf('/') === -1
    ? mime.lookup(type)
    : type
}

/**
 * Check if `expected` mime type
 * matches `actual` mime type with
 * wildcard and +suffix support.
 *
 * @param {String} expected
 * @param {String} actual
 * @return {Boolean}
 * @private
 */

function mimeMatch (expected, actual) {
  // invalid type
  if (expected === false) {
    return false
  }

  // split types
  var actualParts = actual.split('/')
  var expectedParts = expected.split('/')

  // invalid format
  if (actualParts.length !== 2 || expectedParts.length !== 2) {
    return false
  }

  // validate type
  if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {
    return false
  }

  // validate suffix wildcard
  if (expectedParts[1].substr(0, 2) === '*+') {
    return expectedParts[1].length <= actualParts[1].length + 1 &&
      expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length)
  }

  // validate subtype
  if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {
    return false
  }

  return true
}

/**
 * Normalize a type and remove parameters.
 *
 * @param {string} value
 * @return {string}
 * @private
 */

function normalizeType (value) {
  // parse the type
  var type = typer.parse(value)

  // remove the parameters
  type.parameters = undefined

  // reformat it
  return typer.format(type)
}

/**
 * Try to normalize a type and remove parameters.
 *
 * @param {string} value
 * @return {string}
 * @private
 */

function tryNormalizeType (value) {
  if (!value) {
    return null
  }

  try {
    return normalizeType(value)
  } catch (err) {
    return null
  }
}


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var url = __webpack_require__(7)
var parse = url.parse
var Url = url.Url

/**
 * Module exports.
 * @public
 */

module.exports = parseurl
module.exports.original = originalurl

/**
 * Parse the `req` url with memoization.
 *
 * @param {ServerRequest} req
 * @return {Object}
 * @public
 */

function parseurl (req) {
  var url = req.url

  if (url === undefined) {
    // URL is undefined
    return undefined
  }

  var parsed = req._parsedUrl

  if (fresh(url, parsed)) {
    // Return cached URL parse
    return parsed
  }

  // Parse the URL
  parsed = fastparse(url)
  parsed._raw = url

  return (req._parsedUrl = parsed)
};

/**
 * Parse the `req` original url with fallback and memoization.
 *
 * @param {ServerRequest} req
 * @return {Object}
 * @public
 */

function originalurl (req) {
  var url = req.originalUrl

  if (typeof url !== 'string') {
    // Fallback
    return parseurl(req)
  }

  var parsed = req._parsedOriginalUrl

  if (fresh(url, parsed)) {
    // Return cached URL parse
    return parsed
  }

  // Parse the URL
  parsed = fastparse(url)
  parsed._raw = url

  return (req._parsedOriginalUrl = parsed)
};

/**
 * Parse the `str` url with fast-path short-cut.
 *
 * @param {string} str
 * @return {Object}
 * @private
 */

function fastparse (str) {
  if (typeof str !== 'string' || str.charCodeAt(0) !== 0x2f /* / */) {
    return parse(str)
  }

  var pathname = str
  var query = null
  var search = null

  // This takes the regexp from https://github.com/joyent/node/pull/7878
  // Which is /^(\/[^?#\s]*)(\?[^#\s]*)?$/
  // And unrolls it into a for loop
  for (var i = 1; i < str.length; i++) {
    switch (str.charCodeAt(i)) {
      case 0x3f: /* ?  */
        if (search === null) {
          pathname = str.substring(0, i)
          query = str.substring(i + 1)
          search = str.substring(i)
        }
        break
      case 0x09: /* \t */
      case 0x0a: /* \n */
      case 0x0c: /* \f */
      case 0x0d: /* \r */
      case 0x20: /*    */
      case 0x23: /* #  */
      case 0xa0:
      case 0xfeff:
        return parse(str)
    }
  }

  var url = Url !== undefined
    ? new Url()
    : {}

  url.path = str
  url.href = str
  url.pathname = pathname

  if (search !== null) {
    url.query = query
    url.search = search
  }

  return url
}

/**
 * Determine if parsed is still fresh for url.
 *
 * @param {string} url
 * @param {object} parsedUrl
 * @return {boolean}
 * @private
 */

function fresh (url, parsedUrl) {
  return typeof parsedUrl === 'object' &&
    parsedUrl !== null &&
    (Url === undefined || parsedUrl instanceof Url) &&
    parsedUrl._raw === url
}


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer') {
  module.exports = __webpack_require__(153);
} else {
  module.exports = __webpack_require__(154);
}


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  EMPTY_BUFFER: Buffer.alloc(0),
  NOOP: () => {}
};


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
 *
 * parameter     = token "=" ( token / quoted-string )
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
 * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
 * obs-text      = %x80-FF
 * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
 */
var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g
var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/
var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/

/**
 * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
 *
 * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
 * obs-text    = %x80-FF
 */
var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g

/**
 * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
 */
var QUOTE_REGEXP = /([\\"])/g

/**
 * RegExp to match type in RFC 7231 sec 3.1.1.1
 *
 * media-type = type "/" subtype
 * type       = token
 * subtype    = token
 */
var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/

/**
 * Module exports.
 * @public
 */

exports.format = format
exports.parse = parse

/**
 * Format object to media type.
 *
 * @param {object} obj
 * @return {string}
 * @public
 */

function format (obj) {
  if (!obj || typeof obj !== 'object') {
    throw new TypeError('argument obj is required')
  }

  var parameters = obj.parameters
  var type = obj.type

  if (!type || !TYPE_REGEXP.test(type)) {
    throw new TypeError('invalid type')
  }

  var string = type

  // append parameters
  if (parameters && typeof parameters === 'object') {
    var param
    var params = Object.keys(parameters).sort()

    for (var i = 0; i < params.length; i++) {
      param = params[i]

      if (!TOKEN_REGEXP.test(param)) {
        throw new TypeError('invalid parameter name')
      }

      string += '; ' + param + '=' + qstring(parameters[param])
    }
  }

  return string
}

/**
 * Parse media type to object.
 *
 * @param {string|object} string
 * @return {Object}
 * @public
 */

function parse (string) {
  if (!string) {
    throw new TypeError('argument string is required')
  }

  // support req/res-like objects as argument
  var header = typeof string === 'object'
    ? getcontenttype(string)
    : string

  if (typeof header !== 'string') {
    throw new TypeError('argument string is required to be a string')
  }

  var index = header.indexOf(';')
  var type = index !== -1
    ? header.substr(0, index).trim()
    : header.trim()

  if (!TYPE_REGEXP.test(type)) {
    throw new TypeError('invalid media type')
  }

  var obj = new ContentType(type.toLowerCase())

  // parse parameters
  if (index !== -1) {
    var key
    var match
    var value

    PARAM_REGEXP.lastIndex = index

    while ((match = PARAM_REGEXP.exec(header))) {
      if (match.index !== index) {
        throw new TypeError('invalid parameter format')
      }

      index += match[0].length
      key = match[1].toLowerCase()
      value = match[2]

      if (value[0] === '"') {
        // remove quotes and escapes
        value = value
          .substr(1, value.length - 2)
          .replace(QESC_REGEXP, '$1')
      }

      obj.parameters[key] = value
    }

    if (index !== header.length) {
      throw new TypeError('invalid parameter format')
    }
  }

  return obj
}

/**
 * Get content-type from req/res objects.
 *
 * @param {object}
 * @return {Object}
 * @private
 */

function getcontenttype (obj) {
  var header

  if (typeof obj.getHeader === 'function') {
    // res-like
    header = obj.getHeader('content-type')
  } else if (typeof obj.headers === 'object') {
    // req-like
    header = obj.headers && obj.headers['content-type']
  }

  if (typeof header !== 'string') {
    throw new TypeError('content-type header is missing from object')
  }

  return header
}

/**
 * Quote a string if necessary.
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function qstring (val) {
  var str = String(val)

  // no need to quote tokens
  if (TOKEN_REGEXP.test(str)) {
    return str
  }

  if (str.length > 0 && !TEXT_REGEXP.test(str)) {
    throw new TypeError('invalid parameter value')
  }

  return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"'
}

/**
 * Class to represent a content type.
 * @private
 */
function ContentType (type) {
  this.parameters = Object.create(null)
  this.type = type
}


/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = Object.setPrototypeOf || ({__proto__:[]} instanceof Array ? setProtoOf : mixinProperties);

function setProtoOf(obj, proto) {
	obj.__proto__ = proto;
	return obj;
}

function mixinProperties(obj, proto) {
	for (var prop in proto) {
		if (!obj.hasOwnProperty(prop)) {
			obj[prop] = proto[prop];
		}
	}
	return obj;
}


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var codes = __webpack_require__(87)

/**
 * Module exports.
 * @public
 */

module.exports = status

// status code to message map
status.STATUS_CODES = codes

// array of status codes
status.codes = populateStatusesMap(status, codes)

// status codes for redirects
status.redirect = {
  300: true,
  301: true,
  302: true,
  303: true,
  305: true,
  307: true,
  308: true
}

// status codes for empty bodies
status.empty = {
  204: true,
  205: true,
  304: true
}

// status codes for when you should retry the request
status.retry = {
  502: true,
  503: true,
  504: true
}

/**
 * Populate the statuses map for given codes.
 * @private
 */

function populateStatusesMap (statuses, codes) {
  var arr = []

  Object.keys(codes).forEach(function forEachCode (code) {
    var message = codes[code]
    var status = Number(code)

    // Populate properties
    statuses[status] = message
    statuses[message] = status
    statuses[message.toLowerCase()] = status

    // Add to array
    arr.push(status)
  })

  return arr
}

/**
 * Get the status code.
 *
 * Given a number, this will throw if it is not a known status
 * code, otherwise the code will be returned. Given a string,
 * the string will be parsed for a number and return the code
 * if valid, otherwise will lookup the code assuming this is
 * the status message.
 *
 * @param {string|number} code
 * @returns {number}
 * @public
 */

function status (code) {
  if (typeof code === 'number') {
    if (!status[code]) throw new Error('invalid status code: ' + code)
    return code
  }

  if (typeof code !== 'string') {
    throw new TypeError('code must be a number or string')
  }

  // '403'
  var n = parseInt(code, 10)
  if (!isNaN(n)) {
    if (!status[n]) throw new Error('invalid status code: ' + n)
    return n
  }

  n = status[code.toLowerCase()]
  if (!n) throw new Error('invalid status message: "' + code + '"')
  return n
}


/***/ }),
/* 22 */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = require("tty");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var createError = __webpack_require__(14)
var getBody = __webpack_require__(92)
var iconv = __webpack_require__(47)
var onFinished = __webpack_require__(25)
var zlib = __webpack_require__(37)

/**
 * Module exports.
 */

module.exports = read

/**
 * Read a request into a buffer and parse.
 *
 * @param {object} req
 * @param {object} res
 * @param {function} next
 * @param {function} parse
 * @param {function} debug
 * @param {object} options
 * @private
 */

function read (req, res, next, parse, debug, options) {
  var length
  var opts = options
  var stream

  // flag as parsed
  req._body = true

  // read options
  var encoding = opts.encoding !== null
    ? opts.encoding
    : null
  var verify = opts.verify

  try {
    // get the content stream
    stream = contentstream(req, debug, opts.inflate)
    length = stream.length
    stream.length = undefined
  } catch (err) {
    return next(err)
  }

  // set raw-body options
  opts.length = length
  opts.encoding = verify
    ? null
    : encoding

  // assert charset is supported
  if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) {
    return next(createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
      charset: encoding.toLowerCase(),
      type: 'charset.unsupported'
    }))
  }

  // read body
  debug('read body')
  getBody(stream, opts, function (error, body) {
    if (error) {
      var _error

      if (error.type === 'encoding.unsupported') {
        // echo back charset
        _error = createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
          charset: encoding.toLowerCase(),
          type: 'charset.unsupported'
        })
      } else {
        // set status code on error
        _error = createError(400, error)
      }

      // read off entire request
      stream.resume()
      onFinished(req, function onfinished () {
        next(createError(400, _error))
      })
      return
    }

    // verify
    if (verify) {
      try {
        debug('verify body')
        verify(req, res, body, encoding)
      } catch (err) {
        next(createError(403, err, {
          body: body,
          type: err.type || 'entity.verify.failed'
        }))
        return
      }
    }

    // parse
    var str = body
    try {
      debug('parse body')
      str = typeof body !== 'string' && encoding !== null
        ? iconv.decode(body, encoding)
        : body
      req.body = parse(str)
    } catch (err) {
      next(createError(400, err, {
        body: str,
        type: err.type || 'entity.parse.failed'
      }))
      return
    }

    next()
  })
}

/**
 * Get the content stream of the request.
 *
 * @param {object} req
 * @param {function} debug
 * @param {boolean} [inflate=true]
 * @return {object}
 * @api private
 */

function contentstream (req, debug, inflate) {
  var encoding = (req.headers['content-encoding'] || 'identity').toLowerCase()
  var length = req.headers['content-length']
  var stream

  debug('content-encoding "%s"', encoding)

  if (inflate === false && encoding !== 'identity') {
    throw createError(415, 'content encoding unsupported', {
      encoding: encoding,
      type: 'encoding.unsupported'
    })
  }

  switch (encoding) {
    case 'deflate':
      stream = zlib.createInflate()
      debug('inflate body')
      req.pipe(stream)
      break
    case 'gzip':
      stream = zlib.createGunzip()
      debug('gunzip body')
      req.pipe(stream)
      break
    case 'identity':
      stream = req
      stream.length = length
      break
    default:
      throw createError(415, 'unsupported content encoding "' + encoding + '"', {
        encoding: encoding,
        type: 'encoding.unsupported'
      })
  }

  return stream
}


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = onFinished
module.exports.isFinished = isFinished

/**
 * Module dependencies.
 * @private
 */

var first = __webpack_require__(111)

/**
 * Variables.
 * @private
 */

/* istanbul ignore next */
var defer = typeof setImmediate === 'function'
  ? setImmediate
  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }

/**
 * Invoke callback when the response has finished, useful for
 * cleaning up resources afterwards.
 *
 * @param {object} msg
 * @param {function} listener
 * @return {object}
 * @public
 */

function onFinished(msg, listener) {
  if (isFinished(msg) !== false) {
    defer(listener, null, msg)
    return msg
  }

  // attach the listener to the message
  attachListener(msg, listener)

  return msg
}

/**
 * Determine if message is already finished.
 *
 * @param {object} msg
 * @return {boolean}
 * @public
 */

function isFinished(msg) {
  var socket = msg.socket

  if (typeof msg.finished === 'boolean') {
    // OutgoingMessage
    return Boolean(msg.finished || (socket && !socket.writable))
  }

  if (typeof msg.complete === 'boolean') {
    // IncomingMessage
    return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete && !msg.readable))
  }

  // don't know
  return undefined
}

/**
 * Attach a finished listener to the message.
 *
 * @param {object} msg
 * @param {function} callback
 * @private
 */

function attachFinishedListener(msg, callback) {
  var eeMsg
  var eeSocket
  var finished = false

  function onFinish(error) {
    eeMsg.cancel()
    eeSocket.cancel()

    finished = true
    callback(error)
  }

  // finished on first message event
  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish)

  function onSocket(socket) {
    // remove listener
    msg.removeListener('socket', onSocket)

    if (finished) return
    if (eeMsg !== eeSocket) return

    // finished on first socket event
    eeSocket = first([[socket, 'error', 'close']], onFinish)
  }

  if (msg.socket) {
    // socket already assigned
    onSocket(msg.socket)
    return
  }

  // wait for socket to be assigned
  msg.on('socket', onSocket)

  if (msg.socket === undefined) {
    // node.js 0.8 patch
    patchAssignSocket(msg, onSocket)
  }
}

/**
 * Attach the listener to the message.
 *
 * @param {object} msg
 * @return {function}
 * @private
 */

function attachListener(msg, listener) {
  var attached = msg.__onFinished

  // create a private single listener with queue
  if (!attached || !attached.queue) {
    attached = msg.__onFinished = createListener(msg)
    attachFinishedListener(msg, attached)
  }

  attached.queue.push(listener)
}

/**
 * Create listener on message.
 *
 * @param {object} msg
 * @return {function}
 * @private
 */

function createListener(msg) {
  function listener(err) {
    if (msg.__onFinished === listener) msg.__onFinished = null
    if (!listener.queue) return

    var queue = listener.queue
    listener.queue = null

    for (var i = 0; i < queue.length; i++) {
      queue[i](err, msg)
    }
  }

  listener.queue = []

  return listener
}

/**
 * Patch ServerResponse.prototype.assignSocket for node.js 0.8.
 *
 * @param {ServerResponse} res
 * @param {function} callback
 * @private
 */

function patchAssignSocket(res, callback) {
  var assignSocket = res.assignSocket

  if (typeof assignSocket !== 'function') return

  // res.on('socket', callback) is broken in 0.8
  res.assignSocket = function _assignSocket(socket) {
    assignSocket.call(this, socket)
    callback(socket)
  }
}


/***/ }),
/* 26 */
/***/ (function(module, exports) {

module.exports = require("querystring");

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = encodeUrl

/**
 * RegExp to match non-URL code points, *after* encoding (i.e. not including "%")
 * and including invalid escape sequences.
 * @private
 */

var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g

/**
 * RegExp to match unmatched surrogate pair.
 * @private
 */

var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g

/**
 * String to replace unmatched surrogate pair with.
 * @private
 */

var UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\uFFFD$2'

/**
 * Encode a URL to a percent-encoded form, excluding already-encoded sequences.
 *
 * This function will take an already-encoded URL and encode all the non-URL
 * code points. This function will not encode the "%" character unless it is
 * not part of a valid sequence (`%20` will be left as-is, but `%foo` will
 * be encoded as `%25foo`).
 *
 * This encode is meant to be "safe" and does not throw errors. It will try as
 * hard as it can to properly encode the given URL, including replacing any raw,
 * unpaired surrogate pairs with the Unicode replacement character prior to
 * encoding.
 *
 * @param {string} url
 * @return {string}
 * @public
 */

function encodeUrl (url) {
  return String(url)
    .replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE)
    .replace(ENCODE_CHARS_REGEXP, encodeURI)
}


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */



/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Module exports.
 * @public
 */

module.exports = escapeHtml;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34: // "
        escape = '&quot;';
        break;
      case 38: // &
        escape = '&amp;';
        break;
      case 39: // '
        escape = '&#39;';
        break;
      case 60: // <
        escape = '&lt;';
        break;
      case 62: // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index
    ? html + str.substring(lastIndex, index)
    : html;
}


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Expose `arrayFlatten`.
 */
module.exports = arrayFlatten

/**
 * Recursive flatten function with depth.
 *
 * @param  {Array}  array
 * @param  {Array}  result
 * @param  {Number} depth
 * @return {Array}
 */
function flattenWithDepth (array, result, depth) {
  for (var i = 0; i < array.length; i++) {
    var value = array[i]

    if (depth > 0 && Array.isArray(value)) {
      flattenWithDepth(value, result, depth - 1)
    } else {
      result.push(value)
    }
  }

  return result
}

/**
 * Recursive flatten function. Omitting depth is slightly faster.
 *
 * @param  {Array} array
 * @param  {Array} result
 * @return {Array}
 */
function flattenForever (array, result) {
  for (var i = 0; i < array.length; i++) {
    var value = array[i]

    if (Array.isArray(value)) {
      flattenForever(value, result)
    } else {
      result.push(value)
    }
  }

  return result
}

/**
 * Flatten an array, with the ability to define a depth.
 *
 * @param  {Array}  array
 * @param  {Number} depth
 * @return {Array}
 */
function arrayFlatten (array, depth) {
  if (depth == null) {
    return flattenForever(array, [])
  }

  return flattenWithDepth(array, [], depth)
}


/***/ }),
/* 30 */
/***/ (function(module, exports) {

/**
 * Merge object b with object a.
 *
 *     var a = { foo: 'bar' }
 *       , b = { bar: 'baz' };
 *
 *     merge(a, b);
 *     // => { foo: 'bar', bar: 'baz' }
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object}
 * @api public
 */

exports = module.exports = function(a, b){
  if (a && b) {
    for (var key in b) {
      a[key] = b[key];
    }
  }
  return a;
};


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var utf8 = __webpack_require__(149);
var hasBinary = __webpack_require__(42);
var after = __webpack_require__(151);
var keys = __webpack_require__(152);

/**
 * Current protocol version.
 */
exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  if (typeof utf8encode === 'function') {
    callback = utf8encode;
    utf8encode = null;
  }

  if (Buffer.isBuffer(packet.data)) {
    return encodeBuffer(packet, supportsBinary, callback);
  } else if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) {
    return encodeBuffer({ type: packet.type, data: arrayBufferToBuffer(packet.data) }, supportsBinary, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
  }

  return callback('' + encoded);
};

/**
 * Encode Buffer data
 */

function encodeBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var typeBuffer = new Buffer(1);
  typeBuffer[0] = packets[packet.type];
  return callback(Buffer.concat([typeBuffer, data]));
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback){
  var data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);
  var message = 'b' + packets[packet.type];
  message += data.toString('base64');
  return callback(message);
};

/**
 * Decodes a packet. Data also available as an ArrayBuffer if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  if (data === undefined) {
    return err;
  }

  var type;

  // String data
  if (typeof data === 'string') {

    type = data.charAt(0);

    if (type === 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      data = tryDecode(data);
      if (data === false) {
        return err;
      }
    }

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  // Binary data
  if (binaryType === 'arraybuffer') {
    // wrap Buffer/ArrayBuffer data into an Uint8Array
    var intArray = new Uint8Array(data);
    type = intArray[0];
    return { type: packetslist[type], data: intArray.buffer.slice(1) };
  }

  if (data instanceof ArrayBuffer) {
    data = arrayBufferToBuffer(data);
  }
  type = data[0];
  return { type: packetslist[type], data: data.slice(1) };
};

function tryDecode(data) {
  try {
    data = utf8.decode(data, { strict: false });
  } catch (e) {
    return false;
  }
  return data;
}

/**
 * Decodes a packet encoded in a base64 string.
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  var data = new Buffer(msg.substr(1), 'base64');
  if (binaryType === 'arraybuffer') {
    var abv = new Uint8Array(data.length);
    for (var i = 0; i < abv.length; i++){
      abv[i] = data[i];
    }
    data = abv.buffer;
  }
  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  if (supportsBinary && hasBinary(packets)) {
    return exports.encodePayloadAsBinary(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, supportsBinary, false, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

function setLengthHeader(message) {
  return message.length + ':' + message;
}

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  for (var i = 0; i < ary.length; i++) {
    each(ary[i], function(error, msg) {
      result[i] = msg;
      next(error, result);
    });
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data !== 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  if (data === '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = '', n, msg, packet;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (chr !== ':') {
      length += chr;
      continue;
    }

    if (length === '' || (length != (n = Number(length)))) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    msg = data.substr(i + 1, n);

    if (length != msg.length) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    if (msg.length) {
      packet = exports.decodePacket(msg, binaryType, false);

      if (err.type === packet.type && err.data === packet.data) {
        // parser error in individual packet - ignoring payload
        return callback(err, 0, 1);
      }

      var more = callback(packet, i + n, l);
      if (false === more) return;
    }

    // advance cursor
    i += n;
    length = '';
  }

  if (length !== '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 *
 * Converts a buffer to a utf8.js encoded string
 *
 * @api private
 */

function bufferToString(buffer) {
  var str = '';
  for (var i = 0, l = buffer.length; i < l; i++) {
    str += String.fromCharCode(buffer[i]);
  }
  return str;
}

/**
 *
 * Converts a utf8.js encoded string to a buffer
 *
 * @api private
 */

function stringToBuffer(string) {
  var buf = new Buffer(string.length);
  for (var i = 0, l = string.length; i < l; i++) {
    buf.writeUInt8(string.charCodeAt(i), i);
  }
  return buf;
}

/**
 *
 * Converts an ArrayBuffer to a Buffer
 *
 * @api private
 */

function arrayBufferToBuffer(data) {
  // data is either an ArrayBuffer or ArrayBufferView.
  var array = new Uint8Array(data.buffer || data);
  var length = data.byteLength || data.length;
  var offset = data.byteOffset || 0;
  var buffer = new Buffer(length);

  for (var i = 0; i < length; i++) {
    buffer[i] = array[offset + i];
  }
  return buffer;
}

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {Buffer} encoded payload
 * @api private
 */

exports.encodePayloadAsBinary = function (packets, callback) {
  if (!packets.length) {
    return callback(new Buffer(0));
  }

  map(packets, encodeOneBinaryPacket, function(err, results) {
    return callback(Buffer.concat(results));
  });
};

function encodeOneBinaryPacket(p, doneCallback) {

  function onBinaryPacketEncode(packet) {

    var encodingLength = '' + packet.length;
    var sizeBuffer;

    if (typeof packet === 'string') {
      sizeBuffer = new Buffer(encodingLength.length + 2);
      sizeBuffer[0] = 0; // is a string (not true binary = 0)
      for (var i = 0; i < encodingLength.length; i++) {
        sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);
      }
      sizeBuffer[sizeBuffer.length - 1] = 255;
      return doneCallback(null, Buffer.concat([sizeBuffer, stringToBuffer(packet)]));
    }

    sizeBuffer = new Buffer(encodingLength.length + 2);
    sizeBuffer[0] = 1; // is binary (true binary = 1)
    for (var i = 0; i < encodingLength.length; i++) {
      sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);
    }
    sizeBuffer[sizeBuffer.length - 1] = 255;

    doneCallback(null, Buffer.concat([sizeBuffer, packet]));
  }

  exports.encodePacket(p, true, true, onBinaryPacketEncode);

}


/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary

 * @param {Buffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];
  var i;

  while (bufferTail.length > 0) {
    var strLen = '';
    var isString = bufferTail[0] === 0;
    for (i = 1; ; i++) {
      if (bufferTail[i] === 255)  break;
      // 310 = char length of Number.MAX_VALUE
      if (strLen.length > 310) {
        return callback(err, 0, 1);
      }
      strLen += '' + bufferTail[i];
    }
    bufferTail = bufferTail.slice(strLen.length + 1);

    var msgLength = parseInt(strLen, 10);

    var msg = bufferTail.slice(1, msgLength + 1);
    if (isString) msg = bufferToString(msg);
    buffers.push(msg);
    bufferTail = bufferTail.slice(msgLength + 1);
  }

  var total = buffers.length;
  for (i = 0; i < total; i++) {
    var buffer = buffers[i];
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  }
};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Limiter = __webpack_require__(173);
const zlib = __webpack_require__(37);

const bufferUtil = __webpack_require__(44);
const { kStatusCode, NOOP } = __webpack_require__(18);

const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const EMPTY_BLOCK = Buffer.from([0x00]);

const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} options Configuration options
   * @param {Boolean} options.serverNoContextTakeover Request/accept disabling
   *     of server context takeover
   * @param {Boolean} options.clientNoContextTakeover Advertise/acknowledge
   *     disabling of client context takeover
   * @param {(Boolean|Number)} options.serverMaxWindowBits Request/confirm the
   *     use of a custom server window size
   * @param {(Boolean|Number)} options.clientMaxWindowBits Advertise support
   *     for, or request, a custom client window size
   * @param {Object} options.zlibDeflateOptions Options to pass to zlib on deflate
   * @param {Object} options.zlibInflateOptions Options to pass to zlib on inflate
   * @param {Number} options.threshold Size (in bytes) below which messages
   *     should not be compressed
   * @param {Number} options.concurrencyLimit The number of concurrent calls to
   *     zlib
   * @param {Boolean} isServer Create the instance in either server or client
   *     mode
   * @param {Number} maxPayload The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter({ concurrency });
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      this._deflate.close();
      this._deflate = null;
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        var value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited by async-limiter.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.push((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited by async-limiter.
   *
   * @param {Buffer} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.push((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw(
        Object.assign({}, this._options.zlibInflateOptions, { windowBits })
      );
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {Buffer} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    if (!data || data.length === 0) {
      process.nextTick(callback, null, EMPTY_BLOCK);
      return;
    }

    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw(
        Object.assign({}, this._options.zlibDeflateOptions, { windowBits })
      );

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      //
      // An `'error'` event is emitted, only on Node.js < 10.0.0, if the
      // `zlib.DeflateRaw` instance is closed while data is being processed.
      // This can happen if `PerMessageDeflate#cleanup()` is called at the wrong
      // time due to an abnormal WebSocket closure.
      //
      this._deflate.on('error', NOOP);
      this._deflate.on('data', deflateOnData);
    }

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // This `if` statement is only needed for Node.js < 10.0.0 because as of
        // commit https://github.com/nodejs/node/commit/5e3f5164, the flush
        // callback is no longer called if the deflate stream is closed while
        // data is being processed.
        //
        return;
      }

      var data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) data = data.slice(0, data.length - 4);

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.close();
        this._deflate = null;
      } else {
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
      }

      callback(null, data);
    });
  }
}

module.exports = PerMessageDeflate;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode] = 1007;
  this[kCallback](err);
}


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var debug = __webpack_require__(178)('socket.io-parser');
var Emitter = __webpack_require__(181);
var binary = __webpack_require__(182);
var isArray = __webpack_require__(76);
var isBuf = __webpack_require__(77);

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

var ERROR_PACKET = exports.ERROR + '"encode error"';

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    encodeAsBinary(obj, callback);
  } else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {

  // first is type
  var str = '' + obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    str += obj.attachments + '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' !== obj.nsp) {
    str += obj.nsp + ',';
  }

  // immediately followed by the id
  if (null != obj.id) {
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    var payload = tryStringify(obj.data);
    if (payload !== false) {
      str += payload;
    } else {
      return ERROR_PACKET;
    }
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

function tryStringify(str) {
  try {
    return JSON.stringify(str);
  } catch(e){
    return false;
  }
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an encoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if (typeof obj === 'string') {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  } else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  } else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var i = 0;
  // look up type
  var p = {
    type: Number(str.charAt(0))
  };

  if (null == exports.types[p.type]) {
    return error('unknown packet type ' + p.type);
  }

  // look up attachments if type binary
  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
    var buf = '';
    while (str.charAt(++i) !== '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) !== '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' === str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' === c) break;
      p.nsp += c;
      if (i === str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i === str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    var payload = tryParse(str.substr(i));
    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));
    if (isPayloadValid) {
      p.data = payload;
    } else {
      return error('invalid payload');
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

function tryParse(str) {
  try {
    return JSON.parse(str);
  } catch(e){
    return false;
  }
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(msg) {
  return {
    type: exports.ERROR,
    data: 'parser error: ' + msg
  };
}


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __webpack_require__(183);
} else {
	module.exports = __webpack_require__(185);
}


/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = require("net");

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = [["0","\u0000",127,""],["8140","",5,"",9,"",6,""],["8180","",6,"",4,"",4,"",5,""],["8240","",4,"",8,"",4,"",11],["8280","",10,"",4,"",7,"",5,"",8,"",20,"",4,"",6,""],["8340","",17,"",5,"",10,"",4,"",9,""],["8380","",5,"",13,"",28,"",4,"",4,"",5],["8440","",5,"",5,""],["8480","",9,"",4,"",6,"",6,"",9,"",5,"",10,"",7,""],["8540","",9,""],["8580","",4,"",6,"",4,"",4,"",7,""],["8640","",4,"",5,"",4,"",5,""],["8680","",4,"",4,"",5,"",6,"",8,"",4,"",4,"",4,""],["8740","",7,"",11,"",4,"",4],["8780","",7,"",6,"",14,"",10,"",6,"",12,"",8,"",5,"",6],["8840","",9,"",4,"",4,""],["8880","",4,"",6,"",8,"",6,"",7,"",4,"",4,"",7],["8940","",5,"",6,"",4,"",5,"",4,"",16,""],["8980","",4,"",4,"",7,"",17,"",10,"",13,"",5,"",7,"",4,""],["8a40","",4,"",12,""],["8a80","",5,"",6,"",4,"",11,"",6,"",4,"",4,"",9,"",5],["8b40","",8,"",17,"",6,"",13,""],["8b80","",4,"",4,"",5,"",4,"",4,"",22,"",11,"",25,"",7,"",6],["8c40","",7,""],["8c80","",8,"",4,"",6,"",6,"",6,"",4,"",4,"",4],["8d40","",5,"",5,"",5,"",6,"",9,"",4],["8d80","",5,"",4,"",4,"",4,"",7,"",7,"",10,"",10,"",12,"",21,""],["8e40","",21,"",12,"",6,"",12,""],["8e80","",4,"",7,"",4,"",4,"",5,"",6,"",4,"",14,"",4,"",4,"",6],["8f40","",5,"",11,"",8,""],["8f80","",6,"",14,"",5,"",5,"",4,""],["9040","",4,"",4,"",6,""],["9080","",7,"",4,"",4,"",4,"",4,"",18,"",6],["9140","",6,"",6,"",18,"",4,""],["9180","",6,"",8,"",9,"",5,"",4,"",4,"",16,"",13,"",8,"",5,"",4,""],["9240","",6,"",5,""],["9280","",5,"",7,"",6,""],["9340","",6,"",4,"",4,"",5,""],["9380","",5,"",4,"",6,"",4,"",7,"",9,"",6,"",8,"",4,"",6,""],["9440","",24,"",7,"",7,"",4,"",8],["9480","",4,"",4,"",14,"",7,"",7,""],["9540","",4,"",4,"",6,""],["9580","",4,"",4,"",8,"",4,"",4,"",25,"",7,"",5,""],["9640","",5,"",4,""],["9680","",7,"",9,"",7,"",4,"",6,"",6,"",5],["9740","",7,"",8,"",7,"",9,""],["9780","",6,"",5,"",4,"",9,"",4,"",11,"",7,"",16,""],["9840","",4,"",5,"",9,""],["9880","",7,"",5,"",11,"",9,"",9,"",11,"",5,"",5,"",6,"",4,"",7,"",6,""],["9940","",4,"",10,"",6,"",8,"",4,"",7,"",5],["9980","",114,"",6],["9a40","",11,"",7,"",13,""],["9a80","",4,"",7,"",7,"",6,"",4,"",4,"",7,"",6,"",4,"",4,""],["9b40","",4,""],["9b80","",5,"",4,"",4,"",5,""],["9c40","",7,""],["9c80","",7,"",7,"",10,"",14,"",4,"",6,"",5],["9d40","",7,"",4,"",9,"",6,""],["9d80","",9,"",5,"",6,"",12,"",4,"",10,"",5,"",5,"",6,"",10,""],["9e40","",7,"",32,"",7,"",6,"",6],["9e80","",9,"",17,"",13,"",11,"",12,"",12,""],["9f40","",6,"",10,"",4,"",10,"",7,""],["9f80","",13,"",12,"",4,"",4,"",5,"",4,"",4,"",6,"",5,"",8,"",9,"",4],["a040","",9,"",5,"",9,"",11,"",19],["a080","",9,"",6,"",4,"",11,"",11,"",6,""],["a1a1","",7,""],["a2a1","",9],["a2b1","",19,"",19,"",9],["a2e5","",9],["a2f1","",11],["a3a1","",88,""],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a6e0",""],["a6ee",""],["a6f4",""],["a7a1","",5,"",25],["a7d1","",5,"",25],["a840","",35,"",6],["a880","",7,""],["a8a1",""],["a8bd",""],["a8c0",""],["a8c5","",36],["a940","",8,""],["a959",""],["a95c",""],["a960","",9,"",8],["a980","",4,""],["a996",""],["a9a4","",75],["aa40","",5,"",5,"",8],["aa80","",7,"",10,""],["ab40","",11,"",4,"",5,"",4],["ab80","",6,"",4],["ac40","",10,"",8,"",5,"",4,"",11],["ac80","",6,"",12,"",4,""],["ad40","",10,"",7,"",15,"",12],["ad80","",9,"",8,"",6,""],["ae40","",6,"",7,"",4,""],["ae80","",7,"",6,"",4,""],["af40","",4,""],["af80",""],["b040","",6,"",5,"",4,"",6,"",7,""],["b080","",7,"",8,"",9,""],["b140","",4,"",7,"",10,""],["b180","",4,"",7,"",7,""],["b240","",11,"",5,"",11,"",4],["b280","",12,"",8,"",4,""],["b340","",5,""],["b380","",11,"",7,"",6,""],["b440","",7,"",9],["b480","",4,"",5,"",6,""],["b540","",5,"",9,"",4,"",14,"",4,"",8,""],["b580","",6,"",4,""],["b640","",6,"",11,"",10,"",4,"",5,""],["b680","",6,"",4,""],["b740","",14,"",5,"",9,"",4,"",16],["b780","",6,""],["b840","",4,"",10,"",10,"",9,"",5,""],["b880","",4,""],["b940","",5,"",10,"",6,""],["b980","",7,""],["ba40","",4,"",4,"",7,"",5,""],["ba80","",4,"",5,"",12,"",5,""],["bb40","",9,"",36,"",5,"",9],["bb80","",6,"",4,""],["bc40","",6,"",6,"",5,"",7,"",13,"",5],["bc80","",14,"",6,""],["bd40","",54,"",7],["bd80","",32,""],["be40","",12,"",6,"",42],["be80","",32,""],["bf40","",62],["bf80","",4,"",4,"",21,""],["c040","",35,"",23,""],["c080","",6,"",9,""],["c140","",4,"",7,"",4,"",4,"",6,""],["c180","",4,"",4,"",5,""],["c240","",6,"",5,""],["c280","",13,"",5,"",11,""],["c340","",5,"",4,"",6,""],["c380","",12,"",4,""],["c440","",5,"",4,"",4,"",5,"",4,""],["c480","",7,"",5,"",6,""],["c540","",14,"",4,"",5,"",4,"",5,""],["c580","",7,"",7,""],["c640",""],["c680","",4,"",9,""],["c740","",4,"",4,"",6,"",6,"",6,""],["c780",""],["c840","",4,"",5,"",5,"",7,"",5,"",7,""],["c880","",6,"",4,"",4,""],["c940","",4,"",7,"",12,""],["c980","",4,"",4,"",10,""],["ca40","",8,"",8,"",9,"",4,"",10],["ca80","",4,"",8,""],["cb40","",6,"",10,"",6,"",5,"",6,"",6,"",4,""],["cb80","",5,"",6,"",14,""],["cc40","",4,"",10,"",15,"",13,""],["cc80","",11,"",4,"",7,""],["cd40","",6,"",6,"",4,"",5,"",4,"",4,""],["cd80",""],["ce40","",6,"",5,"",7,""],["ce80","",4,"",6,"",4,""],["cf40","",4,"",4,"",6,"",9],["cf80","",5,"",7,"",4,""],["d040","",13,"",5,"",5,"",5,"",6,""],["d080","",4,"",4,"",5,""],["d140","",4,"",4,"",6,"",5],["d180","",4,"",4,"",4,""],["d240","",8,"",24,"",5,"",19,""],["d280","",26,""],["d340","",30,"",6],["d380","",4,"",5,"",21,""],["d440","",31,"",8,"",21],["d480","",25,"",6,""],["d540","",7,"",7,"",46],["d580","",32,""],["d640","",34,"",27],["d680","",30,""],["d740","",31,"",4,"",25],["d780","",24,""],["d840","",8,"",7,"",5,"",6,"",6,"",6,""],["d880","",6,"",20,""],["d940","",62],["d980","",32,""],["da40","",14,"",8,"",4,"",9,""],["da80","",12,""],["db40","",6,"",7,"",4,""],["db80","",4,"",5,"",11,""],["dc40","",4,"",6,"",6,"",11,"",6,"",7],["dc80","",10,"",21,""],["dd40","",62],["dd80","",32,""],["de40","",32,""],["de80","",4,""],["df40","",5,"",4,"",4,"",5,"",4,"",6,""],["df80","",4,""],["e040","",19,""],["e080","",10,"",6,"",8,""],["e140","",4,"",6,"",5,"",5,""],["e180","",10,"",9,"",8,""],["e240","",62],["e280","",32,"",5,""],["e340","",45,"",16],["e380","",7,"",24,""],["e440","",5,"",24,"",31],["e480","",32,""],["e540","",51,"",10],["e580","",31,""],["e640","",34,"",27],["e680","",29,""],["e740","",7,"",54],["e780","",32,"",6,"",4,""],["e840","",14,"",43,""],["e880","",20,""],["e940","",7,"",42],["e980","",32,""],["ea40","",27,"",6,""],["ea80","",4,"",12,""],["eb40","",9,"",7,"",9,"",6,""],["eb80","",4,""],["ec40","",8,"",4,"",18,"",7],["ec80","",4,"",7,"",4,"",4,""],["ed40","",6,"",46],["ed80","",4,"",23,""],["ee40","",62],["ee80","",32,"",4,"",6,""],["ef40","",5,"",37,"",4],["ef80","",30,"",4,"",8,""],["f040","",4,"",28,"",26],["f080","",9,"",12,"",4,"",6,""],["f140","",10,"",47],["f180","",32,""],["f240","",62],["f280","",32,""],["f340","",17,"",6,"",4,""],["f380","",8,"",6,""],["f440","",5,"",10,"",10,"",7,"",5],["f480","",32,""],["f540","",62],["f580","",32,""],["f640","",62],["f680","",32,"",5,"",5,"",4,"",7,""],["f740","",62],["f780","",4,"",4,""],["f840","",62],["f880","",32],["f940","",62],["f980","",32],["fa40","",62],["fa80","",32],["fb40","",27,"",9,""],["fb80","",5,"",8,"",5,""],["fc40","",8,"",4,"",8,"",6],["fc80","",4,"",5,"",8,""],["fd40","",4,"",4,"",10,"",38],["fd80","",5,"",11,"",4,""],["fe40",""]]

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = require("zlib");

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var stringify = __webpack_require__(118);
var parse = __webpack_require__(119);
var formats = __webpack_require__(53);

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * methods
 * Copyright(c) 2013-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var http = __webpack_require__(4);

/**
 * Module exports.
 * @public
 */

module.exports = getCurrentNodeMethods() || getBasicNodeMethods();

/**
 * Get the current Node.js methods.
 * @private
 */

function getCurrentNodeMethods() {
  return http.METHODS && http.METHODS.map(function lowerCaseMethod(method) {
    return method.toLowerCase();
  });
}

/**
 * Get the "basic" Node.js methods, a snapshot from Node.js 0.10.
 * @private
 */

function getBasicNodeMethods() {
  return [
    'get',
    'post',
    'put',
    'head',
    'delete',
    'options',
    'trace',
    'copy',
    'lock',
    'mkcol',
    'move',
    'purge',
    'propfind',
    'proppatch',
    'unlock',
    'report',
    'mkactivity',
    'checkout',
    'merge',
    'm-search',
    'notify',
    'subscribe',
    'unsubscribe',
    'patch',
    'search',
    'connect'
  ];
}


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var createError = __webpack_require__(14)
var debug = __webpack_require__(3)('send')
var deprecate = __webpack_require__(5)('send')
var destroy = __webpack_require__(127)
var encodeUrl = __webpack_require__(27)
var escapeHtml = __webpack_require__(28)
var etag = __webpack_require__(60)
var fresh = __webpack_require__(61)
var fs = __webpack_require__(6)
var mime = __webpack_require__(128)
var ms = __webpack_require__(22)
var onFinished = __webpack_require__(25)
var parseRange = __webpack_require__(62)
var path = __webpack_require__(2)
var statuses = __webpack_require__(21)
var Stream = __webpack_require__(11)
var util = __webpack_require__(0)

/**
 * Path function references.
 * @private
 */

var extname = path.extname
var join = path.join
var normalize = path.normalize
var resolve = path.resolve
var sep = path.sep

/**
 * Regular expression for identifying a bytes Range header.
 * @private
 */

var BYTES_RANGE_REGEXP = /^ *bytes=/

/**
 * Maximum value allowed for the max age.
 * @private
 */

var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1000 // 1 year

/**
 * Regular expression to match a path with a directory up component.
 * @private
 */

var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/

/**
 * Module exports.
 * @public
 */

module.exports = send
module.exports.mime = mime

/**
 * Return a `SendStream` for `req` and `path`.
 *
 * @param {object} req
 * @param {string} path
 * @param {object} [options]
 * @return {SendStream}
 * @public
 */

function send (req, path, options) {
  return new SendStream(req, path, options)
}

/**
 * Initialize a `SendStream` with the given `path`.
 *
 * @param {Request} req
 * @param {String} path
 * @param {object} [options]
 * @private
 */

function SendStream (req, path, options) {
  Stream.call(this)

  var opts = options || {}

  this.options = opts
  this.path = path
  this.req = req

  this._acceptRanges = opts.acceptRanges !== undefined
    ? Boolean(opts.acceptRanges)
    : true

  this._cacheControl = opts.cacheControl !== undefined
    ? Boolean(opts.cacheControl)
    : true

  this._etag = opts.etag !== undefined
    ? Boolean(opts.etag)
    : true

  this._dotfiles = opts.dotfiles !== undefined
    ? opts.dotfiles
    : 'ignore'

  if (this._dotfiles !== 'ignore' && this._dotfiles !== 'allow' && this._dotfiles !== 'deny') {
    throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"')
  }

  this._hidden = Boolean(opts.hidden)

  if (opts.hidden !== undefined) {
    deprecate('hidden: use dotfiles: \'' + (this._hidden ? 'allow' : 'ignore') + '\' instead')
  }

  // legacy support
  if (opts.dotfiles === undefined) {
    this._dotfiles = undefined
  }

  this._extensions = opts.extensions !== undefined
    ? normalizeList(opts.extensions, 'extensions option')
    : []

  this._immutable = opts.immutable !== undefined
    ? Boolean(opts.immutable)
    : false

  this._index = opts.index !== undefined
    ? normalizeList(opts.index, 'index option')
    : ['index.html']

  this._lastModified = opts.lastModified !== undefined
    ? Boolean(opts.lastModified)
    : true

  this._maxage = opts.maxAge || opts.maxage
  this._maxage = typeof this._maxage === 'string'
    ? ms(this._maxage)
    : Number(this._maxage)
  this._maxage = !isNaN(this._maxage)
    ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE)
    : 0

  this._root = opts.root
    ? resolve(opts.root)
    : null

  if (!this._root && opts.from) {
    this.from(opts.from)
  }
}

/**
 * Inherits from `Stream`.
 */

util.inherits(SendStream, Stream)

/**
 * Enable or disable etag generation.
 *
 * @param {Boolean} val
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.etag = deprecate.function(function etag (val) {
  this._etag = Boolean(val)
  debug('etag %s', this._etag)
  return this
}, 'send.etag: pass etag as option')

/**
 * Enable or disable "hidden" (dot) files.
 *
 * @param {Boolean} path
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.hidden = deprecate.function(function hidden (val) {
  this._hidden = Boolean(val)
  this._dotfiles = undefined
  debug('hidden %s', this._hidden)
  return this
}, 'send.hidden: use dotfiles option')

/**
 * Set index `paths`, set to a falsy
 * value to disable index support.
 *
 * @param {String|Boolean|Array} paths
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.index = deprecate.function(function index (paths) {
  var index = !paths ? [] : normalizeList(paths, 'paths argument')
  debug('index %o', paths)
  this._index = index
  return this
}, 'send.index: pass index as option')

/**
 * Set root `path`.
 *
 * @param {String} path
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.root = function root (path) {
  this._root = resolve(String(path))
  debug('root %s', this._root)
  return this
}

SendStream.prototype.from = deprecate.function(SendStream.prototype.root,
  'send.from: pass root as option')

SendStream.prototype.root = deprecate.function(SendStream.prototype.root,
  'send.root: pass root as option')

/**
 * Set max-age to `maxAge`.
 *
 * @param {Number} maxAge
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.maxage = deprecate.function(function maxage (maxAge) {
  this._maxage = typeof maxAge === 'string'
    ? ms(maxAge)
    : Number(maxAge)
  this._maxage = !isNaN(this._maxage)
    ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE)
    : 0
  debug('max-age %d', this._maxage)
  return this
}, 'send.maxage: pass maxAge as option')

/**
 * Emit error with `status`.
 *
 * @param {number} status
 * @param {Error} [err]
 * @private
 */

SendStream.prototype.error = function error (status, err) {
  // emit if listeners instead of responding
  if (hasListeners(this, 'error')) {
    return this.emit('error', createError(status, err, {
      expose: false
    }))
  }

  var res = this.res
  var msg = statuses[status] || String(status)
  var doc = createHtmlDocument('Error', escapeHtml(msg))

  // clear existing headers
  clearHeaders(res)

  // add error headers
  if (err && err.headers) {
    setHeaders(res, err.headers)
  }

  // send basic response
  res.statusCode = status
  res.setHeader('Content-Type', 'text/html; charset=UTF-8')
  res.setHeader('Content-Length', Buffer.byteLength(doc))
  res.setHeader('Content-Security-Policy', "default-src 'self'")
  res.setHeader('X-Content-Type-Options', 'nosniff')
  res.end(doc)
}

/**
 * Check if the pathname ends with "/".
 *
 * @return {boolean}
 * @private
 */

SendStream.prototype.hasTrailingSlash = function hasTrailingSlash () {
  return this.path[this.path.length - 1] === '/'
}

/**
 * Check if this is a conditional GET request.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isConditionalGET = function isConditionalGET () {
  return this.req.headers['if-match'] ||
    this.req.headers['if-unmodified-since'] ||
    this.req.headers['if-none-match'] ||
    this.req.headers['if-modified-since']
}

/**
 * Check if the request preconditions failed.
 *
 * @return {boolean}
 * @private
 */

SendStream.prototype.isPreconditionFailure = function isPreconditionFailure () {
  var req = this.req
  var res = this.res

  // if-match
  var match = req.headers['if-match']
  if (match) {
    var etag = res.getHeader('ETag')
    return !etag || (match !== '*' && parseTokenList(match).every(function (match) {
      return match !== etag && match !== 'W/' + etag && 'W/' + match !== etag
    }))
  }

  // if-unmodified-since
  var unmodifiedSince = parseHttpDate(req.headers['if-unmodified-since'])
  if (!isNaN(unmodifiedSince)) {
    var lastModified = parseHttpDate(res.getHeader('Last-Modified'))
    return isNaN(lastModified) || lastModified > unmodifiedSince
  }

  return false
}

/**
 * Strip content-* header fields.
 *
 * @private
 */

SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields () {
  var res = this.res
  var headers = getHeaderNames(res)

  for (var i = 0; i < headers.length; i++) {
    var header = headers[i]
    if (header.substr(0, 8) === 'content-' && header !== 'content-location') {
      res.removeHeader(header)
    }
  }
}

/**
 * Respond with 304 not modified.
 *
 * @api private
 */

SendStream.prototype.notModified = function notModified () {
  var res = this.res
  debug('not modified')
  this.removeContentHeaderFields()
  res.statusCode = 304
  res.end()
}

/**
 * Raise error that headers already sent.
 *
 * @api private
 */

SendStream.prototype.headersAlreadySent = function headersAlreadySent () {
  var err = new Error('Can\'t set headers after they are sent.')
  debug('headers already sent')
  this.error(500, err)
}

/**
 * Check if the request is cacheable, aka
 * responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}).
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isCachable = function isCachable () {
  var statusCode = this.res.statusCode
  return (statusCode >= 200 && statusCode < 300) ||
    statusCode === 304
}

/**
 * Handle stat() error.
 *
 * @param {Error} error
 * @private
 */

SendStream.prototype.onStatError = function onStatError (error) {
  switch (error.code) {
    case 'ENAMETOOLONG':
    case 'ENOENT':
    case 'ENOTDIR':
      this.error(404, error)
      break
    default:
      this.error(500, error)
      break
  }
}

/**
 * Check if the cache is fresh.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isFresh = function isFresh () {
  return fresh(this.req.headers, {
    'etag': this.res.getHeader('ETag'),
    'last-modified': this.res.getHeader('Last-Modified')
  })
}

/**
 * Check if the range is fresh.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isRangeFresh = function isRangeFresh () {
  var ifRange = this.req.headers['if-range']

  if (!ifRange) {
    return true
  }

  // if-range as etag
  if (ifRange.indexOf('"') !== -1) {
    var etag = this.res.getHeader('ETag')
    return Boolean(etag && ifRange.indexOf(etag) !== -1)
  }

  // if-range as modified date
  var lastModified = this.res.getHeader('Last-Modified')
  return parseHttpDate(lastModified) <= parseHttpDate(ifRange)
}

/**
 * Redirect to path.
 *
 * @param {string} path
 * @private
 */

SendStream.prototype.redirect = function redirect (path) {
  var res = this.res

  if (hasListeners(this, 'directory')) {
    this.emit('directory', res, path)
    return
  }

  if (this.hasTrailingSlash()) {
    this.error(403)
    return
  }

  var loc = encodeUrl(collapseLeadingSlashes(this.path + '/'))
  var doc = createHtmlDocument('Redirecting', 'Redirecting to <a href="' + escapeHtml(loc) + '">' +
    escapeHtml(loc) + '</a>')

  // redirect
  res.statusCode = 301
  res.setHeader('Content-Type', 'text/html; charset=UTF-8')
  res.setHeader('Content-Length', Buffer.byteLength(doc))
  res.setHeader('Content-Security-Policy', "default-src 'self'")
  res.setHeader('X-Content-Type-Options', 'nosniff')
  res.setHeader('Location', loc)
  res.end(doc)
}

/**
 * Pipe to `res.
 *
 * @param {Stream} res
 * @return {Stream} res
 * @api public
 */

SendStream.prototype.pipe = function pipe (res) {
  // root path
  var root = this._root

  // references
  this.res = res

  // decode the path
  var path = decode(this.path)
  if (path === -1) {
    this.error(400)
    return res
  }

  // null byte(s)
  if (~path.indexOf('\0')) {
    this.error(400)
    return res
  }

  var parts
  if (root !== null) {
    // normalize
    if (path) {
      path = normalize('.' + sep + path)
    }

    // malicious path
    if (UP_PATH_REGEXP.test(path)) {
      debug('malicious path "%s"', path)
      this.error(403)
      return res
    }

    // explode path parts
    parts = path.split(sep)

    // join / normalize from optional root dir
    path = normalize(join(root, path))
    root = normalize(root + sep)
  } else {
    // ".." is malicious without "root"
    if (UP_PATH_REGEXP.test(path)) {
      debug('malicious path "%s"', path)
      this.error(403)
      return res
    }

    // explode path parts
    parts = normalize(path).split(sep)

    // resolve the path
    path = resolve(path)
  }

  // dotfile handling
  if (containsDotFile(parts)) {
    var access = this._dotfiles

    // legacy support
    if (access === undefined) {
      access = parts[parts.length - 1][0] === '.'
        ? (this._hidden ? 'allow' : 'ignore')
        : 'allow'
    }

    debug('%s dotfile "%s"', access, path)
    switch (access) {
      case 'allow':
        break
      case 'deny':
        this.error(403)
        return res
      case 'ignore':
      default:
        this.error(404)
        return res
    }
  }

  // index file support
  if (this._index.length && this.hasTrailingSlash()) {
    this.sendIndex(path)
    return res
  }

  this.sendFile(path)
  return res
}

/**
 * Transfer `path`.
 *
 * @param {String} path
 * @api public
 */

SendStream.prototype.send = function send (path, stat) {
  var len = stat.size
  var options = this.options
  var opts = {}
  var res = this.res
  var req = this.req
  var ranges = req.headers.range
  var offset = options.start || 0

  if (headersSent(res)) {
    // impossible to send now
    this.headersAlreadySent()
    return
  }

  debug('pipe "%s"', path)

  // set header fields
  this.setHeader(path, stat)

  // set content-type
  this.type(path)

  // conditional GET support
  if (this.isConditionalGET()) {
    if (this.isPreconditionFailure()) {
      this.error(412)
      return
    }

    if (this.isCachable() && this.isFresh()) {
      this.notModified()
      return
    }
  }

  // adjust len to start/end options
  len = Math.max(0, len - offset)
  if (options.end !== undefined) {
    var bytes = options.end - offset + 1
    if (len > bytes) len = bytes
  }

  // Range support
  if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
    // parse
    ranges = parseRange(len, ranges, {
      combine: true
    })

    // If-Range support
    if (!this.isRangeFresh()) {
      debug('range stale')
      ranges = -2
    }

    // unsatisfiable
    if (ranges === -1) {
      debug('range unsatisfiable')

      // Content-Range
      res.setHeader('Content-Range', contentRange('bytes', len))

      // 416 Requested Range Not Satisfiable
      return this.error(416, {
        headers: {'Content-Range': res.getHeader('Content-Range')}
      })
    }

    // valid (syntactically invalid/multiple ranges are treated as a regular response)
    if (ranges !== -2 && ranges.length === 1) {
      debug('range %j', ranges)

      // Content-Range
      res.statusCode = 206
      res.setHeader('Content-Range', contentRange('bytes', len, ranges[0]))

      // adjust for requested range
      offset += ranges[0].start
      len = ranges[0].end - ranges[0].start + 1
    }
  }

  // clone options
  for (var prop in options) {
    opts[prop] = options[prop]
  }

  // set read options
  opts.start = offset
  opts.end = Math.max(offset, offset + len - 1)

  // content-length
  res.setHeader('Content-Length', len)

  // HEAD support
  if (req.method === 'HEAD') {
    res.end()
    return
  }

  this.stream(path, opts)
}

/**
 * Transfer file for `path`.
 *
 * @param {String} path
 * @api private
 */
SendStream.prototype.sendFile = function sendFile (path) {
  var i = 0
  var self = this

  debug('stat "%s"', path)
  fs.stat(path, function onstat (err, stat) {
    if (err && err.code === 'ENOENT' && !extname(path) && path[path.length - 1] !== sep) {
      // not found, check extensions
      return next(err)
    }
    if (err) return self.onStatError(err)
    if (stat.isDirectory()) return self.redirect(path)
    self.emit('file', path, stat)
    self.send(path, stat)
  })

  function next (err) {
    if (self._extensions.length <= i) {
      return err
        ? self.onStatError(err)
        : self.error(404)
    }

    var p = path + '.' + self._extensions[i++]

    debug('stat "%s"', p)
    fs.stat(p, function (err, stat) {
      if (err) return next(err)
      if (stat.isDirectory()) return next()
      self.emit('file', p, stat)
      self.send(p, stat)
    })
  }
}

/**
 * Transfer index for `path`.
 *
 * @param {String} path
 * @api private
 */
SendStream.prototype.sendIndex = function sendIndex (path) {
  var i = -1
  var self = this

  function next (err) {
    if (++i >= self._index.length) {
      if (err) return self.onStatError(err)
      return self.error(404)
    }

    var p = join(path, self._index[i])

    debug('stat "%s"', p)
    fs.stat(p, function (err, stat) {
      if (err) return next(err)
      if (stat.isDirectory()) return next()
      self.emit('file', p, stat)
      self.send(p, stat)
    })
  }

  next()
}

/**
 * Stream `path` to the response.
 *
 * @param {String} path
 * @param {Object} options
 * @api private
 */

SendStream.prototype.stream = function stream (path, options) {
  // TODO: this is all lame, refactor meeee
  var finished = false
  var self = this
  var res = this.res

  // pipe
  var stream = fs.createReadStream(path, options)
  this.emit('stream', stream)
  stream.pipe(res)

  // response finished, done with the fd
  onFinished(res, function onfinished () {
    finished = true
    destroy(stream)
  })

  // error handling code-smell
  stream.on('error', function onerror (err) {
    // request already finished
    if (finished) return

    // clean up stream
    finished = true
    destroy(stream)

    // error
    self.onStatError(err)
  })

  // end
  stream.on('end', function onend () {
    self.emit('end')
  })
}

/**
 * Set content-type based on `path`
 * if it hasn't been explicitly set.
 *
 * @param {String} path
 * @api private
 */

SendStream.prototype.type = function type (path) {
  var res = this.res

  if (res.getHeader('Content-Type')) return

  var type = mime.lookup(path)

  if (!type) {
    debug('no content-type')
    return
  }

  var charset = mime.charsets.lookup(type)

  debug('content-type %s', type)
  res.setHeader('Content-Type', type + (charset ? '; charset=' + charset : ''))
}

/**
 * Set response header fields, most
 * fields may be pre-defined.
 *
 * @param {String} path
 * @param {Object} stat
 * @api private
 */

SendStream.prototype.setHeader = function setHeader (path, stat) {
  var res = this.res

  this.emit('headers', res, path, stat)

  if (this._acceptRanges && !res.getHeader('Accept-Ranges')) {
    debug('accept ranges')
    res.setHeader('Accept-Ranges', 'bytes')
  }

  if (this._cacheControl && !res.getHeader('Cache-Control')) {
    var cacheControl = 'public, max-age=' + Math.floor(this._maxage / 1000)

    if (this._immutable) {
      cacheControl += ', immutable'
    }

    debug('cache-control %s', cacheControl)
    res.setHeader('Cache-Control', cacheControl)
  }

  if (this._lastModified && !res.getHeader('Last-Modified')) {
    var modified = stat.mtime.toUTCString()
    debug('modified %s', modified)
    res.setHeader('Last-Modified', modified)
  }

  if (this._etag && !res.getHeader('ETag')) {
    var val = etag(stat)
    debug('etag %s', val)
    res.setHeader('ETag', val)
  }
}

/**
 * Clear all headers from a response.
 *
 * @param {object} res
 * @private
 */

function clearHeaders (res) {
  var headers = getHeaderNames(res)

  for (var i = 0; i < headers.length; i++) {
    res.removeHeader(headers[i])
  }
}

/**
 * Collapse all leading slashes into a single slash
 *
 * @param {string} str
 * @private
 */
function collapseLeadingSlashes (str) {
  for (var i = 0; i < str.length; i++) {
    if (str[i] !== '/') {
      break
    }
  }

  return i > 1
    ? '/' + str.substr(i)
    : str
}

/**
 * Determine if path parts contain a dotfile.
 *
 * @api private
 */

function containsDotFile (parts) {
  for (var i = 0; i < parts.length; i++) {
    var part = parts[i]
    if (part.length > 1 && part[0] === '.') {
      return true
    }
  }

  return false
}

/**
 * Create a Content-Range header.
 *
 * @param {string} type
 * @param {number} size
 * @param {array} [range]
 */

function contentRange (type, size, range) {
  return type + ' ' + (range ? range.start + '-' + range.end : '*') + '/' + size
}

/**
 * Create a minimal HTML document.
 *
 * @param {string} title
 * @param {string} body
 * @private
 */

function createHtmlDocument (title, body) {
  return '<!DOCTYPE html>\n' +
    '<html lang="en">\n' +
    '<head>\n' +
    '<meta charset="utf-8">\n' +
    '<title>' + title + '</title>\n' +
    '</head>\n' +
    '<body>\n' +
    '<pre>' + body + '</pre>\n' +
    '</body>\n' +
    '</html>\n'
}

/**
 * decodeURIComponent.
 *
 * Allows V8 to only deoptimize this fn instead of all
 * of send().
 *
 * @param {String} path
 * @api private
 */

function decode (path) {
  try {
    return decodeURIComponent(path)
  } catch (err) {
    return -1
  }
}

/**
 * Get the header names on a respnse.
 *
 * @param {object} res
 * @returns {array[string]}
 * @private
 */

function getHeaderNames (res) {
  return typeof res.getHeaderNames !== 'function'
    ? Object.keys(res._headers || {})
    : res.getHeaderNames()
}

/**
 * Determine if emitter has listeners of a given type.
 *
 * The way to do this check is done three different ways in Node.js >= 0.8
 * so this consolidates them into a minimal set using instance methods.
 *
 * @param {EventEmitter} emitter
 * @param {string} type
 * @returns {boolean}
 * @private
 */

function hasListeners (emitter, type) {
  var count = typeof emitter.listenerCount !== 'function'
    ? emitter.listeners(type).length
    : emitter.listenerCount(type)

  return count > 0
}

/**
 * Determine if the response headers have been sent.
 *
 * @param {object} res
 * @returns {boolean}
 * @private
 */

function headersSent (res) {
  return typeof res.headersSent !== 'boolean'
    ? Boolean(res._header)
    : res.headersSent
}

/**
 * Normalize the index option into an array.
 *
 * @param {boolean|string|array} val
 * @param {string} name
 * @private
 */

function normalizeList (val, name) {
  var list = [].concat(val || [])

  for (var i = 0; i < list.length; i++) {
    if (typeof list[i] !== 'string') {
      throw new TypeError(name + ' must be array of strings or false')
    }
  }

  return list
}

/**
 * Parse an HTTP Date into a number.
 *
 * @param {string} date
 * @private
 */

function parseHttpDate (date) {
  var timestamp = date && Date.parse(date)

  return typeof timestamp === 'number'
    ? timestamp
    : NaN
}

/**
 * Parse a HTTP token list.
 *
 * @param {string} str
 * @private
 */

function parseTokenList (str) {
  var end = 0
  var list = []
  var start = 0

  // gather tokens
  for (var i = 0, len = str.length; i < len; i++) {
    switch (str.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i + 1
        }
        break
      case 0x2c: /* , */
        list.push(str.substring(start, end))
        start = end = i + 1
        break
      default:
        end = i + 1
        break
    }
  }

  // final token
  list.push(str.substring(start, end))

  return list
}

/**
 * Set an object of headers on a response.
 *
 * @param {object} res
 * @param {object} headers
 * @private
 */

function setHeaders (res, headers) {
  var keys = Object.keys(headers)

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i]
    res.setHeader(key, headers[key])
  }
}


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var EventEmitter = __webpack_require__(1).EventEmitter;
var parser = __webpack_require__(31);
var util = __webpack_require__(0);
var debug = __webpack_require__(17)('engine:transport');

/**
 * Expose the constructor.
 */

module.exports = Transport;

/**
 * Noop function.
 *
 * @api private
 */

function noop () {}

/**
 * Transport constructor.
 *
 * @param {http.IncomingMessage} request
 * @api public
 */

function Transport (req) {
  this.readyState = 'open';
  this.discarded = false;
}

/**
 * Inherits from EventEmitter.
 */

util.inherits(Transport, EventEmitter);

/**
 * Flags the transport as discarded.
 *
 * @api private
 */

Transport.prototype.discard = function () {
  this.discarded = true;
};

/**
 * Called with an incoming HTTP request.
 *
 * @param {http.IncomingMessage} request
 * @api private
 */

Transport.prototype.onRequest = function (req) {
  debug('setting request');
  this.req = req;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function (fn) {
  if ('closed' === this.readyState || 'closing' === this.readyState) return;

  this.readyState = 'closing';
  this.doClose(fn || noop);
};

/**
 * Called with a transport error.
 *
 * @param {String} message error
 * @param {Object} error description
 * @api private
 */

Transport.prototype.onError = function (msg, desc) {
  if (this.listeners('error').length) {
    var err = new Error(msg);
    err.type = 'TransportError';
    err.description = desc;
    this.emit('error', err);
  } else {
    debug('ignored transport error %s (%s)', msg, desc);
  }
};

/**
 * Called with parsed out a packets from the data stream.
 *
 * @param {Object} packet
 * @api private
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called with the encoded packet data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function (data) {
  this.onPacket(parser.decodePacket(data));
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

/* global Blob File */

/*
 * Module requirements.
 */

var isArray = __webpack_require__(150);

var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' ||
                        typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]';
var withNativeFile = typeof File === 'function' ||
                        typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]';

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Supports Buffer, ArrayBuffer, Blob and File.
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary (obj) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }

  if (isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }

  if ((typeof Buffer === 'function' && Buffer.isBuffer && Buffer.isBuffer(obj)) ||
    (typeof ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||
    (withNativeBlob && obj instanceof Blob) ||
    (withNativeFile && obj instanceof File)
  ) {
    return true;
  }

  // see: https://github.com/Automattic/has-binary/pull/4
  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const os = __webpack_require__(155);
const hasFlag = __webpack_require__(156);

const env = process.env;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false')) {
	forceColor = false;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = true;
}
if ('FORCE_COLOR' in env) {
	forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(stream) {
	if (forceColor === false) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (stream && !stream.isTTY && forceColor !== true) {
		return 0;
	}

	const min = forceColor ? 1 : 0;

	if (process.platform === 'win32') {
		// Node.js 7.5.0 is the first version of Node.js to include a patch to
		// libuv that enables 256 color output on Windows. Anything earlier and it
		// won't work. However, here we target Node.js 8 at minimum as it is an LTS
		// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
		// release that supports 256 colors. Windows 10 build 14931 is the first release
		// that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(process.versions.node.split('.')[0]) >= 8 &&
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	if (env.TERM === 'dumb') {
		return min;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: getSupportLevel(process.stdout),
	stderr: getSupportLevel(process.stderr)
};


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat(list, totalLength) {
  const target = Buffer.allocUnsafe(totalLength);
  var offset = 0;

  for (var i = 0; i < list.length; i++) {
    const buf = list[i];
    buf.copy(target, offset);
    offset += buf.length;
  }

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) {
  for (var i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask(buffer, mask) {
  // Required until https://github.com/nodejs/node/issues/9006 is resolved.
  const length = buffer.length;
  for (var i = 0; i < length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

try {
  const bufferUtil = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"bufferutil\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
  const bu = bufferUtil.BufferUtil || bufferUtil;

  module.exports = {
    mask(source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bu.mask(source, mask, output, offset, length);
    },
    unmask(buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bu.unmask(buffer, mask);
    },
    concat
  };
} catch (e) /* istanbul ignore next */ {
  module.exports = { concat, mask: _mask, unmask: _unmask };
}


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * depd
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var EventEmitter = __webpack_require__(1).EventEmitter

/**
 * Module exports.
 * @public
 */

lazyProperty(module.exports, 'callSiteToString', function callSiteToString () {
  var limit = Error.stackTraceLimit
  var obj = {}
  var prep = Error.prepareStackTrace

  function prepareObjectStackTrace (obj, stack) {
    return stack
  }

  Error.prepareStackTrace = prepareObjectStackTrace
  Error.stackTraceLimit = 2

  // capture the stack
  Error.captureStackTrace(obj)

  // slice the stack
  var stack = obj.stack.slice()

  Error.prepareStackTrace = prep
  Error.stackTraceLimit = limit

  return stack[0].toString ? toString : __webpack_require__(84)
})

lazyProperty(module.exports, 'eventListenerCount', function eventListenerCount () {
  return EventEmitter.listenerCount || __webpack_require__(85)
})

/**
 * Define a lazy property.
 */

function lazyProperty (obj, prop, getter) {
  function get () {
    var val = getter()

    Object.defineProperty(obj, prop, {
      configurable: true,
      enumerable: true,
      value: val
    })

    return val
  }

  Object.defineProperty(obj, prop, {
    configurable: true,
    enumerable: true,
    get: get
  })
}

/**
 * Call toString() on the obj
 */

function toString (obj) {
  return obj.toString()
}


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(22);

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Some environments don't have global Buffer (e.g. React Native).
// Solution would be installing npm modules "buffer" and "stream" explicitly.
var Buffer = __webpack_require__(9).Buffer;

var bomHandling = __webpack_require__(93),
    iconv = module.exports;

// All codecs and aliases are kept here, keyed by encoding name/alias.
// They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
iconv.encodings = null;

// Characters emitted in case of error.
iconv.defaultCharUnicode = '';
iconv.defaultCharSingleByte = '?';

// Public API.
iconv.encode = function encode(str, encoding, options) {
    str = "" + (str || ""); // Ensure string.

    var encoder = iconv.getEncoder(encoding, options);

    var res = encoder.write(str);
    var trail = encoder.end();
    
    return (trail && trail.length > 0) ? Buffer.concat([res, trail]) : res;
}

iconv.decode = function decode(buf, encoding, options) {
    if (typeof buf === 'string') {
        if (!iconv.skipDecodeWarning) {
            console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
            iconv.skipDecodeWarning = true;
        }

        buf = Buffer.from("" + (buf || ""), "binary"); // Ensure buffer.
    }

    var decoder = iconv.getDecoder(encoding, options);

    var res = decoder.write(buf);
    var trail = decoder.end();

    return trail ? (res + trail) : res;
}

iconv.encodingExists = function encodingExists(enc) {
    try {
        iconv.getCodec(enc);
        return true;
    } catch (e) {
        return false;
    }
}

// Legacy aliases to convert functions
iconv.toEncoding = iconv.encode;
iconv.fromEncoding = iconv.decode;

// Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
iconv._codecDataCache = {};
iconv.getCodec = function getCodec(encoding) {
    if (!iconv.encodings)
        iconv.encodings = __webpack_require__(94); // Lazy load all encoding definitions.
    
    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
    var enc = iconv._canonicalizeEncoding(encoding);

    // Traverse iconv.encodings to find actual codec.
    var codecOptions = {};
    while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
            return codec;

        var codecDef = iconv.encodings[enc];

        switch (typeof codecDef) {
            case "string": // Direct alias to other encoding.
                enc = codecDef;
                break;

            case "object": // Alias with options. Can be layered.
                for (var key in codecDef)
                    codecOptions[key] = codecDef[key];

                if (!codecOptions.encodingName)
                    codecOptions.encodingName = enc;
                
                enc = codecDef.type;
                break;

            case "function": // Codec itself.
                if (!codecOptions.encodingName)
                    codecOptions.encodingName = enc;

                // The codec function must load all tables and return object with .encoder and .decoder methods.
                // It'll be called only once (for each different options object).
                codec = new codecDef(codecOptions, iconv);

                iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
                return codec;

            default:
                throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '"+enc+"')");
        }
    }
}

iconv._canonicalizeEncoding = function(encoding) {
    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
    return (''+encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
}

iconv.getEncoder = function getEncoder(encoding, options) {
    var codec = iconv.getCodec(encoding),
        encoder = new codec.encoder(options, codec);

    if (codec.bomAware && options && options.addBOM)
        encoder = new bomHandling.PrependBOM(encoder, options);

    return encoder;
}

iconv.getDecoder = function getDecoder(encoding, options) {
    var codec = iconv.getCodec(encoding),
        decoder = new codec.decoder(options, codec);

    if (codec.bomAware && !(options && options.stripBOM === false))
        decoder = new bomHandling.StripBOM(decoder, options);

    return decoder;
}


// Load extensions in Node. All of them are omitted in Browserify build via 'browser' field in package.json.
var nodeVer = typeof process !== 'undefined' && process.versions && process.versions.node;
if (nodeVer) {

    // Load streaming support in Node v0.10+
    var nodeVerArr = nodeVer.split(".").map(Number);
    if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
        __webpack_require__(109)(iconv);
    }

    // Load Node primitive extensions.
    __webpack_require__(110)(iconv);
}

if (false) {
    console.error("iconv-lite warning: javascript files use encoding different from utf-8. See https://github.com/ashtuchkin/iconv-lite/wiki/Javascript-source-file-encodings for more info.");
}


/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = [["a140","",62],["a180","",32],["a240","",62],["a280","",32],["a2ab","",5],["a2e3",""],["a2ef",""],["a2fd",""],["a340","",62],["a380","",31,""],["a440","",62],["a480","",32],["a4f4","",10],["a540","",62],["a580","",32],["a5f7","",7],["a640","",62],["a680","",32],["a6b9","",7],["a6d9","",6],["a6ec",""],["a6f3",""],["a6f6","",8],["a740","",62],["a780","",32],["a7c2","",14],["a7f2","",12],["a896","",10],["a8bc",""],["a8bf",""],["a8c1",""],["a8ea","",20],["a958",""],["a95b",""],["a95d",""],["a989","",11],["a997","",12],["a9f0","",14],["aaa1","",93],["aba1","",93],["aca1","",93],["ada1","",93],["aea1","",93],["afa1","",93],["d7fa","",4],["f8a1","",93],["f9a1","",93],["faa1","",93],["fba1","",93],["fca1","",93],["fda1","",93],["fe50",""],["fe80","",6,"",93]]

/***/ }),
/* 49 */
/***/ (function(module, exports) {

module.exports = [["0","\u0000",127],["a140",""],["a1a1","",4,""],["a240","",7,""],["a2a1","",9,"",9,"",8,"",25,"",21],["a340","",16,"",6,"",16,"",6,"",10],["a3a1","",25,""],["a3e1",""],["a440",""],["a4a1",""],["a540",""],["a5a1",""],["a640",""],["a6a1",""],["a740",""],["a7a1",""],["a840",""],["a8a1",""],["a940",""],["a9a1",""],["aa40",""],["aaa1",""],["ab40",""],["aba1",""],["ac40",""],["aca1",""],["ad40",""],["ada1",""],["ae40",""],["aea1",""],["af40",""],["afa1",""],["b040",""],["b0a1",""],["b140",""],["b1a1",""],["b240",""],["b2a1",""],["b340",""],["b3a1",""],["b440",""],["b4a1",""],["b540",""],["b5a1",""],["b640",""],["b6a1",""],["b740",""],["b7a1",""],["b840",""],["b8a1",""],["b940",""],["b9a1",""],["ba40",""],["baa1",""],["bb40",""],["bba1",""],["bc40",""],["bca1",""],["bd40",""],["bda1",""],["be40",""],["bea1",""],["bf40",""],["bfa1",""],["c040",""],["c0a1",""],["c140",""],["c1a1",""],["c240",""],["c2a1",""],["c340",""],["c3a1",""],["c440",""],["c4a1",""],["c540",""],["c5a1",""],["c640",""],["c940",""],["c9a1",""],["ca40",""],["caa1",""],["cb40",""],["cba1",""],["cc40",""],["cca1",""],["cd40",""],["cda1",""],["ce40",""],["cea1",""],["cf40",""],["cfa1",""],["d040",""],["d0a1",""],["d140",""],["d1a1",""],["d240",""],["d2a1",""],["d340",""],["d3a1",""],["d440",""],["d4a1",""],["d540",""],["d5a1",""],["d640",""],["d6a1",""],["d740",""],["d7a1",""],["d840",""],["d8a1",""],["d940",""],["d9a1",""],["da40",""],["daa1",""],["db40",""],["dba1",""],["dc40",""],["dca1",""],["dd40",""],["dda1",""],["de40",""],["dea1",""],["df40",""],["dfa1",""],["e040",""],["e0a1",""],["e140",""],["e1a1",""],["e240",""],["e2a1",""],["e340",""],["e3a1",""],["e440",""],["e4a1",""],["e540",""],["e5a1",""],["e640",""],["e6a1",""],["e740",""],["e7a1",""],["e840",""],["e8a1",""],["e940",""],["e9a1",""],["ea40",""],["eaa1",""],["eb40",""],["eba1",""],["ec40",""],["eca1",""],["ed40",""],["eda1",""],["ee40",""],["eea1",""],["ef40",""],["efa1",""],["f040",""],["f0a1",""],["f140",""],["f1a1",""],["f240",""],["f2a1",""],["f340",""],["f3a1",""],["f440",""],["f4a1",""],["f540",""],["f5a1",""],["f640",""],["f6a1",""],["f740",""],["f7a1",""],["f840",""],["f8a1",""],["f940",""],["f9a1",""]]

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = unpipe

/**
 * Determine if there are Node.js pipe-like data listeners.
 * @private
 */

function hasPipeDataListeners(stream) {
  var listeners = stream.listeners('data')

  for (var i = 0; i < listeners.length; i++) {
    if (listeners[i].name === 'ondata') {
      return true
    }
  }

  return false
}

/**
 * Unpipe a stream from all destinations.
 *
 * @param {object} stream
 * @public
 */

function unpipe(stream) {
  if (!stream) {
    throw new TypeError('argument stream is required')
  }

  if (typeof stream.unpipe === 'function') {
    // new-style
    stream.unpipe()
    return
  }

  // Node.js 0.8 hack
  if (!hasPipeDataListeners(stream)) {
    return
  }

  var listener
  var listeners = stream.listeners('close')

  for (var i = 0; i < listeners.length; i++) {
    listener = listeners[i]

    if (listener.name !== 'cleanup' && listener.name !== 'onclose') {
      continue
    }

    // invoke the listener
    listener.call(stream)
  }
}


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var db = __webpack_require__(113)
var extname = __webpack_require__(2).extname

/**
 * Module variables.
 * @private
 */

var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/
var TEXT_TYPE_REGEXP = /^text\//i

/**
 * Module exports.
 * @public
 */

exports.charset = charset
exports.charsets = { lookup: charset }
exports.contentType = contentType
exports.extension = extension
exports.extensions = Object.create(null)
exports.lookup = lookup
exports.types = Object.create(null)

// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types)

/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)
  var mime = match && db[match[1].toLowerCase()]

  if (mime && mime.charset) {
    return mime.charset
  }

  // default text/* to utf-8
  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8'
  }

  return false
}

/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */

function contentType (str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false
  }

  var mime = str.indexOf('/') === -1
    ? exports.lookup(str)
    : str

  if (!mime) {
    return false
  }

  // TODO: use content-type or other module
  if (mime.indexOf('charset') === -1) {
    var charset = exports.charset(mime)
    if (charset) mime += '; charset=' + charset.toLowerCase()
  }

  return mime
}

/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function extension (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)

  // get extensions
  var exts = match && exports.extensions[match[1].toLowerCase()]

  if (!exts || !exts.length) {
    return false
  }

  return exts[0]
}

/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */

function lookup (path) {
  if (!path || typeof path !== 'string') {
    return false
  }

  // get the extension ("ext" or ".ext" or full path)
  var extension = extname('x.' + path)
    .toLowerCase()
    .substr(1)

  if (!extension) {
    return false
  }

  return exports.types[extension] || false
}

/**
 * Populate the extensions and types maps.
 * @private
 */

function populateMaps (extensions, types) {
  // source preference (least -> most)
  var preference = ['nginx', 'apache', undefined, 'iana']

  Object.keys(db).forEach(function forEachMimeType (type) {
    var mime = db[type]
    var exts = mime.extensions

    if (!exts || !exts.length) {
      return
    }

    // mime -> extensions
    extensions[type] = exts

    // extension -> mime
    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i]

      if (types[extension]) {
        var from = preference.indexOf(db[types[extension]].source)
        var to = preference.indexOf(mime.source)

        if (types[extension] !== 'application/octet-stream' &&
          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
          // skip the remapping
          continue
        }
      }

      // set the extension -> mime
      types[extension] = type
    }
  })
}


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    var obj;

    while (queue.length) {
        var item = queue.pop();
        obj = item.obj[item.prop];

        if (Array.isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }

    return obj;
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (Array.isArray(target)) {
            target.push(source);
        } else if (typeof target === 'object') {
            if (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (Array.isArray(target) && !Array.isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (Array.isArray(target) && Array.isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                if (target[i] && typeof target[i] === 'object') {
                    target[i] = merge(target[i], item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str) {
    try {
        return decodeURIComponent(str.replace(/\+/g, ' '));
    } catch (e) {
        return str;
    }
};

var encode = function encode(str) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = typeof str === 'string' ? str : String(str);

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    return compactQueue(queue);
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (obj === null || typeof obj === 'undefined') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    merge: merge
};


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

module.exports = {
    'default': 'RFC3986',
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return value;
        }
    },
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var Route = __webpack_require__(55);
var Layer = __webpack_require__(56);
var methods = __webpack_require__(39);
var mixin = __webpack_require__(30);
var debug = __webpack_require__(3)('express:router');
var deprecate = __webpack_require__(5)('express');
var flatten = __webpack_require__(29);
var parseUrl = __webpack_require__(16);
var setPrototypeOf = __webpack_require__(20)

/**
 * Module variables.
 * @private
 */

var objectRegExp = /^\[object (\S+)\]$/;
var slice = Array.prototype.slice;
var toString = Object.prototype.toString;

/**
 * Initialize a new `Router` with the given `options`.
 *
 * @param {Object} [options]
 * @return {Router} which is an callable function
 * @public
 */

var proto = module.exports = function(options) {
  var opts = options || {};

  function router(req, res, next) {
    router.handle(req, res, next);
  }

  // mixin Router class functions
  setPrototypeOf(router, proto)

  router.params = {};
  router._params = [];
  router.caseSensitive = opts.caseSensitive;
  router.mergeParams = opts.mergeParams;
  router.strict = opts.strict;
  router.stack = [];

  return router;
};

/**
 * Map the given param placeholder `name`(s) to the given callback.
 *
 * Parameter mapping is used to provide pre-conditions to routes
 * which use normalized placeholders. For example a _:user_id_ parameter
 * could automatically load a user's information from the database without
 * any additional code,
 *
 * The callback uses the same signature as middleware, the only difference
 * being that the value of the placeholder is passed, in this case the _id_
 * of the user. Once the `next()` function is invoked, just like middleware
 * it will continue on to execute the route, or subsequent parameter functions.
 *
 * Just like in middleware, you must either respond to the request or call next
 * to avoid stalling the request.
 *
 *  app.param('user_id', function(req, res, next, id){
 *    User.find(id, function(err, user){
 *      if (err) {
 *        return next(err);
 *      } else if (!user) {
 *        return next(new Error('failed to load user'));
 *      }
 *      req.user = user;
 *      next();
 *    });
 *  });
 *
 * @param {String} name
 * @param {Function} fn
 * @return {app} for chaining
 * @public
 */

proto.param = function param(name, fn) {
  // param logic
  if (typeof name === 'function') {
    deprecate('router.param(fn): Refactor to use path params');
    this._params.push(name);
    return;
  }

  // apply param functions
  var params = this._params;
  var len = params.length;
  var ret;

  if (name[0] === ':') {
    deprecate('router.param(' + JSON.stringify(name) + ', fn): Use router.param(' + JSON.stringify(name.substr(1)) + ', fn) instead');
    name = name.substr(1);
  }

  for (var i = 0; i < len; ++i) {
    if (ret = params[i](name, fn)) {
      fn = ret;
    }
  }

  // ensure we end up with a
  // middleware function
  if ('function' !== typeof fn) {
    throw new Error('invalid param() call for ' + name + ', got ' + fn);
  }

  (this.params[name] = this.params[name] || []).push(fn);
  return this;
};

/**
 * Dispatch a req, res into the router.
 * @private
 */

proto.handle = function handle(req, res, out) {
  var self = this;

  debug('dispatching %s %s', req.method, req.url);

  var idx = 0;
  var protohost = getProtohost(req.url) || ''
  var removed = '';
  var slashAdded = false;
  var paramcalled = {};

  // store options for OPTIONS request
  // only used if OPTIONS request
  var options = [];

  // middleware and routes
  var stack = self.stack;

  // manage inter-router variables
  var parentParams = req.params;
  var parentUrl = req.baseUrl || '';
  var done = restore(out, req, 'baseUrl', 'next', 'params');

  // setup next layer
  req.next = next;

  // for options requests, respond with a default if nothing else responds
  if (req.method === 'OPTIONS') {
    done = wrap(done, function(old, err) {
      if (err || options.length === 0) return old(err);
      sendOptionsResponse(res, options, old);
    });
  }

  // setup basic req values
  req.baseUrl = parentUrl;
  req.originalUrl = req.originalUrl || req.url;

  next();

  function next(err) {
    var layerError = err === 'route'
      ? null
      : err;

    // remove added slash
    if (slashAdded) {
      req.url = req.url.substr(1);
      slashAdded = false;
    }

    // restore altered req.url
    if (removed.length !== 0) {
      req.baseUrl = parentUrl;
      req.url = protohost + removed + req.url.substr(protohost.length);
      removed = '';
    }

    // signal to exit router
    if (layerError === 'router') {
      setImmediate(done, null)
      return
    }

    // no more matching layers
    if (idx >= stack.length) {
      setImmediate(done, layerError);
      return;
    }

    // get pathname of request
    var path = getPathname(req);

    if (path == null) {
      return done(layerError);
    }

    // find next matching layer
    var layer;
    var match;
    var route;

    while (match !== true && idx < stack.length) {
      layer = stack[idx++];
      match = matchLayer(layer, path);
      route = layer.route;

      if (typeof match !== 'boolean') {
        // hold on to layerError
        layerError = layerError || match;
      }

      if (match !== true) {
        continue;
      }

      if (!route) {
        // process non-route handlers normally
        continue;
      }

      if (layerError) {
        // routes do not match with a pending error
        match = false;
        continue;
      }

      var method = req.method;
      var has_method = route._handles_method(method);

      // build up automatic options response
      if (!has_method && method === 'OPTIONS') {
        appendMethods(options, route._options());
      }

      // don't even bother matching route
      if (!has_method && method !== 'HEAD') {
        match = false;
        continue;
      }
    }

    // no match
    if (match !== true) {
      return done(layerError);
    }

    // store route for dispatch on change
    if (route) {
      req.route = route;
    }

    // Capture one-time layer values
    req.params = self.mergeParams
      ? mergeParams(layer.params, parentParams)
      : layer.params;
    var layerPath = layer.path;

    // this should be done for the layer
    self.process_params(layer, paramcalled, req, res, function (err) {
      if (err) {
        return next(layerError || err);
      }

      if (route) {
        return layer.handle_request(req, res, next);
      }

      trim_prefix(layer, layerError, layerPath, path);
    });
  }

  function trim_prefix(layer, layerError, layerPath, path) {
    if (layerPath.length !== 0) {
      // Validate path breaks on a path separator
      var c = path[layerPath.length]
      if (c && c !== '/' && c !== '.') return next(layerError)

      // Trim off the part of the url that matches the route
      // middleware (.use stuff) needs to have the path stripped
      debug('trim prefix (%s) from url %s', layerPath, req.url);
      removed = layerPath;
      req.url = protohost + req.url.substr(protohost.length + removed.length);

      // Ensure leading slash
      if (!protohost && req.url[0] !== '/') {
        req.url = '/' + req.url;
        slashAdded = true;
      }

      // Setup base URL (no trailing slash)
      req.baseUrl = parentUrl + (removed[removed.length - 1] === '/'
        ? removed.substring(0, removed.length - 1)
        : removed);
    }

    debug('%s %s : %s', layer.name, layerPath, req.originalUrl);

    if (layerError) {
      layer.handle_error(layerError, req, res, next);
    } else {
      layer.handle_request(req, res, next);
    }
  }
};

/**
 * Process any parameters for the layer.
 * @private
 */

proto.process_params = function process_params(layer, called, req, res, done) {
  var params = this.params;

  // captured parameters from the layer, keys and values
  var keys = layer.keys;

  // fast track
  if (!keys || keys.length === 0) {
    return done();
  }

  var i = 0;
  var name;
  var paramIndex = 0;
  var key;
  var paramVal;
  var paramCallbacks;
  var paramCalled;

  // process params in order
  // param callbacks can be async
  function param(err) {
    if (err) {
      return done(err);
    }

    if (i >= keys.length ) {
      return done();
    }

    paramIndex = 0;
    key = keys[i++];
    name = key.name;
    paramVal = req.params[name];
    paramCallbacks = params[name];
    paramCalled = called[name];

    if (paramVal === undefined || !paramCallbacks) {
      return param();
    }

    // param previously called with same value or error occurred
    if (paramCalled && (paramCalled.match === paramVal
      || (paramCalled.error && paramCalled.error !== 'route'))) {
      // restore value
      req.params[name] = paramCalled.value;

      // next param
      return param(paramCalled.error);
    }

    called[name] = paramCalled = {
      error: null,
      match: paramVal,
      value: paramVal
    };

    paramCallback();
  }

  // single param callbacks
  function paramCallback(err) {
    var fn = paramCallbacks[paramIndex++];

    // store updated value
    paramCalled.value = req.params[key.name];

    if (err) {
      // store error
      paramCalled.error = err;
      param(err);
      return;
    }

    if (!fn) return param();

    try {
      fn(req, res, paramCallback, paramVal, key.name);
    } catch (e) {
      paramCallback(e);
    }
  }

  param();
};

/**
 * Use the given middleware function, with optional path, defaulting to "/".
 *
 * Use (like `.all`) will run for any http METHOD, but it will not add
 * handlers for those methods so OPTIONS requests will not consider `.use`
 * functions even if they could respond.
 *
 * The other difference is that _route_ path is stripped and not visible
 * to the handler function. The main effect of this feature is that mounted
 * handlers can operate without any code changes regardless of the "prefix"
 * pathname.
 *
 * @public
 */

proto.use = function use(fn) {
  var offset = 0;
  var path = '/';

  // default path to '/'
  // disambiguate router.use([fn])
  if (typeof fn !== 'function') {
    var arg = fn;

    while (Array.isArray(arg) && arg.length !== 0) {
      arg = arg[0];
    }

    // first arg is the path
    if (typeof arg !== 'function') {
      offset = 1;
      path = fn;
    }
  }

  var callbacks = flatten(slice.call(arguments, offset));

  if (callbacks.length === 0) {
    throw new TypeError('Router.use() requires a middleware function')
  }

  for (var i = 0; i < callbacks.length; i++) {
    var fn = callbacks[i];

    if (typeof fn !== 'function') {
      throw new TypeError('Router.use() requires a middleware function but got a ' + gettype(fn))
    }

    // add the middleware
    debug('use %o %s', path, fn.name || '<anonymous>')

    var layer = new Layer(path, {
      sensitive: this.caseSensitive,
      strict: false,
      end: false
    }, fn);

    layer.route = undefined;

    this.stack.push(layer);
  }

  return this;
};

/**
 * Create a new Route for the given path.
 *
 * Each route contains a separate middleware stack and VERB handlers.
 *
 * See the Route api documentation for details on adding handlers
 * and middleware to routes.
 *
 * @param {String} path
 * @return {Route}
 * @public
 */

proto.route = function route(path) {
  var route = new Route(path);

  var layer = new Layer(path, {
    sensitive: this.caseSensitive,
    strict: this.strict,
    end: true
  }, route.dispatch.bind(route));

  layer.route = route;

  this.stack.push(layer);
  return route;
};

// create Router#VERB functions
methods.concat('all').forEach(function(method){
  proto[method] = function(path){
    var route = this.route(path)
    route[method].apply(route, slice.call(arguments, 1));
    return this;
  };
});

// append methods to a list of methods
function appendMethods(list, addition) {
  for (var i = 0; i < addition.length; i++) {
    var method = addition[i];
    if (list.indexOf(method) === -1) {
      list.push(method);
    }
  }
}

// get pathname of request
function getPathname(req) {
  try {
    return parseUrl(req).pathname;
  } catch (err) {
    return undefined;
  }
}

// Get get protocol + host for a URL
function getProtohost(url) {
  if (typeof url !== 'string' || url.length === 0 || url[0] === '/') {
    return undefined
  }

  var searchIndex = url.indexOf('?')
  var pathLength = searchIndex !== -1
    ? searchIndex
    : url.length
  var fqdnIndex = url.substr(0, pathLength).indexOf('://')

  return fqdnIndex !== -1
    ? url.substr(0, url.indexOf('/', 3 + fqdnIndex))
    : undefined
}

// get type for error message
function gettype(obj) {
  var type = typeof obj;

  if (type !== 'object') {
    return type;
  }

  // inspect [[Class]] for objects
  return toString.call(obj)
    .replace(objectRegExp, '$1');
}

/**
 * Match path to a layer.
 *
 * @param {Layer} layer
 * @param {string} path
 * @private
 */

function matchLayer(layer, path) {
  try {
    return layer.match(path);
  } catch (err) {
    return err;
  }
}

// merge params with parent params
function mergeParams(params, parent) {
  if (typeof parent !== 'object' || !parent) {
    return params;
  }

  // make copy of parent for base
  var obj = mixin({}, parent);

  // simple non-numeric merging
  if (!(0 in params) || !(0 in parent)) {
    return mixin(obj, params);
  }

  var i = 0;
  var o = 0;

  // determine numeric gaps
  while (i in params) {
    i++;
  }

  while (o in parent) {
    o++;
  }

  // offset numeric indices in params before merge
  for (i--; i >= 0; i--) {
    params[i + o] = params[i];

    // create holes for the merge when necessary
    if (i < o) {
      delete params[i];
    }
  }

  return mixin(obj, params);
}

// restore obj props after function
function restore(fn, obj) {
  var props = new Array(arguments.length - 2);
  var vals = new Array(arguments.length - 2);

  for (var i = 0; i < props.length; i++) {
    props[i] = arguments[i + 2];
    vals[i] = obj[props[i]];
  }

  return function () {
    // restore vals
    for (var i = 0; i < props.length; i++) {
      obj[props[i]] = vals[i];
    }

    return fn.apply(this, arguments);
  };
}

// send an OPTIONS response
function sendOptionsResponse(res, options, next) {
  try {
    var body = options.join(',');
    res.set('Allow', body);
    res.send(body);
  } catch (err) {
    next(err);
  }
}

// wrap a function
function wrap(old, fn) {
  return function proxy() {
    var args = new Array(arguments.length + 1);

    args[0] = old;
    for (var i = 0, len = arguments.length; i < len; i++) {
      args[i + 1] = arguments[i];
    }

    fn.apply(this, args);
  };
}


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var debug = __webpack_require__(3)('express:router:route');
var flatten = __webpack_require__(29);
var Layer = __webpack_require__(56);
var methods = __webpack_require__(39);

/**
 * Module variables.
 * @private
 */

var slice = Array.prototype.slice;
var toString = Object.prototype.toString;

/**
 * Module exports.
 * @public
 */

module.exports = Route;

/**
 * Initialize `Route` with the given `path`,
 *
 * @param {String} path
 * @public
 */

function Route(path) {
  this.path = path;
  this.stack = [];

  debug('new %o', path)

  // route handlers for various http methods
  this.methods = {};
}

/**
 * Determine if the route handles a given method.
 * @private
 */

Route.prototype._handles_method = function _handles_method(method) {
  if (this.methods._all) {
    return true;
  }

  var name = method.toLowerCase();

  if (name === 'head' && !this.methods['head']) {
    name = 'get';
  }

  return Boolean(this.methods[name]);
};

/**
 * @return {Array} supported HTTP methods
 * @private
 */

Route.prototype._options = function _options() {
  var methods = Object.keys(this.methods);

  // append automatic head
  if (this.methods.get && !this.methods.head) {
    methods.push('head');
  }

  for (var i = 0; i < methods.length; i++) {
    // make upper case
    methods[i] = methods[i].toUpperCase();
  }

  return methods;
};

/**
 * dispatch req, res into this route
 * @private
 */

Route.prototype.dispatch = function dispatch(req, res, done) {
  var idx = 0;
  var stack = this.stack;
  if (stack.length === 0) {
    return done();
  }

  var method = req.method.toLowerCase();
  if (method === 'head' && !this.methods['head']) {
    method = 'get';
  }

  req.route = this;

  next();

  function next(err) {
    // signal to exit route
    if (err && err === 'route') {
      return done();
    }

    // signal to exit router
    if (err && err === 'router') {
      return done(err)
    }

    var layer = stack[idx++];
    if (!layer) {
      return done(err);
    }

    if (layer.method && layer.method !== method) {
      return next(err);
    }

    if (err) {
      layer.handle_error(err, req, res, next);
    } else {
      layer.handle_request(req, res, next);
    }
  }
};

/**
 * Add a handler for all HTTP verbs to this route.
 *
 * Behaves just like middleware and can respond or call `next`
 * to continue processing.
 *
 * You can use multiple `.all` call to add multiple handlers.
 *
 *   function check_something(req, res, next){
 *     next();
 *   };
 *
 *   function validate_user(req, res, next){
 *     next();
 *   };
 *
 *   route
 *   .all(validate_user)
 *   .all(check_something)
 *   .get(function(req, res, next){
 *     res.send('hello world');
 *   });
 *
 * @param {function} handler
 * @return {Route} for chaining
 * @api public
 */

Route.prototype.all = function all() {
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i < handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== 'function') {
      var type = toString.call(handle);
      var msg = 'Route.all() requires a callback function but got a ' + type
      throw new TypeError(msg);
    }

    var layer = Layer('/', {}, handle);
    layer.method = undefined;

    this.methods._all = true;
    this.stack.push(layer);
  }

  return this;
};

methods.forEach(function(method){
  Route.prototype[method] = function(){
    var handles = flatten(slice.call(arguments));

    for (var i = 0; i < handles.length; i++) {
      var handle = handles[i];

      if (typeof handle !== 'function') {
        var type = toString.call(handle);
        var msg = 'Route.' + method + '() requires a callback function but got a ' + type
        throw new Error(msg);
      }

      debug('%s %o', method, this.path)

      var layer = Layer('/', {}, handle);
      layer.method = method;

      this.methods[method] = true;
      this.stack.push(layer);
    }

    return this;
  };
});


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var pathRegexp = __webpack_require__(123);
var debug = __webpack_require__(3)('express:router:layer');

/**
 * Module variables.
 * @private
 */

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Module exports.
 * @public
 */

module.exports = Layer;

function Layer(path, options, fn) {
  if (!(this instanceof Layer)) {
    return new Layer(path, options, fn);
  }

  debug('new %o', path)
  var opts = options || {};

  this.handle = fn;
  this.name = fn.name || '<anonymous>';
  this.params = undefined;
  this.path = undefined;
  this.regexp = pathRegexp(path, this.keys = [], opts);

  // set fast path flags
  this.regexp.fast_star = path === '*'
  this.regexp.fast_slash = path === '/' && opts.end === false
}

/**
 * Handle the error for the layer.
 *
 * @param {Error} error
 * @param {Request} req
 * @param {Response} res
 * @param {function} next
 * @api private
 */

Layer.prototype.handle_error = function handle_error(error, req, res, next) {
  var fn = this.handle;

  if (fn.length !== 4) {
    // not a standard error handler
    return next(error);
  }

  try {
    fn(error, req, res, next);
  } catch (err) {
    next(err);
  }
};

/**
 * Handle the request for the layer.
 *
 * @param {Request} req
 * @param {Response} res
 * @param {function} next
 * @api private
 */

Layer.prototype.handle_request = function handle(req, res, next) {
  var fn = this.handle;

  if (fn.length > 3) {
    // not a standard request handler
    return next();
  }

  try {
    fn(req, res, next);
  } catch (err) {
    next(err);
  }
};

/**
 * Check if this route matches `path`, if so
 * populate `.params`.
 *
 * @param {String} path
 * @return {Boolean}
 * @api private
 */

Layer.prototype.match = function match(path) {
  var match

  if (path != null) {
    // fast path non-ending match for / (any path matches)
    if (this.regexp.fast_slash) {
      this.params = {}
      this.path = ''
      return true
    }

    // fast path for * (everything matched in a param)
    if (this.regexp.fast_star) {
      this.params = {'0': decode_param(path)}
      this.path = path
      return true
    }

    // match the path
    match = this.regexp.exec(path)
  }

  if (!match) {
    this.params = undefined;
    this.path = undefined;
    return false;
  }

  // store values
  this.params = {};
  this.path = match[0]

  var keys = this.keys;
  var params = this.params;

  for (var i = 1; i < match.length; i++) {
    var key = keys[i - 1];
    var prop = key.name;
    var val = decode_param(match[i])

    if (val !== undefined || !(hasOwnProperty.call(params, prop))) {
      params[prop] = val;
    }
  }

  return true;
};

/**
 * Decode param value.
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function decode_param(val) {
  if (typeof val !== 'string' || val.length === 0) {
    return val;
  }

  try {
    return decodeURIComponent(val);
  } catch (err) {
    if (err instanceof URIError) {
      err.message = 'Failed to decode param \'' + val + '\'';
      err.status = err.statusCode = 400;
    }

    throw err;
  }
}


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 */

var merge = __webpack_require__(30)
var parseUrl = __webpack_require__(16);
var qs = __webpack_require__(38);

/**
 * @param {Object} options
 * @return {Function}
 * @api public
 */

module.exports = function query(options) {
  var opts = merge({}, options)
  var queryparse = qs.parse;

  if (typeof options === 'function') {
    queryparse = options;
    opts = undefined;
  }

  if (opts !== undefined && opts.allowPrototypes === undefined) {
    // back-compat for qs module
    opts.allowPrototypes = true;
  }

  return function query(req, res, next){
    if (!req.query) {
      var val = parseUrl(req).query;
      req.query = queryparse(val, opts);
    }

    next();
  };
};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(10)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * content-disposition
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 */

module.exports = contentDisposition
module.exports.parse = parse

/**
 * Module dependencies.
 */

var basename = __webpack_require__(2).basename

/**
 * RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including "%")
 */

var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g // eslint-disable-line no-control-regex

/**
 * RegExp to match percent encoding escape.
 */

var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/
var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g

/**
 * RegExp to match non-latin1 characters.
 */

var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g

/**
 * RegExp to match quoted-pair in RFC 2616
 *
 * quoted-pair = "\" CHAR
 * CHAR        = <any US-ASCII character (octets 0 - 127)>
 */

var QESC_REGEXP = /\\([\u0000-\u007f])/g

/**
 * RegExp to match chars that must be quoted-pair in RFC 2616
 */

var QUOTE_REGEXP = /([\\"])/g

/**
 * RegExp for various RFC 2616 grammar
 *
 * parameter     = token "=" ( token | quoted-string )
 * token         = 1*<any CHAR except CTLs or separators>
 * separators    = "(" | ")" | "<" | ">" | "@"
 *               | "," | ";" | ":" | "\" | <">
 *               | "/" | "[" | "]" | "?" | "="
 *               | "{" | "}" | SP | HT
 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
 * qdtext        = <any TEXT except <">>
 * quoted-pair   = "\" CHAR
 * CHAR          = <any US-ASCII character (octets 0 - 127)>
 * TEXT          = <any OCTET except CTLs, but including LWS>
 * LWS           = [CRLF] 1*( SP | HT )
 * CRLF          = CR LF
 * CR            = <US-ASCII CR, carriage return (13)>
 * LF            = <US-ASCII LF, linefeed (10)>
 * SP            = <US-ASCII SP, space (32)>
 * HT            = <US-ASCII HT, horizontal-tab (9)>
 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
 * OCTET         = <any 8-bit sequence of data>
 */

var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g // eslint-disable-line no-control-regex
var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/
var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/

/**
 * RegExp for various RFC 5987 grammar
 *
 * ext-value     = charset  "'" [ language ] "'" value-chars
 * charset       = "UTF-8" / "ISO-8859-1" / mime-charset
 * mime-charset  = 1*mime-charsetc
 * mime-charsetc = ALPHA / DIGIT
 *               / "!" / "#" / "$" / "%" / "&"
 *               / "+" / "-" / "^" / "_" / "`"
 *               / "{" / "}" / "~"
 * language      = ( 2*3ALPHA [ extlang ] )
 *               / 4ALPHA
 *               / 5*8ALPHA
 * extlang       = *3( "-" 3ALPHA )
 * value-chars   = *( pct-encoded / attr-char )
 * pct-encoded   = "%" HEXDIG HEXDIG
 * attr-char     = ALPHA / DIGIT
 *               / "!" / "#" / "$" / "&" / "+" / "-" / "."
 *               / "^" / "_" / "`" / "|" / "~"
 */

var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/

/**
 * RegExp for various RFC 6266 grammar
 *
 * disposition-type = "inline" | "attachment" | disp-ext-type
 * disp-ext-type    = token
 * disposition-parm = filename-parm | disp-ext-parm
 * filename-parm    = "filename" "=" value
 *                  | "filename*" "=" ext-value
 * disp-ext-parm    = token "=" value
 *                  | ext-token "=" ext-value
 * ext-token        = <the characters in token, followed by "*">
 */

var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/ // eslint-disable-line no-control-regex

/**
 * Create an attachment Content-Disposition header.
 *
 * @param {string} [filename]
 * @param {object} [options]
 * @param {string} [options.type=attachment]
 * @param {string|boolean} [options.fallback=true]
 * @return {string}
 * @api public
 */

function contentDisposition (filename, options) {
  var opts = options || {}

  // get type
  var type = opts.type || 'attachment'

  // get parameters
  var params = createparams(filename, opts.fallback)

  // format into string
  return format(new ContentDisposition(type, params))
}

/**
 * Create parameters object from filename and fallback.
 *
 * @param {string} [filename]
 * @param {string|boolean} [fallback=true]
 * @return {object}
 * @api private
 */

function createparams (filename, fallback) {
  if (filename === undefined) {
    return
  }

  var params = {}

  if (typeof filename !== 'string') {
    throw new TypeError('filename must be a string')
  }

  // fallback defaults to true
  if (fallback === undefined) {
    fallback = true
  }

  if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {
    throw new TypeError('fallback must be a string or boolean')
  }

  if (typeof fallback === 'string' && NON_LATIN1_REGEXP.test(fallback)) {
    throw new TypeError('fallback must be ISO-8859-1 string')
  }

  // restrict to file base name
  var name = basename(filename)

  // determine if name is suitable for quoted string
  var isQuotedString = TEXT_REGEXP.test(name)

  // generate fallback name
  var fallbackName = typeof fallback !== 'string'
    ? fallback && getlatin1(name)
    : basename(fallback)
  var hasFallback = typeof fallbackName === 'string' && fallbackName !== name

  // set extended filename parameter
  if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
    params['filename*'] = name
  }

  // set filename parameter
  if (isQuotedString || hasFallback) {
    params.filename = hasFallback
      ? fallbackName
      : name
  }

  return params
}

/**
 * Format object to Content-Disposition header.
 *
 * @param {object} obj
 * @param {string} obj.type
 * @param {object} [obj.parameters]
 * @return {string}
 * @api private
 */

function format (obj) {
  var parameters = obj.parameters
  var type = obj.type

  if (!type || typeof type !== 'string' || !TOKEN_REGEXP.test(type)) {
    throw new TypeError('invalid type')
  }

  // start with normalized type
  var string = String(type).toLowerCase()

  // append parameters
  if (parameters && typeof parameters === 'object') {
    var param
    var params = Object.keys(parameters).sort()

    for (var i = 0; i < params.length; i++) {
      param = params[i]

      var val = param.substr(-1) === '*'
        ? ustring(parameters[param])
        : qstring(parameters[param])

      string += '; ' + param + '=' + val
    }
  }

  return string
}

/**
 * Decode a RFC 6987 field value (gracefully).
 *
 * @param {string} str
 * @return {string}
 * @api private
 */

function decodefield (str) {
  var match = EXT_VALUE_REGEXP.exec(str)

  if (!match) {
    throw new TypeError('invalid extended field value')
  }

  var charset = match[1].toLowerCase()
  var encoded = match[2]
  var value

  // to binary string
  var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode)

  switch (charset) {
    case 'iso-8859-1':
      value = getlatin1(binary)
      break
    case 'utf-8':
      value = new Buffer(binary, 'binary').toString('utf8')
      break
    default:
      throw new TypeError('unsupported charset in extended field')
  }

  return value
}

/**
 * Get ISO-8859-1 version of string.
 *
 * @param {string} val
 * @return {string}
 * @api private
 */

function getlatin1 (val) {
  // simple Unicode -> ISO-8859-1 transformation
  return String(val).replace(NON_LATIN1_REGEXP, '?')
}

/**
 * Parse Content-Disposition header string.
 *
 * @param {string} string
 * @return {object}
 * @api private
 */

function parse (string) {
  if (!string || typeof string !== 'string') {
    throw new TypeError('argument string is required')
  }

  var match = DISPOSITION_TYPE_REGEXP.exec(string)

  if (!match) {
    throw new TypeError('invalid type format')
  }

  // normalize type
  var index = match[0].length
  var type = match[1].toLowerCase()

  var key
  var names = []
  var params = {}
  var value

  // calculate index to start at
  index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ';'
    ? index - 1
    : index

  // match parameters
  while ((match = PARAM_REGEXP.exec(string))) {
    if (match.index !== index) {
      throw new TypeError('invalid parameter format')
    }

    index += match[0].length
    key = match[1].toLowerCase()
    value = match[2]

    if (names.indexOf(key) !== -1) {
      throw new TypeError('invalid duplicate parameter')
    }

    names.push(key)

    if (key.indexOf('*') + 1 === key.length) {
      // decode extended value
      key = key.slice(0, -1)
      value = decodefield(value)

      // overwrite existing value
      params[key] = value
      continue
    }

    if (typeof params[key] === 'string') {
      continue
    }

    if (value[0] === '"') {
      // remove quotes and escapes
      value = value
        .substr(1, value.length - 2)
        .replace(QESC_REGEXP, '$1')
    }

    params[key] = value
  }

  if (index !== -1 && index !== string.length) {
    throw new TypeError('invalid parameter format')
  }

  return new ContentDisposition(type, params)
}

/**
 * Percent decode a single character.
 *
 * @param {string} str
 * @param {string} hex
 * @return {string}
 * @api private
 */

function pdecode (str, hex) {
  return String.fromCharCode(parseInt(hex, 16))
}

/**
 * Percent encode a single character.
 *
 * @param {string} char
 * @return {string}
 * @api private
 */

function pencode (char) {
  var hex = String(char)
    .charCodeAt(0)
    .toString(16)
    .toUpperCase()
  return hex.length === 1
    ? '%0' + hex
    : '%' + hex
}

/**
 * Quote a string for HTTP.
 *
 * @param {string} val
 * @return {string}
 * @api private
 */

function qstring (val) {
  var str = String(val)

  return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"'
}

/**
 * Encode a Unicode string for HTTP (RFC 5987).
 *
 * @param {string} val
 * @return {string}
 * @api private
 */

function ustring (val) {
  var str = String(val)

  // percent encode as UTF-8
  var encoded = encodeURIComponent(str)
    .replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode)

  return 'UTF-8\'\'' + encoded
}

/**
 * Class for parsed Content-Disposition header for v8 optimization
 */

function ContentDisposition (type, parameters) {
  this.type = type
  this.parameters = parameters
}


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = etag

/**
 * Module dependencies.
 * @private
 */

var crypto = __webpack_require__(12)
var Stats = __webpack_require__(6).Stats

/**
 * Module variables.
 * @private
 */

var toString = Object.prototype.toString

/**
 * Generate an entity tag.
 *
 * @param {Buffer|string} entity
 * @return {string}
 * @private
 */

function entitytag (entity) {
  if (entity.length === 0) {
    // fast-path empty
    return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"'
  }

  // compute hash of entity
  var hash = crypto
    .createHash('sha1')
    .update(entity, 'utf8')
    .digest('base64')
    .substring(0, 27)

  // compute length of entity
  var len = typeof entity === 'string'
    ? Buffer.byteLength(entity, 'utf8')
    : entity.length

  return '"' + len.toString(16) + '-' + hash + '"'
}

/**
 * Create a simple ETag.
 *
 * @param {string|Buffer|Stats} entity
 * @param {object} [options]
 * @param {boolean} [options.weak]
 * @return {String}
 * @public
 */

function etag (entity, options) {
  if (entity == null) {
    throw new TypeError('argument entity is required')
  }

  // support fs.Stats object
  var isStats = isstats(entity)
  var weak = options && typeof options.weak === 'boolean'
    ? options.weak
    : isStats

  // validate argument
  if (!isStats && typeof entity !== 'string' && !Buffer.isBuffer(entity)) {
    throw new TypeError('argument entity must be string, Buffer, or fs.Stats')
  }

  // generate entity tag
  var tag = isStats
    ? stattag(entity)
    : entitytag(entity)

  return weak
    ? 'W/' + tag
    : tag
}

/**
 * Determine if object is a Stats object.
 *
 * @param {object} obj
 * @return {boolean}
 * @api private
 */

function isstats (obj) {
  // genuine fs.Stats
  if (typeof Stats === 'function' && obj instanceof Stats) {
    return true
  }

  // quack quack
  return obj && typeof obj === 'object' &&
    'ctime' in obj && toString.call(obj.ctime) === '[object Date]' &&
    'mtime' in obj && toString.call(obj.mtime) === '[object Date]' &&
    'ino' in obj && typeof obj.ino === 'number' &&
    'size' in obj && typeof obj.size === 'number'
}

/**
 * Generate a tag for a stat.
 *
 * @param {object} stat
 * @return {string}
 * @private
 */

function stattag (stat) {
  var mtime = stat.mtime.getTime().toString(16)
  var size = stat.size.toString(16)

  return '"' + size + '-' + mtime + '"'
}


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * RegExp to check for no-cache token in Cache-Control.
 * @private
 */

var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/

/**
 * Module exports.
 * @public
 */

module.exports = fresh

/**
 * Check freshness of the response using request and response headers.
 *
 * @param {Object} reqHeaders
 * @param {Object} resHeaders
 * @return {Boolean}
 * @public
 */

function fresh (reqHeaders, resHeaders) {
  // fields
  var modifiedSince = reqHeaders['if-modified-since']
  var noneMatch = reqHeaders['if-none-match']

  // unconditional request
  if (!modifiedSince && !noneMatch) {
    return false
  }

  // Always return stale when Cache-Control: no-cache
  // to support end-to-end reload requests
  // https://tools.ietf.org/html/rfc2616#section-14.9.4
  var cacheControl = reqHeaders['cache-control']
  if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
    return false
  }

  // if-none-match
  if (noneMatch && noneMatch !== '*') {
    var etag = resHeaders['etag']

    if (!etag) {
      return false
    }

    var etagStale = true
    var matches = parseTokenList(noneMatch)
    for (var i = 0; i < matches.length; i++) {
      var match = matches[i]
      if (match === etag || match === 'W/' + etag || 'W/' + match === etag) {
        etagStale = false
        break
      }
    }

    if (etagStale) {
      return false
    }
  }

  // if-modified-since
  if (modifiedSince) {
    var lastModified = resHeaders['last-modified']
    var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince))

    if (modifiedStale) {
      return false
    }
  }

  return true
}

/**
 * Parse an HTTP Date into a number.
 *
 * @param {string} date
 * @private
 */

function parseHttpDate (date) {
  var timestamp = date && Date.parse(date)

  // istanbul ignore next: guard against date.js Date.parse patching
  return typeof timestamp === 'number'
    ? timestamp
    : NaN
}

/**
 * Parse a HTTP token list.
 *
 * @param {string} str
 * @private
 */

function parseTokenList (str) {
  var end = 0
  var list = []
  var start = 0

  // gather tokens
  for (var i = 0, len = str.length; i < len; i++) {
    switch (str.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i + 1
        }
        break
      case 0x2c: /* , */
        list.push(str.substring(start, end))
        start = end = i + 1
        break
      default:
        end = i + 1
        break
    }
  }

  // final token
  list.push(str.substring(start, end))

  return list
}


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = rangeParser

/**
 * Parse "Range" header `str` relative to the given file `size`.
 *
 * @param {Number} size
 * @param {String} str
 * @param {Object} [options]
 * @return {Array}
 * @public
 */

function rangeParser (size, str, options) {
  var index = str.indexOf('=')

  if (index === -1) {
    return -2
  }

  // split the range string
  var arr = str.slice(index + 1).split(',')
  var ranges = []

  // add ranges type
  ranges.type = str.slice(0, index)

  // parse all ranges
  for (var i = 0; i < arr.length; i++) {
    var range = arr[i].split('-')
    var start = parseInt(range[0], 10)
    var end = parseInt(range[1], 10)

    // -nnn
    if (isNaN(start)) {
      start = size - end
      end = size - 1
    // nnn-
    } else if (isNaN(end)) {
      end = size - 1
    }

    // limit last-byte-pos to current length
    if (end > size - 1) {
      end = size - 1
    }

    // invalid or unsatisifiable
    if (isNaN(start) || isNaN(end) || start > end || start < 0) {
      continue
    }

    // add range
    ranges.push({
      start: start,
      end: end
    })
  }

  if (ranges.length < 1) {
    // unsatisifiable
    return -1
  }

  return options && options.combine
    ? combineRanges(ranges)
    : ranges
}

/**
 * Combine overlapping & adjacent ranges.
 * @private
 */

function combineRanges (ranges) {
  var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart)

  for (var j = 0, i = 1; i < ordered.length; i++) {
    var range = ordered[i]
    var current = ordered[j]

    if (range.start > current.end + 1) {
      // next range
      ordered[++j] = range
    } else if (range.end > current.end) {
      // extend range
      current.end = range.end
      current.index = Math.min(current.index, range.index)
    }
  }

  // trim ordered array
  ordered.length = j + 1

  // generate combined range
  var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex)

  // copy ranges type
  combined.type = ranges.type

  return combined
}

/**
 * Map function to add index value to ranges.
 * @private
 */

function mapWithIndex (range, index) {
  return {
    start: range.start,
    end: range.end,
    index: index
  }
}

/**
 * Map function to remove index value from ranges.
 * @private
 */

function mapWithoutIndex (range) {
  return {
    start: range.start,
    end: range.end
  }
}

/**
 * Sort function to sort ranges by index.
 * @private
 */

function sortByRangeIndex (a, b) {
  return a.index - b.index
}

/**
 * Sort function to sort ranges by start position.
 * @private
 */

function sortByRangeStart (a, b) {
  return a.start - b.start
}


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = proxyaddr
module.exports.all = alladdrs
module.exports.compile = compile

/**
 * Module dependencies.
 * @private
 */

var forwarded = __webpack_require__(130)
var ipaddr = __webpack_require__(131)

/**
 * Variables.
 * @private
 */

var DIGIT_REGEXP = /^[0-9]+$/
var isip = ipaddr.isValid
var parseip = ipaddr.parse

/**
 * Pre-defined IP ranges.
 * @private
 */

var IP_RANGES = {
  linklocal: ['169.254.0.0/16', 'fe80::/10'],
  loopback: ['127.0.0.1/8', '::1/128'],
  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']
}

/**
 * Get all addresses in the request, optionally stopping
 * at the first untrusted.
 *
 * @param {Object} request
 * @param {Function|Array|String} [trust]
 * @public
 */

function alladdrs (req, trust) {
  // get addresses
  var addrs = forwarded(req)

  if (!trust) {
    // Return all addresses
    return addrs
  }

  if (typeof trust !== 'function') {
    trust = compile(trust)
  }

  for (var i = 0; i < addrs.length - 1; i++) {
    if (trust(addrs[i], i)) continue

    addrs.length = i + 1
  }

  return addrs
}

/**
 * Compile argument into trust function.
 *
 * @param {Array|String} val
 * @private
 */

function compile (val) {
  if (!val) {
    throw new TypeError('argument is required')
  }

  var trust

  if (typeof val === 'string') {
    trust = [val]
  } else if (Array.isArray(val)) {
    trust = val.slice()
  } else {
    throw new TypeError('unsupported trust argument')
  }

  for (var i = 0; i < trust.length; i++) {
    val = trust[i]

    if (!IP_RANGES.hasOwnProperty(val)) {
      continue
    }

    // Splice in pre-defined range
    val = IP_RANGES[val]
    trust.splice.apply(trust, [i, 1].concat(val))
    i += val.length - 1
  }

  return compileTrust(compileRangeSubnets(trust))
}

/**
 * Compile `arr` elements into range subnets.
 *
 * @param {Array} arr
 * @private
 */

function compileRangeSubnets (arr) {
  var rangeSubnets = new Array(arr.length)

  for (var i = 0; i < arr.length; i++) {
    rangeSubnets[i] = parseipNotation(arr[i])
  }

  return rangeSubnets
}

/**
 * Compile range subnet array into trust function.
 *
 * @param {Array} rangeSubnets
 * @private
 */

function compileTrust (rangeSubnets) {
  // Return optimized function based on length
  var len = rangeSubnets.length
  return len === 0
    ? trustNone
    : len === 1
      ? trustSingle(rangeSubnets[0])
      : trustMulti(rangeSubnets)
}

/**
 * Parse IP notation string into range subnet.
 *
 * @param {String} note
 * @private
 */

function parseipNotation (note) {
  var pos = note.lastIndexOf('/')
  var str = pos !== -1
    ? note.substring(0, pos)
    : note

  if (!isip(str)) {
    throw new TypeError('invalid IP address: ' + str)
  }

  var ip = parseip(str)

  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {
    // Store as IPv4
    ip = ip.toIPv4Address()
  }

  var max = ip.kind() === 'ipv6'
    ? 128
    : 32

  var range = pos !== -1
    ? note.substring(pos + 1, note.length)
    : null

  if (range === null) {
    range = max
  } else if (DIGIT_REGEXP.test(range)) {
    range = parseInt(range, 10)
  } else if (ip.kind() === 'ipv4' && isip(range)) {
    range = parseNetmask(range)
  } else {
    range = null
  }

  if (range <= 0 || range > max) {
    throw new TypeError('invalid range on address: ' + note)
  }

  return [ip, range]
}

/**
 * Parse netmask string into CIDR range.
 *
 * @param {String} netmask
 * @private
 */

function parseNetmask (netmask) {
  var ip = parseip(netmask)
  var kind = ip.kind()

  return kind === 'ipv4'
    ? ip.prefixLengthFromSubnetMask()
    : null
}

/**
 * Determine address of proxied request.
 *
 * @param {Object} request
 * @param {Function|Array|String} trust
 * @public
 */

function proxyaddr (req, trust) {
  if (!req) {
    throw new TypeError('req argument is required')
  }

  if (!trust) {
    throw new TypeError('trust argument is required')
  }

  var addrs = alladdrs(req, trust)
  var addr = addrs[addrs.length - 1]

  return addr
}

/**
 * Static trust function to trust nothing.
 *
 * @private
 */

function trustNone () {
  return false
}

/**
 * Compile trust function for multiple subnets.
 *
 * @param {Array} subnets
 * @private
 */

function trustMulti (subnets) {
  return function trust (addr) {
    if (!isip(addr)) return false

    var ip = parseip(addr)
    var ipconv
    var kind = ip.kind()

    for (var i = 0; i < subnets.length; i++) {
      var subnet = subnets[i]
      var subnetip = subnet[0]
      var subnetkind = subnetip.kind()
      var subnetrange = subnet[1]
      var trusted = ip

      if (kind !== subnetkind) {
        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {
          // Incompatible IP addresses
          continue
        }

        if (!ipconv) {
          // Convert IP to match subnet IP kind
          ipconv = subnetkind === 'ipv4'
            ? ip.toIPv4Address()
            : ip.toIPv4MappedAddress()
        }

        trusted = ipconv
      }

      if (trusted.match(subnetip, subnetrange)) {
        return true
      }
    }

    return false
  }
}

/**
 * Compile trust function for single subnet.
 *
 * @param {Object} subnet
 * @private
 */

function trustSingle (subnet) {
  var subnetip = subnet[0]
  var subnetkind = subnetip.kind()
  var subnetisipv4 = subnetkind === 'ipv4'
  var subnetrange = subnet[1]

  return function trust (addr) {
    if (!isip(addr)) return false

    var ip = parseip(addr)
    var kind = ip.kind()

    if (kind !== subnetkind) {
      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
        // Incompatible IP addresses
        return false
      }

      // Convert IP to match subnet IP kind
      ip = subnetisipv4
        ? ip.toIPv4Address()
        : ip.toIPv4MappedAddress()
    }

    return ip.match(subnetip, subnetrange)
  }
}


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var Negotiator = __webpack_require__(134)
var mime = __webpack_require__(51)

/**
 * Module exports.
 * @public
 */

module.exports = Accepts

/**
 * Create a new Accepts object for the given req.
 *
 * @param {object} req
 * @public
 */

function Accepts (req) {
  if (!(this instanceof Accepts)) {
    return new Accepts(req)
  }

  this.headers = req.headers
  this.negotiator = new Negotiator(req)
}

/**
 * Check if the given `type(s)` is acceptable, returning
 * the best match when true, otherwise `undefined`, in which
 * case you should respond with 406 "Not Acceptable".
 *
 * The `type` value may be a single mime type string
 * such as "application/json", the extension name
 * such as "json" or an array `["json", "html", "text/plain"]`. When a list
 * or array is given the _best_ match, if any is returned.
 *
 * Examples:
 *
 *     // Accept: text/html
 *     this.types('html');
 *     // => "html"
 *
 *     // Accept: text/*, application/json
 *     this.types('html');
 *     // => "html"
 *     this.types('text/html');
 *     // => "text/html"
 *     this.types('json', 'text');
 *     // => "json"
 *     this.types('application/json');
 *     // => "application/json"
 *
 *     // Accept: text/*, application/json
 *     this.types('image/png');
 *     this.types('png');
 *     // => undefined
 *
 *     // Accept: text/*;q=.5, application/json
 *     this.types(['html', 'json']);
 *     this.types('html', 'json');
 *     // => "json"
 *
 * @param {String|Array} types...
 * @return {String|Array|Boolean}
 * @public
 */

Accepts.prototype.type =
Accepts.prototype.types = function (types_) {
  var types = types_

  // support flattened arguments
  if (types && !Array.isArray(types)) {
    types = new Array(arguments.length)
    for (var i = 0; i < types.length; i++) {
      types[i] = arguments[i]
    }
  }

  // no types, return all requested types
  if (!types || types.length === 0) {
    return this.negotiator.mediaTypes()
  }

  // no accept header, return first given type
  if (!this.headers.accept) {
    return types[0]
  }

  var mimes = types.map(extToMime)
  var accepts = this.negotiator.mediaTypes(mimes.filter(validMime))
  var first = accepts[0]

  return first
    ? types[mimes.indexOf(first)]
    : false
}

/**
 * Return accepted encodings or best fit based on `encodings`.
 *
 * Given `Accept-Encoding: gzip, deflate`
 * an array sorted by quality is returned:
 *
 *     ['gzip', 'deflate']
 *
 * @param {String|Array} encodings...
 * @return {String|Array}
 * @public
 */

Accepts.prototype.encoding =
Accepts.prototype.encodings = function (encodings_) {
  var encodings = encodings_

  // support flattened arguments
  if (encodings && !Array.isArray(encodings)) {
    encodings = new Array(arguments.length)
    for (var i = 0; i < encodings.length; i++) {
      encodings[i] = arguments[i]
    }
  }

  // no encodings, return all requested encodings
  if (!encodings || encodings.length === 0) {
    return this.negotiator.encodings()
  }

  return this.negotiator.encodings(encodings)[0] || false
}

/**
 * Return accepted charsets or best fit based on `charsets`.
 *
 * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
 * an array sorted by quality is returned:
 *
 *     ['utf-8', 'utf-7', 'iso-8859-1']
 *
 * @param {String|Array} charsets...
 * @return {String|Array}
 * @public
 */

Accepts.prototype.charset =
Accepts.prototype.charsets = function (charsets_) {
  var charsets = charsets_

  // support flattened arguments
  if (charsets && !Array.isArray(charsets)) {
    charsets = new Array(arguments.length)
    for (var i = 0; i < charsets.length; i++) {
      charsets[i] = arguments[i]
    }
  }

  // no charsets, return all requested charsets
  if (!charsets || charsets.length === 0) {
    return this.negotiator.charsets()
  }

  return this.negotiator.charsets(charsets)[0] || false
}

/**
 * Return accepted languages or best fit based on `langs`.
 *
 * Given `Accept-Language: en;q=0.8, es, pt`
 * an array sorted by quality is returned:
 *
 *     ['es', 'pt', 'en']
 *
 * @param {String|Array} langs...
 * @return {Array|String}
 * @public
 */

Accepts.prototype.lang =
Accepts.prototype.langs =
Accepts.prototype.language =
Accepts.prototype.languages = function (languages_) {
  var languages = languages_

  // support flattened arguments
  if (languages && !Array.isArray(languages)) {
    languages = new Array(arguments.length)
    for (var i = 0; i < languages.length; i++) {
      languages[i] = arguments[i]
    }
  }

  // no languages, return all requested languages
  if (!languages || languages.length === 0) {
    return this.negotiator.languages()
  }

  return this.negotiator.languages(languages)[0] || false
}

/**
 * Convert extnames to mime.
 *
 * @param {String} type
 * @return {String}
 * @private
 */

function extToMime (type) {
  return type.indexOf('/') === -1
    ? mime.lookup(type)
    : type
}

/**
 * Check if mime is valid.
 *
 * @param {String} type
 * @return {String}
 * @private
 */

function validMime (type) {
  return typeof type === 'string'
}


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

exports.parse = parse;
exports.serialize = serialize;

/**
 * Module variables.
 * @private
 */

var decode = decodeURIComponent;
var encode = encodeURIComponent;
var pairSplitRegExp = /; */;

/**
 * RegExp to match field-content in RFC 7230 sec 3.2
 *
 * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 * field-vchar   = VCHAR / obs-text
 * obs-text      = %x80-FF
 */

var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 *
 * @param {string} str
 * @param {object} [options]
 * @return {object}
 * @public
 */

function parse(str, options) {
  if (typeof str !== 'string') {
    throw new TypeError('argument str must be a string');
  }

  var obj = {}
  var opt = options || {};
  var pairs = str.split(pairSplitRegExp);
  var dec = opt.decode || decode;

  for (var i = 0; i < pairs.length; i++) {
    var pair = pairs[i];
    var eq_idx = pair.indexOf('=');

    // skip things that don't look like key=value
    if (eq_idx < 0) {
      continue;
    }

    var key = pair.substr(0, eq_idx).trim()
    var val = pair.substr(++eq_idx, pair.length).trim();

    // quoted values
    if ('"' == val[0]) {
      val = val.slice(1, -1);
    }

    // only assign once
    if (undefined == obj[key]) {
      obj[key] = tryDecode(val, dec);
    }
  }

  return obj;
}

/**
 * Serialize data into a cookie header.
 *
 * Serialize the a name value pair into a cookie string suitable for
 * http headers. An optional options object specified cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 *
 * @param {string} name
 * @param {string} val
 * @param {object} [options]
 * @return {string}
 * @public
 */

function serialize(name, val, options) {
  var opt = options || {};
  var enc = opt.encode || encode;

  if (typeof enc !== 'function') {
    throw new TypeError('option encode is invalid');
  }

  if (!fieldContentRegExp.test(name)) {
    throw new TypeError('argument name is invalid');
  }

  var value = enc(val);

  if (value && !fieldContentRegExp.test(value)) {
    throw new TypeError('argument val is invalid');
  }

  var str = name + '=' + value;

  if (null != opt.maxAge) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge)) throw new Error('maxAge should be a Number');
    str += '; Max-Age=' + Math.floor(maxAge);
  }

  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError('option domain is invalid');
    }

    str += '; Domain=' + opt.domain;
  }

  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError('option path is invalid');
    }

    str += '; Path=' + opt.path;
  }

  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== 'function') {
      throw new TypeError('option expires is invalid');
    }

    str += '; Expires=' + opt.expires.toUTCString();
  }

  if (opt.httpOnly) {
    str += '; HttpOnly';
  }

  if (opt.secure) {
    str += '; Secure';
  }

  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === 'string'
      ? opt.sameSite.toLowerCase() : opt.sameSite;

    switch (sameSite) {
      case true:
        str += '; SameSite=Strict';
        break;
      case 'lax':
        str += '; SameSite=Lax';
        break;
      case 'strict':
        str += '; SameSite=Strict';
        break;
      default:
        throw new TypeError('option sameSite is invalid');
    }
  }

  return str;
}

/**
 * Try decoding a string using a decoding function.
 *
 * @param {string} str
 * @param {function} decode
 * @private
 */

function tryDecode(str, decode) {
  try {
    return decode(str);
  } catch (e) {
    return str;
  }
}


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var XHR = __webpack_require__(148);
var JSONP = __webpack_require__(157);

/**
 * Export transports.
 */

module.exports = exports = {
  polling: polling,
  websocket: __webpack_require__(158)
};

/**
 * Export upgrades map.
 */

exports.polling.upgradesTo = ['websocket'];

/**
 * Polling polymorphic constructor.
 *
 * @api private
 */

function polling (req) {
  if ('string' === typeof req._query.j) {
    return new JSONP(req);
  } else {
    return new XHR(req);
  }
}


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module requirements.
 */

var Transport = __webpack_require__(41);
var parser = __webpack_require__(31);
var zlib = __webpack_require__(37);
var accepts = __webpack_require__(64);
var util = __webpack_require__(0);
var debug = __webpack_require__(17)('engine:polling');

var compressionMethods = {
  gzip: zlib.createGzip,
  deflate: zlib.createDeflate
};

/**
 * Exports the constructor.
 */

module.exports = Polling;

/**
 * HTTP polling constructor.
 *
 * @api public.
 */

function Polling (req) {
  Transport.call(this, req);

  this.closeTimeout = 30 * 1000;
  this.maxHttpBufferSize = null;
  this.httpCompression = null;
}

/**
 * Inherits from Transport.
 *
 * @api public.
 */

util.inherits(Polling, Transport);

/**
 * Transport name
 *
 * @api public
 */

Polling.prototype.name = 'polling';

/**
 * Overrides onRequest.
 *
 * @param {http.IncomingMessage}
 * @api private
 */

Polling.prototype.onRequest = function (req) {
  var res = req.res;

  if ('GET' === req.method) {
    this.onPollRequest(req, res);
  } else if ('POST' === req.method) {
    this.onDataRequest(req, res);
  } else {
    res.writeHead(500);
    res.end();
  }
};

/**
 * The client sends a request awaiting for us to send data.
 *
 * @api private
 */

Polling.prototype.onPollRequest = function (req, res) {
  if (this.req) {
    debug('request overlap');
    // assert: this.res, '.req and .res should be (un)set together'
    this.onError('overlap from client');
    res.writeHead(500);
    res.end();
    return;
  }

  debug('setting request');

  this.req = req;
  this.res = res;

  var self = this;

  function onClose () {
    self.onError('poll connection closed prematurely');
  }

  function cleanup () {
    req.removeListener('close', onClose);
    self.req = self.res = null;
  }

  req.cleanup = cleanup;
  req.on('close', onClose);

  this.writable = true;
  this.emit('drain');

  // if we're still writable but had a pending close, trigger an empty send
  if (this.writable && this.shouldClose) {
    debug('triggering empty send to append close packet');
    this.send([{ type: 'noop' }]);
  }
};

/**
 * The client sends a request with data.
 *
 * @api private
 */

Polling.prototype.onDataRequest = function (req, res) {
  if (this.dataReq) {
    // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'
    this.onError('data request overlap from client');
    res.writeHead(500);
    res.end();
    return;
  }

  var isBinary = 'application/octet-stream' === req.headers['content-type'];

  this.dataReq = req;
  this.dataRes = res;

  var chunks = isBinary ? Buffer.concat([]) : '';
  var self = this;

  function cleanup () {
    req.removeListener('data', onData);
    req.removeListener('end', onEnd);
    req.removeListener('close', onClose);
    self.dataReq = self.dataRes = chunks = null;
  }

  function onClose () {
    cleanup();
    self.onError('data request connection closed prematurely');
  }

  function onData (data) {
    var contentLength;
    if (isBinary) {
      chunks = Buffer.concat([chunks, data]);
      contentLength = chunks.length;
    } else {
      chunks += data;
      contentLength = Buffer.byteLength(chunks);
    }

    if (contentLength > self.maxHttpBufferSize) {
      chunks = isBinary ? Buffer.concat([]) : '';
      req.connection.destroy();
    }
  }

  function onEnd () {
    self.onData(chunks);

    var headers = {
      // text/html is required instead of text/plain to avoid an
      // unwanted download dialog on certain user-agents (GH-43)
      'Content-Type': 'text/html',
      'Content-Length': 2
    };

    res.writeHead(200, self.headers(req, headers));
    res.end('ok');
    cleanup();
  }

  req.on('close', onClose);
  if (!isBinary) req.setEncoding('utf8');
  req.on('data', onData);
  req.on('end', onEnd);
};

/**
 * Processes the incoming data payload.
 *
 * @param {String} encoded payload
 * @api private
 */

Polling.prototype.onData = function (data) {
  debug('received "%s"', data);
  var self = this;
  var callback = function (packet) {
    if ('close' === packet.type) {
      debug('got xhr close packet');
      self.onClose();
      return false;
    }

    self.onPacket(packet);
  };

  parser.decodePayload(data, callback);
};

/**
 * Overrides onClose.
 *
 * @api private
 */

Polling.prototype.onClose = function () {
  if (this.writable) {
    // close pending poll request
    this.send([{ type: 'noop' }]);
  }
  Transport.prototype.onClose.call(this);
};

/**
 * Writes a packet payload.
 *
 * @param {Object} packet
 * @api private
 */

Polling.prototype.send = function (packets) {
  this.writable = false;

  if (this.shouldClose) {
    debug('appending close packet to payload');
    packets.push({ type: 'close' });
    this.shouldClose();
    this.shouldClose = null;
  }

  var self = this;
  parser.encodePayload(packets, this.supportsBinary, function (data) {
    var compress = packets.some(function (packet) {
      return packet.options && packet.options.compress;
    });
    self.write(data, { compress: compress });
  });
};

/**
 * Writes data as response to poll request.
 *
 * @param {String} data
 * @param {Object} options
 * @api private
 */

Polling.prototype.write = function (data, options) {
  debug('writing "%s"', data);
  var self = this;
  this.doWrite(data, options, function () {
    self.req.cleanup();
  });
};

/**
 * Performs the write.
 *
 * @api private
 */

Polling.prototype.doWrite = function (data, options, callback) {
  var self = this;

  // explicit UTF-8 is required for pages not served under utf
  var isString = typeof data === 'string';
  var contentType = isString
    ? 'text/plain; charset=UTF-8'
    : 'application/octet-stream';

  var headers = {
    'Content-Type': contentType
  };

  if (!this.httpCompression || !options.compress) {
    respond(data);
    return;
  }

  var len = isString ? Buffer.byteLength(data) : data.length;
  if (len < this.httpCompression.threshold) {
    respond(data);
    return;
  }

  var encoding = accepts(this.req).encodings(['gzip', 'deflate']);
  if (!encoding) {
    respond(data);
    return;
  }

  this.compress(data, encoding, function (err, data) {
    if (err) {
      self.res.writeHead(500);
      self.res.end();
      callback(err);
      return;
    }

    headers['Content-Encoding'] = encoding;
    respond(data);
  });

  function respond (data) {
    headers['Content-Length'] = 'string' === typeof data ? Buffer.byteLength(data) : data.length;
    self.res.writeHead(200, self.headers(self.req, headers));
    self.res.end(data);
    callback();
  }
};

/**
 * Compresses data.
 *
 * @api private
 */

Polling.prototype.compress = function (data, encoding, callback) {
  debug('compressing');

  var buffers = [];
  var nread = 0;

  compressionMethods[encoding](this.httpCompression)
    .on('error', callback)
    .on('data', function (chunk) {
      buffers.push(chunk);
      nread += chunk.length;
    })
    .on('end', function () {
      callback(null, Buffer.concat(buffers, nread));
    })
    .end(data);
};

/**
 * Closes the transport.
 *
 * @api private
 */

Polling.prototype.doClose = function (fn) {
  debug('closing');

  var self = this;
  var closeTimeoutTimer;

  if (this.dataReq) {
    debug('aborting ongoing data request');
    this.dataReq.destroy();
  }

  if (this.writable) {
    debug('transport writable - closing right away');
    this.send([{ type: 'close' }]);
    onClose();
  } else if (this.discarded) {
    debug('transport discarded - closing right away');
    onClose();
  } else {
    debug('transport not writable - buffering orderly close');
    this.shouldClose = onClose;
    closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
  }

  function onClose () {
    clearTimeout(closeTimeoutTimer);
    fn();
    self.onClose();
  }
};

/**
 * Returns headers for a response.
 *
 * @param {http.IncomingMessage} request
 * @param {Object} extra headers
 * @api private
 */

Polling.prototype.headers = function (req, headers) {
  headers = headers || {};

  // prevent XSS warnings on IE
  // https://github.com/LearnBoost/socket.io/pull/1333
  var ua = req.headers['user-agent'];
  if (ua && (~ua.indexOf(';MSIE') || ~ua.indexOf('Trident/'))) {
    headers['X-XSS-Protection'] = '0';
  }

  this.emit('headers', headers);
  return headers;
};


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(22);

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var EventEmitter = __webpack_require__(1).EventEmitter;
var util = __webpack_require__(0);
var debug = __webpack_require__(17)('engine:socket');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Client class (abstract).
 *
 * @api private
 */

function Socket (id, server, transport, req) {
  this.id = id;
  this.server = server;
  this.upgrading = false;
  this.upgraded = false;
  this.readyState = 'opening';
  this.writeBuffer = [];
  this.packetsFn = [];
  this.sentCallbackFn = [];
  this.cleanupFn = [];
  this.request = req;

  // Cache IP since it might not be in the req later
  if (req.websocket && req.websocket._socket) {
    this.remoteAddress = req.websocket._socket.remoteAddress;
  } else {
    this.remoteAddress = req.connection.remoteAddress;
  }

  this.checkIntervalTimer = null;
  this.upgradeTimeoutTimer = null;
  this.pingTimeoutTimer = null;

  this.setTransport(transport);
  this.onOpen();
}

/**
 * Inherits from EventEmitter.
 */

util.inherits(Socket, EventEmitter);

/**
 * Called upon transport considered open.
 *
 * @api private
 */

Socket.prototype.onOpen = function () {
  this.readyState = 'open';

  // sends an `open` packet
  this.transport.sid = this.id;
  this.sendPacket('open', JSON.stringify({
    sid: this.id,
    upgrades: this.getAvailableUpgrades(),
    pingInterval: this.server.pingInterval,
    pingTimeout: this.server.pingTimeout
  }));

  if (this.server.initialPacket) {
    this.sendPacket('message', this.server.initialPacket);
  }

  this.emit('open');
  this.setPingTimeout();
};

/**
 * Called upon transport packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('open' === this.readyState) {
    // export packet event
    debug('packet');
    this.emit('packet', packet);

    // Reset ping timeout on any packet, incoming data is a good sign of
    // other side's liveness
    this.setPingTimeout();

    switch (packet.type) {
      case 'ping':
        debug('got ping');
        this.sendPacket('pong');
        this.emit('heartbeat');
        break;

      case 'error':
        this.onClose('parse error');
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with closed socket');
  }
};

/**
 * Called upon transport error.
 *
 * @param {Error} error object
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('transport error');
  this.onClose('transport error', err);
};

/**
 * Sets and resets ping timeout timer based on client pings.
 *
 * @api private
 */

Socket.prototype.setPingTimeout = function () {
  var self = this;
  clearTimeout(self.pingTimeoutTimer);
  self.pingTimeoutTimer = setTimeout(function () {
    self.onClose('ping timeout');
  }, self.server.pingInterval + self.server.pingTimeout);
};

/**
 * Attaches handlers for the given transport.
 *
 * @param {Transport} transport
 * @api private
 */

Socket.prototype.setTransport = function (transport) {
  var onError = this.onError.bind(this);
  var onPacket = this.onPacket.bind(this);
  var flush = this.flush.bind(this);
  var onClose = this.onClose.bind(this, 'transport close');

  this.transport = transport;
  this.transport.once('error', onError);
  this.transport.on('packet', onPacket);
  this.transport.on('drain', flush);
  this.transport.once('close', onClose);
  // this function will manage packet events (also message callbacks)
  this.setupSendCallback();

  this.cleanupFn.push(function () {
    transport.removeListener('error', onError);
    transport.removeListener('packet', onPacket);
    transport.removeListener('drain', flush);
    transport.removeListener('close', onClose);
  });
};

/**
 * Upgrades socket to the given transport
 *
 * @param {Transport} transport
 * @api private
 */

Socket.prototype.maybeUpgrade = function (transport) {
  debug('might upgrade socket transport from "%s" to "%s"'
    , this.transport.name, transport.name);

  this.upgrading = true;

  var self = this;

  // set transport upgrade timer
  self.upgradeTimeoutTimer = setTimeout(function () {
    debug('client did not complete upgrade - closing transport');
    cleanup();
    if ('open' === transport.readyState) {
      transport.close();
    }
  }, this.server.upgradeTimeout);

  function onPacket (packet) {
    if ('ping' === packet.type && 'probe' === packet.data) {
      transport.send([{ type: 'pong', data: 'probe' }]);
      self.emit('upgrading', transport);
      clearInterval(self.checkIntervalTimer);
      self.checkIntervalTimer = setInterval(check, 100);
    } else if ('upgrade' === packet.type && self.readyState !== 'closed') {
      debug('got upgrade packet - upgrading');
      cleanup();
      self.transport.discard();
      self.upgraded = true;
      self.clearTransport();
      self.setTransport(transport);
      self.emit('upgrade', transport);
      self.setPingTimeout();
      self.flush();
      if (self.readyState === 'closing') {
        transport.close(function () {
          self.onClose('forced close');
        });
      }
    } else {
      cleanup();
      transport.close();
    }
  }

  // we force a polling cycle to ensure a fast upgrade
  function check () {
    if ('polling' === self.transport.name && self.transport.writable) {
      debug('writing a noop packet to polling for fast upgrade');
      self.transport.send([{ type: 'noop' }]);
    }
  }

  function cleanup () {
    self.upgrading = false;

    clearInterval(self.checkIntervalTimer);
    self.checkIntervalTimer = null;

    clearTimeout(self.upgradeTimeoutTimer);
    self.upgradeTimeoutTimer = null;

    transport.removeListener('packet', onPacket);
    transport.removeListener('close', onTransportClose);
    transport.removeListener('error', onError);
    self.removeListener('close', onClose);
  }

  function onError (err) {
    debug('client did not complete upgrade - %s', err);
    cleanup();
    transport.close();
    transport = null;
  }

  function onTransportClose () {
    onError('transport closed');
  }

  function onClose () {
    onError('socket closed');
  }

  transport.on('packet', onPacket);
  transport.once('close', onTransportClose);
  transport.once('error', onError);

  self.once('close', onClose);
};

/**
 * Clears listeners and timers associated with current transport.
 *
 * @api private
 */

Socket.prototype.clearTransport = function () {
  var cleanup;

  var toCleanUp = this.cleanupFn.length;

  for (var i = 0; i < toCleanUp; i++) {
    cleanup = this.cleanupFn.shift();
    cleanup();
  }

  // silence further transport errors and prevent uncaught exceptions
  this.transport.on('error', function () {
    debug('error triggered by discarded transport');
  });

  // ensure transport won't stay open
  this.transport.close();

  clearTimeout(this.pingTimeoutTimer);
};

/**
 * Called upon transport considered closed.
 * Possible reasons: `ping timeout`, `client error`, `parse error`,
 * `transport error`, `server close`, `transport close`
 */

Socket.prototype.onClose = function (reason, description) {
  if ('closed' !== this.readyState) {
    this.readyState = 'closed';
    clearTimeout(this.pingTimeoutTimer);
    clearInterval(this.checkIntervalTimer);
    this.checkIntervalTimer = null;
    clearTimeout(this.upgradeTimeoutTimer);
    var self = this;
    // clean writeBuffer in next tick, so developers can still
    // grab the writeBuffer on 'close' event
    process.nextTick(function () {
      self.writeBuffer = [];
    });
    this.packetsFn = [];
    this.sentCallbackFn = [];
    this.clearTransport();
    this.emit('close', reason, description);
  }
};

/**
 * Setup and manage send callback
 *
 * @api private
 */

Socket.prototype.setupSendCallback = function () {
  var self = this;
  this.transport.on('drain', onDrain);

  this.cleanupFn.push(function () {
    self.transport.removeListener('drain', onDrain);
  });

  // the message was sent successfully, execute the callback
  function onDrain () {
    if (self.sentCallbackFn.length > 0) {
      var seqFn = self.sentCallbackFn.splice(0, 1)[0];
      if ('function' === typeof seqFn) {
        debug('executing send callback');
        seqFn(self.transport);
      } else if (Array.isArray(seqFn)) {
        debug('executing batch send callback');
        for (var l = seqFn.length, i = 0; i < l; i++) {
          if ('function' === typeof seqFn[i]) {
            seqFn[i](self.transport);
          }
        }
      }
    }
  }
};

/**
 * Sends a message packet.
 *
 * @param {String} message
 * @param {Object} options
 * @param {Function} callback
 * @return {Socket} for chaining
 * @api public
 */

Socket.prototype.send =
Socket.prototype.write = function (data, options, callback) {
  this.sendPacket('message', data, options, callback);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type
 * @param {String} optional, data
 * @param {Object} options
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, callback) {
  if ('function' === typeof options) {
    callback = options;
    options = null;
  }

  options = options || {};
  options.compress = false !== options.compress;

  if ('closing' !== this.readyState && 'closed' !== this.readyState) {
    debug('sending packet "%s" (%s)', type, data);

    var packet = {
      type: type,
      options: options
    };
    if (data) packet.data = data;

    // exports packetCreate event
    this.emit('packetCreate', packet);

    this.writeBuffer.push(packet);

    // add send callback to object, if defined
    if (callback) this.packetsFn.push(callback);

    this.flush();
  }
};

/**
 * Attempts to flush the packets buffer.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' !== this.readyState &&
                this.transport.writable &&
                this.writeBuffer.length) {
    debug('flushing buffer to transport');
    this.emit('flush', this.writeBuffer);
    this.server.emit('flush', this, this.writeBuffer);
    var wbuf = this.writeBuffer;
    this.writeBuffer = [];
    if (!this.transport.supportsFraming) {
      this.sentCallbackFn.push(this.packetsFn);
    } else {
      this.sentCallbackFn.push.apply(this.sentCallbackFn, this.packetsFn);
    }
    this.packetsFn = [];
    this.transport.send(wbuf);
    this.emit('drain');
    this.server.emit('drain', this);
  }
};

/**
 * Get available upgrades for this socket.
 *
 * @api private
 */

Socket.prototype.getAvailableUpgrades = function () {
  var availableUpgrades = [];
  var allUpgrades = this.server.upgrades(this.transport.name);
  for (var i = 0, l = allUpgrades.length; i < l; ++i) {
    var upg = allUpgrades[i];
    if (this.server.transports.indexOf(upg) !== -1) {
      availableUpgrades.push(upg);
    }
  }
  return availableUpgrades;
};

/**
 * Closes the socket and underlying transport.
 *
 * @param {Boolean} optional, discard
 * @return {Socket} for chaining
 * @api public
 */

Socket.prototype.close = function (discard) {
  if ('open' !== this.readyState) return;

  this.readyState = 'closing';

  if (this.writeBuffer.length) {
    this.once('drain', this.closeTransport.bind(this, discard));
    return;
  }

  this.closeTransport(discard);
};

/**
 * Closes the underlying transport.
 *
 * @param {Boolean} discard
 * @api private
 */

Socket.prototype.closeTransport = function (discard) {
  if (discard) this.transport.discard();
  this.transport.close(this.onClose.bind(this, 'forced close'));
};


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const EventEmitter = __webpack_require__(1);
const crypto = __webpack_require__(12);
const https = __webpack_require__(171);
const http = __webpack_require__(4);
const net = __webpack_require__(35);
const tls = __webpack_require__(172);
const url = __webpack_require__(7);

const PerMessageDeflate = __webpack_require__(32);
const EventTarget = __webpack_require__(174);
const extension = __webpack_require__(71);
const constants = __webpack_require__(18);
const Receiver = __webpack_require__(72);
const Sender = __webpack_require__(74);

const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const kWebSocket = constants.kWebSocket;
const protocolVersions = [8, 13];
const closeTimeout = 30 * 1000; // Allow 30 seconds to terminate the connection cleanly.

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|url.Url|url.URL)} address The URL to which to connect
   * @param {(String|String[])} protocols The subprotocols
   * @param {Object} options Connection options
   */
  constructor(address, protocols, options) {
    super();

    this.readyState = WebSocket.CONNECTING;
    this.protocol = '';

    this._binaryType = constants.BINARY_TYPES[0];
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = '';
    this._closeTimer = null;
    this._closeCode = 1006;
    this._extensions = {};
    this._isServer = true;
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      if (Array.isArray(protocols)) {
        protocols = protocols.join(', ');
      } else if (typeof protocols === 'object' && protocols !== null) {
        options = protocols;
        protocols = undefined;
      }

      initAsClient.call(this, address, protocols, options);
    }
  }

  get CONNECTING() {
    return WebSocket.CONNECTING;
  }
  get CLOSING() {
    return WebSocket.CLOSING;
  }
  get CLOSED() {
    return WebSocket.CLOSED;
  }
  get OPEN() {
    return WebSocket.OPEN;
  }

  /**
   * This deviates from the WHATWG interface since ws doesn't support the required
   * default "blob" type (instead we define a custom "nodebuffer" type).
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!constants.BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return 0;

    //
    // `socket.bufferSize` is `undefined` if the socket is closed.
    //
    return (this._socket.bufferSize || 0) + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Number} maxPayload The maximum allowed message size
   * @private
   */
  setSocket(socket, head, maxPayload) {
    const receiver = new Receiver(
      this._binaryType,
      this._extensions,
      maxPayload
    );

    this._sender = new Sender(socket, this._extensions);
    this._receiver = receiver;
    this._socket = socket;

    receiver[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    socket.setTimeout(0);
    socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this.readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    this.readyState = WebSocket.CLOSED;

    if (!this._socket) {
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate.extensionName]) {
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} code Status code explaining why the connection is closing
   * @param {String} data A string explaining why the connection is closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();
      return;
    }

    this.readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;

      if (this._socket.writable) {
        if (this._closeFrameReceived) this._socket.end();

        //
        // Ensure that the connection is closed even if the closing handshake
        // fails.
        //
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
    });
  }

  /**
   * Send a ping.
   *
   * @param {*} data The data to send
   * @param {Boolean} mask Indicates whether or not to mask `data`
   * @param {Function} cb Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (this.readyState !== WebSocket.OPEN) {
      const err = new Error(
        `WebSocket is not open: readyState ${this.readyState} ` +
          `(${readyStates[this.readyState]})`
      );

      if (cb) return cb(err);
      throw err;
    }

    if (typeof data === 'number') data = data.toString();
    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || constants.EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} data The data to send
   * @param {Boolean} mask Indicates whether or not to mask `data`
   * @param {Function} cb Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (this.readyState !== WebSocket.OPEN) {
      const err = new Error(
        `WebSocket is not open: readyState ${this.readyState} ` +
          `(${readyStates[this.readyState]})`
      );

      if (cb) return cb(err);
      throw err;
    }

    if (typeof data === 'number') data = data.toString();
    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || constants.EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} options.compress Specifies whether or not to compress `data`
   * @param {Boolean} options.binary Specifies whether `data` is binary or text
   * @param {Boolean} options.fin Specifies whether the fragment is the last one
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (this.readyState !== WebSocket.OPEN) {
      const err = new Error(
        `WebSocket is not open: readyState ${this.readyState} ` +
          `(${readyStates[this.readyState]})`
      );

      if (cb) return cb(err);
      throw err;
    }

    if (typeof data === 'number') data = data.toString();

    const opts = Object.assign(
      {
        binary: typeof data !== 'string',
        mask: !this._isServer,
        compress: true,
        fin: true
      },
      options
    );

    if (!this._extensions[PerMessageDeflate.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || constants.EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this._socket) {
      this.readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
}

readyStates.forEach((readyState, i) => {
  WebSocket[readyState] = i;
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket.prototype, `on${method}`, {
    /**
     * Return the listener of the event.
     *
     * @return {(Function|undefined)} The event listener or `undefined`
     * @public
     */
    get() {
      const listeners = this.listeners(method);
      for (var i = 0; i < listeners.length; i++) {
        if (listeners[i]._listener) return listeners[i]._listener;
      }

      return undefined;
    },
    /**
     * Add a listener for the event.
     *
     * @param {Function} listener The listener to add
     * @public
     */
    set(listener) {
      const listeners = this.listeners(method);
      for (var i = 0; i < listeners.length; i++) {
        //
        // Remove only the listeners added via `addEventListener`.
        //
        if (listeners[i]._listener) this.removeListener(method, listeners[i]);
      }
      this.addEventListener(method, listener);
    }
  });
});

WebSocket.prototype.addEventListener = EventTarget.addEventListener;
WebSocket.prototype.removeEventListener = EventTarget.removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param {(String|url.Url|url.URL)} address The URL to which to connect
 * @param {String} protocols The subprotocols
 * @param {Object} options Connection options
 * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate
 * @param {Number} options.handshakeTimeout Timeout in milliseconds for the handshake request
 * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version` header
 * @param {String} options.origin Value of the `Origin` or `Sec-WebSocket-Origin` header
 * @param {Number} options.maxPayload The maximum allowed message size
 * @private
 */
function initAsClient(address, protocols, options) {
  options = Object.assign(
    {
      protocolVersion: protocolVersions[1],
      perMessageDeflate: true,
      maxPayload: 100 * 1024 * 1024
    },
    options,
    {
      createConnection: undefined,
      socketPath: undefined,
      hostname: undefined,
      protocol: undefined,
      timeout: undefined,
      method: undefined,
      auth: undefined,
      host: undefined,
      path: undefined,
      port: undefined
    }
  );

  if (!protocolVersions.includes(options.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${options.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  this._isServer = false;

  var parsedUrl;

  if (typeof address === 'object' && address.href !== undefined) {
    parsedUrl = address;
    this.url = address.href;
  } else {
    //
    // The WHATWG URL constructor is not available on Node.js < 6.13.0
    //
    parsedUrl = url.URL ? new url.URL(address) : url.parse(address);
    this.url = address;
  }

  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';

  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
    throw new Error(`Invalid URL: ${this.url}`);
  }

  const isSecure =
    parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';
  const defaultPort = isSecure ? 443 : 80;
  const key = crypto.randomBytes(16).toString('base64');
  const httpObj = isSecure ? https : http;
  const path = parsedUrl.search
    ? `${parsedUrl.pathname || '/'}${parsedUrl.search}`
    : parsedUrl.pathname || '/';
  var perMessageDeflate;

  options.createConnection = isSecure ? tlsConnect : netConnect;
  options.defaultPort = options.defaultPort || defaultPort;
  options.port = parsedUrl.port || defaultPort;
  options.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  options.headers = Object.assign(
    {
      'Sec-WebSocket-Version': options.protocolVersion,
      'Sec-WebSocket-Key': key,
      Connection: 'Upgrade',
      Upgrade: 'websocket'
    },
    options.headers
  );
  options.path = path;
  options.timeout = options.handshakeTimeout;

  if (options.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(
      options.perMessageDeflate !== true ? options.perMessageDeflate : {},
      false,
      options.maxPayload
    );
    options.headers['Sec-WebSocket-Extensions'] = extension.format({
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols) {
    options.headers['Sec-WebSocket-Protocol'] = protocols;
  }
  if (options.origin) {
    if (options.protocolVersion < 13) {
      options.headers['Sec-WebSocket-Origin'] = options.origin;
    } else {
      options.headers.Origin = options.origin;
    }
  }
  if (parsedUrl.auth) {
    options.auth = parsedUrl.auth;
  } else if (parsedUrl.username || parsedUrl.password) {
    options.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isUnixSocket) {
    const parts = path.split(':');

    options.socketPath = parts[0];
    options.path = parts[1];
  }

  var req = (this._req = httpObj.get(options));

  if (options.handshakeTimeout) {
    req.on('timeout', () => {
      abortHandshake(this, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (this._req.aborted) return;

    req = this._req = null;
    this.readyState = WebSocket.CLOSING;
    this.emit('error', err);
    this.emitClose();
  });

  req.on('response', (res) => {
    if (this.emit('unexpected-response', req, res)) return;

    abortHandshake(this, req, `Unexpected server response: ${res.statusCode}`);
  });

  req.on('upgrade', (res, socket, head) => {
    this.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the `upgrade`
    // event.
    //
    if (this.readyState !== WebSocket.CONNECTING) return;

    req = this._req = null;

    const digest = crypto
      .createHash('sha1')
      .update(key + constants.GUID, 'binary')
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(this, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    const protList = (protocols || '').split(/, */);
    var protError;

    if (!protocols && serverProt) {
      protError = 'Server sent a subprotocol but none was requested';
    } else if (protocols && !serverProt) {
      protError = 'Server sent no subprotocol';
    } else if (serverProt && !protList.includes(serverProt)) {
      protError = 'Server sent an invalid subprotocol';
    }

    if (protError) {
      abortHandshake(this, socket, protError);
      return;
    }

    if (serverProt) this.protocol = serverProt;

    if (perMessageDeflate) {
      try {
        const extensions = extension.parse(
          res.headers['sec-websocket-extensions']
        );

        if (extensions[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          this._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        abortHandshake(this, socket, 'Invalid Sec-WebSocket-Extensions header');
        return;
      }
    }

    this.setSocket(socket, head, options.maxPayload);
  });
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect(options) {
  //
  // Override `options.path` only if `options` is a copy of the original options
  // object. This is always true on Node.js >= 8 but not on Node.js 6 where
  // `options.socketPath` might be `undefined` even if the `socketPath` option
  // was originally set.
  //
  if (options.protocolVersion) options.path = options.socketPath;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) {
  options.path = undefined;
  options.servername = options.servername || options.host;
  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket)} stream The request to abort or the
 *     socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake(websocket, stream, message) {
  websocket.readyState = WebSocket.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream.abort();
    stream.once('abort', websocket.emitClose.bind(websocket));
    websocket.emit('error', err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {String} reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket];

  websocket._socket.removeListener('data', socketOnData);
  websocket._socket.resume();

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() {
  this[kWebSocket]._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError(err) {
  const websocket = this[kWebSocket];

  websocket._socket.removeListener('data', socketOnData);

  websocket.readyState = WebSocket.CLOSING;
  websocket._closeCode = err[constants.kStatusCode];
  websocket.emit('error', err);
  websocket._socket.destroy();
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() {
  this[kWebSocket].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message
 * @private
 */
function receiverOnMessage(data) {
  this[kWebSocket].emit('message', data);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) {
  const websocket = this[kWebSocket];

  websocket.pong(data, !websocket._isServer, constants.NOOP);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) {
  this[kWebSocket].emit('pong', data);
}

/**
 * The listener of the `net.Socket` `'close'` event.
 *
 * @private
 */
function socketOnClose() {
  const websocket = this[kWebSocket];

  this.removeListener('close', socketOnClose);
  this.removeListener('end', socketOnEnd);

  websocket.readyState = WebSocket.CLOSING;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk and emitted synchronously in a single
  // `'data'` event.
  //
  websocket._socket.read();
  websocket._receiver.end();

  this.removeListener('data', socketOnData);
  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the `net.Socket` `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the `net.Socket` `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket];

  websocket.readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the `net.Socket` `'error'` event.
 *
 * @private
 */
function socketOnError() {
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', constants.NOOP);

  if (websocket) {
    websocket.readyState = WebSocket.CLOSING;
    this.destroy();
  }
}


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (Object.prototype.hasOwnProperty.call(dest, name)) dest[name].push(elem);
  else dest[name] = [elem];
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse(header) {
  const offers = {};

  if (header === undefined || header === '') return offers;

  var params = {};
  var mustUnescape = false;
  var isEscaping = false;
  var inQuotes = false;
  var extensionName;
  var paramName;
  var start = -1;
  var end = -1;

  for (var i = 0; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 /* ' ' */ || code === 0x09 /* '\t' */) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = {};
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = {};
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        var value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = {};
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, {});
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      var configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                var values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

module.exports = { format, parse };


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const stream = __webpack_require__(11);

const PerMessageDeflate = __webpack_require__(32);
const bufferUtil = __webpack_require__(44);
const validation = __webpack_require__(73);
const constants = __webpack_require__(18);

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;

/**
 * HyBi Receiver implementation.
 *
 * @extends stream.Writable
 */
class Receiver extends stream.Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {String} binaryType The type for binary data
   * @param {Object} extensions An object containing the negotiated extensions
   * @param {Number} maxPayload The maximum allowed message length
   */
  constructor(binaryType, extensions, maxPayload) {
    super();

    this._binaryType = binaryType || constants.BINARY_TYPES[0];
    this[constants.kWebSocket] = undefined;
    this._extensions = extensions || {};
    this._maxPayload = maxPayload | 0;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._state = GET_INFO;
    this._loop = false;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = buf.slice(n);
      return buf.slice(0, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];

      if (n >= buf.length) {
        this._buffers.shift().copy(dst, dst.length - n);
      } else {
        buf.copy(dst, dst.length - n, 0, n);
        this._buffers[0] = buf.slice(n);
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    var err;
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          err = this.getInfo();
          break;
        case GET_PAYLOAD_LENGTH_16:
          err = this.getPayloadLength16();
          break;
        case GET_PAYLOAD_LENGTH_64:
          err = this.getPayloadLength64();
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          err = this.getData(cb);
          break;
        default:
          // `INFLATING`
          this._loop = false;
          return;
      }
    } while (this._loop);

    cb(err);
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getInfo() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      this._loop = false;
      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002);
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
      this._loop = false;
      return error(RangeError, 'RSV1 must be clear', true, 1002);
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        this._loop = false;
        return error(RangeError, 'RSV1 must be clear', true, 1002);
      }

      if (!this._fragmented) {
        this._loop = false;
        return error(RangeError, 'invalid opcode 0', true, 1002);
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        this._loop = false;
        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        this._loop = false;
        return error(RangeError, 'FIN must be set', true, 1002);
      }

      if (compressed) {
        this._loop = false;
        return error(RangeError, 'RSV1 must be clear', true, 1002);
      }

      if (this._payloadLength > 0x7d) {
        this._loop = false;
        return error(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002
        );
      }
    } else {
      this._loop = false;
      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else return this.haveLength();
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength16() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    return this.haveLength();
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength64() {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      this._loop = false;
      return error(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009
      );
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    return this.haveLength();
  }

  /**
   * Payload length has been read.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  haveLength() {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        this._loop = false;
        return error(RangeError, 'Max payload size exceeded', false, 1009);
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  getData(cb) {
    var data = constants.EMPTY_BUFFER;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);
      if (this._masked) bufferUtil.unmask(data, this._mask);
    }

    if (this._opcode > 0x07) return this.controlMessage(data);

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its lenght is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    return this.dataMessage();
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          return cb(
            error(RangeError, 'Max payload size exceeded', false, 1009)
          );
        }

        this._fragments.push(buf);
      }

      const er = this.dataMessage();
      if (er) return cb(er);

      this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @return {(Error|undefined)} A possible error
   * @private
   */
  dataMessage() {
    if (this._fin) {
      const messageLength = this._messageLength;
      const fragments = this._fragments;

      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];

      if (this._opcode === 2) {
        var data;

        if (this._binaryType === 'nodebuffer') {
          data = toBuffer(fragments, messageLength);
        } else if (this._binaryType === 'arraybuffer') {
          data = toArrayBuffer(toBuffer(fragments, messageLength));
        } else {
          data = fragments;
        }

        this.emit('message', data);
      } else {
        const buf = toBuffer(fragments, messageLength);

        if (!validation.isValidUTF8(buf)) {
          this._loop = false;
          return error(Error, 'invalid UTF-8 sequence', true, 1007);
        }

        this.emit('message', buf.toString());
      }
    }

    this._state = GET_INFO;
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data) {
    if (this._opcode === 0x08) {
      this._loop = false;

      if (data.length === 0) {
        this.emit('conclude', 1005, '');
        this.end();
      } else if (data.length === 1) {
        return error(RangeError, 'invalid payload length 1', true, 1002);
      } else {
        const code = data.readUInt16BE(0);

        if (!validation.isValidStatusCode(code)) {
          return error(RangeError, `invalid status code ${code}`, true, 1002);
        }

        const buf = data.slice(2);

        if (!validation.isValidUTF8(buf)) {
          return error(Error, 'invalid UTF-8 sequence', true, 1007);
        }

        this.emit('conclude', code, buf.toString());
        this.end();
      }
    } else if (this._opcode === 0x09) {
      this.emit('ping', data);
    } else {
      this.emit('pong', data);
    }

    this._state = GET_INFO;
  }
}

module.exports = Receiver;

/**
 * Builds an error object.
 *
 * @param {(Error|RangeError)} ErrorCtor The error constructor
 * @param {String} message The error message
 * @param {Boolean} prefix Specifies whether or not to add a default prefix to
 *     `message`
 * @param {Number} statusCode The status code
 * @return {(Error|RangeError)} The error
 * @private
 */
function error(ErrorCtor, message, prefix, statusCode) {
  const err = new ErrorCtor(
    prefix ? `Invalid WebSocket frame: ${message}` : message
  );

  Error.captureStackTrace(err, error);
  err[constants.kStatusCode] = statusCode;
  return err;
}

/**
 * Makes a buffer from a list of fragments.
 *
 * @param {Buffer[]} fragments The list of fragments composing the message
 * @param {Number} messageLength The length of the message
 * @return {Buffer}
 * @private
 */
function toBuffer(fragments, messageLength) {
  if (fragments.length === 1) return fragments[0];
  if (fragments.length > 1) return bufferUtil.concat(fragments, messageLength);
  return constants.EMPTY_BUFFER;
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 */
function toArrayBuffer(buf) {
  if (buf.byteLength === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
}


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


try {
  const isValidUTF8 = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"utf-8-validate\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

  exports.isValidUTF8 =
    typeof isValidUTF8 === 'object'
      ? isValidUTF8.Validation.isValidUTF8 // utf-8-validate@<3.0.0
      : isValidUTF8;
} catch (e) /* istanbul ignore next */ {
  exports.isValidUTF8 = () => true;
}

/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
exports.isValidStatusCode = (code) => {
  return (
    (code >= 1000 &&
      code <= 1013 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
};


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const crypto = __webpack_require__(12);

const PerMessageDeflate = __webpack_require__(32);
const bufferUtil = __webpack_require__(44);
const validation = __webpack_require__(73);
const constants = __webpack_require__(18);

/**
 * HyBi Sender implementation.
 */
class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {net.Socket} socket The connection socket
   * @param {Object} extensions An object containing the negotiated extensions
   */
  constructor(socket, extensions) {
    this._extensions = extensions || {};
    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._deflating = false;
    this._queue = [];
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {Buffer} data The data to frame
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} options.readOnly Specifies whether `data` can be modified
   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit
   * @return {Buffer[]} The framed data as a list of `Buffer` instances
   * @public
   */
  static frame(data, options) {
    const merge = data.length < 1024 || (options.mask && options.readOnly);
    var offset = options.mask ? 6 : 2;
    var payloadLength = data.length;

    if (data.length >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (data.length > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    if (payloadLength === 126) {
      target.writeUInt16BE(data.length, 2);
    } else if (payloadLength === 127) {
      target.writeUInt32BE(0, 2);
      target.writeUInt32BE(data.length, 6);
    }

    if (!options.mask) {
      target[1] = payloadLength;
      if (merge) {
        data.copy(target, offset);
        return [target];
      }

      return [target, data];
    }

    const mask = crypto.randomBytes(4);

    target[1] = payloadLength | 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (merge) {
      bufferUtil.mask(data, mask, target, offset, data.length);
      return [target];
    }

    bufferUtil.mask(data, mask, data, 0, data.length);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {(Number|undefined)} code The status code component of the body
   * @param {String} data The message component of the body
   * @param {Boolean} mask Specifies whether or not to mask the message
   * @param {Function} cb Callback
   * @public
   */
  close(code, data, mask, cb) {
    var buf;

    if (code === undefined) {
      buf = constants.EMPTY_BUFFER;
    } else if (
      typeof code !== 'number' ||
      !validation.isValidStatusCode(code)
    ) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || data === '') {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      buf = Buffer.allocUnsafe(2 + Buffer.byteLength(data));
      buf.writeUInt16BE(code, 0);
      buf.write(data, 2);
    }

    if (this._deflating) {
      this.enqueue([this.doClose, buf, mask, cb]);
    } else {
      this.doClose(buf, mask, cb);
    }
  }

  /**
   * Frames and sends a close message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @private
   */
  doClose(data, mask, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x08,
        mask,
        readOnly: false
      }),
      cb
    );
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @public
   */
  ping(data, mask, cb) {
    var readOnly = true;

    if (!Buffer.isBuffer(data)) {
      if (data instanceof ArrayBuffer) {
        data = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        data = viewToBuffer(data);
      } else {
        data = Buffer.from(data);
        readOnly = false;
      }
    }

    if (this._deflating) {
      this.enqueue([this.doPing, data, mask, readOnly, cb]);
    } else {
      this.doPing(data, mask, readOnly, cb);
    }
  }

  /**
   * Frames and sends a ping message.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Boolean} readOnly Specifies whether `data` can be modified
   * @param {Function} cb Callback
   * @private
   */
  doPing(data, mask, readOnly, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x09,
        mask,
        readOnly
      }),
      cb
    );
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @public
   */
  pong(data, mask, cb) {
    var readOnly = true;

    if (!Buffer.isBuffer(data)) {
      if (data instanceof ArrayBuffer) {
        data = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        data = viewToBuffer(data);
      } else {
        data = Buffer.from(data);
        readOnly = false;
      }
    }

    if (this._deflating) {
      this.enqueue([this.doPong, data, mask, readOnly, cb]);
    } else {
      this.doPong(data, mask, readOnly, cb);
    }
  }

  /**
   * Frames and sends a pong message.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Boolean} readOnly Specifies whether `data` can be modified
   * @param {Function} cb Callback
   * @private
   */
  doPong(data, mask, readOnly, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x0a,
        mask,
        readOnly
      }),
      cb
    );
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} options.compress Specifies whether or not to compress `data`
   * @param {Boolean} options.binary Specifies whether `data` is binary or text
   * @param {Boolean} options.fin Specifies whether the fragment is the last one
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @public
   */
  send(data, options, cb) {
    var opcode = options.binary ? 2 : 1;
    var rsv1 = options.compress;
    var readOnly = true;

    if (!Buffer.isBuffer(data)) {
      if (data instanceof ArrayBuffer) {
        data = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        data = viewToBuffer(data);
      } else {
        data = Buffer.from(data);
        readOnly = false;
      }
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    if (this._firstFragment) {
      this._firstFragment = false;
      if (rsv1 && perMessageDeflate) {
        rsv1 = data.length >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    if (perMessageDeflate) {
      const opts = {
        fin: options.fin,
        rsv1,
        opcode,
        mask: options.mask,
        readOnly
      };

      if (this._deflating) {
        this.enqueue([this.dispatch, data, this._compress, opts, cb]);
      } else {
        this.dispatch(data, this._compress, opts, cb);
      }
    } else {
      this.sendFrame(
        Sender.frame(data, {
          fin: options.fin,
          rsv1: false,
          opcode,
          mask: options.mask,
          readOnly
        }),
        cb
      );
    }
  }

  /**
   * Dispatches a data message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} compress Specifies whether or not to compress `data`
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} options.readOnly Specifies whether `data` can be modified
   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit
   * @param {Function} cb Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    this._deflating = true;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      this._deflating = false;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (!this._deflating && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[1].length;
      params[0].apply(this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[1].length;
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} cb Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
    } else {
      this._socket.write(list[0], cb);
    }
  }
}

module.exports = Sender;

/**
 * Converts an `ArrayBuffer` view into a buffer.
 *
 * @param {(DataView|TypedArray)} view The view to convert
 * @return {Buffer} Converted view
 * @private
 */
function viewToBuffer(view) {
  const buf = Buffer.from(view.buffer);

  if (view.byteLength !== view.buffer.byteLength) {
    return buf.slice(view.byteOffset, view.byteOffset + view.byteLength);
  }

  return buf;
}


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(22);

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),
/* 76 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 77 */
/***/ (function(module, exports) {


module.exports = isBuf;

var withNativeBuffer = typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function';
var withNativeArrayBuffer = typeof ArrayBuffer === 'function';

var isView = function (obj) {
  return typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(obj) : (obj.buffer instanceof ArrayBuffer);
};

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (withNativeBuffer && Buffer.isBuffer(obj)) ||
          (withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)));
}


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(184);

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* Active `debug` instances.
	*/
	createDebug.instances = [];

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return match;
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.enabled = createDebug.enabled(namespace);
		debug.useColors = createDebug.useColors();
		debug.color = selectColor(namespace);
		debug.destroy = destroy;
		debug.extend = extend;
		// Debug.formatArgs = formatArgs;
		// debug.rawLog = rawLog;

		// env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		createDebug.instances.push(debug);

		return debug;
	}

	function destroy() {
		const index = createDebug.instances.indexOf(this);
		if (index !== -1) {
			createDebug.instances.splice(index, 1);
			return true;
		}
		return false;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}

		for (i = 0; i < createDebug.instances.length; i++) {
			const instance = createDebug.instances[i];
			instance.enabled = createDebug.enabled(instance.namespace);
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var Socket = __webpack_require__(186);
var Emitter = __webpack_require__(1).EventEmitter;
var parser = __webpack_require__(33);
var hasBin = __webpack_require__(42);
var debug = __webpack_require__(34)('socket.io:namespace');

/**
 * Module exports.
 */

module.exports = exports = Namespace;

/**
 * Blacklisted events.
 */

exports.events = [
  'connect',    // for symmetry with client
  'connection',
  'newListener'
];

/**
 * Flags.
 */

exports.flags = [
  'json',
  'volatile',
  'local'
];

/**
 * `EventEmitter#emit` reference.
 */

var emit = Emitter.prototype.emit;

/**
 * Namespace constructor.
 *
 * @param {Server} server instance
 * @param {Socket} name
 * @api private
 */

function Namespace(server, name){
  this.name = name;
  this.server = server;
  this.sockets = {};
  this.connected = {};
  this.fns = [];
  this.ids = 0;
  this.rooms = [];
  this.flags = {};
  this.initAdapter();
}

/**
 * Inherits from `EventEmitter`.
 */

Namespace.prototype.__proto__ = Emitter.prototype;

/**
 * Apply flags from `Socket`.
 */

exports.flags.forEach(function(flag){
  Object.defineProperty(Namespace.prototype, flag, {
    get: function() {
      this.flags[flag] = true;
      return this;
    }
  });
});

/**
 * Initializes the `Adapter` for this nsp.
 * Run upon changing adapter by `Server#adapter`
 * in addition to the constructor.
 *
 * @api private
 */

Namespace.prototype.initAdapter = function(){
  this.adapter = new (this.server.adapter())(this);
};

/**
 * Sets up namespace middleware.
 *
 * @return {Namespace} self
 * @api public
 */

Namespace.prototype.use = function(fn){
  if (this.server.eio && this.name === '/') {
    debug('removing initial packet');
    delete this.server.eio.initialPacket;
  }
  this.fns.push(fn);
  return this;
};

/**
 * Executes the middleware for an incoming client.
 *
 * @param {Socket} socket that will get added
 * @param {Function} fn last fn call in the middleware
 * @api private
 */

Namespace.prototype.run = function(socket, fn){
  var fns = this.fns.slice(0);
  if (!fns.length) return fn(null);

  function run(i){
    fns[i](socket, function(err){
      // upon error, short-circuit
      if (err) return fn(err);

      // if no middleware left, summon callback
      if (!fns[i + 1]) return fn(null);

      // go on to next
      run(i + 1);
    });
  }

  run(0);
};

/**
 * Targets a room when emitting.
 *
 * @param {String} name
 * @return {Namespace} self
 * @api public
 */

Namespace.prototype.to =
Namespace.prototype.in = function(name){
  if (!~this.rooms.indexOf(name)) this.rooms.push(name);
  return this;
};

/**
 * Adds a new client.
 *
 * @return {Socket}
 * @api private
 */

Namespace.prototype.add = function(client, query, fn){
  debug('adding socket to nsp %s', this.name);
  var socket = new Socket(this, client, query);
  var self = this;
  this.run(socket, function(err){
    process.nextTick(function(){
      if ('open' == client.conn.readyState) {
        if (err) return socket.error(err.data || err.message);

        // track socket
        self.sockets[socket.id] = socket;

        // it's paramount that the internal `onconnect` logic
        // fires before user-set events to prevent state order
        // violations (such as a disconnection before the connection
        // logic is complete)
        socket.onconnect();
        if (fn) fn();

        // fire user-set events
        self.emit('connect', socket);
        self.emit('connection', socket);
      } else {
        debug('next called after client was closed - ignoring socket');
      }
    });
  });
  return socket;
};

/**
 * Removes a client. Called by each `Socket`.
 *
 * @api private
 */

Namespace.prototype.remove = function(socket){
  if (this.sockets.hasOwnProperty(socket.id)) {
    delete this.sockets[socket.id];
  } else {
    debug('ignoring remove for %s', socket.id);
  }
};

/**
 * Emits to all clients.
 *
 * @return {Namespace} self
 * @api public
 */

Namespace.prototype.emit = function(ev){
  if (~exports.events.indexOf(ev)) {
    emit.apply(this, arguments);
    return this;
  }
  // set up packet object
  var args = Array.prototype.slice.call(arguments);
  var packet = {
    type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,
    data: args
  };

  if ('function' == typeof args[args.length - 1]) {
    throw new Error('Callbacks are not supported when broadcasting');
  }

  var rooms = this.rooms.slice(0);
  var flags = Object.assign({}, this.flags);

  // reset flags
  this.rooms = [];
  this.flags = {};

  this.adapter.broadcast(packet, {
    rooms: rooms,
    flags: flags
  });

  return this;
};

/**
 * Sends a `message` event to all clients.
 *
 * @return {Namespace} self
 * @api public
 */

Namespace.prototype.send =
Namespace.prototype.write = function(){
  var args = Array.prototype.slice.call(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Gets a list of clients.
 *
 * @return {Namespace} self
 * @api public
 */

Namespace.prototype.clients = function(fn){
  if(!this.adapter){
    throw new Error('No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?')
  }
  this.adapter.clients(this.rooms, fn);
  // reset rooms for scenario:
  // .in('room').clients() (GH-1978)
  this.rooms = [];
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} compress if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Namespace.prototype.compress = function(compress){
  this.flags.compress = compress;
  return this;
};

/**
 * Sets the binary flag
 *
 * @param {Boolean} Encode as if it has binary data if `true`, Encode as if it doesnt have binary data if `false`
 * @return {Socket} self
 * @api public
 */

 Namespace.prototype.binary = function (binary) {
   this.flags.binary = binary;
   return this;
 };


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var express = __webpack_require__(81);
var socketServer_1 = __webpack_require__(143);
var path = __webpack_require__(2);
var app = express();
app.set("port", process.env.PORT || 3000);
var router = express.Router();
var http = __webpack_require__(4).Server(app);
app.use(express.static(path.resolve('./../client/build/')));
// login page
router.get("/login", function (req, res) {
    res.sendFile(path.resolve('./../client/login.html'));
});
// game page
router.get("/game", function (req, res) {
    res.sendFile(path.resolve('./../client/game.html'));
});
// redirects to login page 
router.get("*", function (req, res) {
    res.redirect("/login");
});
app.use('/', router);
// starts socket server
var sockets = new socketServer_1.SocketServer(http);
// start our simple server up on localhost:3000
// starts http server
var server = http.listen(3000, function () {
    console.log("listening on *:3000");
});


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



module.exports = __webpack_require__(82);


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 */

var bodyParser = __webpack_require__(83)
var EventEmitter = __webpack_require__(1).EventEmitter;
var mixin = __webpack_require__(120);
var proto = __webpack_require__(121);
var Route = __webpack_require__(55);
var Router = __webpack_require__(54);
var req = __webpack_require__(133);
var res = __webpack_require__(139);

/**
 * Expose `createApplication()`.
 */

exports = module.exports = createApplication;

/**
 * Create an express application.
 *
 * @return {Function}
 * @api public
 */

function createApplication() {
  var app = function(req, res, next) {
    app.handle(req, res, next);
  };

  mixin(app, EventEmitter.prototype, false);
  mixin(app, proto, false);

  // expose the prototype that will get set on requests
  app.request = Object.create(req, {
    app: { configurable: true, enumerable: true, writable: true, value: app }
  })

  // expose the prototype that will get set on responses
  app.response = Object.create(res, {
    app: { configurable: true, enumerable: true, writable: true, value: app }
  })

  app.init();
  return app;
}

/**
 * Expose the prototypes.
 */

exports.application = proto;
exports.request = req;
exports.response = res;

/**
 * Expose constructors.
 */

exports.Route = Route;
exports.Router = Router;

/**
 * Expose middleware
 */

exports.json = bodyParser.json
exports.query = __webpack_require__(57);
exports.static = __webpack_require__(142);
exports.urlencoded = bodyParser.urlencoded

/**
 * Replace removed middleware with an appropriate error message.
 */

var removedMiddlewares = [
  'bodyParser',
  'compress',
  'cookieSession',
  'session',
  'logger',
  'cookieParser',
  'favicon',
  'responseTime',
  'errorHandler',
  'timeout',
  'methodOverride',
  'vhost',
  'csrf',
  'directory',
  'limit',
  'multipart',
  'staticCache'
]

removedMiddlewares.forEach(function (name) {
  Object.defineProperty(exports, name, {
    get: function () {
      throw new Error('Most middleware (like ' + name + ') is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.');
    },
    configurable: true
  });
});


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var deprecate = __webpack_require__(5)('body-parser')

/**
 * Cache of loaded parsers.
 * @private
 */

var parsers = Object.create(null)

/**
 * @typedef Parsers
 * @type {function}
 * @property {function} json
 * @property {function} raw
 * @property {function} text
 * @property {function} urlencoded
 */

/**
 * Module exports.
 * @type {Parsers}
 */

exports = module.exports = deprecate.function(bodyParser,
  'bodyParser: use individual json/urlencoded middlewares')

/**
 * JSON parser.
 * @public
 */

Object.defineProperty(exports, 'json', {
  configurable: true,
  enumerable: true,
  get: createParserGetter('json')
})

/**
 * Raw parser.
 * @public
 */

Object.defineProperty(exports, 'raw', {
  configurable: true,
  enumerable: true,
  get: createParserGetter('raw')
})

/**
 * Text parser.
 * @public
 */

Object.defineProperty(exports, 'text', {
  configurable: true,
  enumerable: true,
  get: createParserGetter('text')
})

/**
 * URL-encoded parser.
 * @public
 */

Object.defineProperty(exports, 'urlencoded', {
  configurable: true,
  enumerable: true,
  get: createParserGetter('urlencoded')
})

/**
 * Create a middleware to parse json and urlencoded bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @deprecated
 * @public
 */

function bodyParser (options) {
  var opts = {}

  // exclude type option
  if (options) {
    for (var prop in options) {
      if (prop !== 'type') {
        opts[prop] = options[prop]
      }
    }
  }

  var _urlencoded = exports.urlencoded(opts)
  var _json = exports.json(opts)

  return function bodyParser (req, res, next) {
    _json(req, res, function (err) {
      if (err) return next(err)
      _urlencoded(req, res, next)
    })
  }
}

/**
 * Create a getter for loading a parser.
 * @private
 */

function createParserGetter (name) {
  return function get () {
    return loadParser(name)
  }
}

/**
 * Load a parser module.
 * @private
 */

function loadParser (parserName) {
  var parser = parsers[parserName]

  if (parser !== undefined) {
    return parser
  }

  // this uses a switch for static require analysis
  switch (parserName) {
    case 'json':
      parser = __webpack_require__(86)
      break
    case 'raw':
      parser = __webpack_require__(115)
      break
    case 'text':
      parser = __webpack_require__(116)
      break
    case 'urlencoded':
      parser = __webpack_require__(117)
      break
  }

  // store to prevent invoking require()
  return (parsers[parserName] = parser)
}


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * depd
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 */

module.exports = callSiteToString

/**
 * Format a CallSite file location to a string.
 */

function callSiteFileLocation (callSite) {
  var fileName
  var fileLocation = ''

  if (callSite.isNative()) {
    fileLocation = 'native'
  } else if (callSite.isEval()) {
    fileName = callSite.getScriptNameOrSourceURL()
    if (!fileName) {
      fileLocation = callSite.getEvalOrigin()
    }
  } else {
    fileName = callSite.getFileName()
  }

  if (fileName) {
    fileLocation += fileName

    var lineNumber = callSite.getLineNumber()
    if (lineNumber != null) {
      fileLocation += ':' + lineNumber

      var columnNumber = callSite.getColumnNumber()
      if (columnNumber) {
        fileLocation += ':' + columnNumber
      }
    }
  }

  return fileLocation || 'unknown source'
}

/**
 * Format a CallSite to a string.
 */

function callSiteToString (callSite) {
  var addSuffix = true
  var fileLocation = callSiteFileLocation(callSite)
  var functionName = callSite.getFunctionName()
  var isConstructor = callSite.isConstructor()
  var isMethodCall = !(callSite.isToplevel() || isConstructor)
  var line = ''

  if (isMethodCall) {
    var methodName = callSite.getMethodName()
    var typeName = getConstructorName(callSite)

    if (functionName) {
      if (typeName && functionName.indexOf(typeName) !== 0) {
        line += typeName + '.'
      }

      line += functionName

      if (methodName && functionName.lastIndexOf('.' + methodName) !== functionName.length - methodName.length - 1) {
        line += ' [as ' + methodName + ']'
      }
    } else {
      line += typeName + '.' + (methodName || '<anonymous>')
    }
  } else if (isConstructor) {
    line += 'new ' + (functionName || '<anonymous>')
  } else if (functionName) {
    line += functionName
  } else {
    addSuffix = false
    line += fileLocation
  }

  if (addSuffix) {
    line += ' (' + fileLocation + ')'
  }

  return line
}

/**
 * Get constructor name of reviver.
 */

function getConstructorName (obj) {
  var receiver = obj.receiver
  return (receiver.constructor && receiver.constructor.name) || null
}


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = eventListenerCount

/**
 * Get the count of listeners on an event emitter of a specific type.
 */

function eventListenerCount (emitter, type) {
  return emitter.listeners(type).length
}


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var bytes = __webpack_require__(13)
var contentType = __webpack_require__(19)
var createError = __webpack_require__(14)
var debug = __webpack_require__(3)('body-parser:json')
var read = __webpack_require__(24)
var typeis = __webpack_require__(15)

/**
 * Module exports.
 */

module.exports = json

/**
 * RegExp to match the first non-space in a string.
 *
 * Allowed whitespace is defined in RFC 7159:
 *
 *    ws = *(
 *            %x20 /              ; Space
 *            %x09 /              ; Horizontal tab
 *            %x0A /              ; Line feed or New line
 *            %x0D )              ; Carriage return
 */

var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*(.)/ // eslint-disable-line no-control-regex

/**
 * Create a middleware to parse JSON bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @public
 */

function json (options) {
  var opts = options || {}

  var limit = typeof opts.limit !== 'number'
    ? bytes.parse(opts.limit || '100kb')
    : opts.limit
  var inflate = opts.inflate !== false
  var reviver = opts.reviver
  var strict = opts.strict !== false
  var type = opts.type || 'application/json'
  var verify = opts.verify || false

  if (verify !== false && typeof verify !== 'function') {
    throw new TypeError('option verify must be function')
  }

  // create the appropriate type checking function
  var shouldParse = typeof type !== 'function'
    ? typeChecker(type)
    : type

  function parse (body) {
    if (body.length === 0) {
      // special-case empty json body, as it's a common client-side mistake
      // TODO: maybe make this configurable or part of "strict" option
      return {}
    }

    if (strict) {
      var first = firstchar(body)

      if (first !== '{' && first !== '[') {
        debug('strict violation')
        throw createStrictSyntaxError(body, first)
      }
    }

    try {
      debug('parse json')
      return JSON.parse(body, reviver)
    } catch (e) {
      throw normalizeJsonSyntaxError(e, {
        message: e.message,
        stack: e.stack
      })
    }
  }

  return function jsonParser (req, res, next) {
    if (req._body) {
      debug('body already parsed')
      next()
      return
    }

    req.body = req.body || {}

    // skip requests without bodies
    if (!typeis.hasBody(req)) {
      debug('skip empty body')
      next()
      return
    }

    debug('content-type %j', req.headers['content-type'])

    // determine if request should be parsed
    if (!shouldParse(req)) {
      debug('skip parsing')
      next()
      return
    }

    // assert charset per RFC 7159 sec 8.1
    var charset = getCharset(req) || 'utf-8'
    if (charset.substr(0, 4) !== 'utf-') {
      debug('invalid charset')
      next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
        charset: charset,
        type: 'charset.unsupported'
      }))
      return
    }

    // read
    read(req, res, next, parse, debug, {
      encoding: charset,
      inflate: inflate,
      limit: limit,
      verify: verify
    })
  }
}

/**
 * Create strict violation syntax error matching native error.
 *
 * @param {string} str
 * @param {string} char
 * @return {Error}
 * @private
 */

function createStrictSyntaxError (str, char) {
  var index = str.indexOf(char)
  var partial = str.substring(0, index) + '#'

  try {
    JSON.parse(partial); /* istanbul ignore next */ throw new SyntaxError('strict violation')
  } catch (e) {
    return normalizeJsonSyntaxError(e, {
      message: e.message.replace('#', char),
      stack: e.stack
    })
  }
}

/**
 * Get the first non-whitespace character in a string.
 *
 * @param {string} str
 * @return {function}
 * @private
 */

function firstchar (str) {
  return FIRST_CHAR_REGEXP.exec(str)[1]
}

/**
 * Get the charset of a request.
 *
 * @param {object} req
 * @api private
 */

function getCharset (req) {
  try {
    return (contentType.parse(req).parameters.charset || '').toLowerCase()
  } catch (e) {
    return undefined
  }
}

/**
 * Normalize a SyntaxError for JSON.parse.
 *
 * @param {SyntaxError} error
 * @param {object} obj
 * @return {SyntaxError}
 */

function normalizeJsonSyntaxError (error, obj) {
  var keys = Object.getOwnPropertyNames(error)

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i]
    if (key !== 'stack' && key !== 'message') {
      delete error[key]
    }
  }

  // replace stack before message for Node.js 0.10 and below
  error.stack = obj.stack.replace(error.message, obj.message)
  error.message = obj.message

  return error
}

/**
 * Get the simple type checker.
 *
 * @param {string} type
 * @return {function}
 */

function typeChecker (type) {
  return function checkType (req) {
    return Boolean(typeis(req, type))
  }
}


/***/ }),
/* 87 */
/***/ (function(module, exports) {

module.exports = {"100":"Continue","101":"Switching Protocols","102":"Processing","200":"OK","201":"Created","202":"Accepted","203":"Non-Authoritative Information","204":"No Content","205":"Reset Content","206":"Partial Content","207":"Multi-Status","208":"Already Reported","226":"IM Used","300":"Multiple Choices","301":"Moved Permanently","302":"Found","303":"See Other","304":"Not Modified","305":"Use Proxy","306":"(Unused)","307":"Temporary Redirect","308":"Permanent Redirect","400":"Bad Request","401":"Unauthorized","402":"Payment Required","403":"Forbidden","404":"Not Found","405":"Method Not Allowed","406":"Not Acceptable","407":"Proxy Authentication Required","408":"Request Timeout","409":"Conflict","410":"Gone","411":"Length Required","412":"Precondition Failed","413":"Payload Too Large","414":"URI Too Long","415":"Unsupported Media Type","416":"Range Not Satisfiable","417":"Expectation Failed","418":"I'm a teapot","421":"Misdirected Request","422":"Unprocessable Entity","423":"Locked","424":"Failed Dependency","425":"Unordered Collection","426":"Upgrade Required","428":"Precondition Required","429":"Too Many Requests","431":"Request Header Fields Too Large","451":"Unavailable For Legal Reasons","500":"Internal Server Error","501":"Not Implemented","502":"Bad Gateway","503":"Service Unavailable","504":"Gateway Timeout","505":"HTTP Version Not Supported","506":"Variant Also Negotiates","507":"Insufficient Storage","508":"Loop Detected","509":"Bandwidth Limit Exceeded","510":"Not Extended","511":"Network Authentication Required"}

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

try {
  var util = __webpack_require__(0);
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  module.exports = __webpack_require__(89);
}


/***/ }),
/* 89 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(46);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var tty = __webpack_require__(23);
var util = __webpack_require__(0);

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(46);
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()
}

var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = __webpack_require__(6);
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = __webpack_require__(35);
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var bytes = __webpack_require__(13)
var createError = __webpack_require__(14)
var iconv = __webpack_require__(47)
var unpipe = __webpack_require__(50)

/**
 * Module exports.
 * @public
 */

module.exports = getRawBody

/**
 * Module variables.
 * @private
 */

var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /

/**
 * Get the decoder for a given encoding.
 *
 * @param {string} encoding
 * @private
 */

function getDecoder (encoding) {
  if (!encoding) return null

  try {
    return iconv.getDecoder(encoding)
  } catch (e) {
    // error getting decoder
    if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e

    // the encoding was not found
    throw createError(415, 'specified encoding unsupported', {
      encoding: encoding,
      type: 'encoding.unsupported'
    })
  }
}

/**
 * Get the raw body of a stream (typically HTTP).
 *
 * @param {object} stream
 * @param {object|string|function} [options]
 * @param {function} [callback]
 * @public
 */

function getRawBody (stream, options, callback) {
  var done = callback
  var opts = options || {}

  if (options === true || typeof options === 'string') {
    // short cut for encoding
    opts = {
      encoding: options
    }
  }

  if (typeof options === 'function') {
    done = options
    opts = {}
  }

  // validate callback is a function, if provided
  if (done !== undefined && typeof done !== 'function') {
    throw new TypeError('argument callback must be a function')
  }

  // require the callback without promises
  if (!done && !global.Promise) {
    throw new TypeError('argument callback is required')
  }

  // get encoding
  var encoding = opts.encoding !== true
    ? opts.encoding
    : 'utf-8'

  // convert the limit to an integer
  var limit = bytes.parse(opts.limit)

  // convert the expected length to an integer
  var length = opts.length != null && !isNaN(opts.length)
    ? parseInt(opts.length, 10)
    : null

  if (done) {
    // classic callback style
    return readStream(stream, encoding, length, limit, done)
  }

  return new Promise(function executor (resolve, reject) {
    readStream(stream, encoding, length, limit, function onRead (err, buf) {
      if (err) return reject(err)
      resolve(buf)
    })
  })
}

/**
 * Halt a stream.
 *
 * @param {Object} stream
 * @private
 */

function halt (stream) {
  // unpipe everything from the stream
  unpipe(stream)

  // pause stream
  if (typeof stream.pause === 'function') {
    stream.pause()
  }
}

/**
 * Read the data from the stream.
 *
 * @param {object} stream
 * @param {string} encoding
 * @param {number} length
 * @param {number} limit
 * @param {function} callback
 * @public
 */

function readStream (stream, encoding, length, limit, callback) {
  var complete = false
  var sync = true

  // check the length and limit options.
  // note: we intentionally leave the stream paused,
  // so users should handle the stream themselves.
  if (limit !== null && length !== null && length > limit) {
    return done(createError(413, 'request entity too large', {
      expected: length,
      length: length,
      limit: limit,
      type: 'entity.too.large'
    }))
  }

  // streams1: assert request encoding is buffer.
  // streams2+: assert the stream encoding is buffer.
  //   stream._decoder: streams1
  //   state.encoding: streams2
  //   state.decoder: streams2, specifically < 0.10.6
  var state = stream._readableState
  if (stream._decoder || (state && (state.encoding || state.decoder))) {
    // developer error
    return done(createError(500, 'stream encoding should not be set', {
      type: 'stream.encoding.set'
    }))
  }

  var received = 0
  var decoder

  try {
    decoder = getDecoder(encoding)
  } catch (err) {
    return done(err)
  }

  var buffer = decoder
    ? ''
    : []

  // attach listeners
  stream.on('aborted', onAborted)
  stream.on('close', cleanup)
  stream.on('data', onData)
  stream.on('end', onEnd)
  stream.on('error', onEnd)

  // mark sync section complete
  sync = false

  function done () {
    var args = new Array(arguments.length)

    // copy arguments
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }

    // mark complete
    complete = true

    if (sync) {
      process.nextTick(invokeCallback)
    } else {
      invokeCallback()
    }

    function invokeCallback () {
      cleanup()

      if (args[0]) {
        // halt the stream on error
        halt(stream)
      }

      callback.apply(null, args)
    }
  }

  function onAborted () {
    if (complete) return

    done(createError(400, 'request aborted', {
      code: 'ECONNABORTED',
      expected: length,
      length: length,
      received: received,
      type: 'request.aborted'
    }))
  }

  function onData (chunk) {
    if (complete) return

    received += chunk.length

    if (limit !== null && received > limit) {
      done(createError(413, 'request entity too large', {
        limit: limit,
        received: received,
        type: 'entity.too.large'
      }))
    } else if (decoder) {
      buffer += decoder.write(chunk)
    } else {
      buffer.push(chunk)
    }
  }

  function onEnd (err) {
    if (complete) return
    if (err) return done(err)

    if (length !== null && received !== length) {
      done(createError(400, 'request size did not match content length', {
        expected: length,
        length: length,
        received: received,
        type: 'request.size.invalid'
      }))
    } else {
      var string = decoder
        ? buffer + (decoder.end() || '')
        : Buffer.concat(buffer)
      done(null, string)
    }
  }

  function cleanup () {
    buffer = null

    stream.removeListener('aborted', onAborted)
    stream.removeListener('data', onData)
    stream.removeListener('end', onEnd)
    stream.removeListener('error', onEnd)
    stream.removeListener('close', cleanup)
  }
}


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BOMChar = '\uFEFF';

exports.PrependBOM = PrependBOMWrapper
function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
}

PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
        str = BOMChar + str;
        this.addBOM = false;
    }

    return this.encoder.write(str);
}

PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
}


//------------------------------------------------------------------------------

exports.StripBOM = StripBOMWrapper;
function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
}

StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
        return res;

    if (res[0] === BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === 'function')
            this.options.stripBOM();
    }

    this.pass = true;
    return res;
}

StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
}



/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Update this array if you add/rename/remove files in this directory.
// We support Browserify by skipping automatic module discovery and requiring modules directly.
var modules = [
    __webpack_require__(95),
    __webpack_require__(97),
    __webpack_require__(98),
    __webpack_require__(99),
    __webpack_require__(100),
    __webpack_require__(101),
    __webpack_require__(102),
    __webpack_require__(103),
];

// Put all encoding/alias/codec definitions to single object and export it. 
for (var i = 0; i < modules.length; i++) {
    var module = modules[i];
    for (var enc in module)
        if (Object.prototype.hasOwnProperty.call(module, enc))
            exports[enc] = module[enc];
}


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(9).Buffer;

// Export Node.js internal encodings.

module.exports = {
    // Encodings
    utf8:   { type: "_internal", bomAware: true},
    cesu8:  { type: "_internal", bomAware: true},
    unicode11utf8: "utf8",

    ucs2:   { type: "_internal", bomAware: true},
    utf16le: "ucs2",

    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex:    { type: "_internal" },

    // Codec.
    _internal: InternalCodec,
};

//------------------------------------------------------------------------------

function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;

    if (this.enc === "base64")
        this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
        this.enc = "utf8"; // Use utf8 for decoding.
        this.encoder = InternalEncoderCesu8;

        // Add decoder for versions of Node not supporting CESU-8
        if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== '') {
            this.decoder = InternalDecoderCesu8;
            this.defaultCharUnicode = iconv.defaultCharUnicode;
        }
    }
}

InternalCodec.prototype.encoder = InternalEncoder;
InternalCodec.prototype.decoder = InternalDecoder;

//------------------------------------------------------------------------------

// We use node.js internal decoder. Its signature is the same as ours.
var StringDecoder = __webpack_require__(96).StringDecoder;

if (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.
    StringDecoder.prototype.end = function() {};


function InternalDecoder(options, codec) {
    StringDecoder.call(this, codec.enc);
}

InternalDecoder.prototype = StringDecoder.prototype;


//------------------------------------------------------------------------------
// Encoder is mostly trivial

function InternalEncoder(options, codec) {
    this.enc = codec.enc;
}

InternalEncoder.prototype.write = function(str) {
    return Buffer.from(str, this.enc);
}

InternalEncoder.prototype.end = function() {
}


//------------------------------------------------------------------------------
// Except base64 encoder, which must keep its state.

function InternalEncoderBase64(options, codec) {
    this.prevStr = '';
}

InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - (str.length % 4);
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);

    return Buffer.from(str, "base64");
}

InternalEncoderBase64.prototype.end = function() {
    return Buffer.from(this.prevStr, "base64");
}


//------------------------------------------------------------------------------
// CESU-8 encoder is also special.

function InternalEncoderCesu8(options, codec) {
}

InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        // Naive implementation, but it works because CESU-8 is especially easy
        // to convert from UTF-16 (which all JS strings are encoded in).
        if (charCode < 0x80)
            buf[bufIdx++] = charCode;
        else if (charCode < 0x800) {
            buf[bufIdx++] = 0xC0 + (charCode >>> 6);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
        else { // charCode will always be < 0x10000 in javascript.
            buf[bufIdx++] = 0xE0 + (charCode >>> 12);
            buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
    }
    return buf.slice(0, bufIdx);
}

InternalEncoderCesu8.prototype.end = function() {
}

//------------------------------------------------------------------------------
// CESU-8 decoder is not implemented in Node v4.0+

function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
}

InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, 
        res = '';
    for (var i = 0; i < buf.length; i++) {
        var curByte = buf[i];
        if ((curByte & 0xC0) !== 0x80) { // Leading byte
            if (contBytes > 0) { // Previous code is invalid
                res += this.defaultCharUnicode;
                contBytes = 0;
            }

            if (curByte < 0x80) { // Single-byte code
                res += String.fromCharCode(curByte);
            } else if (curByte < 0xE0) { // Two-byte code
                acc = curByte & 0x1F;
                contBytes = 1; accBytes = 1;
            } else if (curByte < 0xF0) { // Three-byte code
                acc = curByte & 0x0F;
                contBytes = 2; accBytes = 1;
            } else { // Four or more are not supported for CESU-8.
                res += this.defaultCharUnicode;
            }
        } else { // Continuation byte
            if (contBytes > 0) { // We're waiting for it.
                acc = (acc << 6) | (curByte & 0x3f);
                contBytes--; accBytes++;
                if (contBytes === 0) {
                    // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
                    if (accBytes === 2 && acc < 0x80 && acc > 0)
                        res += this.defaultCharUnicode;
                    else if (accBytes === 3 && acc < 0x800)
                        res += this.defaultCharUnicode;
                    else
                        // Actually add character.
                        res += String.fromCharCode(acc);
                }
            } else { // Unexpected continuation byte
                res += this.defaultCharUnicode;
            }
        }
    }
    this.acc = acc; this.contBytes = contBytes; this.accBytes = accBytes;
    return res;
}

InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
        res += this.defaultCharUnicode;
    return res;
}


/***/ }),
/* 96 */
/***/ (function(module, exports) {

module.exports = require("string_decoder");

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(9).Buffer;

// Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

// == UTF16-BE codec. ==========================================================

exports.utf16be = Utf16BECodec;
function Utf16BECodec() {
}

Utf16BECodec.prototype.encoder = Utf16BEEncoder;
Utf16BECodec.prototype.decoder = Utf16BEDecoder;
Utf16BECodec.prototype.bomAware = true;


// -- Encoding

function Utf16BEEncoder() {
}

Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer.from(str, 'ucs2');
    for (var i = 0; i < buf.length; i += 2) {
        var tmp = buf[i]; buf[i] = buf[i+1]; buf[i+1] = tmp;
    }
    return buf;
}

Utf16BEEncoder.prototype.end = function() {
}


// -- Decoding

function Utf16BEDecoder() {
    this.overflowByte = -1;
}

Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
        return '';

    var buf2 = Buffer.alloc(buf.length + 1),
        i = 0, j = 0;

    if (this.overflowByte !== -1) {
        buf2[0] = buf[0];
        buf2[1] = this.overflowByte;
        i = 1; j = 2;
    }

    for (; i < buf.length-1; i += 2, j+= 2) {
        buf2[j] = buf[i+1];
        buf2[j+1] = buf[i];
    }

    this.overflowByte = (i == buf.length-1) ? buf[buf.length-1] : -1;

    return buf2.slice(0, j).toString('ucs2');
}

Utf16BEDecoder.prototype.end = function() {
}


// == UTF-16 codec =============================================================
// Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
// Defaults to UTF-16LE, as it's prevalent and default in Node.
// http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
// Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

// Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

exports.utf16 = Utf16Codec;
function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
}

Utf16Codec.prototype.encoder = Utf16Encoder;
Utf16Codec.prototype.decoder = Utf16Decoder;


// -- Encoding (pass-through)

function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined)
        options.addBOM = true;
    this.encoder = codec.iconv.getEncoder('utf-16le', options);
}

Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
}

Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
}


// -- Decoding

function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBytes = [];
    this.initialBytesLen = 0;

    this.options = options || {};
    this.iconv = codec.iconv;
}

Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
        // Codec is not chosen yet. Accumulate initial bytes.
        this.initialBytes.push(buf);
        this.initialBytesLen += buf.length;
        
        if (this.initialBytesLen < 16) // We need more bytes to use space heuristic (see below)
            return '';

        // We have enough bytes -> detect endianness.
        var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        this.initialBytes.length = this.initialBytesLen = 0;
    }

    return this.decoder.write(buf);
}

Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
        var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);

        var res = this.decoder.write(buf),
            trail = this.decoder.end();

        return trail ? (res + trail) : res;
    }
    return this.decoder.end();
}

function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || 'utf-16le';

    if (buf.length >= 2) {
        // Check BOM.
        if (buf[0] == 0xFE && buf[1] == 0xFF) // UTF-16BE BOM
            enc = 'utf-16be';
        else if (buf[0] == 0xFF && buf[1] == 0xFE) // UTF-16LE BOM
            enc = 'utf-16le';
        else {
            // No BOM found. Try to deduce encoding from initial content.
            // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
            // So, we count ASCII as if it was LE or BE, and decide from that.
            var asciiCharsLE = 0, asciiCharsBE = 0, // Counts of chars in both positions
                _len = Math.min(buf.length - (buf.length % 2), 64); // Len is always even.

            for (var i = 0; i < _len; i += 2) {
                if (buf[i] === 0 && buf[i+1] !== 0) asciiCharsBE++;
                if (buf[i] !== 0 && buf[i+1] === 0) asciiCharsLE++;
            }

            if (asciiCharsBE > asciiCharsLE)
                enc = 'utf-16be';
            else if (asciiCharsBE < asciiCharsLE)
                enc = 'utf-16le';
        }
    }

    return enc;
}




/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(9).Buffer;

// UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
// See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

exports.utf7 = Utf7Codec;
exports.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
};

Utf7Codec.prototype.encoder = Utf7Encoder;
Utf7Codec.prototype.decoder = Utf7Decoder;
Utf7Codec.prototype.bomAware = true;


// -- Encoding

var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;

function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
}

Utf7Encoder.prototype.write = function(str) {
    // Naive implementation.
    // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
    return Buffer.from(str.replace(nonDirectChars, function(chunk) {
        return "+" + (chunk === '+' ? '' : 
            this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) 
            + "-";
    }.bind(this)));
}

Utf7Encoder.prototype.end = function() {
}


// -- Decoding

function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
}

var base64Regex = /[A-Za-z0-9\/+]/;
var base64Chars = [];
for (var i = 0; i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));

var plusChar = '+'.charCodeAt(0), 
    minusChar = '-'.charCodeAt(0),
    andChar = '&'.charCodeAt(0);

Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.

    for (var i = 0; i < buf.length; i++) {
        if (!inBase64) { // We're in direct mode.
            // Write direct chars until '+'
            if (buf[i] == plusChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i+1;
                inBase64 = true;
            }
        } else { // We decode base64.
            if (!base64Chars[buf[i]]) { // Base64 ended.
                if (i == lastI && buf[i] == minusChar) {// "+-" -> "+"
                    res += "+";
                } else {
                    var b64str = base64Accum + buf.slice(lastI, i).toString();
                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
                }

                if (buf[i] != minusChar) // Minus is absorbed after base64.
                    i--;

                lastI = i+1;
                inBase64 = false;
                base64Accum = '';
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
        var b64str = base64Accum + buf.slice(lastI).toString();

        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
}

Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

    this.inBase64 = false;
    this.base64Accum = '';
    return res;
}


// UTF-7-IMAP codec.
// RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
// Differences:
//  * Base64 part is started by "&" instead of "+"
//  * Direct characters are 0x20-0x7E, except "&" (0x26)
//  * In Base64, "," is used instead of "/"
//  * Base64 must not be used to represent direct characters.
//  * No implicit shift back from Base64 (should always end with '-')
//  * String must end in non-shifted position.
//  * "-&" while in base64 is not allowed.


exports.utf7imap = Utf7IMAPCodec;
function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
};

Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
Utf7IMAPCodec.prototype.bomAware = true;


// -- Encoding

function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer.alloc(6);
    this.base64AccumIdx = 0;
}

Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64,
        base64Accum = this.base64Accum,
        base64AccumIdx = this.base64AccumIdx,
        buf = Buffer.alloc(str.length*5 + 10), bufIdx = 0;

    for (var i = 0; i < str.length; i++) {
        var uChar = str.charCodeAt(i);
        if (0x20 <= uChar && uChar <= 0x7E) { // Direct character or '&'.
            if (inBase64) {
                if (base64AccumIdx > 0) {
                    bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
                    base64AccumIdx = 0;
                }

                buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
                inBase64 = false;
            }

            if (!inBase64) {
                buf[bufIdx++] = uChar; // Write direct character

                if (uChar === andChar)  // Ampersand -> '&-'
                    buf[bufIdx++] = minusChar;
            }

        } else { // Non-direct character
            if (!inBase64) {
                buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
                inBase64 = true;
            }
            if (inBase64) {
                base64Accum[base64AccumIdx++] = uChar >> 8;
                base64Accum[base64AccumIdx++] = uChar & 0xFF;

                if (base64AccumIdx == base64Accum.length) {
                    bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
                    base64AccumIdx = 0;
                }
            }
        }
    }

    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;

    return buf.slice(0, bufIdx);
}

Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer.alloc(10), bufIdx = 0;
    if (this.inBase64) {
        if (this.base64AccumIdx > 0) {
            bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
            this.base64AccumIdx = 0;
        }

        buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
        this.inBase64 = false;
    }

    return buf.slice(0, bufIdx);
}


// -- Decoding

function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
}

var base64IMAPChars = base64Chars.slice();
base64IMAPChars[','.charCodeAt(0)] = true;

Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.
    // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

    for (var i = 0; i < buf.length; i++) {
        if (!inBase64) { // We're in direct mode.
            // Write direct chars until '&'
            if (buf[i] == andChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i+1;
                inBase64 = true;
            }
        } else { // We decode base64.
            if (!base64IMAPChars[buf[i]]) { // Base64 ended.
                if (i == lastI && buf[i] == minusChar) { // "&-" -> "&"
                    res += "&";
                } else {
                    var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
                }

                if (buf[i] != minusChar) // Minus may be absorbed after base64.
                    i--;

                lastI = i+1;
                inBase64 = false;
                base64Accum = '';
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
        var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');

        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
}

Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

    this.inBase64 = false;
    this.base64Accum = '';
    return res;
}




/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(9).Buffer;

// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
// correspond to encoded bytes (if 128 - then lower half is ASCII). 

exports._sbcs = SBCSCodec;
function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
        throw new Error("SBCS codec is called without the data.")
    
    // Prepare char buffer for decoding.
    if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256))
        throw new Error("Encoding '"+codecOptions.type+"' has incorrect 'chars' (must be of len 128 or 256)");
    
    if (codecOptions.chars.length === 128) {
        var asciiString = "";
        for (var i = 0; i < 128; i++)
            asciiString += String.fromCharCode(i);
        codecOptions.chars = asciiString + codecOptions.chars;
    }

    this.decodeBuf = new Buffer.from(codecOptions.chars, 'ucs2');
    
    // Encoding buffer.
    var encodeBuf = new Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));

    for (var i = 0; i < codecOptions.chars.length; i++)
        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;

    this.encodeBuf = encodeBuf;
}

SBCSCodec.prototype.encoder = SBCSEncoder;
SBCSCodec.prototype.decoder = SBCSDecoder;


function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
}

SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer.alloc(str.length);
    for (var i = 0; i < str.length; i++)
        buf[i] = this.encodeBuf[str.charCodeAt(i)];
    
    return buf;
}

SBCSEncoder.prototype.end = function() {
}


function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
}

SBCSDecoder.prototype.write = function(buf) {
    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer.alloc(buf.length*2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
        idx1 = buf[i]*2; idx2 = i*2;
        newBuf[idx2] = decodeBuf[idx1];
        newBuf[idx2+1] = decodeBuf[idx1+1];
    }
    return newBuf.toString('ucs2');
}

SBCSDecoder.prototype.end = function() {
}


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Manually added data to be used by sbcs codec in addition to generated one.

module.exports = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
        "type": "_sbcs",
        "chars": ""
    },

    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
        "type": "_sbcs",
        "chars": ""
    },

    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",

    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",

    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek" : "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",

    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",

    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",

    "cp819": "iso88591",
    "ibm819": "iso88591",

    "cyrillic": "iso88595",

    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",

    "greek" : "iso88597",
    "greek8" : "iso88597",
    "ecma118" : "iso88597",
    "elot928" : "iso88597",

    "hebrew": "iso88598",
    "hebrew8": "iso88598",

    "turkish": "iso88599",
    "turkish8": "iso88599",

    "thai": "iso885911",
    "thai8": "iso885911",

    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",

    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",

    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",

    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",

    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",

    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",

    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",

    "strk10482002": "rk1048",

    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",

    "gb198880": "iso646cn",
    "cn": "iso646cn",

    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",

    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",

    "mac": "macintosh",
    "csmacintosh": "macintosh",
};



/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
module.exports = {
  "437": "cp437",
  "737": "cp737",
  "775": "cp775",
  "850": "cp850",
  "852": "cp852",
  "855": "cp855",
  "856": "cp856",
  "857": "cp857",
  "858": "cp858",
  "860": "cp860",
  "861": "cp861",
  "862": "cp862",
  "863": "cp863",
  "864": "cp864",
  "865": "cp865",
  "866": "cp866",
  "869": "cp869",
  "874": "windows874",
  "922": "cp922",
  "1046": "cp1046",
  "1124": "cp1124",
  "1125": "cp1125",
  "1129": "cp1129",
  "1133": "cp1133",
  "1161": "cp1161",
  "1162": "cp1162",
  "1163": "cp1163",
  "1250": "windows1250",
  "1251": "windows1251",
  "1252": "windows1252",
  "1253": "windows1253",
  "1254": "windows1254",
  "1255": "windows1255",
  "1256": "windows1256",
  "1257": "windows1257",
  "1258": "windows1258",
  "28591": "iso88591",
  "28592": "iso88592",
  "28593": "iso88593",
  "28594": "iso88594",
  "28595": "iso88595",
  "28596": "iso88596",
  "28597": "iso88597",
  "28598": "iso88598",
  "28599": "iso88599",
  "28600": "iso885910",
  "28601": "iso885911",
  "28603": "iso885913",
  "28604": "iso885914",
  "28605": "iso885915",
  "28606": "iso885916",
  "windows874": {
    "type": "_sbcs",
    "chars": ""
  },
  "win874": "windows874",
  "cp874": "windows874",
  "windows1250": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1250": "windows1250",
  "cp1250": "windows1250",
  "windows1251": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1251": "windows1251",
  "cp1251": "windows1251",
  "windows1252": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1252": "windows1252",
  "cp1252": "windows1252",
  "windows1253": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1253": "windows1253",
  "cp1253": "windows1253",
  "windows1254": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1254": "windows1254",
  "cp1254": "windows1254",
  "windows1255": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1255": "windows1255",
  "cp1255": "windows1255",
  "windows1256": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1256": "windows1256",
  "cp1256": "windows1256",
  "windows1257": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1257": "windows1257",
  "cp1257": "windows1257",
  "windows1258": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1258": "windows1258",
  "cp1258": "windows1258",
  "iso88591": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28591": "iso88591",
  "iso88592": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28592": "iso88592",
  "iso88593": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28593": "iso88593",
  "iso88594": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28594": "iso88594",
  "iso88595": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28595": "iso88595",
  "iso88596": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28596": "iso88596",
  "iso88597": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28597": "iso88597",
  "iso88598": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28598": "iso88598",
  "iso88599": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28599": "iso88599",
  "iso885910": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28600": "iso885910",
  "iso885911": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28601": "iso885911",
  "iso885913": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28603": "iso885913",
  "iso885914": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28604": "iso885914",
  "iso885915": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28605": "iso885915",
  "iso885916": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28606": "iso885916",
  "cp437": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm437": "cp437",
  "csibm437": "cp437",
  "cp737": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm737": "cp737",
  "csibm737": "cp737",
  "cp775": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm775": "cp775",
  "csibm775": "cp775",
  "cp850": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm850": "cp850",
  "csibm850": "cp850",
  "cp852": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm852": "cp852",
  "csibm852": "cp852",
  "cp855": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm855": "cp855",
  "csibm855": "cp855",
  "cp856": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm856": "cp856",
  "csibm856": "cp856",
  "cp857": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm857": "cp857",
  "csibm857": "cp857",
  "cp858": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm858": "cp858",
  "csibm858": "cp858",
  "cp860": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm860": "cp860",
  "csibm860": "cp860",
  "cp861": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm861": "cp861",
  "csibm861": "cp861",
  "cp862": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm862": "cp862",
  "csibm862": "cp862",
  "cp863": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm863": "cp863",
  "csibm863": "cp863",
  "cp864": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "ibm864": "cp864",
  "csibm864": "cp864",
  "cp865": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm865": "cp865",
  "csibm865": "cp865",
  "cp866": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm866": "cp866",
  "csibm866": "cp866",
  "cp869": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm869": "cp869",
  "csibm869": "cp869",
  "cp922": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm922": "cp922",
  "csibm922": "cp922",
  "cp1046": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1046": "cp1046",
  "csibm1046": "cp1046",
  "cp1124": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1124": "cp1124",
  "csibm1124": "cp1124",
  "cp1125": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1125": "cp1125",
  "csibm1125": "cp1125",
  "cp1129": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1129": "cp1129",
  "csibm1129": "cp1129",
  "cp1133": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1133": "cp1133",
  "csibm1133": "cp1133",
  "cp1161": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1161": "cp1161",
  "csibm1161": "cp1161",
  "cp1162": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1162": "cp1162",
  "csibm1162": "cp1162",
  "cp1163": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1163": "cp1163",
  "csibm1163": "cp1163",
  "maccroatian": {
    "type": "_sbcs",
    "chars": ""
  },
  "maccyrillic": {
    "type": "_sbcs",
    "chars": ""
  },
  "macgreek": {
    "type": "_sbcs",
    "chars": ""
  },
  "maciceland": {
    "type": "_sbcs",
    "chars": ""
  },
  "macroman": {
    "type": "_sbcs",
    "chars": ""
  },
  "macromania": {
    "type": "_sbcs",
    "chars": ""
  },
  "macthai": {
    "type": "_sbcs",
    "chars": ""
  },
  "macturkish": {
    "type": "_sbcs",
    "chars": ""
  },
  "macukraine": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8r": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8u": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8ru": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8t": {
    "type": "_sbcs",
    "chars": ""
  },
  "armscii8": {
    "type": "_sbcs",
    "chars": ")(.,-"
  },
  "rk1048": {
    "type": "_sbcs",
    "chars": ""
  },
  "tcvn": {
    "type": "_sbcs",
    "chars": "\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "georgianacademy": {
    "type": "_sbcs",
    "chars": ""
  },
  "georgianps": {
    "type": "_sbcs",
    "chars": ""
  },
  "pt154": {
    "type": "_sbcs",
    "chars": ""
  },
  "viscii": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "iso646cn": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
  },
  "iso646jp": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
  },
  "hproman8": {
    "type": "_sbcs",
    "chars": ""
  },
  "macintosh": {
    "type": "_sbcs",
    "chars": ""
  },
  "ascii": {
    "type": "_sbcs",
    "chars": ""
  },
  "tis620": {
    "type": "_sbcs",
    "chars": ""
  }
}

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(9).Buffer;

// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
// To save memory and loading time, we read table files only when requested.

exports._dbcs = DBCSCodec;

var UNASSIGNED = -1,
    GB18030_CODE = -2,
    SEQ_START  = -10,
    NODE_START = -1000,
    UNASSIGNED_NODE = new Array(0x100),
    DEF_CHAR = -1;

for (var i = 0; i < 0x100; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;


// Class DBCSCodec reads and initializes mapping tables.
function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
        throw new Error("DBCS codec is called without the data.")
    if (!codecOptions.table)
        throw new Error("Encoding '" + this.encodingName + "' has no data.");

    // Load tables.
    var mappingTable = codecOptions.table();


    // Decode tables: MBCS -> Unicode.

    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
    // Trie root is decodeTables[0].
    // Values: >=  0 -> unicode character code. can be > 0xFFFF
    //         == UNASSIGNED -> unknown/unassigned sequence.
    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
    //         <= NODE_START -> index of the next node in our trie to process next byte.
    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
    this.decodeTableSeq = [];

    // Actual mapping tables consist of chunks. Use them to fill up decode tables.
    for (var i = 0; i < mappingTable.length; i++)
        this._addDecodeChunk(mappingTable[i]);

    this.defaultCharUnicode = iconv.defaultCharUnicode;

    
    // Encode tables: Unicode -> DBCS.

    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
    //         == UNASSIGNED -> no conversion found. Output a default char.
    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
    this.encodeTable = [];
    
    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
    // means end of sequence (needed when one sequence is a strict subsequence of another).
    // Objects are kept separately from encodeTable to increase performance.
    this.encodeTableSeq = [];

    // Some chars can be decoded, but need not be encoded.
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
            var val = codecOptions.encodeSkipVals[i];
            if (typeof val === 'number')
                skipEncodeChars[val] = true;
            else
                for (var j = val.from; j <= val.to; j++)
                    skipEncodeChars[j] = true;
        }
        
    // Use decode trie to recursively fill out encode tables.
    this._fillEncodeTable(0, 0, skipEncodeChars);

    // Add more encoding pairs when needed.
    if (codecOptions.encodeAdd) {
        for (var uChar in codecOptions.encodeAdd)
            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }

    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);


    // Load & create GB18030 tables when needed.
    if (typeof codecOptions.gb18030 === 'function') {
        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

        // Add GB18030 decode tables.
        var thirdByteNodeIdx = this.decodeTables.length;
        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);

        var fourthByteNodeIdx = this.decodeTables.length;
        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);

        for (var i = 0x81; i <= 0xFE; i++) {
            var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
            var secondByteNode = this.decodeTables[secondByteNodeIdx];
            for (var j = 0x30; j <= 0x39; j++)
                secondByteNode[j] = NODE_START - thirdByteNodeIdx;
        }
        for (var i = 0x81; i <= 0xFE; i++)
            thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
        for (var i = 0x30; i <= 0x39; i++)
            fourthByteNode[i] = GB18030_CODE
    }        
}

DBCSCodec.prototype.encoder = DBCSEncoder;
DBCSCodec.prototype.decoder = DBCSDecoder;

// Decoder helpers
DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (; addr > 0; addr >>= 8)
        bytes.push(addr & 0xFF);
    if (bytes.length == 0)
        bytes.push(0);

    var node = this.decodeTables[0];
    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.
        var val = node[bytes[i]];

        if (val == UNASSIGNED) { // Create new node.
            node[bytes[i]] = NODE_START - this.decodeTables.length;
            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
        }
        else if (val <= NODE_START) { // Existing node.
            node = this.decodeTables[NODE_START - val];
        }
        else
            throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
}


DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    // First element of chunk is the hex mbcs code where we start.
    var curAddr = parseInt(chunk[0], 16);

    // Choose the decoding node where we'll write our chars.
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 0xFF;

    // Write all other elements of the chunk to the table.
    for (var k = 1; k < chunk.length; k++) {
        var part = chunk[k];
        if (typeof part === "string") { // String, write as-is.
            for (var l = 0; l < part.length;) {
                var code = part.charCodeAt(l++);
                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate
                    var codeTrail = part.charCodeAt(l++);
                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)
                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);
                    else
                        throw new Error("Incorrect surrogate pair in "  + this.encodingName + " at chunk " + chunk[0]);
                }
                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)
                    var len = 0xFFF - code + 2;
                    var seq = [];
                    for (var m = 0; m < len; m++)
                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.

                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
                    this.decodeTableSeq.push(seq);
                }
                else
                    writeTable[curAddr++] = code; // Basic char
            }
        } 
        else if (typeof part === "number") { // Integer, meaning increasing sequence starting with prev character.
            var charCode = writeTable[curAddr - 1] + 1;
            for (var l = 0; l < part; l++)
                writeTable[curAddr++] = charCode++;
        }
        else
            throw new Error("Incorrect type '" + typeof part + "' given in "  + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 0xFF)
        throw new Error("Incorrect chunk in "  + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
}

// Encoder helpers
DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8; // This could be > 0xFF because of astral characters.
    if (this.encodeTable[high] === undefined)
        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
    return this.encodeTable[high];
}

DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;
    if (bucket[low] <= SEQ_START)
        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
    else if (bucket[low] == UNASSIGNED)
        bucket[low] = dbcsCode;
}

DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    
    // Get the root of character tree according to first character of the sequence.
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;

    var node;
    if (bucket[low] <= SEQ_START) {
        // There's already a sequence with  - use it.
        node = this.encodeTableSeq[SEQ_START-bucket[low]];
    }
    else {
        // There was no sequence object - allocate a new one.
        node = {};
        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
        bucket[low] = SEQ_START - this.encodeTableSeq.length;
        this.encodeTableSeq.push(node);
    }

    // Traverse the character tree, allocating new nodes as needed.
    for (var j = 1; j < seq.length-1; j++) {
        var oldVal = node[uCode];
        if (typeof oldVal === 'object')
            node = oldVal;
        else {
            node = node[uCode] = {}
            if (oldVal !== undefined)
                node[DEF_CHAR] = oldVal
        }
    }

    // Set the leaf to given dbcsCode.
    uCode = seq[seq.length-1];
    node[uCode] = dbcsCode;
}

DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    for (var i = 0; i < 0x100; i++) {
        var uCode = node[i];
        var mbCode = prefix + i;
        if (skipEncodeChars[mbCode])
            continue;

        if (uCode >= 0)
            this._setEncodeChar(uCode, mbCode);
        else if (uCode <= NODE_START)
            this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
        else if (uCode <= SEQ_START)
            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
    }
}



// == Encoder ==================================================================

function DBCSEncoder(options, codec) {
    // Encoder state
    this.leadSurrogate = -1;
    this.seqObj = undefined;
    
    // Static data
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
}

DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),
        leadSurrogate = this.leadSurrogate,
        seqObj = this.seqObj, nextChar = -1,
        i = 0, j = 0;

    while (true) {
        // 0. Get next character.
        if (nextChar === -1) {
            if (i == str.length) break;
            var uCode = str.charCodeAt(i++);
        }
        else {
            var uCode = nextChar;
            nextChar = -1;    
        }

        // 1. Handle surrogates.
        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.
            if (uCode < 0xDC00) { // We've got lead surrogate.
                if (leadSurrogate === -1) {
                    leadSurrogate = uCode;
                    continue;
                } else {
                    leadSurrogate = uCode;
                    // Double lead surrogate found.
                    uCode = UNASSIGNED;
                }
            } else { // We've got trail surrogate.
                if (leadSurrogate !== -1) {
                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
                    leadSurrogate = -1;
                } else {
                    // Incomplete surrogate pair - only trail surrogate found.
                    uCode = UNASSIGNED;
                }
                
            }
        }
        else if (leadSurrogate !== -1) {
            // Incomplete surrogate pair - only lead surrogate found.
            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.
            leadSurrogate = -1;
        }

        // 2. Convert uCode character.
        var dbcsCode = UNASSIGNED;
        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence
            var resCode = seqObj[uCode];
            if (typeof resCode === 'object') { // Sequence continues.
                seqObj = resCode;
                continue;

            } else if (typeof resCode == 'number') { // Sequence finished. Write it.
                dbcsCode = resCode;

            } else if (resCode == undefined) { // Current character is not part of the sequence.

                // Try default character for this sequence
                resCode = seqObj[DEF_CHAR];
                if (resCode !== undefined) {
                    dbcsCode = resCode; // Found. Write it.
                    nextChar = uCode; // Current character will be written too in the next iteration.

                } else {
                    // TODO: What if we have no default? (resCode == undefined)
                    // Then, we should write first char of the sequence as-is and try the rest recursively.
                    // Didn't do it for now because no encoding has this situation yet.
                    // Currently, just skip the sequence and write current char.
                }
            }
            seqObj = undefined;
        }
        else if (uCode >= 0) {  // Regular character
            var subtable = this.encodeTable[uCode >> 8];
            if (subtable !== undefined)
                dbcsCode = subtable[uCode & 0xFF];
            
            if (dbcsCode <= SEQ_START) { // Sequence start
                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];
                continue;
            }

            if (dbcsCode == UNASSIGNED && this.gb18030) {
                // Use GB18030 algorithm to find character(s) to write.
                var idx = findIdx(this.gb18030.uChars, uCode);
                if (idx != -1) {
                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;
                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;
                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;
                    newBuf[j++] = 0x30 + dbcsCode;
                    continue;
                }
            }
        }

        // 3. Write dbcsCode character.
        if (dbcsCode === UNASSIGNED)
            dbcsCode = this.defaultCharSingleByte;
        
        if (dbcsCode < 0x100) {
            newBuf[j++] = dbcsCode;
        }
        else if (dbcsCode < 0x10000) {
            newBuf[j++] = dbcsCode >> 8;   // high byte
            newBuf[j++] = dbcsCode & 0xFF; // low byte
        }
        else {
            newBuf[j++] = dbcsCode >> 16;
            newBuf[j++] = (dbcsCode >> 8) & 0xFF;
            newBuf[j++] = dbcsCode & 0xFF;
        }
    }

    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
}

DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === undefined)
        return; // All clean. Most often case.

    var newBuf = Buffer.alloc(10), j = 0;

    if (this.seqObj) { // We're in the sequence.
        var dbcsCode = this.seqObj[DEF_CHAR];
        if (dbcsCode !== undefined) { // Write beginning of the sequence.
            if (dbcsCode < 0x100) {
                newBuf[j++] = dbcsCode;
            }
            else {
                newBuf[j++] = dbcsCode >> 8;   // high byte
                newBuf[j++] = dbcsCode & 0xFF; // low byte
            }
        } else {
            // See todo above.
        }
        this.seqObj = undefined;
    }

    if (this.leadSurrogate !== -1) {
        // Incomplete surrogate pair - only lead surrogate found.
        newBuf[j++] = this.defaultCharSingleByte;
        this.leadSurrogate = -1;
    }
    
    return newBuf.slice(0, j);
}

// Export for testing
DBCSEncoder.prototype.findIdx = findIdx;


// == Decoder ==================================================================

function DBCSDecoder(options, codec) {
    // Decoder state
    this.nodeIdx = 0;
    this.prevBuf = Buffer.alloc(0);

    // Static data
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
}

DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer.alloc(buf.length*2),
        nodeIdx = this.nodeIdx, 
        prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length,
        seqStart = -this.prevBuf.length, // idx of the start of current parsed sequence.
        uCode;

    if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.
        prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);
    
    for (var i = 0, j = 0; i < buf.length; i++) {
        var curByte = (i >= 0) ? buf[i] : prevBuf[i + prevBufOffset];

        // Lookup in current trie node.
        var uCode = this.decodeTables[nodeIdx][curByte];

        if (uCode >= 0) { 
            // Normal character, just use it.
        }
        else if (uCode === UNASSIGNED) { // Unknown char.
            // TODO: Callback with seq.
            //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
            i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).
            uCode = this.defaultCharUnicode.charCodeAt(0);
        }
        else if (uCode === GB18030_CODE) {
            var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
            var ptr = (curSeq[0]-0x81)*12600 + (curSeq[1]-0x30)*1260 + (curSeq[2]-0x81)*10 + (curSeq[3]-0x30);
            var idx = findIdx(this.gb18030.gbChars, ptr);
            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
        }
        else if (uCode <= NODE_START) { // Go to next trie node.
            nodeIdx = NODE_START - uCode;
            continue;
        }
        else if (uCode <= SEQ_START) { // Output a sequence of chars.
            var seq = this.decodeTableSeq[SEQ_START - uCode];
            for (var k = 0; k < seq.length - 1; k++) {
                uCode = seq[k];
                newBuf[j++] = uCode & 0xFF;
                newBuf[j++] = uCode >> 8;
            }
            uCode = seq[seq.length-1];
        }
        else
            throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);

        // Write the character to buffer, handling higher planes using surrogate pair.
        if (uCode > 0xFFFF) { 
            uCode -= 0x10000;
            var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);
            newBuf[j++] = uCodeLead & 0xFF;
            newBuf[j++] = uCodeLead >> 8;

            uCode = 0xDC00 + uCode % 0x400;
        }
        newBuf[j++] = uCode & 0xFF;
        newBuf[j++] = uCode >> 8;

        // Reset trie node.
        nodeIdx = 0; seqStart = i+1;
    }

    this.nodeIdx = nodeIdx;
    this.prevBuf = (seqStart >= 0) ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
    return newBuf.slice(0, j).toString('ucs2');
}

DBCSDecoder.prototype.end = function() {
    var ret = '';

    // Try to parse all remaining chars.
    while (this.prevBuf.length > 0) {
        // Skip 1 character in the buffer.
        ret += this.defaultCharUnicode;
        var buf = this.prevBuf.slice(1);

        // Parse remaining as usual.
        this.prevBuf = Buffer.alloc(0);
        this.nodeIdx = 0;
        if (buf.length > 0)
            ret += this.write(buf);
    }

    this.nodeIdx = 0;
    return ret;
}

// Binary search for GB18030. Returns largest i such that table[i] <= val.
function findIdx(table, val) {
    if (table[0] > val)
        return -1;

    var l = 0, r = table.length;
    while (l < r-1) { // always table[l] <= val < table[r]
        var mid = l + Math.floor((r-l+1)/2);
        if (table[mid] <= val)
            l = mid;
        else
            r = mid;
    }
    return l;
}



/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Description of supported double byte encodings and aliases.
// Tables are not require()-d until they are needed to speed up library load.
// require()-s are direct to support Browserify.

module.exports = {
    
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

    'shiftjis': {
        type: '_dbcs',
        table: function() { return __webpack_require__(104) },
        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
        encodeSkipVals: [{from: 0xED40, to: 0xF940}],
    },
    'csshiftjis': 'shiftjis',
    'mskanji': 'shiftjis',
    'sjis': 'shiftjis',
    'windows31j': 'shiftjis',
    'ms31j': 'shiftjis',
    'xsjis': 'shiftjis',
    'windows932': 'shiftjis',
    'ms932': 'shiftjis',
    '932': 'shiftjis',
    'cp932': 'shiftjis',

    'eucjp': {
        type: '_dbcs',
        table: function() { return __webpack_require__(105) },
        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
    },

    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.


    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    'gb2312': 'cp936',
    'gb231280': 'cp936',
    'gb23121980': 'cp936',
    'csgb2312': 'cp936',
    'csiso58gb231280': 'cp936',
    'euccn': 'cp936',

    // Microsoft's CP936 is a subset and approximation of GBK.
    'windows936': 'cp936',
    'ms936': 'cp936',
    '936': 'cp936',
    'cp936': {
        type: '_dbcs',
        table: function() { return __webpack_require__(36) },
    },

    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    'gbk': {
        type: '_dbcs',
        table: function() { return __webpack_require__(36).concat(__webpack_require__(48)) },
    },
    'xgbk': 'gbk',
    'isoir58': 'gbk',

    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    'gb18030': {
        type: '_dbcs',
        table: function() { return __webpack_require__(36).concat(__webpack_require__(48)) },
        gb18030: function() { return __webpack_require__(106) },
        encodeSkipVals: [0x80],
        encodeAdd: {'': 0xA2E3},
    },

    'chinese': 'gb18030',


    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    'windows949': 'cp949',
    'ms949': 'cp949',
    '949': 'cp949',
    'cp949': {
        type: '_dbcs',
        table: function() { return __webpack_require__(107) },
    },

    'cseuckr': 'cp949',
    'csksc56011987': 'cp949',
    'euckr': 'cp949',
    'isoir149': 'cp949',
    'korean': 'cp949',
    'ksc56011987': 'cp949',
    'ksc56011989': 'cp949',
    'ksc5601': 'cp949',


    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

    'windows950': 'cp950',
    'ms950': 'cp950',
    '950': 'cp950',
    'cp950': {
        type: '_dbcs',
        table: function() { return __webpack_require__(49) },
    },

    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    'big5': 'big5hkscs',
    'big5hkscs': {
        type: '_dbcs',
        table: function() { return __webpack_require__(49).concat(__webpack_require__(108)) },
        encodeSkipVals: [0xa2cc],
    },

    'cnbig5': 'big5hkscs',
    'csbig5': 'big5hkscs',
    'xxbig5': 'big5hkscs',
};


/***/ }),
/* 104 */
/***/ (function(module, exports) {

module.exports = [["0","\u0000",128],["a1","",62],["8140","",9,""],["8180",""],["81b8",""],["81c8",""],["81da",""],["81f0",""],["81fc",""],["824f","",9],["8260","",25],["8281","",25],["829f","",82],["8340","",62],["8380","",22],["839f","",16,"",6],["83bf","",16,"",6],["8440","",5,"",25],["8470","",5,"",7],["8480","",17],["849f",""],["8740","",19,"",9],["875f",""],["877e",""],["8780","",4,""],["889f",""],["8940",""],["8980",""],["8a40",""],["8a80",""],["8b40",""],["8b80",""],["8c40",""],["8c80",""],["8d40",""],["8d80",""],["8e40",""],["8e80",""],["8f40",""],["8f80",""],["9040",""],["9080",""],["9140",""],["9180",""],["9240",""],["9280",""],["9340",""],["9380",""],["9440",""],["9480",""],["9540",""],["9580",""],["9640",""],["9680",""],["9740",""],["9780",""],["9840",""],["989f",""],["9940",""],["9980",""],["9a40",""],["9a80",""],["9b40",""],["9b80",""],["9c40",""],["9c80",""],["9d40",""],["9d80",""],["9e40",""],["9e80",""],["9f40",""],["9f80",""],["e040",""],["e080",""],["e140",""],["e180",""],["e240",""],["e280",""],["e340",""],["e380",""],["e440",""],["e480",""],["e540",""],["e580",""],["e640",""],["e680",""],["e740",""],["e780",""],["e840",""],["e880",""],["e940",""],["e980",""],["ea40",""],["ea80",""],["ed40",""],["ed80",""],["ee40",""],["ee80",""],["eeef","",9,""],["f040","",62],["f080","",124],["f140","",62],["f180","",124],["f240","",62],["f280","",124],["f340","",62],["f380","",124],["f440","",62],["f480","",124],["f540","",62],["f580","",124],["f640","",62],["f680","",124],["f740","",62],["f780","",124],["f840","",62],["f880","",124],["f940",""],["fa40","",9,"",9,""],["fa80",""],["fb40",""],["fb80",""],["fc40",""]]

/***/ }),
/* 105 */
/***/ (function(module, exports) {

module.exports = [["0","\u0000",127],["8ea1","",62],["a1a1","",9,""],["a2a1",""],["a2ba",""],["a2ca",""],["a2dc",""],["a2f2",""],["a2fe",""],["a3b0","",9],["a3c1","",25],["a3e1","",25],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a7a1","",5,"",25],["a7d1","",5,"",25],["a8a1",""],["ada1","",19,"",9],["adc0",""],["addf","",4,""],["b0a1",""],["b1a1",""],["b2a1",""],["b3a1",""],["b4a1",""],["b5a1",""],["b6a1",""],["b7a1",""],["b8a1",""],["b9a1",""],["baa1",""],["bba1",""],["bca1",""],["bda1",""],["bea1",""],["bfa1",""],["c0a1",""],["c1a1",""],["c2a1",""],["c3a1",""],["c4a1",""],["c5a1",""],["c6a1",""],["c7a1",""],["c8a1",""],["c9a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1",""],["d2a1",""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fcf1","",9,""],["8fa2af",""],["8fa2c2",""],["8fa2eb",""],["8fa6e1",""],["8fa6e7",""],["8fa6e9",""],["8fa6ec",""],["8fa6f1",""],["8fa7c2","",10,""],["8fa7f2","",10,""],["8fa9a1",""],["8fa9a4",""],["8fa9a6",""],["8fa9a8",""],["8fa9ab",""],["8fa9af",""],["8fa9c1",""],["8faaa1",""],["8faaba",""],["8faba1",""],["8fabbd",""],["8fabc5",""],["8fb0a1",""],["8fb1a1",""],["8fb2a1","",4,""],["8fb3a1",""],["8fb4a1",""],["8fb5a1",""],["8fb6a1","",5,"",4,""],["8fb7a1","",4,""],["8fb8a1",""],["8fb9a1",""],["8fbaa1","",4,""],["8fbba1",""],["8fbca1","",4,""],["8fbda1","",4,""],["8fbea1","",4,""],["8fbfa1",""],["8fc0a1",""],["8fc1a1",""],["8fc2a1",""],["8fc3a1","",4,""],["8fc4a1",""],["8fc5a1",""],["8fc6a1",""],["8fc7a1",""],["8fc8a1",""],["8fc9a1","",4,"",4,""],["8fcaa1",""],["8fcba1",""],["8fcca1","",9,""],["8fcda1","",5,""],["8fcea1","",6,""],["8fcfa1",""],["8fd0a1",""],["8fd1a1",""],["8fd2a1","",5],["8fd3a1",""],["8fd4a1","",4,""],["8fd5a1",""],["8fd6a1",""],["8fd7a1",""],["8fd8a1",""],["8fd9a1","",4,"",6,""],["8fdaa1","",4,""],["8fdba1","",6,""],["8fdca1","",4,""],["8fdda1","",4,""],["8fdea1","",4,""],["8fdfa1",""],["8fe0a1",""],["8fe1a1","",4,""],["8fe2a1",""],["8fe3a1","",5,"",4,""],["8fe4a1","",4,""],["8fe5a1","",4,""],["8fe6a1",""],["8fe7a1",""],["8fe8a1","",4,""],["8fe9a1","",4],["8feaa1","",4,""],["8feba1","",4,""],["8feca1",""],["8feda1","",4,"",4,""]]

/***/ }),
/* 106 */
/***/ (function(module, exports) {

module.exports = {"uChars":[128,165,169,178,184,216,226,235,238,244,248,251,253,258,276,284,300,325,329,334,364,463,465,467,469,471,473,475,477,506,594,610,712,716,730,930,938,962,970,1026,1104,1106,8209,8215,8218,8222,8231,8241,8244,8246,8252,8365,8452,8454,8458,8471,8482,8556,8570,8596,8602,8713,8720,8722,8726,8731,8737,8740,8742,8748,8751,8760,8766,8777,8781,8787,8802,8808,8816,8854,8858,8870,8896,8979,9322,9372,9548,9588,9616,9622,9634,9652,9662,9672,9676,9680,9702,9735,9738,9793,9795,11906,11909,11913,11917,11928,11944,11947,11951,11956,11960,11964,11979,12284,12292,12312,12319,12330,12351,12436,12447,12535,12543,12586,12842,12850,12964,13200,13215,13218,13253,13263,13267,13270,13384,13428,13727,13839,13851,14617,14703,14801,14816,14964,15183,15471,15585,16471,16736,17208,17325,17330,17374,17623,17997,18018,18212,18218,18301,18318,18760,18811,18814,18820,18823,18844,18848,18872,19576,19620,19738,19887,40870,59244,59336,59367,59413,59417,59423,59431,59437,59443,59452,59460,59478,59493,63789,63866,63894,63976,63986,64016,64018,64021,64025,64034,64037,64042,65074,65093,65107,65112,65127,65132,65375,65510,65536],"gbChars":[0,36,38,45,50,81,89,95,96,100,103,104,105,109,126,133,148,172,175,179,208,306,307,308,309,310,311,312,313,341,428,443,544,545,558,741,742,749,750,805,819,820,7922,7924,7925,7927,7934,7943,7944,7945,7950,8062,8148,8149,8152,8164,8174,8236,8240,8262,8264,8374,8380,8381,8384,8388,8390,8392,8393,8394,8396,8401,8406,8416,8419,8424,8437,8439,8445,8482,8485,8496,8521,8603,8936,8946,9046,9050,9063,9066,9076,9092,9100,9108,9111,9113,9131,9162,9164,9218,9219,11329,11331,11334,11336,11346,11361,11363,11366,11370,11372,11375,11389,11682,11686,11687,11692,11694,11714,11716,11723,11725,11730,11736,11982,11989,12102,12336,12348,12350,12384,12393,12395,12397,12510,12553,12851,12962,12973,13738,13823,13919,13933,14080,14298,14585,14698,15583,15847,16318,16434,16438,16481,16729,17102,17122,17315,17320,17402,17418,17859,17909,17911,17915,17916,17936,17939,17961,18664,18703,18814,18962,19043,33469,33470,33471,33484,33485,33490,33497,33501,33505,33513,33520,33536,33550,37845,37921,37948,38029,38038,38064,38065,38066,38069,38075,38076,38078,39108,39109,39113,39114,39115,39116,39265,39394,189000]}

/***/ }),
/* 107 */
/***/ (function(module, exports) {

module.exports = [["0","\u0000",127],["8141","",4,"",6,""],["8161","",9,"",5,""],["8181","",18,"",4,"",6,"",5,"",6,"",7,"",7,"",4,"",4,""],["8241","",7,"",5],["8261","",6,"",5,""],["8281","",7,"",7,"",4,"",10,"",5,"",17,"",7,"",6,"",7,"",18],["8341","",5,"",5,"",7],["8361","",18,""],["8381","",4,"",6,"",5,"",5,"",46,"",6,"",5,"",8],["8441","",5,"",8],["8461","",18],["8481","",7,"",6,"",5,"",10,"",5,"",18,"",5,"",6,"",5,"",26,""],["8541","",5,"",4,"",6,"",4],["8561","",5,"",5,"",6,""],["8581","",6,"",6,"",9,"",26,"",29,"",6,"",5,""],["8641","",6,"",5,""],["8661","",6,"",10],["8681","",22,"",4,"",6,"",5,"",6,"",22,"",4,""],["8741","",9,"",15],["8761","",18,""],["8781","",5,"",7,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",4],["8841","",4,"",5,"",6,"",4],["8861","",4,""],["8881","",15,"",4,"",6,"",5,"",54,""],["8941","",6,"",5,""],["8961","",10,"",5,""],["8981","",21,"",18,"",18,"",6,"",6,"",7,"",15],["8a41","",10,"",6,""],["8a61","",4,"",18,""],["8a81","",4,"",19,"",5,"",7,"",5,"",6,"",5,"",4,"",5,"",26,""],["8b41","",5,"",4,"",6,""],["8b61","",6,"",8],["8b81","",52,"",4,"",6,"",5,"",18,"",18],["8c41","",15,"",4],["8c61","",6,"",5,"",6,"",5],["8c81","",12,"",26,"",50,"",5,"",16],["8d41","",16,"",8],["8d61","",17,""],["8d81","",4,"",33,"",6,"",7,"",6,"",9,"",6,"",5,"",6,""],["8e41","",6,"",5,"",8],["8e61","",4,"",19],["8e81","",13,"",6,"",4,"",6,"",5,"",6,"",5,"",11,"",7,"",6,"",5,"",7],["8f41","",7,"",17],["8f61","",7,"",6,"",4],["8f81","",5,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",5],["9041","",6,"",5,""],["9061","",5,"",15],["9081","",12,"",6,"",5,"",4,"",6,"",4,"",5,"",11,"",33,""],["9141","",6,"",5],["9161","",9,"",5],["9181","",20,"",4,"",5,"",14,"",33,"",7,"",5,"",6],["9241","",7,"",4,""],["9261","",7,"",7,"",4],["9281","",21,"",18,"",6,"",7,"",6,"",35,""],["9341","",4,""],["9361","",6,"",8],["9381","",37,"",4,"",4,"",6,"",5,"",7,"",22,""],["9441","",5,"",5,"",8],["9461","",5,"",6,"",12],["9481","",5,"",6,"",6,"",9,"",22,"",4,"",6,"",10,"",6,"",24],["9541","",11,"",5,""],["9561","",6,"",5,""],["9581","",6,"",35,"",4,"",4,"",4,"",6,"",5,"",13,"",14],["9641","",23,""],["9661","",6,"",5,"",8],["9681","",10,"",5,"",13,"",33,"",6,"",44],["9741","",16,"",8],["9761","",17,"",7],["9781","",11,"",5,"",6,"",89,""],["9841","",16,"",5,""],["9861","",6,"",15],["9881","",21,"",6,"",5,"",4,"",6,"",5,"",6,"",5,"",6,"",5,""],["9941","",6,"",5,""],["9961","",6,"",5,""],["9981","",8,"",5,"",4,"",11,"",5,"",6,"",6,"",6,"",7,"",6,"",5,""],["9a41","",16],["9a61","",6,"",6,""],["9a81","",4,"",6,"",5,"",5,"",6,"",5,"",5,"",33,"",5,"",6,""],["9b41","",6,"",8],["9b61","",17,"",7],["9b81","",25,"",4,"",5,"",50,"",22,""],["9c41","",4,"",5,"",5],["9c61","",8,"",6,"",9],["9c81","",8,"",6,"",6,"",9,"",26,"",6,"",5,"",18,"",6,"",12],["9d41","",13,"",8],["9d61","",25],["9d81","",8,"",5,"",9,"",6,"",10,"",6,"",5,"",6,"",5,""],["9e41","",7,"",9,""],["9e61","",4,"",6,""],["9e81","",6,"",6,"",6,"",5,"",10,"",5,"",6,"",5,"",6,""],["9f41","",5,"",4,"",5,""],["9f61","",6,"",5,""],["9f81","",4,"",5,"",6,"",5,"",6,"",4,"",6,"",7,"",4,"",4,""],["a041","",5,"",6,""],["a061","",5,"",13],["a081","",4,"",4,"",4,"",6,"",5,"",6,"",5,"",26,"",4,"",5,"",7,""],["a141","",18,""],["a161","",6,"",5,""],["a181","",14,"",5,"",4,"",9,""],["a241","",5,"",18],["a261","",6,"",18],["a281","",7,"",6,"",7,""],["a341","",6,"",10,""],["a361","",6,"",16],["a381","",16,"",4,"",58,"",32,""],["a441","",5,""],["a461","",5,"",12],["a481","",28,"",93],["a541","",4,"",6,"",5,""],["a561","",17,"",5,""],["a581","",16,"",14,"",9],["a5b0","",9],["a5c1","",16,"",6],["a5e1","",16,"",6],["a641","",19,""],["a661","",5,"",5,"",6],["a681","",6,"",18,"",7],["a741","",4,"",6,"",7],["a761","",22,""],["a781","",6,"",5,"",7,"",9,"",9,"",4,"",5,"",4,""],["a841","",10,"",14],["a861","",18,"",6],["a881","",19,"",11,""],["a8a6",""],["a8a8",""],["a8b1","",27,"",25,"",14,""],["a941","",14,"",10],["a961","",18],["a981","",14,"",6,"",27,"",25,"",14,""],["aa41","",6,"",4,""],["aa61","",4,"",5,"",6,""],["aa81","",29,"",82],["ab41","",6,"",5,""],["ab61","",6,"",5,"",5],["ab81","",8,"",6,"",12,"",85],["ac41","",5,"",6,""],["ac61","",11,"",4],["ac81","",28,"",5,"",25],["acd1","",5,"",25],["ad41","",6,"",5,"",7],["ad61","",6,"",10,""],["ad81","",5,"",18,""],["ae41","",5,"",16],["ae61","",5,"",6,"",4],["ae81","",6,"",5,""],["af41","",19],["af61","",13,"",5,""],["af81","",5,"",6,"",5,""],["b041","",5,"",5,"",12],["b061","",5,"",19],["b081","",13,"",6,"",5,"",7,"",4,""],["b141","",6,"",5,""],["b161","",6,"",5,"",11],["b181","",14,"",6,""],["b241","",6,"",5,""],["b261","",18,"",5,""],["b281","",5,"",18,"",6,""],["b341","",19,""],["b361","",5,"",5,"",5],["b381","",5,"",5,"",19,"",4,""],["b441","",5,"",6,"",5],["b461","",6,"",10,""],["b481","",6,"",18,"",4,"",4,""],["b541","",14,"",5],["b561","",5,"",5,"",4],["b581","",6,"",5,"",11,""],["b641","",7,"",17],["b661","",15,""],["b681","",5,"",6,"",5,""],["b741","",13,"",6,""],["b761","",20,""],["b781","",6,"",14,""],["b841","",7,"",17],["b861","",8,"",13],["b881","",5,"",24,"",4,""],["b941","",6,"",5,""],["b961","",14,"",6,""],["b981","",22,"",4,"",4,""],["ba41","",5,"",6,""],["ba61","",5,"",4,"",5],["ba81","",6,"",9,""],["bb41","",4,"",5,"",4,""],["bb61","",6,"",5,""],["bb81","",31,""],["bc41","",17,""],["bc61","",5,"",6,""],["bc81","",4,"",6,"",5,"",5,"",4,""],["bd41","",7,"",7,""],["bd61","",5,"",13],["bd81","",5,"",25,""],["be41","",7,"",14],["be61","",7,"",7,""],["be81","",4,"",4,"",5,"",8,"",6,""],["bf41","",10,"",14],["bf61","",18,""],["bf81","",5,"",7,"",6,"",5,""],["c041","",5,"",6,"",5],["c061","",25],["c081","",6,"",5,"",7,""],["c141","",5,"",6,""],["c161","",19,""],["c181","",31,""],["c241","",4,"",5,""],["c261","",4,"",5,"",6,""],["c281","",5,"",7,"",9,""],["c341","",4],["c361","",4,"",5,"",11],["c381","",5,"",7,"",5,""],["c441","",7,"",7,""],["c461","",5,"",4],["c481","",5,"",11,""],["c541","",6,"",5,""],["c561","",6,"",5,"",4],["c581","",6,"",5,""],["c641","",6,"",5],["c6a1",""],["c7a1",""],["c8a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1","",5,"",4,""],["d2a1","",4,"",5,"",10,"",7,"",5,""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f5a1",""],["f6a1",""],["f7a1",""],["f8a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fda1",""]]

/***/ }),
/* 108 */
/***/ (function(module, exports) {

module.exports = [["8740",""],["8767",""],["87a1",""],["8840","",4,""],["88a1",""],["8940",""],["8943",""],["8946",""],["894c",""],["89a1",""],["89ab",""],["89b0",""],["89b5",""],["89c1",""],["89c5",""],["8a40",""],["8a43",""],["8a64",""],["8a76",""],["8aa1",""],["8aac",""],["8ab2",""],["8abb",""],["8ac9",""],["8ace",""],["8adf",""],["8af6",""],["8b40",""],["8b55",""],["8ba1",""],["8bde",""],["8c40",""],["8ca1",""],["8ca7",""],["8cc9",""],["8cce",""],["8ce6",""],["8d40",""],["8d42",""],["8da1",""],["8e40",""],["8ea1",""],["8f40",""],["8fa1",""],["9040",""],["90a1",""],["9140",""],["91a1",""],["9240",""],["92a1",""],["9340",""],["93a1",""],["9440",""],["94a1",""],["9540",""],["95a1",""],["9640",""],["96a1",""],["9740",""],["97a1",""],["9840",""],["98a1",""],["9940",""],["99a1",""],["9a40",""],["9aa1",""],["9b40",""],["9b62",""],["9ba1",""],["9c40",""],["9ca1",""],["9d40",""],["9da1",""],["9e40",""],["9ea1",""],["9ead",""],["9ec5",""],["9ef5",""],["9f40",""],["9f4f",""],["9fa1",""],["9fae",""],["9fb2",""],["9fc1",""],["9fc9",""],["9fdb",""],["9fe7",""],["9feb",""],["9ff0",""],["a040",""],["a055",""],["a058",""],["a05b",""],["a063",""],["a073",""],["a0a1",""],["a0a6",""],["a0ae",""],["a0b0",""],["a0d4",""],["a0e2",""],["a3c0","",31,""],["c6a1","",9,"",9,"",9,"",23],["c740","",58,""],["c7a1","",81,"",5,"",4],["c840","",26,"",25,""],["c8a1",""],["c8cd",""],["c8f5",""],["f9fe",""],["fa40",""],["faa1",""],["fb40",""],["fba1",""],["fc40",""],["fca1",""],["fd40",""],["fda1",""],["fe40",""],["fea1",""]]

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Buffer = __webpack_require__(10).Buffer,
    Transform = __webpack_require__(11).Transform;


// == Exports ==================================================================
module.exports = function(iconv) {
    
    // Additional Public API.
    iconv.encodeStream = function encodeStream(encoding, options) {
        return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
    }

    iconv.decodeStream = function decodeStream(encoding, options) {
        return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
    }

    iconv.supportsStreams = true;


    // Not published yet.
    iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
    iconv._collect = IconvLiteDecoderStream.prototype.collect;
};


// == Encoder stream =======================================================
function IconvLiteEncoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
    Transform.call(this, options);
}

IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteEncoderStream }
});

IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
    if (typeof chunk != 'string')
        return done(new Error("Iconv encoding stream needs strings as its input."));
    try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res);
        done();
    }
    catch (e) {
        done(e);
    }
}

IconvLiteEncoderStream.prototype._flush = function(done) {
    try {
        var res = this.conv.end();
        if (res && res.length) this.push(res);
        done();
    }
    catch (e) {
        done(e);
    }
}

IconvLiteEncoderStream.prototype.collect = function(cb) {
    var chunks = [];
    this.on('error', cb);
    this.on('data', function(chunk) { chunks.push(chunk); });
    this.on('end', function() {
        cb(null, Buffer.concat(chunks));
    });
    return this;
}


// == Decoder stream =======================================================
function IconvLiteDecoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.encoding = this.encoding = 'utf8'; // We output strings.
    Transform.call(this, options);
}

IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteDecoderStream }
});

IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
    if (!Buffer.isBuffer(chunk))
        return done(new Error("Iconv decoding stream needs buffers as its input."));
    try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res, this.encoding);
        done();
    }
    catch (e) {
        done(e);
    }
}

IconvLiteDecoderStream.prototype._flush = function(done) {
    try {
        var res = this.conv.end();
        if (res && res.length) this.push(res, this.encoding);                
        done();
    }
    catch (e) {
        done(e);
    }
}

IconvLiteDecoderStream.prototype.collect = function(cb) {
    var res = '';
    this.on('error', cb);
    this.on('data', function(chunk) { res += chunk; });
    this.on('end', function() {
        cb(null, res);
    });
    return this;
}



/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(10).Buffer;
// Note: not polyfilled with safer-buffer on a purpose, as overrides Buffer

// == Extend Node primitives to use iconv-lite =================================

module.exports = function (iconv) {
    var original = undefined; // Place to keep original methods.

    // Node authors rewrote Buffer internals to make it compatible with
    // Uint8Array and we cannot patch key functions since then.
    // Note: this does use older Buffer API on a purpose
    iconv.supportsNodeEncodingsExtension = !(Buffer.from || new Buffer(0) instanceof Uint8Array);

    iconv.extendNodeEncodings = function extendNodeEncodings() {
        if (original) return;
        original = {};

        if (!iconv.supportsNodeEncodingsExtension) {
            console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
            console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
            return;
        }

        var nodeNativeEncodings = {
            'hex': true, 'utf8': true, 'utf-8': true, 'ascii': true, 'binary': true, 
            'base64': true, 'ucs2': true, 'ucs-2': true, 'utf16le': true, 'utf-16le': true,
        };

        Buffer.isNativeEncoding = function(enc) {
            return enc && nodeNativeEncodings[enc.toLowerCase()];
        }

        // -- SlowBuffer -----------------------------------------------------------
        var SlowBuffer = __webpack_require__(10).SlowBuffer;

        original.SlowBufferToString = SlowBuffer.prototype.toString;
        SlowBuffer.prototype.toString = function(encoding, start, end) {
            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.SlowBufferToString.call(this, encoding, start, end);

            // Otherwise, use our decoding method.
            if (typeof start == 'undefined') start = 0;
            if (typeof end == 'undefined') end = this.length;
            return iconv.decode(this.slice(start, end), encoding);
        }

        original.SlowBufferWrite = SlowBuffer.prototype.write;
        SlowBuffer.prototype.write = function(string, offset, length, encoding) {
            // Support both (string, offset, length, encoding)
            // and the legacy (string, encoding, offset, length)
            if (isFinite(offset)) {
                if (!isFinite(length)) {
                    encoding = length;
                    length = undefined;
                }
            } else {  // legacy
                var swap = encoding;
                encoding = offset;
                offset = length;
                length = swap;
            }

            offset = +offset || 0;
            var remaining = this.length - offset;
            if (!length) {
                length = remaining;
            } else {
                length = +length;
                if (length > remaining) {
                    length = remaining;
                }
            }
            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.SlowBufferWrite.call(this, string, offset, length, encoding);

            if (string.length > 0 && (length < 0 || offset < 0))
                throw new RangeError('attempt to write beyond buffer bounds');

            // Otherwise, use our encoding method.
            var buf = iconv.encode(string, encoding);
            if (buf.length < length) length = buf.length;
            buf.copy(this, offset, 0, length);
            return length;
        }

        // -- Buffer ---------------------------------------------------------------

        original.BufferIsEncoding = Buffer.isEncoding;
        Buffer.isEncoding = function(encoding) {
            return Buffer.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
        }

        original.BufferByteLength = Buffer.byteLength;
        Buffer.byteLength = SlowBuffer.byteLength = function(str, encoding) {
            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.BufferByteLength.call(this, str, encoding);

            // Slow, I know, but we don't have a better way yet.
            return iconv.encode(str, encoding).length;
        }

        original.BufferToString = Buffer.prototype.toString;
        Buffer.prototype.toString = function(encoding, start, end) {
            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.BufferToString.call(this, encoding, start, end);

            // Otherwise, use our decoding method.
            if (typeof start == 'undefined') start = 0;
            if (typeof end == 'undefined') end = this.length;
            return iconv.decode(this.slice(start, end), encoding);
        }

        original.BufferWrite = Buffer.prototype.write;
        Buffer.prototype.write = function(string, offset, length, encoding) {
            var _offset = offset, _length = length, _encoding = encoding;
            // Support both (string, offset, length, encoding)
            // and the legacy (string, encoding, offset, length)
            if (isFinite(offset)) {
                if (!isFinite(length)) {
                    encoding = length;
                    length = undefined;
                }
            } else {  // legacy
                var swap = encoding;
                encoding = offset;
                offset = length;
                length = swap;
            }

            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.BufferWrite.call(this, string, _offset, _length, _encoding);

            offset = +offset || 0;
            var remaining = this.length - offset;
            if (!length) {
                length = remaining;
            } else {
                length = +length;
                if (length > remaining) {
                    length = remaining;
                }
            }

            if (string.length > 0 && (length < 0 || offset < 0))
                throw new RangeError('attempt to write beyond buffer bounds');

            // Otherwise, use our encoding method.
            var buf = iconv.encode(string, encoding);
            if (buf.length < length) length = buf.length;
            buf.copy(this, offset, 0, length);
            return length;

            // TODO: Set _charsWritten.
        }


        // -- Readable -------------------------------------------------------------
        if (iconv.supportsStreams) {
            var Readable = __webpack_require__(11).Readable;

            original.ReadableSetEncoding = Readable.prototype.setEncoding;
            Readable.prototype.setEncoding = function setEncoding(enc, options) {
                // Use our own decoder, it has the same interface.
                // We cannot use original function as it doesn't handle BOM-s.
                this._readableState.decoder = iconv.getDecoder(enc, options);
                this._readableState.encoding = enc;
            }

            Readable.prototype.collect = iconv._collect;
        }
    }

    // Remove iconv-lite Node primitive extensions.
    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
        if (!iconv.supportsNodeEncodingsExtension)
            return;
        if (!original)
            throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.")

        delete Buffer.isNativeEncoding;

        var SlowBuffer = __webpack_require__(10).SlowBuffer;

        SlowBuffer.prototype.toString = original.SlowBufferToString;
        SlowBuffer.prototype.write = original.SlowBufferWrite;

        Buffer.isEncoding = original.BufferIsEncoding;
        Buffer.byteLength = original.BufferByteLength;
        Buffer.prototype.toString = original.BufferToString;
        Buffer.prototype.write = original.BufferWrite;

        if (iconv.supportsStreams) {
            var Readable = __webpack_require__(11).Readable;

            Readable.prototype.setEncoding = original.ReadableSetEncoding;
            delete Readable.prototype.collect;
        }

        original = undefined;
    }
}


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = first

/**
 * Get the first event in a set of event emitters and event pairs.
 *
 * @param {array} stuff
 * @param {function} done
 * @public
 */

function first(stuff, done) {
  if (!Array.isArray(stuff))
    throw new TypeError('arg must be an array of [ee, events...] arrays')

  var cleanups = []

  for (var i = 0; i < stuff.length; i++) {
    var arr = stuff[i]

    if (!Array.isArray(arr) || arr.length < 2)
      throw new TypeError('each array member must be [ee, events...]')

    var ee = arr[0]

    for (var j = 1; j < arr.length; j++) {
      var event = arr[j]
      var fn = listener(event, callback)

      // listen to the event
      ee.on(event, fn)
      // push this listener to the list of cleanups
      cleanups.push({
        ee: ee,
        event: event,
        fn: fn,
      })
    }
  }

  function callback() {
    cleanup()
    done.apply(null, arguments)
  }

  function cleanup() {
    var x
    for (var i = 0; i < cleanups.length; i++) {
      x = cleanups[i]
      x.ee.removeListener(x.event, x.fn)
    }
  }

  function thunk(fn) {
    done = fn
  }

  thunk.cancel = cleanup

  return thunk
}

/**
 * Create the event listener.
 * @private
 */

function listener(event, done) {
  return function onevent(arg1) {
    var args = new Array(arguments.length)
    var ee = this
    var err = event === 'error'
      ? arg1
      : null

    // copy args to prevent arguments escaping scope
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }

    done(err, ee, event, args)
  }
}


/***/ }),
/* 112 */
/***/ (function(module, exports) {

/*!
 * media-typer
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * RegExp to match *( ";" parameter ) in RFC 2616 sec 3.7
 *
 * parameter     = token "=" ( token | quoted-string )
 * token         = 1*<any CHAR except CTLs or separators>
 * separators    = "(" | ")" | "<" | ">" | "@"
 *               | "," | ";" | ":" | "\" | <">
 *               | "/" | "[" | "]" | "?" | "="
 *               | "{" | "}" | SP | HT
 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
 * qdtext        = <any TEXT except <">>
 * quoted-pair   = "\" CHAR
 * CHAR          = <any US-ASCII character (octets 0 - 127)>
 * TEXT          = <any OCTET except CTLs, but including LWS>
 * LWS           = [CRLF] 1*( SP | HT )
 * CRLF          = CR LF
 * CR            = <US-ASCII CR, carriage return (13)>
 * LF            = <US-ASCII LF, linefeed (10)>
 * SP            = <US-ASCII SP, space (32)>
 * SHT           = <US-ASCII HT, horizontal-tab (9)>
 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
 * OCTET         = <any 8-bit sequence of data>
 */
var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/
var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/

/**
 * RegExp to match quoted-pair in RFC 2616
 *
 * quoted-pair = "\" CHAR
 * CHAR        = <any US-ASCII character (octets 0 - 127)>
 */
var qescRegExp = /\\([\u0000-\u007f])/g;

/**
 * RegExp to match chars that must be quoted-pair in RFC 2616
 */
var quoteRegExp = /([\\"])/g;

/**
 * RegExp to match type in RFC 6838
 *
 * type-name = restricted-name
 * subtype-name = restricted-name
 * restricted-name = restricted-name-first *126restricted-name-chars
 * restricted-name-first  = ALPHA / DIGIT
 * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
 *                          "$" / "&" / "-" / "^" / "_"
 * restricted-name-chars =/ "." ; Characters before first dot always
 *                              ; specify a facet name
 * restricted-name-chars =/ "+" ; Characters after last plus always
 *                              ; specify a structured syntax suffix
 * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
 * DIGIT =  %x30-39             ; 0-9
 */
var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/
var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/
var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;

/**
 * Module exports.
 */

exports.format = format
exports.parse = parse

/**
 * Format object to media type.
 *
 * @param {object} obj
 * @return {string}
 * @api public
 */

function format(obj) {
  if (!obj || typeof obj !== 'object') {
    throw new TypeError('argument obj is required')
  }

  var parameters = obj.parameters
  var subtype = obj.subtype
  var suffix = obj.suffix
  var type = obj.type

  if (!type || !typeNameRegExp.test(type)) {
    throw new TypeError('invalid type')
  }

  if (!subtype || !subtypeNameRegExp.test(subtype)) {
    throw new TypeError('invalid subtype')
  }

  // format as type/subtype
  var string = type + '/' + subtype

  // append +suffix
  if (suffix) {
    if (!typeNameRegExp.test(suffix)) {
      throw new TypeError('invalid suffix')
    }

    string += '+' + suffix
  }

  // append parameters
  if (parameters && typeof parameters === 'object') {
    var param
    var params = Object.keys(parameters).sort()

    for (var i = 0; i < params.length; i++) {
      param = params[i]

      if (!tokenRegExp.test(param)) {
        throw new TypeError('invalid parameter name')
      }

      string += '; ' + param + '=' + qstring(parameters[param])
    }
  }

  return string
}

/**
 * Parse media type to object.
 *
 * @param {string|object} string
 * @return {Object}
 * @api public
 */

function parse(string) {
  if (!string) {
    throw new TypeError('argument string is required')
  }

  // support req/res-like objects as argument
  if (typeof string === 'object') {
    string = getcontenttype(string)
  }

  if (typeof string !== 'string') {
    throw new TypeError('argument string is required to be a string')
  }

  var index = string.indexOf(';')
  var type = index !== -1
    ? string.substr(0, index)
    : string

  var key
  var match
  var obj = splitType(type)
  var params = {}
  var value

  paramRegExp.lastIndex = index

  while (match = paramRegExp.exec(string)) {
    if (match.index !== index) {
      throw new TypeError('invalid parameter format')
    }

    index += match[0].length
    key = match[1].toLowerCase()
    value = match[2]

    if (value[0] === '"') {
      // remove quotes and escapes
      value = value
        .substr(1, value.length - 2)
        .replace(qescRegExp, '$1')
    }

    params[key] = value
  }

  if (index !== -1 && index !== string.length) {
    throw new TypeError('invalid parameter format')
  }

  obj.parameters = params

  return obj
}

/**
 * Get content-type from req/res objects.
 *
 * @param {object}
 * @return {Object}
 * @api private
 */

function getcontenttype(obj) {
  if (typeof obj.getHeader === 'function') {
    // res-like
    return obj.getHeader('content-type')
  }

  if (typeof obj.headers === 'object') {
    // req-like
    return obj.headers && obj.headers['content-type']
  }
}

/**
 * Quote a string if necessary.
 *
 * @param {string} val
 * @return {string}
 * @api private
 */

function qstring(val) {
  var str = String(val)

  // no need to quote tokens
  if (tokenRegExp.test(str)) {
    return str
  }

  if (str.length > 0 && !textRegExp.test(str)) {
    throw new TypeError('invalid parameter value')
  }

  return '"' + str.replace(quoteRegExp, '\\$1') + '"'
}

/**
 * Simply "type/subtype+siffx" into parts.
 *
 * @param {string} string
 * @return {Object}
 * @api private
 */

function splitType(string) {
  var match = typeRegExp.exec(string.toLowerCase())

  if (!match) {
    throw new TypeError('invalid media type')
  }

  var type = match[1]
  var subtype = match[2]
  var suffix

  // suffix after last +
  var index = subtype.lastIndexOf('+')
  if (index !== -1) {
    suffix = subtype.substr(index + 1)
    subtype = subtype.substr(0, index)
  }

  var obj = {
    type: type,
    subtype: subtype,
    suffix: suffix
  }

  return obj
}


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = __webpack_require__(114)


/***/ }),
/* 114 */
/***/ (function(module, exports) {

module.exports = {"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true},"application/atsc-held+xml":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/cbor":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["ecma","es"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true},"application/fhir+json":{"source":"iana","compressible":true},"application/fhir+xml":{"source":"iana","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true},"application/mmt-usd+xml":{"source":"iana","compressible":true},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","compressible":true},"application/msc-mixer+xml":{"source":"iana","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana"},"application/news-groupinfo":{"source":"iana"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana"},"application/nss":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p2p-overlay+xml":{"source":"iana","compressible":true},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana"},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","compressible":true},"application/pidf-diff+xml":{"source":"iana","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true},"application/route-s-tsid+xml":{"source":"iana","compressible":true},"application/route-usd+xml":{"source":"iana","compressible":true},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana"},"application/ttml+xml":{"source":"iana","compressible":true},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true},"application/urc-targetdesc+xml":{"source":"iana","compressible":true},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["keynote"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana"},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana"},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","compressible":true},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"apache","extensions":["der","crt","pem"]},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true},"application/xcap-caps+xml":{"source":"iana","compressible":true},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana"},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana"},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana"},"image/avcs":{"source":"iana"},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana","compressible":false},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shex":{"extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana"},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vp8":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 */

var bytes = __webpack_require__(13)
var debug = __webpack_require__(3)('body-parser:raw')
var read = __webpack_require__(24)
var typeis = __webpack_require__(15)

/**
 * Module exports.
 */

module.exports = raw

/**
 * Create a middleware to parse raw bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @api public
 */

function raw (options) {
  var opts = options || {}

  var inflate = opts.inflate !== false
  var limit = typeof opts.limit !== 'number'
    ? bytes.parse(opts.limit || '100kb')
    : opts.limit
  var type = opts.type || 'application/octet-stream'
  var verify = opts.verify || false

  if (verify !== false && typeof verify !== 'function') {
    throw new TypeError('option verify must be function')
  }

  // create the appropriate type checking function
  var shouldParse = typeof type !== 'function'
    ? typeChecker(type)
    : type

  function parse (buf) {
    return buf
  }

  return function rawParser (req, res, next) {
    if (req._body) {
      debug('body already parsed')
      next()
      return
    }

    req.body = req.body || {}

    // skip requests without bodies
    if (!typeis.hasBody(req)) {
      debug('skip empty body')
      next()
      return
    }

    debug('content-type %j', req.headers['content-type'])

    // determine if request should be parsed
    if (!shouldParse(req)) {
      debug('skip parsing')
      next()
      return
    }

    // read
    read(req, res, next, parse, debug, {
      encoding: null,
      inflate: inflate,
      limit: limit,
      verify: verify
    })
  }
}

/**
 * Get the simple type checker.
 *
 * @param {string} type
 * @return {function}
 */

function typeChecker (type) {
  return function checkType (req) {
    return Boolean(typeis(req, type))
  }
}


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 */

var bytes = __webpack_require__(13)
var contentType = __webpack_require__(19)
var debug = __webpack_require__(3)('body-parser:text')
var read = __webpack_require__(24)
var typeis = __webpack_require__(15)

/**
 * Module exports.
 */

module.exports = text

/**
 * Create a middleware to parse text bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @api public
 */

function text (options) {
  var opts = options || {}

  var defaultCharset = opts.defaultCharset || 'utf-8'
  var inflate = opts.inflate !== false
  var limit = typeof opts.limit !== 'number'
    ? bytes.parse(opts.limit || '100kb')
    : opts.limit
  var type = opts.type || 'text/plain'
  var verify = opts.verify || false

  if (verify !== false && typeof verify !== 'function') {
    throw new TypeError('option verify must be function')
  }

  // create the appropriate type checking function
  var shouldParse = typeof type !== 'function'
    ? typeChecker(type)
    : type

  function parse (buf) {
    return buf
  }

  return function textParser (req, res, next) {
    if (req._body) {
      debug('body already parsed')
      next()
      return
    }

    req.body = req.body || {}

    // skip requests without bodies
    if (!typeis.hasBody(req)) {
      debug('skip empty body')
      next()
      return
    }

    debug('content-type %j', req.headers['content-type'])

    // determine if request should be parsed
    if (!shouldParse(req)) {
      debug('skip parsing')
      next()
      return
    }

    // get charset
    var charset = getCharset(req) || defaultCharset

    // read
    read(req, res, next, parse, debug, {
      encoding: charset,
      inflate: inflate,
      limit: limit,
      verify: verify
    })
  }
}

/**
 * Get the charset of a request.
 *
 * @param {object} req
 * @api private
 */

function getCharset (req) {
  try {
    return (contentType.parse(req).parameters.charset || '').toLowerCase()
  } catch (e) {
    return undefined
  }
}

/**
 * Get the simple type checker.
 *
 * @param {string} type
 * @return {function}
 */

function typeChecker (type) {
  return function checkType (req) {
    return Boolean(typeis(req, type))
  }
}


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var bytes = __webpack_require__(13)
var contentType = __webpack_require__(19)
var createError = __webpack_require__(14)
var debug = __webpack_require__(3)('body-parser:urlencoded')
var deprecate = __webpack_require__(5)('body-parser')
var read = __webpack_require__(24)
var typeis = __webpack_require__(15)

/**
 * Module exports.
 */

module.exports = urlencoded

/**
 * Cache of parser modules.
 */

var parsers = Object.create(null)

/**
 * Create a middleware to parse urlencoded bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @public
 */

function urlencoded (options) {
  var opts = options || {}

  // notice because option default will flip in next major
  if (opts.extended === undefined) {
    deprecate('undefined extended: provide extended option')
  }

  var extended = opts.extended !== false
  var inflate = opts.inflate !== false
  var limit = typeof opts.limit !== 'number'
    ? bytes.parse(opts.limit || '100kb')
    : opts.limit
  var type = opts.type || 'application/x-www-form-urlencoded'
  var verify = opts.verify || false

  if (verify !== false && typeof verify !== 'function') {
    throw new TypeError('option verify must be function')
  }

  // create the appropriate query parser
  var queryparse = extended
    ? extendedparser(opts)
    : simpleparser(opts)

  // create the appropriate type checking function
  var shouldParse = typeof type !== 'function'
    ? typeChecker(type)
    : type

  function parse (body) {
    return body.length
      ? queryparse(body)
      : {}
  }

  return function urlencodedParser (req, res, next) {
    if (req._body) {
      debug('body already parsed')
      next()
      return
    }

    req.body = req.body || {}

    // skip requests without bodies
    if (!typeis.hasBody(req)) {
      debug('skip empty body')
      next()
      return
    }

    debug('content-type %j', req.headers['content-type'])

    // determine if request should be parsed
    if (!shouldParse(req)) {
      debug('skip parsing')
      next()
      return
    }

    // assert charset
    var charset = getCharset(req) || 'utf-8'
    if (charset !== 'utf-8') {
      debug('invalid charset')
      next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
        charset: charset,
        type: 'charset.unsupported'
      }))
      return
    }

    // read
    read(req, res, next, parse, debug, {
      debug: debug,
      encoding: charset,
      inflate: inflate,
      limit: limit,
      verify: verify
    })
  }
}

/**
 * Get the extended query parser.
 *
 * @param {object} options
 */

function extendedparser (options) {
  var parameterLimit = options.parameterLimit !== undefined
    ? options.parameterLimit
    : 1000
  var parse = parser('qs')

  if (isNaN(parameterLimit) || parameterLimit < 1) {
    throw new TypeError('option parameterLimit must be a positive number')
  }

  if (isFinite(parameterLimit)) {
    parameterLimit = parameterLimit | 0
  }

  return function queryparse (body) {
    var paramCount = parameterCount(body, parameterLimit)

    if (paramCount === undefined) {
      debug('too many parameters')
      throw createError(413, 'too many parameters', {
        type: 'parameters.too.many'
      })
    }

    var arrayLimit = Math.max(100, paramCount)

    debug('parse extended urlencoding')
    return parse(body, {
      allowPrototypes: true,
      arrayLimit: arrayLimit,
      depth: Infinity,
      parameterLimit: parameterLimit
    })
  }
}

/**
 * Get the charset of a request.
 *
 * @param {object} req
 * @api private
 */

function getCharset (req) {
  try {
    return (contentType.parse(req).parameters.charset || '').toLowerCase()
  } catch (e) {
    return undefined
  }
}

/**
 * Count the number of parameters, stopping once limit reached
 *
 * @param {string} body
 * @param {number} limit
 * @api private
 */

function parameterCount (body, limit) {
  var count = 0
  var index = 0

  while ((index = body.indexOf('&', index)) !== -1) {
    count++
    index++

    if (count === limit) {
      return undefined
    }
  }

  return count
}

/**
 * Get parser for module name dynamically.
 *
 * @param {string} name
 * @return {function}
 * @api private
 */

function parser (name) {
  var mod = parsers[name]

  if (mod !== undefined) {
    return mod.parse
  }

  // this uses a switch for static require analysis
  switch (name) {
    case 'qs':
      mod = __webpack_require__(38)
      break
    case 'querystring':
      mod = __webpack_require__(26)
      break
  }

  // store to prevent invoking require()
  parsers[name] = mod

  return mod.parse
}

/**
 * Get the simple query parser.
 *
 * @param {object} options
 */

function simpleparser (options) {
  var parameterLimit = options.parameterLimit !== undefined
    ? options.parameterLimit
    : 1000
  var parse = parser('querystring')

  if (isNaN(parameterLimit) || parameterLimit < 1) {
    throw new TypeError('option parameterLimit must be a positive number')
  }

  if (isFinite(parameterLimit)) {
    parameterLimit = parameterLimit | 0
  }

  return function queryparse (body) {
    var paramCount = parameterCount(body, parameterLimit)

    if (paramCount === undefined) {
      debug('too many parameters')
      throw createError(413, 'too many parameters', {
        type: 'parameters.too.many'
      })
    }

    debug('parse urlencoding')
    return parse(body, undefined, undefined, {maxKeys: parameterLimit})
  }
}

/**
 * Get the simple type checker.
 *
 * @param {string} type
 * @return {function}
 */

function typeChecker (type) {
  return function checkType (req) {
    return Boolean(typeis(req, type))
  }
}


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(52);
var formats = __webpack_require__(53);

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching
        return prefix + '[]';
    },
    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching
        return prefix;
    }
};

var toISO = Date.prototype.toISOString;

var defaults = {
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var stringify = function stringify( // eslint-disable-line func-name-matching
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    formatter,
    encodeValuesOnly
) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;
        }

        obj = '';
    }

    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (Array.isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        if (Array.isArray(obj)) {
            values = values.concat(stringify(
                obj[key],
                generateArrayPrefix(prefix, key),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        } else {
            values = values.concat(stringify(
                obj[key],
                prefix + (allowDots ? '.' + key : '[' + key + ']'),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        }
    }

    return values;
};

module.exports = function (object, opts) {
    var obj = object;
    var options = opts ? utils.assign({}, opts) : {};

    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;
    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;
    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;
    var encoder = typeof options.encoder === 'function' ? options.encoder : defaults.encoder;
    var sort = typeof options.sort === 'function' ? options.sort : null;
    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
    var serializeDate = typeof options.serializeDate === 'function' ? options.serializeDate : defaults.serializeDate;
    var encodeValuesOnly = typeof options.encodeValuesOnly === 'boolean' ? options.encodeValuesOnly : defaults.encodeValuesOnly;
    if (typeof options.format === 'undefined') {
        options.format = formats['default'];
    } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {
        throw new TypeError('Unknown format option provided.');
    }
    var formatter = formats.formatters[options.format];
    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (Array.isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (options.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = options.arrayFormat;
    } else if ('indices' in options) {
        arrayFormat = options.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (sort) {
        objKeys.sort(sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        keys = keys.concat(stringify(
            obj[key],
            key,
            generateArrayPrefix,
            strictNullHandling,
            skipNulls,
            encode ? encoder : null,
            filter,
            sort,
            allowDots,
            serializeDate,
            formatter,
            encodeValuesOnly
        ));
    }

    var joined = keys.join(delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(52);

var has = Object.prototype.hasOwnProperty;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    parameterLimit: 1000,
    plainObjects: false,
    strictNullHandling: false
};

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);

    for (var i = 0; i < parts.length; ++i) {
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder);
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder);
            val = options.decoder(part.slice(pos + 1), defaults.decoder);
        }
        if (has.call(obj, key)) {
            obj[key] = [].concat(obj[key]).concat(val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options) {
    var leaf = val;

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]') {
            obj = [];
            obj = obj.concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys
        // that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options);
};

module.exports = function (str, opts) {
    var options = opts ? utils.assign({}, opts) : {};

    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
    options.delimiter = typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;
    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;
    options.parseArrays = options.parseArrays !== false;
    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;
    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;
    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;
    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;
    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;
    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * merge-descriptors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = merge

/**
 * Module variables.
 * @private
 */

var hasOwnProperty = Object.prototype.hasOwnProperty

/**
 * Merge the property descriptors of `src` into `dest`
 *
 * @param {object} dest Object to add descriptors to
 * @param {object} src Object to clone descriptors from
 * @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties
 * @returns {object} Reference to dest
 * @public
 */

function merge(dest, src, redefine) {
  if (!dest) {
    throw new TypeError('argument dest is required')
  }

  if (!src) {
    throw new TypeError('argument src is required')
  }

  if (redefine === undefined) {
    // Default to true
    redefine = true
  }

  Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {
    if (!redefine && hasOwnProperty.call(dest, name)) {
      // Skip desriptor
      return
    }

    // Copy descriptor
    var descriptor = Object.getOwnPropertyDescriptor(src, name)
    Object.defineProperty(dest, name, descriptor)
  })

  return dest
}


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var finalhandler = __webpack_require__(122);
var Router = __webpack_require__(54);
var methods = __webpack_require__(39);
var middleware = __webpack_require__(124);
var query = __webpack_require__(57);
var debug = __webpack_require__(3)('express:application');
var View = __webpack_require__(125);
var http = __webpack_require__(4);
var compileETag = __webpack_require__(8).compileETag;
var compileQueryParser = __webpack_require__(8).compileQueryParser;
var compileTrust = __webpack_require__(8).compileTrust;
var deprecate = __webpack_require__(5)('express');
var flatten = __webpack_require__(29);
var merge = __webpack_require__(30);
var resolve = __webpack_require__(2).resolve;
var setPrototypeOf = __webpack_require__(20)
var slice = Array.prototype.slice;

/**
 * Application prototype.
 */

var app = exports = module.exports = {};

/**
 * Variable for trust proxy inheritance back-compat
 * @private
 */

var trustProxyDefaultSymbol = '@@symbol:trust_proxy_default';

/**
 * Initialize the server.
 *
 *   - setup default configuration
 *   - setup default middleware
 *   - setup route reflection methods
 *
 * @private
 */

app.init = function init() {
  this.cache = {};
  this.engines = {};
  this.settings = {};

  this.defaultConfiguration();
};

/**
 * Initialize application configuration.
 * @private
 */

app.defaultConfiguration = function defaultConfiguration() {
  var env = process.env.NODE_ENV || 'development';

  // default settings
  this.enable('x-powered-by');
  this.set('etag', 'weak');
  this.set('env', env);
  this.set('query parser', 'extended');
  this.set('subdomain offset', 2);
  this.set('trust proxy', false);

  // trust proxy inherit back-compat
  Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
    configurable: true,
    value: true
  });

  debug('booting in %s mode', env);

  this.on('mount', function onmount(parent) {
    // inherit trust proxy
    if (this.settings[trustProxyDefaultSymbol] === true
      && typeof parent.settings['trust proxy fn'] === 'function') {
      delete this.settings['trust proxy'];
      delete this.settings['trust proxy fn'];
    }

    // inherit protos
    setPrototypeOf(this.request, parent.request)
    setPrototypeOf(this.response, parent.response)
    setPrototypeOf(this.engines, parent.engines)
    setPrototypeOf(this.settings, parent.settings)
  });

  // setup locals
  this.locals = Object.create(null);

  // top-most app is mounted at /
  this.mountpath = '/';

  // default locals
  this.locals.settings = this.settings;

  // default configuration
  this.set('view', View);
  this.set('views', resolve('views'));
  this.set('jsonp callback name', 'callback');

  if (env === 'production') {
    this.enable('view cache');
  }

  Object.defineProperty(this, 'router', {
    get: function() {
      throw new Error('\'app.router\' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.');
    }
  });
};

/**
 * lazily adds the base router if it has not yet been added.
 *
 * We cannot add the base router in the defaultConfiguration because
 * it reads app settings which might be set after that has run.
 *
 * @private
 */
app.lazyrouter = function lazyrouter() {
  if (!this._router) {
    this._router = new Router({
      caseSensitive: this.enabled('case sensitive routing'),
      strict: this.enabled('strict routing')
    });

    this._router.use(query(this.get('query parser fn')));
    this._router.use(middleware.init(this));
  }
};

/**
 * Dispatch a req, res pair into the application. Starts pipeline processing.
 *
 * If no callback is provided, then default error handlers will respond
 * in the event of an error bubbling through the stack.
 *
 * @private
 */

app.handle = function handle(req, res, callback) {
  var router = this._router;

  // final handler
  var done = callback || finalhandler(req, res, {
    env: this.get('env'),
    onerror: logerror.bind(this)
  });

  // no routes
  if (!router) {
    debug('no routes defined on app');
    done();
    return;
  }

  router.handle(req, res, done);
};

/**
 * Proxy `Router#use()` to add middleware to the app router.
 * See Router#use() documentation for details.
 *
 * If the _fn_ parameter is an express app, then it will be
 * mounted at the _route_ specified.
 *
 * @public
 */

app.use = function use(fn) {
  var offset = 0;
  var path = '/';

  // default path to '/'
  // disambiguate app.use([fn])
  if (typeof fn !== 'function') {
    var arg = fn;

    while (Array.isArray(arg) && arg.length !== 0) {
      arg = arg[0];
    }

    // first arg is the path
    if (typeof arg !== 'function') {
      offset = 1;
      path = fn;
    }
  }

  var fns = flatten(slice.call(arguments, offset));

  if (fns.length === 0) {
    throw new TypeError('app.use() requires a middleware function')
  }

  // setup router
  this.lazyrouter();
  var router = this._router;

  fns.forEach(function (fn) {
    // non-express app
    if (!fn || !fn.handle || !fn.set) {
      return router.use(path, fn);
    }

    debug('.use app under %s', path);
    fn.mountpath = path;
    fn.parent = this;

    // restore .app property on req and res
    router.use(path, function mounted_app(req, res, next) {
      var orig = req.app;
      fn.handle(req, res, function (err) {
        setPrototypeOf(req, orig.request)
        setPrototypeOf(res, orig.response)
        next(err);
      });
    });

    // mounted an app
    fn.emit('mount', this);
  }, this);

  return this;
};

/**
 * Proxy to the app `Router#route()`
 * Returns a new `Route` instance for the _path_.
 *
 * Routes are isolated middleware stacks for specific paths.
 * See the Route api docs for details.
 *
 * @public
 */

app.route = function route(path) {
  this.lazyrouter();
  return this._router.route(path);
};

/**
 * Register the given template engine callback `fn`
 * as `ext`.
 *
 * By default will `require()` the engine based on the
 * file extension. For example if you try to render
 * a "foo.ejs" file Express will invoke the following internally:
 *
 *     app.engine('ejs', require('ejs').__express);
 *
 * For engines that do not provide `.__express` out of the box,
 * or if you wish to "map" a different extension to the template engine
 * you may use this method. For example mapping the EJS template engine to
 * ".html" files:
 *
 *     app.engine('html', require('ejs').renderFile);
 *
 * In this case EJS provides a `.renderFile()` method with
 * the same signature that Express expects: `(path, options, callback)`,
 * though note that it aliases this method as `ejs.__express` internally
 * so if you're using ".ejs" extensions you dont need to do anything.
 *
 * Some template engines do not follow this convention, the
 * [Consolidate.js](https://github.com/tj/consolidate.js)
 * library was created to map all of node's popular template
 * engines to follow this convention, thus allowing them to
 * work seamlessly within Express.
 *
 * @param {String} ext
 * @param {Function} fn
 * @return {app} for chaining
 * @public
 */

app.engine = function engine(ext, fn) {
  if (typeof fn !== 'function') {
    throw new Error('callback function required');
  }

  // get file extension
  var extension = ext[0] !== '.'
    ? '.' + ext
    : ext;

  // store engine
  this.engines[extension] = fn;

  return this;
};

/**
 * Proxy to `Router#param()` with one added api feature. The _name_ parameter
 * can be an array of names.
 *
 * See the Router#param() docs for more details.
 *
 * @param {String|Array} name
 * @param {Function} fn
 * @return {app} for chaining
 * @public
 */

app.param = function param(name, fn) {
  this.lazyrouter();

  if (Array.isArray(name)) {
    for (var i = 0; i < name.length; i++) {
      this.param(name[i], fn);
    }

    return this;
  }

  this._router.param(name, fn);

  return this;
};

/**
 * Assign `setting` to `val`, or return `setting`'s value.
 *
 *    app.set('foo', 'bar');
 *    app.set('foo');
 *    // => "bar"
 *
 * Mounted servers inherit their parent server's settings.
 *
 * @param {String} setting
 * @param {*} [val]
 * @return {Server} for chaining
 * @public
 */

app.set = function set(setting, val) {
  if (arguments.length === 1) {
    // app.get(setting)
    return this.settings[setting];
  }

  debug('set "%s" to %o', setting, val);

  // set value
  this.settings[setting] = val;

  // trigger matched settings
  switch (setting) {
    case 'etag':
      this.set('etag fn', compileETag(val));
      break;
    case 'query parser':
      this.set('query parser fn', compileQueryParser(val));
      break;
    case 'trust proxy':
      this.set('trust proxy fn', compileTrust(val));

      // trust proxy inherit back-compat
      Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
        configurable: true,
        value: false
      });

      break;
  }

  return this;
};

/**
 * Return the app's absolute pathname
 * based on the parent(s) that have
 * mounted it.
 *
 * For example if the application was
 * mounted as "/admin", which itself
 * was mounted as "/blog" then the
 * return value would be "/blog/admin".
 *
 * @return {String}
 * @private
 */

app.path = function path() {
  return this.parent
    ? this.parent.path() + this.mountpath
    : '';
};

/**
 * Check if `setting` is enabled (truthy).
 *
 *    app.enabled('foo')
 *    // => false
 *
 *    app.enable('foo')
 *    app.enabled('foo')
 *    // => true
 *
 * @param {String} setting
 * @return {Boolean}
 * @public
 */

app.enabled = function enabled(setting) {
  return Boolean(this.set(setting));
};

/**
 * Check if `setting` is disabled.
 *
 *    app.disabled('foo')
 *    // => true
 *
 *    app.enable('foo')
 *    app.disabled('foo')
 *    // => false
 *
 * @param {String} setting
 * @return {Boolean}
 * @public
 */

app.disabled = function disabled(setting) {
  return !this.set(setting);
};

/**
 * Enable `setting`.
 *
 * @param {String} setting
 * @return {app} for chaining
 * @public
 */

app.enable = function enable(setting) {
  return this.set(setting, true);
};

/**
 * Disable `setting`.
 *
 * @param {String} setting
 * @return {app} for chaining
 * @public
 */

app.disable = function disable(setting) {
  return this.set(setting, false);
};

/**
 * Delegate `.VERB(...)` calls to `router.VERB(...)`.
 */

methods.forEach(function(method){
  app[method] = function(path){
    if (method === 'get' && arguments.length === 1) {
      // app.get(setting)
      return this.set(path);
    }

    this.lazyrouter();

    var route = this._router.route(path);
    route[method].apply(route, slice.call(arguments, 1));
    return this;
  };
});

/**
 * Special-cased "all" method, applying the given route `path`,
 * middleware, and callback to _every_ HTTP method.
 *
 * @param {String} path
 * @param {Function} ...
 * @return {app} for chaining
 * @public
 */

app.all = function all(path) {
  this.lazyrouter();

  var route = this._router.route(path);
  var args = slice.call(arguments, 1);

  for (var i = 0; i < methods.length; i++) {
    route[methods[i]].apply(route, args);
  }

  return this;
};

// del -> delete alias

app.del = deprecate.function(app.delete, 'app.del: Use app.delete instead');

/**
 * Render the given view `name` name with `options`
 * and a callback accepting an error and the
 * rendered template string.
 *
 * Example:
 *
 *    app.render('email', { name: 'Tobi' }, function(err, html){
 *      // ...
 *    })
 *
 * @param {String} name
 * @param {Object|Function} options or fn
 * @param {Function} callback
 * @public
 */

app.render = function render(name, options, callback) {
  var cache = this.cache;
  var done = callback;
  var engines = this.engines;
  var opts = options;
  var renderOptions = {};
  var view;

  // support callback function as second arg
  if (typeof options === 'function') {
    done = options;
    opts = {};
  }

  // merge app.locals
  merge(renderOptions, this.locals);

  // merge options._locals
  if (opts._locals) {
    merge(renderOptions, opts._locals);
  }

  // merge options
  merge(renderOptions, opts);

  // set .cache unless explicitly provided
  if (renderOptions.cache == null) {
    renderOptions.cache = this.enabled('view cache');
  }

  // primed cache
  if (renderOptions.cache) {
    view = cache[name];
  }

  // view
  if (!view) {
    var View = this.get('view');

    view = new View(name, {
      defaultEngine: this.get('view engine'),
      root: this.get('views'),
      engines: engines
    });

    if (!view.path) {
      var dirs = Array.isArray(view.root) && view.root.length > 1
        ? 'directories "' + view.root.slice(0, -1).join('", "') + '" or "' + view.root[view.root.length - 1] + '"'
        : 'directory "' + view.root + '"'
      var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
      err.view = view;
      return done(err);
    }

    // prime the cache
    if (renderOptions.cache) {
      cache[name] = view;
    }
  }

  // render
  tryRender(view, renderOptions, done);
};

/**
 * Listen for connections.
 *
 * A node `http.Server` is returned, with this
 * application (which is a `Function`) as its
 * callback. If you wish to create both an HTTP
 * and HTTPS server you may do so with the "http"
 * and "https" modules as shown here:
 *
 *    var http = require('http')
 *      , https = require('https')
 *      , express = require('express')
 *      , app = express();
 *
 *    http.createServer(app).listen(80);
 *    https.createServer({ ... }, app).listen(443);
 *
 * @return {http.Server}
 * @public
 */

app.listen = function listen() {
  var server = http.createServer(this);
  return server.listen.apply(server, arguments);
};

/**
 * Log error using console.error.
 *
 * @param {Error} err
 * @private
 */

function logerror(err) {
  /* istanbul ignore next */
  if (this.get('env') !== 'test') console.error(err.stack || err.toString());
}

/**
 * Try rendering a view.
 * @private
 */

function tryRender(view, options, callback) {
  try {
    view.render(options, callback);
  } catch (err) {
    callback(err);
  }
}


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * finalhandler
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var debug = __webpack_require__(3)('finalhandler')
var encodeUrl = __webpack_require__(27)
var escapeHtml = __webpack_require__(28)
var onFinished = __webpack_require__(25)
var parseUrl = __webpack_require__(16)
var statuses = __webpack_require__(21)
var unpipe = __webpack_require__(50)

/**
 * Module variables.
 * @private
 */

var DOUBLE_SPACE_REGEXP = /\x20{2}/g
var NEWLINE_REGEXP = /\n/g

/* istanbul ignore next */
var defer = typeof setImmediate === 'function'
  ? setImmediate
  : function (fn) { process.nextTick(fn.bind.apply(fn, arguments)) }
var isFinished = onFinished.isFinished

/**
 * Create a minimal HTML document.
 *
 * @param {string} message
 * @private
 */

function createHtmlDocument (message) {
  var body = escapeHtml(message)
    .replace(NEWLINE_REGEXP, '<br>')
    .replace(DOUBLE_SPACE_REGEXP, ' &nbsp;')

  return '<!DOCTYPE html>\n' +
    '<html lang="en">\n' +
    '<head>\n' +
    '<meta charset="utf-8">\n' +
    '<title>Error</title>\n' +
    '</head>\n' +
    '<body>\n' +
    '<pre>' + body + '</pre>\n' +
    '</body>\n' +
    '</html>\n'
}

/**
 * Module exports.
 * @public
 */

module.exports = finalhandler

/**
 * Create a function to handle the final response.
 *
 * @param {Request} req
 * @param {Response} res
 * @param {Object} [options]
 * @return {Function}
 * @public
 */

function finalhandler (req, res, options) {
  var opts = options || {}

  // get environment
  var env = opts.env || process.env.NODE_ENV || 'development'

  // get error callback
  var onerror = opts.onerror

  return function (err) {
    var headers
    var msg
    var status

    // ignore 404 on in-flight response
    if (!err && headersSent(res)) {
      debug('cannot 404 after headers sent')
      return
    }

    // unhandled error
    if (err) {
      // respect status code from error
      status = getErrorStatusCode(err)

      if (status === undefined) {
        // fallback to status code on response
        status = getResponseStatusCode(res)
      } else {
        // respect headers from error
        headers = getErrorHeaders(err)
      }

      // get error message
      msg = getErrorMessage(err, status, env)
    } else {
      // not found
      status = 404
      msg = 'Cannot ' + req.method + ' ' + encodeUrl(getResourceName(req))
    }

    debug('default %s', status)

    // schedule onerror callback
    if (err && onerror) {
      defer(onerror, err, req, res)
    }

    // cannot actually respond
    if (headersSent(res)) {
      debug('cannot %d after headers sent', status)
      req.socket.destroy()
      return
    }

    // send response
    send(req, res, status, headers, msg)
  }
}

/**
 * Get headers from Error object.
 *
 * @param {Error} err
 * @return {object}
 * @private
 */

function getErrorHeaders (err) {
  if (!err.headers || typeof err.headers !== 'object') {
    return undefined
  }

  var headers = Object.create(null)
  var keys = Object.keys(err.headers)

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i]
    headers[key] = err.headers[key]
  }

  return headers
}

/**
 * Get message from Error object, fallback to status message.
 *
 * @param {Error} err
 * @param {number} status
 * @param {string} env
 * @return {string}
 * @private
 */

function getErrorMessage (err, status, env) {
  var msg

  if (env !== 'production') {
    // use err.stack, which typically includes err.message
    msg = err.stack

    // fallback to err.toString() when possible
    if (!msg && typeof err.toString === 'function') {
      msg = err.toString()
    }
  }

  return msg || statuses[status]
}

/**
 * Get status code from Error object.
 *
 * @param {Error} err
 * @return {number}
 * @private
 */

function getErrorStatusCode (err) {
  // check err.status
  if (typeof err.status === 'number' && err.status >= 400 && err.status < 600) {
    return err.status
  }

  // check err.statusCode
  if (typeof err.statusCode === 'number' && err.statusCode >= 400 && err.statusCode < 600) {
    return err.statusCode
  }

  return undefined
}

/**
 * Get resource name for the request.
 *
 * This is typically just the original pathname of the request
 * but will fallback to "resource" is that cannot be determined.
 *
 * @param {IncomingMessage} req
 * @return {string}
 * @private
 */

function getResourceName (req) {
  try {
    return parseUrl.original(req).pathname
  } catch (e) {
    return 'resource'
  }
}

/**
 * Get status code from response.
 *
 * @param {OutgoingMessage} res
 * @return {number}
 * @private
 */

function getResponseStatusCode (res) {
  var status = res.statusCode

  // default status code to 500 if outside valid range
  if (typeof status !== 'number' || status < 400 || status > 599) {
    status = 500
  }

  return status
}

/**
 * Determine if the response headers have been sent.
 *
 * @param {object} res
 * @returns {boolean}
 * @private
 */

function headersSent (res) {
  return typeof res.headersSent !== 'boolean'
    ? Boolean(res._header)
    : res.headersSent
}

/**
 * Send response.
 *
 * @param {IncomingMessage} req
 * @param {OutgoingMessage} res
 * @param {number} status
 * @param {object} headers
 * @param {string} message
 * @private
 */

function send (req, res, status, headers, message) {
  function write () {
    // response body
    var body = createHtmlDocument(message)

    // response status
    res.statusCode = status
    res.statusMessage = statuses[status]

    // response headers
    setHeaders(res, headers)

    // security headers
    res.setHeader('Content-Security-Policy', "default-src 'self'")
    res.setHeader('X-Content-Type-Options', 'nosniff')

    // standard headers
    res.setHeader('Content-Type', 'text/html; charset=utf-8')
    res.setHeader('Content-Length', Buffer.byteLength(body, 'utf8'))

    if (req.method === 'HEAD') {
      res.end()
      return
    }

    res.end(body, 'utf8')
  }

  if (isFinished(req)) {
    write()
    return
  }

  // unpipe everything from the request
  unpipe(req)

  // flush the request
  onFinished(req, write)
  req.resume()
}

/**
 * Set response headers from an object.
 *
 * @param {OutgoingMessage} res
 * @param {object} headers
 * @private
 */

function setHeaders (res, headers) {
  if (!headers) {
    return
  }

  var keys = Object.keys(headers)
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i]
    res.setHeader(key, headers[key])
  }
}


/***/ }),
/* 123 */
/***/ (function(module, exports) {

/**
 * Expose `pathtoRegexp`.
 */

module.exports = pathtoRegexp;

/**
 * Match matching groups in a regular expression.
 */
var MATCHING_GROUP_REGEXP = /\((?!\?)/g;

/**
 * Normalize the given path string,
 * returning a regular expression.
 *
 * An empty array should be passed,
 * which will contain the placeholder
 * key names. For example "/user/:id" will
 * then contain ["id"].
 *
 * @param  {String|RegExp|Array} path
 * @param  {Array} keys
 * @param  {Object} options
 * @return {RegExp}
 * @api private
 */

function pathtoRegexp(path, keys, options) {
  options = options || {};
  keys = keys || [];
  var strict = options.strict;
  var end = options.end !== false;
  var flags = options.sensitive ? '' : 'i';
  var extraOffset = 0;
  var keysOffset = keys.length;
  var i = 0;
  var name = 0;
  var m;

  if (path instanceof RegExp) {
    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {
      keys.push({
        name: name++,
        optional: false,
        offset: m.index
      });
    }

    return path;
  }

  if (Array.isArray(path)) {
    // Map array parts into regexps and return their source. We also pass
    // the same keys and options instance into every generation to get
    // consistent matching groups before we join the sources together.
    path = path.map(function (value) {
      return pathtoRegexp(value, keys, options).source;
    });

    return new RegExp('(?:' + path.join('|') + ')', flags);
  }

  path = ('^' + path + (strict ? '' : path[path.length - 1] === '/' ? '?' : '/?'))
    .replace(/\/\(/g, '/(?:')
    .replace(/([\/\.])/g, '\\$1')
    .replace(/(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g, function (match, slash, format, key, capture, star, optional, offset) {
      slash = slash || '';
      format = format || '';
      capture = capture || '([^\\/' + format + ']+?)';
      optional = optional || '';

      keys.push({
        name: key,
        optional: !!optional,
        offset: offset + extraOffset
      });

      var result = ''
        + (optional ? '' : slash)
        + '(?:'
        + format + (optional ? slash : '') + capture
        + (star ? '((?:[\\/' + format + '].+?)?)' : '')
        + ')'
        + optional;

      extraOffset += result.length - match.length;

      return result;
    })
    .replace(/\*/g, function (star, index) {
      var len = keys.length

      while (len-- > keysOffset && keys[len].offset > index) {
        keys[len].offset += 3; // Replacement length minus asterisk length.
      }

      return '(.*)';
    });

  // This is a workaround for handling unnamed matching groups.
  while (m = MATCHING_GROUP_REGEXP.exec(path)) {
    var escapeCount = 0;
    var index = m.index;

    while (path.charAt(--index) === '\\') {
      escapeCount++;
    }

    // It's possible to escape the bracket.
    if (escapeCount % 2 === 1) {
      continue;
    }

    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {
      keys.splice(keysOffset + i, 0, {
        name: name++, // Unnamed matching groups must be consistently linear.
        optional: false,
        offset: m.index
      });
    }

    i++;
  }

  // If the path is non-ending, match until the end or a slash.
  path += (end ? '$' : (path[path.length - 1] === '/' ? '' : '(?=\\/|$)'));

  return new RegExp(path, flags);
};


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var setPrototypeOf = __webpack_require__(20)

/**
 * Initialization middleware, exposing the
 * request and response to each other, as well
 * as defaulting the X-Powered-By header field.
 *
 * @param {Function} app
 * @return {Function}
 * @api private
 */

exports.init = function(app){
  return function expressInit(req, res, next){
    if (app.enabled('x-powered-by')) res.setHeader('X-Powered-By', 'Express');
    req.res = res;
    res.req = req;
    req.next = next;

    setPrototypeOf(req, app.request)
    setPrototypeOf(res, app.response)

    res.locals = res.locals || Object.create(null);

    next();
  };
};



/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var debug = __webpack_require__(3)('express:view');
var path = __webpack_require__(2);
var fs = __webpack_require__(6);

/**
 * Module variables.
 * @private
 */

var dirname = path.dirname;
var basename = path.basename;
var extname = path.extname;
var join = path.join;
var resolve = path.resolve;

/**
 * Module exports.
 * @public
 */

module.exports = View;

/**
 * Initialize a new `View` with the given `name`.
 *
 * Options:
 *
 *   - `defaultEngine` the default template engine name
 *   - `engines` template engine require() cache
 *   - `root` root path for view lookup
 *
 * @param {string} name
 * @param {object} options
 * @public
 */

function View(name, options) {
  var opts = options || {};

  this.defaultEngine = opts.defaultEngine;
  this.ext = extname(name);
  this.name = name;
  this.root = opts.root;

  if (!this.ext && !this.defaultEngine) {
    throw new Error('No default engine was specified and no extension was provided.');
  }

  var fileName = name;

  if (!this.ext) {
    // get extension from default engine name
    this.ext = this.defaultEngine[0] !== '.'
      ? '.' + this.defaultEngine
      : this.defaultEngine;

    fileName += this.ext;
  }

  if (!opts.engines[this.ext]) {
    // load engine
    var mod = this.ext.substr(1)
    debug('require "%s"', mod)

    // default engine export
    var fn = !(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()).__express

    if (typeof fn !== 'function') {
      throw new Error('Module "' + mod + '" does not provide a view engine.')
    }

    opts.engines[this.ext] = fn
  }

  // store loaded engine
  this.engine = opts.engines[this.ext];

  // lookup path
  this.path = this.lookup(fileName);
}

/**
 * Lookup view by the given `name`
 *
 * @param {string} name
 * @private
 */

View.prototype.lookup = function lookup(name) {
  var path;
  var roots = [].concat(this.root);

  debug('lookup "%s"', name);

  for (var i = 0; i < roots.length && !path; i++) {
    var root = roots[i];

    // resolve the path
    var loc = resolve(root, name);
    var dir = dirname(loc);
    var file = basename(loc);

    // resolve the file
    path = this.resolve(dir, file);
  }

  return path;
};

/**
 * Render with the given options.
 *
 * @param {object} options
 * @param {function} callback
 * @private
 */

View.prototype.render = function render(options, callback) {
  debug('render "%s"', this.path);
  this.engine(this.path, options, callback);
};

/**
 * Resolve the file within the given directory.
 *
 * @param {string} dir
 * @param {string} file
 * @private
 */

View.prototype.resolve = function resolve(dir, file) {
  var ext = this.ext;

  // <path>.<ext>
  var path = join(dir, file);
  var stat = tryStat(path);

  if (stat && stat.isFile()) {
    return path;
  }

  // <path>/index.<ext>
  path = join(dir, basename(file, ext), 'index' + ext);
  stat = tryStat(path);

  if (stat && stat.isFile()) {
    return path;
  }
};

/**
 * Return a stat, maybe.
 *
 * @param {string} path
 * @return {fs.Stats}
 * @private
 */

function tryStat(path) {
  debug('stat "%s"', path);

  try {
    return fs.statSync(path);
  } catch (e) {
    return undefined;
  }
}


/***/ }),
/* 126 */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	throw new Error("Cannot find module '" + req + "'.");
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = 126;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * destroy
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var ReadStream = __webpack_require__(6).ReadStream
var Stream = __webpack_require__(11)

/**
 * Module exports.
 * @public
 */

module.exports = destroy

/**
 * Destroy a stream.
 *
 * @param {object} stream
 * @public
 */

function destroy(stream) {
  if (stream instanceof ReadStream) {
    return destroyReadStream(stream)
  }

  if (!(stream instanceof Stream)) {
    return stream
  }

  if (typeof stream.destroy === 'function') {
    stream.destroy()
  }

  return stream
}

/**
 * Destroy a ReadStream.
 *
 * @param {object} stream
 * @private
 */

function destroyReadStream(stream) {
  stream.destroy()

  if (typeof stream.close === 'function') {
    // node.js core bug work-around
    stream.on('open', onOpenClose)
  }

  return stream
}

/**
 * On open handler to close stream.
 * @private
 */

function onOpenClose() {
  if (typeof this.fd === 'number') {
    // actually close down the fd
    this.close()
  }
}


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__(2);
var fs = __webpack_require__(6);

function Mime() {
  // Map of extension -> mime type
  this.types = Object.create(null);

  // Map of mime type -> extension
  this.extensions = Object.create(null);
}

/**
 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
 * to an array of extensions associated with the type.  The first extension is
 * used as the default extension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
 *
 * @param map (Object) type definitions
 */
Mime.prototype.define = function (map) {
  for (var type in map) {
    var exts = map[type];
    for (var i = 0; i < exts.length; i++) {
      if (process.env.DEBUG_MIME && this.types[exts[i]]) {
        console.warn((this._loading || "define()").replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' +
          this.types[exts[i]] + ' to ' + type);
      }

      this.types[exts[i]] = type;
    }

    // Default extension is the first one we encounter
    if (!this.extensions[type]) {
      this.extensions[type] = exts[0];
    }
  }
};

/**
 * Load an Apache2-style ".types" file
 *
 * This may be called multiple times (it's expected).  Where files declare
 * overlapping types/extensions, the last file wins.
 *
 * @param file (String) path of file to load.
 */
Mime.prototype.load = function(file) {
  this._loading = file;
  // Read file and split into lines
  var map = {},
      content = fs.readFileSync(file, 'ascii'),
      lines = content.split(/[\r\n]+/);

  lines.forEach(function(line) {
    // Clean up whitespace/comments, and split into fields
    var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
    map[fields.shift()] = fields;
  });

  this.define(map);

  this._loading = null;
};

/**
 * Lookup a mime type based on extension
 */
Mime.prototype.lookup = function(path, fallback) {
  var ext = path.replace(/^.*[\.\/\\]/, '').toLowerCase();

  return this.types[ext] || fallback || this.default_type;
};

/**
 * Return file extension associated with a mime type
 */
Mime.prototype.extension = function(mimeType) {
  var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
  return this.extensions[type];
};

// Default instance
var mime = new Mime();

// Define built-in types
mime.define(__webpack_require__(129));

// Default type
mime.default_type = mime.lookup('bin');

//
// Additional API specific to the default instance
//

mime.Mime = Mime;

/**
 * Lookup a charset based on mime type.
 */
mime.charsets = {
  lookup: function(mimeType, fallback) {
    // Assume text types are utf8
    return (/^text\/|^application\/(javascript|json)/).test(mimeType) ? 'UTF-8' : fallback;
  }
};

module.exports = mime;


/***/ }),
/* 129 */
/***/ (function(module, exports) {

module.exports = {"application/andrew-inset":["ez"],"application/applixware":["aw"],"application/atom+xml":["atom"],"application/atomcat+xml":["atomcat"],"application/atomsvc+xml":["atomsvc"],"application/bdoc":["bdoc"],"application/ccxml+xml":["ccxml"],"application/cdmi-capability":["cdmia"],"application/cdmi-container":["cdmic"],"application/cdmi-domain":["cdmid"],"application/cdmi-object":["cdmio"],"application/cdmi-queue":["cdmiq"],"application/cu-seeme":["cu"],"application/dash+xml":["mpd"],"application/davmount+xml":["davmount"],"application/docbook+xml":["dbk"],"application/dssc+der":["dssc"],"application/dssc+xml":["xdssc"],"application/ecmascript":["ecma"],"application/emma+xml":["emma"],"application/epub+zip":["epub"],"application/exi":["exi"],"application/font-tdpfr":["pfr"],"application/font-woff":["woff"],"application/font-woff2":["woff2"],"application/geo+json":["geojson"],"application/gml+xml":["gml"],"application/gpx+xml":["gpx"],"application/gxf":["gxf"],"application/gzip":["gz"],"application/hyperstudio":["stk"],"application/inkml+xml":["ink","inkml"],"application/ipfix":["ipfix"],"application/java-archive":["jar","war","ear"],"application/java-serialized-object":["ser"],"application/java-vm":["class"],"application/javascript":["js","mjs"],"application/json":["json","map"],"application/json5":["json5"],"application/jsonml+json":["jsonml"],"application/ld+json":["jsonld"],"application/lost+xml":["lostxml"],"application/mac-binhex40":["hqx"],"application/mac-compactpro":["cpt"],"application/mads+xml":["mads"],"application/manifest+json":["webmanifest"],"application/marc":["mrc"],"application/marcxml+xml":["mrcx"],"application/mathematica":["ma","nb","mb"],"application/mathml+xml":["mathml"],"application/mbox":["mbox"],"application/mediaservercontrol+xml":["mscml"],"application/metalink+xml":["metalink"],"application/metalink4+xml":["meta4"],"application/mets+xml":["mets"],"application/mods+xml":["mods"],"application/mp21":["m21","mp21"],"application/mp4":["mp4s","m4p"],"application/msword":["doc","dot"],"application/mxf":["mxf"],"application/octet-stream":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"],"application/oda":["oda"],"application/oebps-package+xml":["opf"],"application/ogg":["ogx"],"application/omdoc+xml":["omdoc"],"application/onenote":["onetoc","onetoc2","onetmp","onepkg"],"application/oxps":["oxps"],"application/patch-ops-error+xml":["xer"],"application/pdf":["pdf"],"application/pgp-encrypted":["pgp"],"application/pgp-signature":["asc","sig"],"application/pics-rules":["prf"],"application/pkcs10":["p10"],"application/pkcs7-mime":["p7m","p7c"],"application/pkcs7-signature":["p7s"],"application/pkcs8":["p8"],"application/pkix-attr-cert":["ac"],"application/pkix-cert":["cer"],"application/pkix-crl":["crl"],"application/pkix-pkipath":["pkipath"],"application/pkixcmp":["pki"],"application/pls+xml":["pls"],"application/postscript":["ai","eps","ps"],"application/prs.cww":["cww"],"application/pskc+xml":["pskcxml"],"application/rdf+xml":["rdf"],"application/reginfo+xml":["rif"],"application/relax-ng-compact-syntax":["rnc"],"application/resource-lists+xml":["rl"],"application/resource-lists-diff+xml":["rld"],"application/rls-services+xml":["rs"],"application/rpki-ghostbusters":["gbr"],"application/rpki-manifest":["mft"],"application/rpki-roa":["roa"],"application/rsd+xml":["rsd"],"application/rss+xml":["rss"],"application/rtf":["rtf"],"application/sbml+xml":["sbml"],"application/scvp-cv-request":["scq"],"application/scvp-cv-response":["scs"],"application/scvp-vp-request":["spq"],"application/scvp-vp-response":["spp"],"application/sdp":["sdp"],"application/set-payment-initiation":["setpay"],"application/set-registration-initiation":["setreg"],"application/shf+xml":["shf"],"application/smil+xml":["smi","smil"],"application/sparql-query":["rq"],"application/sparql-results+xml":["srx"],"application/srgs":["gram"],"application/srgs+xml":["grxml"],"application/sru+xml":["sru"],"application/ssdl+xml":["ssdl"],"application/ssml+xml":["ssml"],"application/tei+xml":["tei","teicorpus"],"application/thraud+xml":["tfi"],"application/timestamped-data":["tsd"],"application/vnd.3gpp.pic-bw-large":["plb"],"application/vnd.3gpp.pic-bw-small":["psb"],"application/vnd.3gpp.pic-bw-var":["pvb"],"application/vnd.3gpp2.tcap":["tcap"],"application/vnd.3m.post-it-notes":["pwn"],"application/vnd.accpac.simply.aso":["aso"],"application/vnd.accpac.simply.imp":["imp"],"application/vnd.acucobol":["acu"],"application/vnd.acucorp":["atc","acutc"],"application/vnd.adobe.air-application-installer-package+zip":["air"],"application/vnd.adobe.formscentral.fcdt":["fcdt"],"application/vnd.adobe.fxp":["fxp","fxpl"],"application/vnd.adobe.xdp+xml":["xdp"],"application/vnd.adobe.xfdf":["xfdf"],"application/vnd.ahead.space":["ahead"],"application/vnd.airzip.filesecure.azf":["azf"],"application/vnd.airzip.filesecure.azs":["azs"],"application/vnd.amazon.ebook":["azw"],"application/vnd.americandynamics.acc":["acc"],"application/vnd.amiga.ami":["ami"],"application/vnd.android.package-archive":["apk"],"application/vnd.anser-web-certificate-issue-initiation":["cii"],"application/vnd.anser-web-funds-transfer-initiation":["fti"],"application/vnd.antix.game-component":["atx"],"application/vnd.apple.installer+xml":["mpkg"],"application/vnd.apple.mpegurl":["m3u8"],"application/vnd.apple.pkpass":["pkpass"],"application/vnd.aristanetworks.swi":["swi"],"application/vnd.astraea-software.iota":["iota"],"application/vnd.audiograph":["aep"],"application/vnd.blueice.multipass":["mpm"],"application/vnd.bmi":["bmi"],"application/vnd.businessobjects":["rep"],"application/vnd.chemdraw+xml":["cdxml"],"application/vnd.chipnuts.karaoke-mmd":["mmd"],"application/vnd.cinderella":["cdy"],"application/vnd.claymore":["cla"],"application/vnd.cloanto.rp9":["rp9"],"application/vnd.clonk.c4group":["c4g","c4d","c4f","c4p","c4u"],"application/vnd.cluetrust.cartomobile-config":["c11amc"],"application/vnd.cluetrust.cartomobile-config-pkg":["c11amz"],"application/vnd.commonspace":["csp"],"application/vnd.contact.cmsg":["cdbcmsg"],"application/vnd.cosmocaller":["cmc"],"application/vnd.crick.clicker":["clkx"],"application/vnd.crick.clicker.keyboard":["clkk"],"application/vnd.crick.clicker.palette":["clkp"],"application/vnd.crick.clicker.template":["clkt"],"application/vnd.crick.clicker.wordbank":["clkw"],"application/vnd.criticaltools.wbs+xml":["wbs"],"application/vnd.ctc-posml":["pml"],"application/vnd.cups-ppd":["ppd"],"application/vnd.curl.car":["car"],"application/vnd.curl.pcurl":["pcurl"],"application/vnd.dart":["dart"],"application/vnd.data-vision.rdz":["rdz"],"application/vnd.dece.data":["uvf","uvvf","uvd","uvvd"],"application/vnd.dece.ttml+xml":["uvt","uvvt"],"application/vnd.dece.unspecified":["uvx","uvvx"],"application/vnd.dece.zip":["uvz","uvvz"],"application/vnd.denovo.fcselayout-link":["fe_launch"],"application/vnd.dna":["dna"],"application/vnd.dolby.mlp":["mlp"],"application/vnd.dpgraph":["dpg"],"application/vnd.dreamfactory":["dfac"],"application/vnd.ds-keypoint":["kpxx"],"application/vnd.dvb.ait":["ait"],"application/vnd.dvb.service":["svc"],"application/vnd.dynageo":["geo"],"application/vnd.ecowin.chart":["mag"],"application/vnd.enliven":["nml"],"application/vnd.epson.esf":["esf"],"application/vnd.epson.msf":["msf"],"application/vnd.epson.quickanime":["qam"],"application/vnd.epson.salt":["slt"],"application/vnd.epson.ssf":["ssf"],"application/vnd.eszigno3+xml":["es3","et3"],"application/vnd.ezpix-album":["ez2"],"application/vnd.ezpix-package":["ez3"],"application/vnd.fdf":["fdf"],"application/vnd.fdsn.mseed":["mseed"],"application/vnd.fdsn.seed":["seed","dataless"],"application/vnd.flographit":["gph"],"application/vnd.fluxtime.clip":["ftc"],"application/vnd.framemaker":["fm","frame","maker","book"],"application/vnd.frogans.fnc":["fnc"],"application/vnd.frogans.ltf":["ltf"],"application/vnd.fsc.weblaunch":["fsc"],"application/vnd.fujitsu.oasys":["oas"],"application/vnd.fujitsu.oasys2":["oa2"],"application/vnd.fujitsu.oasys3":["oa3"],"application/vnd.fujitsu.oasysgp":["fg5"],"application/vnd.fujitsu.oasysprs":["bh2"],"application/vnd.fujixerox.ddd":["ddd"],"application/vnd.fujixerox.docuworks":["xdw"],"application/vnd.fujixerox.docuworks.binder":["xbd"],"application/vnd.fuzzysheet":["fzs"],"application/vnd.genomatix.tuxedo":["txd"],"application/vnd.geogebra.file":["ggb"],"application/vnd.geogebra.tool":["ggt"],"application/vnd.geometry-explorer":["gex","gre"],"application/vnd.geonext":["gxt"],"application/vnd.geoplan":["g2w"],"application/vnd.geospace":["g3w"],"application/vnd.gmx":["gmx"],"application/vnd.google-apps.document":["gdoc"],"application/vnd.google-apps.presentation":["gslides"],"application/vnd.google-apps.spreadsheet":["gsheet"],"application/vnd.google-earth.kml+xml":["kml"],"application/vnd.google-earth.kmz":["kmz"],"application/vnd.grafeq":["gqf","gqs"],"application/vnd.groove-account":["gac"],"application/vnd.groove-help":["ghf"],"application/vnd.groove-identity-message":["gim"],"application/vnd.groove-injector":["grv"],"application/vnd.groove-tool-message":["gtm"],"application/vnd.groove-tool-template":["tpl"],"application/vnd.groove-vcard":["vcg"],"application/vnd.hal+xml":["hal"],"application/vnd.handheld-entertainment+xml":["zmm"],"application/vnd.hbci":["hbci"],"application/vnd.hhe.lesson-player":["les"],"application/vnd.hp-hpgl":["hpgl"],"application/vnd.hp-hpid":["hpid"],"application/vnd.hp-hps":["hps"],"application/vnd.hp-jlyt":["jlt"],"application/vnd.hp-pcl":["pcl"],"application/vnd.hp-pclxl":["pclxl"],"application/vnd.hydrostatix.sof-data":["sfd-hdstx"],"application/vnd.ibm.minipay":["mpy"],"application/vnd.ibm.modcap":["afp","listafp","list3820"],"application/vnd.ibm.rights-management":["irm"],"application/vnd.ibm.secure-container":["sc"],"application/vnd.iccprofile":["icc","icm"],"application/vnd.igloader":["igl"],"application/vnd.immervision-ivp":["ivp"],"application/vnd.immervision-ivu":["ivu"],"application/vnd.insors.igm":["igm"],"application/vnd.intercon.formnet":["xpw","xpx"],"application/vnd.intergeo":["i2g"],"application/vnd.intu.qbo":["qbo"],"application/vnd.intu.qfx":["qfx"],"application/vnd.ipunplugged.rcprofile":["rcprofile"],"application/vnd.irepository.package+xml":["irp"],"application/vnd.is-xpr":["xpr"],"application/vnd.isac.fcs":["fcs"],"application/vnd.jam":["jam"],"application/vnd.jcp.javame.midlet-rms":["rms"],"application/vnd.jisp":["jisp"],"application/vnd.joost.joda-archive":["joda"],"application/vnd.kahootz":["ktz","ktr"],"application/vnd.kde.karbon":["karbon"],"application/vnd.kde.kchart":["chrt"],"application/vnd.kde.kformula":["kfo"],"application/vnd.kde.kivio":["flw"],"application/vnd.kde.kontour":["kon"],"application/vnd.kde.kpresenter":["kpr","kpt"],"application/vnd.kde.kspread":["ksp"],"application/vnd.kde.kword":["kwd","kwt"],"application/vnd.kenameaapp":["htke"],"application/vnd.kidspiration":["kia"],"application/vnd.kinar":["kne","knp"],"application/vnd.koan":["skp","skd","skt","skm"],"application/vnd.kodak-descriptor":["sse"],"application/vnd.las.las+xml":["lasxml"],"application/vnd.llamagraphics.life-balance.desktop":["lbd"],"application/vnd.llamagraphics.life-balance.exchange+xml":["lbe"],"application/vnd.lotus-1-2-3":["123"],"application/vnd.lotus-approach":["apr"],"application/vnd.lotus-freelance":["pre"],"application/vnd.lotus-notes":["nsf"],"application/vnd.lotus-organizer":["org"],"application/vnd.lotus-screencam":["scm"],"application/vnd.lotus-wordpro":["lwp"],"application/vnd.macports.portpkg":["portpkg"],"application/vnd.mcd":["mcd"],"application/vnd.medcalcdata":["mc1"],"application/vnd.mediastation.cdkey":["cdkey"],"application/vnd.mfer":["mwf"],"application/vnd.mfmp":["mfm"],"application/vnd.micrografx.flo":["flo"],"application/vnd.micrografx.igx":["igx"],"application/vnd.mif":["mif"],"application/vnd.mobius.daf":["daf"],"application/vnd.mobius.dis":["dis"],"application/vnd.mobius.mbk":["mbk"],"application/vnd.mobius.mqy":["mqy"],"application/vnd.mobius.msl":["msl"],"application/vnd.mobius.plc":["plc"],"application/vnd.mobius.txf":["txf"],"application/vnd.mophun.application":["mpn"],"application/vnd.mophun.certificate":["mpc"],"application/vnd.mozilla.xul+xml":["xul"],"application/vnd.ms-artgalry":["cil"],"application/vnd.ms-cab-compressed":["cab"],"application/vnd.ms-excel":["xls","xlm","xla","xlc","xlt","xlw"],"application/vnd.ms-excel.addin.macroenabled.12":["xlam"],"application/vnd.ms-excel.sheet.binary.macroenabled.12":["xlsb"],"application/vnd.ms-excel.sheet.macroenabled.12":["xlsm"],"application/vnd.ms-excel.template.macroenabled.12":["xltm"],"application/vnd.ms-fontobject":["eot"],"application/vnd.ms-htmlhelp":["chm"],"application/vnd.ms-ims":["ims"],"application/vnd.ms-lrm":["lrm"],"application/vnd.ms-officetheme":["thmx"],"application/vnd.ms-outlook":["msg"],"application/vnd.ms-pki.seccat":["cat"],"application/vnd.ms-pki.stl":["stl"],"application/vnd.ms-powerpoint":["ppt","pps","pot"],"application/vnd.ms-powerpoint.addin.macroenabled.12":["ppam"],"application/vnd.ms-powerpoint.presentation.macroenabled.12":["pptm"],"application/vnd.ms-powerpoint.slide.macroenabled.12":["sldm"],"application/vnd.ms-powerpoint.slideshow.macroenabled.12":["ppsm"],"application/vnd.ms-powerpoint.template.macroenabled.12":["potm"],"application/vnd.ms-project":["mpp","mpt"],"application/vnd.ms-word.document.macroenabled.12":["docm"],"application/vnd.ms-word.template.macroenabled.12":["dotm"],"application/vnd.ms-works":["wps","wks","wcm","wdb"],"application/vnd.ms-wpl":["wpl"],"application/vnd.ms-xpsdocument":["xps"],"application/vnd.mseq":["mseq"],"application/vnd.musician":["mus"],"application/vnd.muvee.style":["msty"],"application/vnd.mynfc":["taglet"],"application/vnd.neurolanguage.nlu":["nlu"],"application/vnd.nitf":["ntf","nitf"],"application/vnd.noblenet-directory":["nnd"],"application/vnd.noblenet-sealer":["nns"],"application/vnd.noblenet-web":["nnw"],"application/vnd.nokia.n-gage.data":["ngdat"],"application/vnd.nokia.n-gage.symbian.install":["n-gage"],"application/vnd.nokia.radio-preset":["rpst"],"application/vnd.nokia.radio-presets":["rpss"],"application/vnd.novadigm.edm":["edm"],"application/vnd.novadigm.edx":["edx"],"application/vnd.novadigm.ext":["ext"],"application/vnd.oasis.opendocument.chart":["odc"],"application/vnd.oasis.opendocument.chart-template":["otc"],"application/vnd.oasis.opendocument.database":["odb"],"application/vnd.oasis.opendocument.formula":["odf"],"application/vnd.oasis.opendocument.formula-template":["odft"],"application/vnd.oasis.opendocument.graphics":["odg"],"application/vnd.oasis.opendocument.graphics-template":["otg"],"application/vnd.oasis.opendocument.image":["odi"],"application/vnd.oasis.opendocument.image-template":["oti"],"application/vnd.oasis.opendocument.presentation":["odp"],"application/vnd.oasis.opendocument.presentation-template":["otp"],"application/vnd.oasis.opendocument.spreadsheet":["ods"],"application/vnd.oasis.opendocument.spreadsheet-template":["ots"],"application/vnd.oasis.opendocument.text":["odt"],"application/vnd.oasis.opendocument.text-master":["odm"],"application/vnd.oasis.opendocument.text-template":["ott"],"application/vnd.oasis.opendocument.text-web":["oth"],"application/vnd.olpc-sugar":["xo"],"application/vnd.oma.dd2+xml":["dd2"],"application/vnd.openofficeorg.extension":["oxt"],"application/vnd.openxmlformats-officedocument.presentationml.presentation":["pptx"],"application/vnd.openxmlformats-officedocument.presentationml.slide":["sldx"],"application/vnd.openxmlformats-officedocument.presentationml.slideshow":["ppsx"],"application/vnd.openxmlformats-officedocument.presentationml.template":["potx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":["xlsx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.template":["xltx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.document":["docx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.template":["dotx"],"application/vnd.osgeo.mapguide.package":["mgp"],"application/vnd.osgi.dp":["dp"],"application/vnd.osgi.subsystem":["esa"],"application/vnd.palm":["pdb","pqa","oprc"],"application/vnd.pawaafile":["paw"],"application/vnd.pg.format":["str"],"application/vnd.pg.osasli":["ei6"],"application/vnd.picsel":["efif"],"application/vnd.pmi.widget":["wg"],"application/vnd.pocketlearn":["plf"],"application/vnd.powerbuilder6":["pbd"],"application/vnd.previewsystems.box":["box"],"application/vnd.proteus.magazine":["mgz"],"application/vnd.publishare-delta-tree":["qps"],"application/vnd.pvi.ptid1":["ptid"],"application/vnd.quark.quarkxpress":["qxd","qxt","qwd","qwt","qxl","qxb"],"application/vnd.realvnc.bed":["bed"],"application/vnd.recordare.musicxml":["mxl"],"application/vnd.recordare.musicxml+xml":["musicxml"],"application/vnd.rig.cryptonote":["cryptonote"],"application/vnd.rim.cod":["cod"],"application/vnd.rn-realmedia":["rm"],"application/vnd.rn-realmedia-vbr":["rmvb"],"application/vnd.route66.link66+xml":["link66"],"application/vnd.sailingtracker.track":["st"],"application/vnd.seemail":["see"],"application/vnd.sema":["sema"],"application/vnd.semd":["semd"],"application/vnd.semf":["semf"],"application/vnd.shana.informed.formdata":["ifm"],"application/vnd.shana.informed.formtemplate":["itp"],"application/vnd.shana.informed.interchange":["iif"],"application/vnd.shana.informed.package":["ipk"],"application/vnd.simtech-mindmapper":["twd","twds"],"application/vnd.smaf":["mmf"],"application/vnd.smart.teacher":["teacher"],"application/vnd.solent.sdkm+xml":["sdkm","sdkd"],"application/vnd.spotfire.dxp":["dxp"],"application/vnd.spotfire.sfs":["sfs"],"application/vnd.stardivision.calc":["sdc"],"application/vnd.stardivision.draw":["sda"],"application/vnd.stardivision.impress":["sdd"],"application/vnd.stardivision.math":["smf"],"application/vnd.stardivision.writer":["sdw","vor"],"application/vnd.stardivision.writer-global":["sgl"],"application/vnd.stepmania.package":["smzip"],"application/vnd.stepmania.stepchart":["sm"],"application/vnd.sun.wadl+xml":["wadl"],"application/vnd.sun.xml.calc":["sxc"],"application/vnd.sun.xml.calc.template":["stc"],"application/vnd.sun.xml.draw":["sxd"],"application/vnd.sun.xml.draw.template":["std"],"application/vnd.sun.xml.impress":["sxi"],"application/vnd.sun.xml.impress.template":["sti"],"application/vnd.sun.xml.math":["sxm"],"application/vnd.sun.xml.writer":["sxw"],"application/vnd.sun.xml.writer.global":["sxg"],"application/vnd.sun.xml.writer.template":["stw"],"application/vnd.sus-calendar":["sus","susp"],"application/vnd.svd":["svd"],"application/vnd.symbian.install":["sis","sisx"],"application/vnd.syncml+xml":["xsm"],"application/vnd.syncml.dm+wbxml":["bdm"],"application/vnd.syncml.dm+xml":["xdm"],"application/vnd.tao.intent-module-archive":["tao"],"application/vnd.tcpdump.pcap":["pcap","cap","dmp"],"application/vnd.tmobile-livetv":["tmo"],"application/vnd.trid.tpt":["tpt"],"application/vnd.triscape.mxs":["mxs"],"application/vnd.trueapp":["tra"],"application/vnd.ufdl":["ufd","ufdl"],"application/vnd.uiq.theme":["utz"],"application/vnd.umajin":["umj"],"application/vnd.unity":["unityweb"],"application/vnd.uoml+xml":["uoml"],"application/vnd.vcx":["vcx"],"application/vnd.visio":["vsd","vst","vss","vsw"],"application/vnd.visionary":["vis"],"application/vnd.vsf":["vsf"],"application/vnd.wap.wbxml":["wbxml"],"application/vnd.wap.wmlc":["wmlc"],"application/vnd.wap.wmlscriptc":["wmlsc"],"application/vnd.webturbo":["wtb"],"application/vnd.wolfram.player":["nbp"],"application/vnd.wordperfect":["wpd"],"application/vnd.wqd":["wqd"],"application/vnd.wt.stf":["stf"],"application/vnd.xara":["xar"],"application/vnd.xfdl":["xfdl"],"application/vnd.yamaha.hv-dic":["hvd"],"application/vnd.yamaha.hv-script":["hvs"],"application/vnd.yamaha.hv-voice":["hvp"],"application/vnd.yamaha.openscoreformat":["osf"],"application/vnd.yamaha.openscoreformat.osfpvg+xml":["osfpvg"],"application/vnd.yamaha.smaf-audio":["saf"],"application/vnd.yamaha.smaf-phrase":["spf"],"application/vnd.yellowriver-custom-menu":["cmp"],"application/vnd.zul":["zir","zirz"],"application/vnd.zzazz.deck+xml":["zaz"],"application/voicexml+xml":["vxml"],"application/widget":["wgt"],"application/winhlp":["hlp"],"application/wsdl+xml":["wsdl"],"application/wspolicy+xml":["wspolicy"],"application/x-7z-compressed":["7z"],"application/x-abiword":["abw"],"application/x-ace-compressed":["ace"],"application/x-apple-diskimage":["dmg"],"application/x-arj":["arj"],"application/x-authorware-bin":["aab","x32","u32","vox"],"application/x-authorware-map":["aam"],"application/x-authorware-seg":["aas"],"application/x-bcpio":["bcpio"],"application/x-bdoc":["bdoc"],"application/x-bittorrent":["torrent"],"application/x-blorb":["blb","blorb"],"application/x-bzip":["bz"],"application/x-bzip2":["bz2","boz"],"application/x-cbr":["cbr","cba","cbt","cbz","cb7"],"application/x-cdlink":["vcd"],"application/x-cfs-compressed":["cfs"],"application/x-chat":["chat"],"application/x-chess-pgn":["pgn"],"application/x-chrome-extension":["crx"],"application/x-cocoa":["cco"],"application/x-conference":["nsc"],"application/x-cpio":["cpio"],"application/x-csh":["csh"],"application/x-debian-package":["deb","udeb"],"application/x-dgc-compressed":["dgc"],"application/x-director":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"],"application/x-doom":["wad"],"application/x-dtbncx+xml":["ncx"],"application/x-dtbook+xml":["dtb"],"application/x-dtbresource+xml":["res"],"application/x-dvi":["dvi"],"application/x-envoy":["evy"],"application/x-eva":["eva"],"application/x-font-bdf":["bdf"],"application/x-font-ghostscript":["gsf"],"application/x-font-linux-psf":["psf"],"application/x-font-otf":["otf"],"application/x-font-pcf":["pcf"],"application/x-font-snf":["snf"],"application/x-font-ttf":["ttf","ttc"],"application/x-font-type1":["pfa","pfb","pfm","afm"],"application/x-freearc":["arc"],"application/x-futuresplash":["spl"],"application/x-gca-compressed":["gca"],"application/x-glulx":["ulx"],"application/x-gnumeric":["gnumeric"],"application/x-gramps-xml":["gramps"],"application/x-gtar":["gtar"],"application/x-hdf":["hdf"],"application/x-httpd-php":["php"],"application/x-install-instructions":["install"],"application/x-iso9660-image":["iso"],"application/x-java-archive-diff":["jardiff"],"application/x-java-jnlp-file":["jnlp"],"application/x-latex":["latex"],"application/x-lua-bytecode":["luac"],"application/x-lzh-compressed":["lzh","lha"],"application/x-makeself":["run"],"application/x-mie":["mie"],"application/x-mobipocket-ebook":["prc","mobi"],"application/x-ms-application":["application"],"application/x-ms-shortcut":["lnk"],"application/x-ms-wmd":["wmd"],"application/x-ms-wmz":["wmz"],"application/x-ms-xbap":["xbap"],"application/x-msaccess":["mdb"],"application/x-msbinder":["obd"],"application/x-mscardfile":["crd"],"application/x-msclip":["clp"],"application/x-msdos-program":["exe"],"application/x-msdownload":["exe","dll","com","bat","msi"],"application/x-msmediaview":["mvb","m13","m14"],"application/x-msmetafile":["wmf","wmz","emf","emz"],"application/x-msmoney":["mny"],"application/x-mspublisher":["pub"],"application/x-msschedule":["scd"],"application/x-msterminal":["trm"],"application/x-mswrite":["wri"],"application/x-netcdf":["nc","cdf"],"application/x-ns-proxy-autoconfig":["pac"],"application/x-nzb":["nzb"],"application/x-perl":["pl","pm"],"application/x-pilot":["prc","pdb"],"application/x-pkcs12":["p12","pfx"],"application/x-pkcs7-certificates":["p7b","spc"],"application/x-pkcs7-certreqresp":["p7r"],"application/x-rar-compressed":["rar"],"application/x-redhat-package-manager":["rpm"],"application/x-research-info-systems":["ris"],"application/x-sea":["sea"],"application/x-sh":["sh"],"application/x-shar":["shar"],"application/x-shockwave-flash":["swf"],"application/x-silverlight-app":["xap"],"application/x-sql":["sql"],"application/x-stuffit":["sit"],"application/x-stuffitx":["sitx"],"application/x-subrip":["srt"],"application/x-sv4cpio":["sv4cpio"],"application/x-sv4crc":["sv4crc"],"application/x-t3vm-image":["t3"],"application/x-tads":["gam"],"application/x-tar":["tar"],"application/x-tcl":["tcl","tk"],"application/x-tex":["tex"],"application/x-tex-tfm":["tfm"],"application/x-texinfo":["texinfo","texi"],"application/x-tgif":["obj"],"application/x-ustar":["ustar"],"application/x-virtualbox-hdd":["hdd"],"application/x-virtualbox-ova":["ova"],"application/x-virtualbox-ovf":["ovf"],"application/x-virtualbox-vbox":["vbox"],"application/x-virtualbox-vbox-extpack":["vbox-extpack"],"application/x-virtualbox-vdi":["vdi"],"application/x-virtualbox-vhd":["vhd"],"application/x-virtualbox-vmdk":["vmdk"],"application/x-wais-source":["src"],"application/x-web-app-manifest+json":["webapp"],"application/x-x509-ca-cert":["der","crt","pem"],"application/x-xfig":["fig"],"application/x-xliff+xml":["xlf"],"application/x-xpinstall":["xpi"],"application/x-xz":["xz"],"application/x-zmachine":["z1","z2","z3","z4","z5","z6","z7","z8"],"application/xaml+xml":["xaml"],"application/xcap-diff+xml":["xdf"],"application/xenc+xml":["xenc"],"application/xhtml+xml":["xhtml","xht"],"application/xml":["xml","xsl","xsd","rng"],"application/xml-dtd":["dtd"],"application/xop+xml":["xop"],"application/xproc+xml":["xpl"],"application/xslt+xml":["xslt"],"application/xspf+xml":["xspf"],"application/xv+xml":["mxml","xhvml","xvml","xvm"],"application/yang":["yang"],"application/yin+xml":["yin"],"application/zip":["zip"],"audio/3gpp":["3gpp"],"audio/adpcm":["adp"],"audio/basic":["au","snd"],"audio/midi":["mid","midi","kar","rmi"],"audio/mp3":["mp3"],"audio/mp4":["m4a","mp4a"],"audio/mpeg":["mpga","mp2","mp2a","mp3","m2a","m3a"],"audio/ogg":["oga","ogg","spx"],"audio/s3m":["s3m"],"audio/silk":["sil"],"audio/vnd.dece.audio":["uva","uvva"],"audio/vnd.digital-winds":["eol"],"audio/vnd.dra":["dra"],"audio/vnd.dts":["dts"],"audio/vnd.dts.hd":["dtshd"],"audio/vnd.lucent.voice":["lvp"],"audio/vnd.ms-playready.media.pya":["pya"],"audio/vnd.nuera.ecelp4800":["ecelp4800"],"audio/vnd.nuera.ecelp7470":["ecelp7470"],"audio/vnd.nuera.ecelp9600":["ecelp9600"],"audio/vnd.rip":["rip"],"audio/wav":["wav"],"audio/wave":["wav"],"audio/webm":["weba"],"audio/x-aac":["aac"],"audio/x-aiff":["aif","aiff","aifc"],"audio/x-caf":["caf"],"audio/x-flac":["flac"],"audio/x-m4a":["m4a"],"audio/x-matroska":["mka"],"audio/x-mpegurl":["m3u"],"audio/x-ms-wax":["wax"],"audio/x-ms-wma":["wma"],"audio/x-pn-realaudio":["ram","ra"],"audio/x-pn-realaudio-plugin":["rmp"],"audio/x-realaudio":["ra"],"audio/x-wav":["wav"],"audio/xm":["xm"],"chemical/x-cdx":["cdx"],"chemical/x-cif":["cif"],"chemical/x-cmdf":["cmdf"],"chemical/x-cml":["cml"],"chemical/x-csml":["csml"],"chemical/x-xyz":["xyz"],"font/otf":["otf"],"image/apng":["apng"],"image/bmp":["bmp"],"image/cgm":["cgm"],"image/g3fax":["g3"],"image/gif":["gif"],"image/ief":["ief"],"image/jpeg":["jpeg","jpg","jpe"],"image/ktx":["ktx"],"image/png":["png"],"image/prs.btif":["btif"],"image/sgi":["sgi"],"image/svg+xml":["svg","svgz"],"image/tiff":["tiff","tif"],"image/vnd.adobe.photoshop":["psd"],"image/vnd.dece.graphic":["uvi","uvvi","uvg","uvvg"],"image/vnd.djvu":["djvu","djv"],"image/vnd.dvb.subtitle":["sub"],"image/vnd.dwg":["dwg"],"image/vnd.dxf":["dxf"],"image/vnd.fastbidsheet":["fbs"],"image/vnd.fpx":["fpx"],"image/vnd.fst":["fst"],"image/vnd.fujixerox.edmics-mmr":["mmr"],"image/vnd.fujixerox.edmics-rlc":["rlc"],"image/vnd.ms-modi":["mdi"],"image/vnd.ms-photo":["wdp"],"image/vnd.net-fpx":["npx"],"image/vnd.wap.wbmp":["wbmp"],"image/vnd.xiff":["xif"],"image/webp":["webp"],"image/x-3ds":["3ds"],"image/x-cmu-raster":["ras"],"image/x-cmx":["cmx"],"image/x-freehand":["fh","fhc","fh4","fh5","fh7"],"image/x-icon":["ico"],"image/x-jng":["jng"],"image/x-mrsid-image":["sid"],"image/x-ms-bmp":["bmp"],"image/x-pcx":["pcx"],"image/x-pict":["pic","pct"],"image/x-portable-anymap":["pnm"],"image/x-portable-bitmap":["pbm"],"image/x-portable-graymap":["pgm"],"image/x-portable-pixmap":["ppm"],"image/x-rgb":["rgb"],"image/x-tga":["tga"],"image/x-xbitmap":["xbm"],"image/x-xpixmap":["xpm"],"image/x-xwindowdump":["xwd"],"message/rfc822":["eml","mime"],"model/gltf+json":["gltf"],"model/gltf-binary":["glb"],"model/iges":["igs","iges"],"model/mesh":["msh","mesh","silo"],"model/vnd.collada+xml":["dae"],"model/vnd.dwf":["dwf"],"model/vnd.gdl":["gdl"],"model/vnd.gtw":["gtw"],"model/vnd.mts":["mts"],"model/vnd.vtu":["vtu"],"model/vrml":["wrl","vrml"],"model/x3d+binary":["x3db","x3dbz"],"model/x3d+vrml":["x3dv","x3dvz"],"model/x3d+xml":["x3d","x3dz"],"text/cache-manifest":["appcache","manifest"],"text/calendar":["ics","ifb"],"text/coffeescript":["coffee","litcoffee"],"text/css":["css"],"text/csv":["csv"],"text/hjson":["hjson"],"text/html":["html","htm","shtml"],"text/jade":["jade"],"text/jsx":["jsx"],"text/less":["less"],"text/markdown":["markdown","md"],"text/mathml":["mml"],"text/n3":["n3"],"text/plain":["txt","text","conf","def","list","log","in","ini"],"text/prs.lines.tag":["dsc"],"text/richtext":["rtx"],"text/rtf":["rtf"],"text/sgml":["sgml","sgm"],"text/slim":["slim","slm"],"text/stylus":["stylus","styl"],"text/tab-separated-values":["tsv"],"text/troff":["t","tr","roff","man","me","ms"],"text/turtle":["ttl"],"text/uri-list":["uri","uris","urls"],"text/vcard":["vcard"],"text/vnd.curl":["curl"],"text/vnd.curl.dcurl":["dcurl"],"text/vnd.curl.mcurl":["mcurl"],"text/vnd.curl.scurl":["scurl"],"text/vnd.dvb.subtitle":["sub"],"text/vnd.fly":["fly"],"text/vnd.fmi.flexstor":["flx"],"text/vnd.graphviz":["gv"],"text/vnd.in3d.3dml":["3dml"],"text/vnd.in3d.spot":["spot"],"text/vnd.sun.j2me.app-descriptor":["jad"],"text/vnd.wap.wml":["wml"],"text/vnd.wap.wmlscript":["wmls"],"text/vtt":["vtt"],"text/x-asm":["s","asm"],"text/x-c":["c","cc","cxx","cpp","h","hh","dic"],"text/x-component":["htc"],"text/x-fortran":["f","for","f77","f90"],"text/x-handlebars-template":["hbs"],"text/x-java-source":["java"],"text/x-lua":["lua"],"text/x-markdown":["mkd"],"text/x-nfo":["nfo"],"text/x-opml":["opml"],"text/x-org":["org"],"text/x-pascal":["p","pas"],"text/x-processing":["pde"],"text/x-sass":["sass"],"text/x-scss":["scss"],"text/x-setext":["etx"],"text/x-sfv":["sfv"],"text/x-suse-ymp":["ymp"],"text/x-uuencode":["uu"],"text/x-vcalendar":["vcs"],"text/x-vcard":["vcf"],"text/xml":["xml"],"text/yaml":["yaml","yml"],"video/3gpp":["3gp","3gpp"],"video/3gpp2":["3g2"],"video/h261":["h261"],"video/h263":["h263"],"video/h264":["h264"],"video/jpeg":["jpgv"],"video/jpm":["jpm","jpgm"],"video/mj2":["mj2","mjp2"],"video/mp2t":["ts"],"video/mp4":["mp4","mp4v","mpg4"],"video/mpeg":["mpeg","mpg","mpe","m1v","m2v"],"video/ogg":["ogv"],"video/quicktime":["qt","mov"],"video/vnd.dece.hd":["uvh","uvvh"],"video/vnd.dece.mobile":["uvm","uvvm"],"video/vnd.dece.pd":["uvp","uvvp"],"video/vnd.dece.sd":["uvs","uvvs"],"video/vnd.dece.video":["uvv","uvvv"],"video/vnd.dvb.file":["dvb"],"video/vnd.fvt":["fvt"],"video/vnd.mpegurl":["mxu","m4u"],"video/vnd.ms-playready.media.pyv":["pyv"],"video/vnd.uvvu.mp4":["uvu","uvvu"],"video/vnd.vivo":["viv"],"video/webm":["webm"],"video/x-f4v":["f4v"],"video/x-fli":["fli"],"video/x-flv":["flv"],"video/x-m4v":["m4v"],"video/x-matroska":["mkv","mk3d","mks"],"video/x-mng":["mng"],"video/x-ms-asf":["asf","asx"],"video/x-ms-vob":["vob"],"video/x-ms-wm":["wm"],"video/x-ms-wmv":["wmv"],"video/x-ms-wmx":["wmx"],"video/x-ms-wvx":["wvx"],"video/x-msvideo":["avi"],"video/x-sgi-movie":["movie"],"video/x-smv":["smv"],"x-conference/x-cooltalk":["ice"]}

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = forwarded

/**
 * Get all addresses in the request, using the `X-Forwarded-For` header.
 *
 * @param {object} req
 * @return {array}
 * @public
 */

function forwarded (req) {
  if (!req) {
    throw new TypeError('argument req is required')
  }

  // simple header parsing
  var proxyAddrs = parse(req.headers['x-forwarded-for'] || '')
  var socketAddr = req.connection.remoteAddress
  var addrs = [socketAddr].concat(proxyAddrs)

  // return all addresses
  return addrs
}

/**
 * Parse the X-Forwarded-For header.
 *
 * @param {string} header
 * @private
 */

function parse (header) {
  var end = header.length
  var list = []
  var start = header.length

  // gather addresses, backwards
  for (var i = header.length - 1; i >= 0; i--) {
    switch (header.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i
        }
        break
      case 0x2c: /* , */
        if (start !== end) {
          list.push(header.substring(start, end))
        }
        start = end = i
        break
      default:
        start = i
        break
    }
  }

  // final address
  if (start !== end) {
    list.push(header.substring(start, end))
  }

  return list
}


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {(function() {
  var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;

  ipaddr = {};

  root = this;

  if ((typeof module !== "undefined" && module !== null) && module.exports) {
    module.exports = ipaddr;
  } else {
    root['ipaddr'] = ipaddr;
  }

  matchCIDR = function(first, second, partSize, cidrBits) {
    var part, shift;
    if (first.length !== second.length) {
      throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
    }
    part = 0;
    while (cidrBits > 0) {
      shift = partSize - cidrBits;
      if (shift < 0) {
        shift = 0;
      }
      if (first[part] >> shift !== second[part] >> shift) {
        return false;
      }
      cidrBits -= partSize;
      part += 1;
    }
    return true;
  };

  ipaddr.subnetMatch = function(address, rangeList, defaultName) {
    var k, len, rangeName, rangeSubnets, subnet;
    if (defaultName == null) {
      defaultName = 'unicast';
    }
    for (rangeName in rangeList) {
      rangeSubnets = rangeList[rangeName];
      if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
        rangeSubnets = [rangeSubnets];
      }
      for (k = 0, len = rangeSubnets.length; k < len; k++) {
        subnet = rangeSubnets[k];
        if (address.kind() === subnet[0].kind()) {
          if (address.match.apply(address, subnet)) {
            return rangeName;
          }
        }
      }
    }
    return defaultName;
  };

  ipaddr.IPv4 = (function() {
    function IPv4(octets) {
      var k, len, octet;
      if (octets.length !== 4) {
        throw new Error("ipaddr: ipv4 octet count should be 4");
      }
      for (k = 0, len = octets.length; k < len; k++) {
        octet = octets[k];
        if (!((0 <= octet && octet <= 255))) {
          throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
        }
      }
      this.octets = octets;
    }

    IPv4.prototype.kind = function() {
      return 'ipv4';
    };

    IPv4.prototype.toString = function() {
      return this.octets.join(".");
    };

    IPv4.prototype.toNormalizedString = function() {
      return this.toString();
    };

    IPv4.prototype.toByteArray = function() {
      return this.octets.slice(0);
    };

    IPv4.prototype.match = function(other, cidrRange) {
      var ref;
      if (cidrRange === void 0) {
        ref = other, other = ref[0], cidrRange = ref[1];
      }
      if (other.kind() !== 'ipv4') {
        throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
      }
      return matchCIDR(this.octets, other.octets, 8, cidrRange);
    };

    IPv4.prototype.SpecialRanges = {
      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
      multicast: [[new IPv4([224, 0, 0, 0]), 4]],
      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
      loopback: [[new IPv4([127, 0, 0, 0]), 8]],
      carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
      "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
    };

    IPv4.prototype.range = function() {
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    };

    IPv4.prototype.toIPv4MappedAddress = function() {
      return ipaddr.IPv6.parse("::ffff:" + (this.toString()));
    };

    IPv4.prototype.prefixLengthFromSubnetMask = function() {
      var cidr, i, k, octet, stop, zeros, zerotable;
      zerotable = {
        0: 8,
        128: 7,
        192: 6,
        224: 5,
        240: 4,
        248: 3,
        252: 2,
        254: 1,
        255: 0
      };
      cidr = 0;
      stop = false;
      for (i = k = 3; k >= 0; i = k += -1) {
        octet = this.octets[i];
        if (octet in zerotable) {
          zeros = zerotable[octet];
          if (stop && zeros !== 0) {
            return null;
          }
          if (zeros !== 8) {
            stop = true;
          }
          cidr += zeros;
        } else {
          return null;
        }
      }
      return 32 - cidr;
    };

    return IPv4;

  })();

  ipv4Part = "(0?\\d+|0x[a-f0-9]+)";

  ipv4Regexes = {
    fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
    longValue: new RegExp("^" + ipv4Part + "$", 'i')
  };

  ipaddr.IPv4.parser = function(string) {
    var match, parseIntAuto, part, shift, value;
    parseIntAuto = function(string) {
      if (string[0] === "0" && string[1] !== "x") {
        return parseInt(string, 8);
      } else {
        return parseInt(string);
      }
    };
    if (match = string.match(ipv4Regexes.fourOctet)) {
      return (function() {
        var k, len, ref, results;
        ref = match.slice(1, 6);
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          part = ref[k];
          results.push(parseIntAuto(part));
        }
        return results;
      })();
    } else if (match = string.match(ipv4Regexes.longValue)) {
      value = parseIntAuto(match[1]);
      if (value > 0xffffffff || value < 0) {
        throw new Error("ipaddr: address outside defined range");
      }
      return ((function() {
        var k, results;
        results = [];
        for (shift = k = 0; k <= 24; shift = k += 8) {
          results.push((value >> shift) & 0xff);
        }
        return results;
      })()).reverse();
    } else {
      return null;
    }
  };

  ipaddr.IPv6 = (function() {
    function IPv6(parts, zoneId) {
      var i, k, l, len, part, ref;
      if (parts.length === 16) {
        this.parts = [];
        for (i = k = 0; k <= 14; i = k += 2) {
          this.parts.push((parts[i] << 8) | parts[i + 1]);
        }
      } else if (parts.length === 8) {
        this.parts = parts;
      } else {
        throw new Error("ipaddr: ipv6 part count should be 8 or 16");
      }
      ref = this.parts;
      for (l = 0, len = ref.length; l < len; l++) {
        part = ref[l];
        if (!((0 <= part && part <= 0xffff))) {
          throw new Error("ipaddr: ipv6 part should fit in 16 bits");
        }
      }
      if (zoneId) {
        this.zoneId = zoneId;
      }
    }

    IPv6.prototype.kind = function() {
      return 'ipv6';
    };

    IPv6.prototype.toString = function() {
      return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, '::');
    };

    IPv6.prototype.toRFC5952String = function() {
      var bestMatchIndex, bestMatchLength, match, regex, string;
      regex = /((^|:)(0(:|$)){2,})/g;
      string = this.toNormalizedString();
      bestMatchIndex = 0;
      bestMatchLength = -1;
      while ((match = regex.exec(string))) {
        if (match[0].length > bestMatchLength) {
          bestMatchIndex = match.index;
          bestMatchLength = match[0].length;
        }
      }
      if (bestMatchLength < 0) {
        return string;
      }
      return string.substring(0, bestMatchIndex) + '::' + string.substring(bestMatchIndex + bestMatchLength);
    };

    IPv6.prototype.toByteArray = function() {
      var bytes, k, len, part, ref;
      bytes = [];
      ref = this.parts;
      for (k = 0, len = ref.length; k < len; k++) {
        part = ref[k];
        bytes.push(part >> 8);
        bytes.push(part & 0xff);
      }
      return bytes;
    };

    IPv6.prototype.toNormalizedString = function() {
      var addr, part, suffix;
      addr = ((function() {
        var k, len, ref, results;
        ref = this.parts;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          part = ref[k];
          results.push(part.toString(16));
        }
        return results;
      }).call(this)).join(":");
      suffix = '';
      if (this.zoneId) {
        suffix = '%' + this.zoneId;
      }
      return addr + suffix;
    };

    IPv6.prototype.toFixedLengthString = function() {
      var addr, part, suffix;
      addr = ((function() {
        var k, len, ref, results;
        ref = this.parts;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          part = ref[k];
          results.push(part.toString(16).padStart(4, '0'));
        }
        return results;
      }).call(this)).join(":");
      suffix = '';
      if (this.zoneId) {
        suffix = '%' + this.zoneId;
      }
      return addr + suffix;
    };

    IPv6.prototype.match = function(other, cidrRange) {
      var ref;
      if (cidrRange === void 0) {
        ref = other, other = ref[0], cidrRange = ref[1];
      }
      if (other.kind() !== 'ipv6') {
        throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
      }
      return matchCIDR(this.parts, other.parts, 16, cidrRange);
    };

    IPv6.prototype.SpecialRanges = {
      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
      reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]
    };

    IPv6.prototype.range = function() {
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    };

    IPv6.prototype.isIPv4MappedAddress = function() {
      return this.range() === 'ipv4Mapped';
    };

    IPv6.prototype.toIPv4Address = function() {
      var high, low, ref;
      if (!this.isIPv4MappedAddress()) {
        throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
      }
      ref = this.parts.slice(-2), high = ref[0], low = ref[1];
      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
    };

    IPv6.prototype.prefixLengthFromSubnetMask = function() {
      var cidr, i, k, part, stop, zeros, zerotable;
      zerotable = {
        0: 16,
        32768: 15,
        49152: 14,
        57344: 13,
        61440: 12,
        63488: 11,
        64512: 10,
        65024: 9,
        65280: 8,
        65408: 7,
        65472: 6,
        65504: 5,
        65520: 4,
        65528: 3,
        65532: 2,
        65534: 1,
        65535: 0
      };
      cidr = 0;
      stop = false;
      for (i = k = 7; k >= 0; i = k += -1) {
        part = this.parts[i];
        if (part in zerotable) {
          zeros = zerotable[part];
          if (stop && zeros !== 0) {
            return null;
          }
          if (zeros !== 16) {
            stop = true;
          }
          cidr += zeros;
        } else {
          return null;
        }
      }
      return 128 - cidr;
    };

    return IPv6;

  })();

  ipv6Part = "(?:[0-9a-f]+::?)+";

  zoneIndex = "%[0-9a-z]{1,}";

  ipv6Regexes = {
    zoneIndex: new RegExp(zoneIndex, 'i'),
    "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", 'i'),
    transitional: new RegExp(("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)") + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), 'i')
  };

  expandIPv6 = function(string, parts) {
    var colonCount, lastColon, part, replacement, replacementCount, zoneId;
    if (string.indexOf('::') !== string.lastIndexOf('::')) {
      return null;
    }
    zoneId = (string.match(ipv6Regexes['zoneIndex']) || [])[0];
    if (zoneId) {
      zoneId = zoneId.substring(1);
      string = string.replace(/%.+$/, '');
    }
    colonCount = 0;
    lastColon = -1;
    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {
      colonCount++;
    }
    if (string.substr(0, 2) === '::') {
      colonCount--;
    }
    if (string.substr(-2, 2) === '::') {
      colonCount--;
    }
    if (colonCount > parts) {
      return null;
    }
    replacementCount = parts - colonCount;
    replacement = ':';
    while (replacementCount--) {
      replacement += '0:';
    }
    string = string.replace('::', replacement);
    if (string[0] === ':') {
      string = string.slice(1);
    }
    if (string[string.length - 1] === ':') {
      string = string.slice(0, -1);
    }
    parts = (function() {
      var k, len, ref, results;
      ref = string.split(":");
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        part = ref[k];
        results.push(parseInt(part, 16));
      }
      return results;
    })();
    return {
      parts: parts,
      zoneId: zoneId
    };
  };

  ipaddr.IPv6.parser = function(string) {
    var addr, k, len, match, octet, octets, zoneId;
    if (ipv6Regexes['native'].test(string)) {
      return expandIPv6(string, 8);
    } else if (match = string.match(ipv6Regexes['transitional'])) {
      zoneId = match[6] || '';
      addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
      if (addr.parts) {
        octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
        for (k = 0, len = octets.length; k < len; k++) {
          octet = octets[k];
          if (!((0 <= octet && octet <= 255))) {
            return null;
          }
        }
        addr.parts.push(octets[0] << 8 | octets[1]);
        addr.parts.push(octets[2] << 8 | octets[3]);
        return {
          parts: addr.parts,
          zoneId: addr.zoneId
        };
      }
    }
    return null;
  };

  ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
    return this.parser(string) !== null;
  };

  ipaddr.IPv4.isValid = function(string) {
    var e;
    try {
      new this(this.parser(string));
      return true;
    } catch (error1) {
      e = error1;
      return false;
    }
  };

  ipaddr.IPv4.isValidFourPartDecimal = function(string) {
    if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
      return true;
    } else {
      return false;
    }
  };

  ipaddr.IPv6.isValid = function(string) {
    var addr, e;
    if (typeof string === "string" && string.indexOf(":") === -1) {
      return false;
    }
    try {
      addr = this.parser(string);
      new this(addr.parts, addr.zoneId);
      return true;
    } catch (error1) {
      e = error1;
      return false;
    }
  };

  ipaddr.IPv4.parse = function(string) {
    var parts;
    parts = this.parser(string);
    if (parts === null) {
      throw new Error("ipaddr: string is not formatted like ip address");
    }
    return new this(parts);
  };

  ipaddr.IPv6.parse = function(string) {
    var addr;
    addr = this.parser(string);
    if (addr.parts === null) {
      throw new Error("ipaddr: string is not formatted like ip address");
    }
    return new this(addr.parts, addr.zoneId);
  };

  ipaddr.IPv4.parseCIDR = function(string) {
    var maskLength, match, parsed;
    if (match = string.match(/^(.+)\/(\d+)$/)) {
      maskLength = parseInt(match[2]);
      if (maskLength >= 0 && maskLength <= 32) {
        parsed = [this.parse(match[1]), maskLength];
        Object.defineProperty(parsed, 'toString', {
          value: function() {
            return this.join('/');
          }
        });
        return parsed;
      }
    }
    throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
  };

  ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
    var filledOctetCount, j, octets;
    prefix = parseInt(prefix);
    if (prefix < 0 || prefix > 32) {
      throw new Error('ipaddr: invalid IPv4 prefix length');
    }
    octets = [0, 0, 0, 0];
    j = 0;
    filledOctetCount = Math.floor(prefix / 8);
    while (j < filledOctetCount) {
      octets[j] = 255;
      j++;
    }
    if (filledOctetCount < 4) {
      octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);
    }
    return new this(octets);
  };

  ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
    var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
    try {
      cidr = this.parseCIDR(string);
      ipInterfaceOctets = cidr[0].toByteArray();
      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
      octets = [];
      i = 0;
      while (i < 4) {
        octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
        i++;
      }
      return new this(octets);
    } catch (error1) {
      error = error1;
      throw new Error('ipaddr: the address does not have IPv4 CIDR format');
    }
  };

  ipaddr.IPv4.networkAddressFromCIDR = function(string) {
    var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
    try {
      cidr = this.parseCIDR(string);
      ipInterfaceOctets = cidr[0].toByteArray();
      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
      octets = [];
      i = 0;
      while (i < 4) {
        octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
        i++;
      }
      return new this(octets);
    } catch (error1) {
      error = error1;
      throw new Error('ipaddr: the address does not have IPv4 CIDR format');
    }
  };

  ipaddr.IPv6.parseCIDR = function(string) {
    var maskLength, match, parsed;
    if (match = string.match(/^(.+)\/(\d+)$/)) {
      maskLength = parseInt(match[2]);
      if (maskLength >= 0 && maskLength <= 128) {
        parsed = [this.parse(match[1]), maskLength];
        Object.defineProperty(parsed, 'toString', {
          value: function() {
            return this.join('/');
          }
        });
        return parsed;
      }
    }
    throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
  };

  ipaddr.isValid = function(string) {
    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
  };

  ipaddr.parse = function(string) {
    if (ipaddr.IPv6.isValid(string)) {
      return ipaddr.IPv6.parse(string);
    } else if (ipaddr.IPv4.isValid(string)) {
      return ipaddr.IPv4.parse(string);
    } else {
      throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
    }
  };

  ipaddr.parseCIDR = function(string) {
    var e;
    try {
      return ipaddr.IPv6.parseCIDR(string);
    } catch (error1) {
      e = error1;
      try {
        return ipaddr.IPv4.parseCIDR(string);
      } catch (error1) {
        e = error1;
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
      }
    }
  };

  ipaddr.fromByteArray = function(bytes) {
    var length;
    length = bytes.length;
    if (length === 4) {
      return new ipaddr.IPv4(bytes);
    } else if (length === 16) {
      return new ipaddr.IPv6(bytes);
    } else {
      throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
    }
  };

  ipaddr.process = function(string) {
    var addr;
    addr = this.parse(string);
    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
      return addr.toIPv4Address();
    } else {
      return addr;
    }
  };

}).call(this);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(132)(module)))

/***/ }),
/* 132 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var accepts = __webpack_require__(64);
var deprecate = __webpack_require__(5)('express');
var isIP = __webpack_require__(35).isIP;
var typeis = __webpack_require__(15);
var http = __webpack_require__(4);
var fresh = __webpack_require__(61);
var parseRange = __webpack_require__(62);
var parse = __webpack_require__(16);
var proxyaddr = __webpack_require__(63);

/**
 * Request prototype.
 * @public
 */

var req = Object.create(http.IncomingMessage.prototype)

/**
 * Module exports.
 * @public
 */

module.exports = req

/**
 * Return request header.
 *
 * The `Referrer` header field is special-cased,
 * both `Referrer` and `Referer` are interchangeable.
 *
 * Examples:
 *
 *     req.get('Content-Type');
 *     // => "text/plain"
 *
 *     req.get('content-type');
 *     // => "text/plain"
 *
 *     req.get('Something');
 *     // => undefined
 *
 * Aliased as `req.header()`.
 *
 * @param {String} name
 * @return {String}
 * @public
 */

req.get =
req.header = function header(name) {
  if (!name) {
    throw new TypeError('name argument is required to req.get');
  }

  if (typeof name !== 'string') {
    throw new TypeError('name must be a string to req.get');
  }

  var lc = name.toLowerCase();

  switch (lc) {
    case 'referer':
    case 'referrer':
      return this.headers.referrer
        || this.headers.referer;
    default:
      return this.headers[lc];
  }
};

/**
 * To do: update docs.
 *
 * Check if the given `type(s)` is acceptable, returning
 * the best match when true, otherwise `undefined`, in which
 * case you should respond with 406 "Not Acceptable".
 *
 * The `type` value may be a single MIME type string
 * such as "application/json", an extension name
 * such as "json", a comma-delimited list such as "json, html, text/plain",
 * an argument list such as `"json", "html", "text/plain"`,
 * or an array `["json", "html", "text/plain"]`. When a list
 * or array is given, the _best_ match, if any is returned.
 *
 * Examples:
 *
 *     // Accept: text/html
 *     req.accepts('html');
 *     // => "html"
 *
 *     // Accept: text/*, application/json
 *     req.accepts('html');
 *     // => "html"
 *     req.accepts('text/html');
 *     // => "text/html"
 *     req.accepts('json, text');
 *     // => "json"
 *     req.accepts('application/json');
 *     // => "application/json"
 *
 *     // Accept: text/*, application/json
 *     req.accepts('image/png');
 *     req.accepts('png');
 *     // => undefined
 *
 *     // Accept: text/*;q=.5, application/json
 *     req.accepts(['html', 'json']);
 *     req.accepts('html', 'json');
 *     req.accepts('html, json');
 *     // => "json"
 *
 * @param {String|Array} type(s)
 * @return {String|Array|Boolean}
 * @public
 */

req.accepts = function(){
  var accept = accepts(this);
  return accept.types.apply(accept, arguments);
};

/**
 * Check if the given `encoding`s are accepted.
 *
 * @param {String} ...encoding
 * @return {String|Array}
 * @public
 */

req.acceptsEncodings = function(){
  var accept = accepts(this);
  return accept.encodings.apply(accept, arguments);
};

req.acceptsEncoding = deprecate.function(req.acceptsEncodings,
  'req.acceptsEncoding: Use acceptsEncodings instead');

/**
 * Check if the given `charset`s are acceptable,
 * otherwise you should respond with 406 "Not Acceptable".
 *
 * @param {String} ...charset
 * @return {String|Array}
 * @public
 */

req.acceptsCharsets = function(){
  var accept = accepts(this);
  return accept.charsets.apply(accept, arguments);
};

req.acceptsCharset = deprecate.function(req.acceptsCharsets,
  'req.acceptsCharset: Use acceptsCharsets instead');

/**
 * Check if the given `lang`s are acceptable,
 * otherwise you should respond with 406 "Not Acceptable".
 *
 * @param {String} ...lang
 * @return {String|Array}
 * @public
 */

req.acceptsLanguages = function(){
  var accept = accepts(this);
  return accept.languages.apply(accept, arguments);
};

req.acceptsLanguage = deprecate.function(req.acceptsLanguages,
  'req.acceptsLanguage: Use acceptsLanguages instead');

/**
 * Parse Range header field, capping to the given `size`.
 *
 * Unspecified ranges such as "0-" require knowledge of your resource length. In
 * the case of a byte range this is of course the total number of bytes. If the
 * Range header field is not given `undefined` is returned, `-1` when unsatisfiable,
 * and `-2` when syntactically invalid.
 *
 * When ranges are returned, the array has a "type" property which is the type of
 * range that is required (most commonly, "bytes"). Each array element is an object
 * with a "start" and "end" property for the portion of the range.
 *
 * The "combine" option can be set to `true` and overlapping & adjacent ranges
 * will be combined into a single range.
 *
 * NOTE: remember that ranges are inclusive, so for example "Range: users=0-3"
 * should respond with 4 users when available, not 3.
 *
 * @param {number} size
 * @param {object} [options]
 * @param {boolean} [options.combine=false]
 * @return {number|array}
 * @public
 */

req.range = function range(size, options) {
  var range = this.get('Range');
  if (!range) return;
  return parseRange(size, range, options);
};

/**
 * Return the value of param `name` when present or `defaultValue`.
 *
 *  - Checks route placeholders, ex: _/user/:id_
 *  - Checks body params, ex: id=12, {"id":12}
 *  - Checks query string params, ex: ?id=12
 *
 * To utilize request bodies, `req.body`
 * should be an object. This can be done by using
 * the `bodyParser()` middleware.
 *
 * @param {String} name
 * @param {Mixed} [defaultValue]
 * @return {String}
 * @public
 */

req.param = function param(name, defaultValue) {
  var params = this.params || {};
  var body = this.body || {};
  var query = this.query || {};

  var args = arguments.length === 1
    ? 'name'
    : 'name, default';
  deprecate('req.param(' + args + '): Use req.params, req.body, or req.query instead');

  if (null != params[name] && params.hasOwnProperty(name)) return params[name];
  if (null != body[name]) return body[name];
  if (null != query[name]) return query[name];

  return defaultValue;
};

/**
 * Check if the incoming request contains the "Content-Type"
 * header field, and it contains the give mime `type`.
 *
 * Examples:
 *
 *      // With Content-Type: text/html; charset=utf-8
 *      req.is('html');
 *      req.is('text/html');
 *      req.is('text/*');
 *      // => true
 *
 *      // When Content-Type is application/json
 *      req.is('json');
 *      req.is('application/json');
 *      req.is('application/*');
 *      // => true
 *
 *      req.is('html');
 *      // => false
 *
 * @param {String|Array} types...
 * @return {String|false|null}
 * @public
 */

req.is = function is(types) {
  var arr = types;

  // support flattened arguments
  if (!Array.isArray(types)) {
    arr = new Array(arguments.length);
    for (var i = 0; i < arr.length; i++) {
      arr[i] = arguments[i];
    }
  }

  return typeis(this, arr);
};

/**
 * Return the protocol string "http" or "https"
 * when requested with TLS. When the "trust proxy"
 * setting trusts the socket address, the
 * "X-Forwarded-Proto" header field will be trusted
 * and used if present.
 *
 * If you're running behind a reverse proxy that
 * supplies https for you this may be enabled.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'protocol', function protocol(){
  var proto = this.connection.encrypted
    ? 'https'
    : 'http';
  var trust = this.app.get('trust proxy fn');

  if (!trust(this.connection.remoteAddress, 0)) {
    return proto;
  }

  // Note: X-Forwarded-Proto is normally only ever a
  //       single value, but this is to be safe.
  var header = this.get('X-Forwarded-Proto') || proto
  var index = header.indexOf(',')

  return index !== -1
    ? header.substring(0, index).trim()
    : header.trim()
});

/**
 * Short-hand for:
 *
 *    req.protocol === 'https'
 *
 * @return {Boolean}
 * @public
 */

defineGetter(req, 'secure', function secure(){
  return this.protocol === 'https';
});

/**
 * Return the remote address from the trusted proxy.
 *
 * The is the remote address on the socket unless
 * "trust proxy" is set.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'ip', function ip(){
  var trust = this.app.get('trust proxy fn');
  return proxyaddr(this, trust);
});

/**
 * When "trust proxy" is set, trusted proxy addresses + client.
 *
 * For example if the value were "client, proxy1, proxy2"
 * you would receive the array `["client", "proxy1", "proxy2"]`
 * where "proxy2" is the furthest down-stream and "proxy1" and
 * "proxy2" were trusted.
 *
 * @return {Array}
 * @public
 */

defineGetter(req, 'ips', function ips() {
  var trust = this.app.get('trust proxy fn');
  var addrs = proxyaddr.all(this, trust);

  // reverse the order (to farthest -> closest)
  // and remove socket address
  addrs.reverse().pop()

  return addrs
});

/**
 * Return subdomains as an array.
 *
 * Subdomains are the dot-separated parts of the host before the main domain of
 * the app. By default, the domain of the app is assumed to be the last two
 * parts of the host. This can be changed by setting "subdomain offset".
 *
 * For example, if the domain is "tobi.ferrets.example.com":
 * If "subdomain offset" is not set, req.subdomains is `["ferrets", "tobi"]`.
 * If "subdomain offset" is 3, req.subdomains is `["tobi"]`.
 *
 * @return {Array}
 * @public
 */

defineGetter(req, 'subdomains', function subdomains() {
  var hostname = this.hostname;

  if (!hostname) return [];

  var offset = this.app.get('subdomain offset');
  var subdomains = !isIP(hostname)
    ? hostname.split('.').reverse()
    : [hostname];

  return subdomains.slice(offset);
});

/**
 * Short-hand for `url.parse(req.url).pathname`.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'path', function path() {
  return parse(this).pathname;
});

/**
 * Parse the "Host" header field to a hostname.
 *
 * When the "trust proxy" setting trusts the socket
 * address, the "X-Forwarded-Host" header field will
 * be trusted.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'hostname', function hostname(){
  var trust = this.app.get('trust proxy fn');
  var host = this.get('X-Forwarded-Host');

  if (!host || !trust(this.connection.remoteAddress, 0)) {
    host = this.get('Host');
  }

  if (!host) return;

  // IPv6 literal support
  var offset = host[0] === '['
    ? host.indexOf(']') + 1
    : 0;
  var index = host.indexOf(':', offset);

  return index !== -1
    ? host.substring(0, index)
    : host;
});

// TODO: change req.host to return host in next major

defineGetter(req, 'host', deprecate.function(function host(){
  return this.hostname;
}, 'req.host: Use req.hostname instead'));

/**
 * Check if the request is fresh, aka
 * Last-Modified and/or the ETag
 * still match.
 *
 * @return {Boolean}
 * @public
 */

defineGetter(req, 'fresh', function(){
  var method = this.method;
  var res = this.res
  var status = res.statusCode

  // GET or HEAD for weak freshness validation only
  if ('GET' !== method && 'HEAD' !== method) return false;

  // 2xx or 304 as per rfc2616 14.26
  if ((status >= 200 && status < 300) || 304 === status) {
    return fresh(this.headers, {
      'etag': res.get('ETag'),
      'last-modified': res.get('Last-Modified')
    })
  }

  return false;
});

/**
 * Check if the request is stale, aka
 * "Last-Modified" and / or the "ETag" for the
 * resource has changed.
 *
 * @return {Boolean}
 * @public
 */

defineGetter(req, 'stale', function stale(){
  return !this.fresh;
});

/**
 * Check if the request was an _XMLHttpRequest_.
 *
 * @return {Boolean}
 * @public
 */

defineGetter(req, 'xhr', function xhr(){
  var val = this.get('X-Requested-With') || '';
  return val.toLowerCase() === 'xmlhttprequest';
});

/**
 * Helper function for creating a getter on an object.
 *
 * @param {Object} obj
 * @param {String} name
 * @param {Function} getter
 * @private
 */
function defineGetter(obj, name, getter) {
  Object.defineProperty(obj, name, {
    configurable: true,
    enumerable: true,
    get: getter
  });
}


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Cached loaded submodules.
 * @private
 */

var modules = Object.create(null);

/**
 * Module exports.
 * @public
 */

module.exports = Negotiator;
module.exports.Negotiator = Negotiator;

/**
 * Create a Negotiator instance from a request.
 * @param {object} request
 * @public
 */

function Negotiator(request) {
  if (!(this instanceof Negotiator)) {
    return new Negotiator(request);
  }

  this.request = request;
}

Negotiator.prototype.charset = function charset(available) {
  var set = this.charsets(available);
  return set && set[0];
};

Negotiator.prototype.charsets = function charsets(available) {
  var preferredCharsets = loadModule('charset').preferredCharsets;
  return preferredCharsets(this.request.headers['accept-charset'], available);
};

Negotiator.prototype.encoding = function encoding(available) {
  var set = this.encodings(available);
  return set && set[0];
};

Negotiator.prototype.encodings = function encodings(available) {
  var preferredEncodings = loadModule('encoding').preferredEncodings;
  return preferredEncodings(this.request.headers['accept-encoding'], available);
};

Negotiator.prototype.language = function language(available) {
  var set = this.languages(available);
  return set && set[0];
};

Negotiator.prototype.languages = function languages(available) {
  var preferredLanguages = loadModule('language').preferredLanguages;
  return preferredLanguages(this.request.headers['accept-language'], available);
};

Negotiator.prototype.mediaType = function mediaType(available) {
  var set = this.mediaTypes(available);
  return set && set[0];
};

Negotiator.prototype.mediaTypes = function mediaTypes(available) {
  var preferredMediaTypes = loadModule('mediaType').preferredMediaTypes;
  return preferredMediaTypes(this.request.headers.accept, available);
};

// Backwards compatibility
Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;

/**
 * Load the given module.
 * @private
 */

function loadModule(moduleName) {
  var module = modules[moduleName];

  if (module !== undefined) {
    return module;
  }

  // This uses a switch for static require analysis
  switch (moduleName) {
    case 'charset':
      module = __webpack_require__(135);
      break;
    case 'encoding':
      module = __webpack_require__(136);
      break;
    case 'language':
      module = __webpack_require__(137);
      break;
    case 'mediaType':
      module = __webpack_require__(138);
      break;
    default:
      throw new Error('Cannot find module \'' + moduleName + '\'');
  }

  // Store to prevent invoking require()
  modules[moduleName] = module;

  return module;
}


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = preferredCharsets;
module.exports.preferredCharsets = preferredCharsets;

/**
 * Module variables.
 * @private
 */

var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Charset header.
 * @private
 */

function parseAcceptCharset(accept) {
  var accepts = accept.split(',');

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var charset = parseCharset(accepts[i].trim(), i);

    if (charset) {
      accepts[j++] = charset;
    }
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse a charset from the Accept-Charset header.
 * @private
 */

function parseCharset(str, i) {
  var match = simpleCharsetRegExp.exec(str);
  if (!match) return null;

  var charset = match[1];
  var q = 1;
  if (match[2]) {
    var params = match[2].split(';')
    for (var j = 0; j < params.length; j++) {
      var p = params[j].trim().split('=');
      if (p[0] === 'q') {
        q = parseFloat(p[1]);
        break;
      }
    }
  }

  return {
    charset: charset,
    q: q,
    i: i
  };
}

/**
 * Get the priority of a charset.
 * @private
 */

function getCharsetPriority(charset, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(charset, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the charset.
 * @private
 */

function specify(charset, spec, index) {
  var s = 0;
  if(spec.charset.toLowerCase() === charset.toLowerCase()){
    s |= 1;
  } else if (spec.charset !== '*' ) {
    return null
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  }
}

/**
 * Get the preferred charsets from an Accept-Charset header.
 * @public
 */

function preferredCharsets(accept, provided) {
  // RFC 2616 sec 14.2: no header = *
  var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');

  if (!provided) {
    // sorted list of all charsets
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullCharset);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getCharsetPriority(type, accepts, index);
  });

  // sorted list of accepted charsets
  return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full charset string.
 * @private
 */

function getFullCharset(spec) {
  return spec.charset;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = preferredEncodings;
module.exports.preferredEncodings = preferredEncodings;

/**
 * Module variables.
 * @private
 */

var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Encoding header.
 * @private
 */

function parseAcceptEncoding(accept) {
  var accepts = accept.split(',');
  var hasIdentity = false;
  var minQuality = 1;

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var encoding = parseEncoding(accepts[i].trim(), i);

    if (encoding) {
      accepts[j++] = encoding;
      hasIdentity = hasIdentity || specify('identity', encoding);
      minQuality = Math.min(minQuality, encoding.q || 1);
    }
  }

  if (!hasIdentity) {
    /*
     * If identity doesn't explicitly appear in the accept-encoding header,
     * it's added to the list of acceptable encoding with the lowest q
     */
    accepts[j++] = {
      encoding: 'identity',
      q: minQuality,
      i: i
    };
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse an encoding from the Accept-Encoding header.
 * @private
 */

function parseEncoding(str, i) {
  var match = simpleEncodingRegExp.exec(str);
  if (!match) return null;

  var encoding = match[1];
  var q = 1;
  if (match[2]) {
    var params = match[2].split(';');
    for (var j = 0; j < params.length; j++) {
      var p = params[j].trim().split('=');
      if (p[0] === 'q') {
        q = parseFloat(p[1]);
        break;
      }
    }
  }

  return {
    encoding: encoding,
    q: q,
    i: i
  };
}

/**
 * Get the priority of an encoding.
 * @private
 */

function getEncodingPriority(encoding, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(encoding, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the encoding.
 * @private
 */

function specify(encoding, spec, index) {
  var s = 0;
  if(spec.encoding.toLowerCase() === encoding.toLowerCase()){
    s |= 1;
  } else if (spec.encoding !== '*' ) {
    return null
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  }
};

/**
 * Get the preferred encodings from an Accept-Encoding header.
 * @public
 */

function preferredEncodings(accept, provided) {
  var accepts = parseAcceptEncoding(accept || '');

  if (!provided) {
    // sorted list of all encodings
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullEncoding);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getEncodingPriority(type, accepts, index);
  });

  // sorted list of accepted encodings
  return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full encoding string.
 * @private
 */

function getFullEncoding(spec) {
  return spec.encoding;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = preferredLanguages;
module.exports.preferredLanguages = preferredLanguages;

/**
 * Module variables.
 * @private
 */

var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Language header.
 * @private
 */

function parseAcceptLanguage(accept) {
  var accepts = accept.split(',');

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var language = parseLanguage(accepts[i].trim(), i);

    if (language) {
      accepts[j++] = language;
    }
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse a language from the Accept-Language header.
 * @private
 */

function parseLanguage(str, i) {
  var match = simpleLanguageRegExp.exec(str);
  if (!match) return null;

  var prefix = match[1],
    suffix = match[2],
    full = prefix;

  if (suffix) full += "-" + suffix;

  var q = 1;
  if (match[3]) {
    var params = match[3].split(';')
    for (var j = 0; j < params.length; j++) {
      var p = params[j].split('=');
      if (p[0] === 'q') q = parseFloat(p[1]);
    }
  }

  return {
    prefix: prefix,
    suffix: suffix,
    q: q,
    i: i,
    full: full
  };
}

/**
 * Get the priority of a language.
 * @private
 */

function getLanguagePriority(language, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(language, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the language.
 * @private
 */

function specify(language, spec, index) {
  var p = parseLanguage(language)
  if (!p) return null;
  var s = 0;
  if(spec.full.toLowerCase() === p.full.toLowerCase()){
    s |= 4;
  } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
    s |= 2;
  } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
    s |= 1;
  } else if (spec.full !== '*' ) {
    return null
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  }
};

/**
 * Get the preferred languages from an Accept-Language header.
 * @public
 */

function preferredLanguages(accept, provided) {
  // RFC 2616 sec 14.4: no header = *
  var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');

  if (!provided) {
    // sorted list of all languages
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullLanguage);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getLanguagePriority(type, accepts, index);
  });

  // sorted list of accepted languages
  return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full language string.
 * @private
 */

function getFullLanguage(spec) {
  return spec.full;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = preferredMediaTypes;
module.exports.preferredMediaTypes = preferredMediaTypes;

/**
 * Module variables.
 * @private
 */

var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept header.
 * @private
 */

function parseAccept(accept) {
  var accepts = splitMediaTypes(accept);

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var mediaType = parseMediaType(accepts[i].trim(), i);

    if (mediaType) {
      accepts[j++] = mediaType;
    }
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse a media type from the Accept header.
 * @private
 */

function parseMediaType(str, i) {
  var match = simpleMediaTypeRegExp.exec(str);
  if (!match) return null;

  var params = Object.create(null);
  var q = 1;
  var subtype = match[2];
  var type = match[1];

  if (match[3]) {
    var kvps = splitParameters(match[3]).map(splitKeyValuePair);

    for (var j = 0; j < kvps.length; j++) {
      var pair = kvps[j];
      var key = pair[0].toLowerCase();
      var val = pair[1];

      // get the value, unwrapping quotes
      var value = val && val[0] === '"' && val[val.length - 1] === '"'
        ? val.substr(1, val.length - 2)
        : val;

      if (key === 'q') {
        q = parseFloat(value);
        break;
      }

      // store parameter
      params[key] = value;
    }
  }

  return {
    type: type,
    subtype: subtype,
    params: params,
    q: q,
    i: i
  };
}

/**
 * Get the priority of a media type.
 * @private
 */

function getMediaTypePriority(type, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(type, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the media type.
 * @private
 */

function specify(type, spec, index) {
  var p = parseMediaType(type);
  var s = 0;

  if (!p) {
    return null;
  }

  if(spec.type.toLowerCase() == p.type.toLowerCase()) {
    s |= 4
  } else if(spec.type != '*') {
    return null;
  }

  if(spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
    s |= 2
  } else if(spec.subtype != '*') {
    return null;
  }

  var keys = Object.keys(spec.params);
  if (keys.length > 0) {
    if (keys.every(function (k) {
      return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
    })) {
      s |= 1
    } else {
      return null
    }
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s,
  }
}

/**
 * Get the preferred media types from an Accept header.
 * @public
 */

function preferredMediaTypes(accept, provided) {
  // RFC 2616 sec 14.2: no header = */*
  var accepts = parseAccept(accept === undefined ? '*/*' : accept || '');

  if (!provided) {
    // sorted list of all types
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullType);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getMediaTypePriority(type, accepts, index);
  });

  // sorted list of accepted types
  return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full type string.
 * @private
 */

function getFullType(spec) {
  return spec.type + '/' + spec.subtype;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}

/**
 * Count the number of quotes in a string.
 * @private
 */

function quoteCount(string) {
  var count = 0;
  var index = 0;

  while ((index = string.indexOf('"', index)) !== -1) {
    count++;
    index++;
  }

  return count;
}

/**
 * Split a key value pair.
 * @private
 */

function splitKeyValuePair(str) {
  var index = str.indexOf('=');
  var key;
  var val;

  if (index === -1) {
    key = str;
  } else {
    key = str.substr(0, index);
    val = str.substr(index + 1);
  }

  return [key, val];
}

/**
 * Split an Accept header into media types.
 * @private
 */

function splitMediaTypes(accept) {
  var accepts = accept.split(',');

  for (var i = 1, j = 0; i < accepts.length; i++) {
    if (quoteCount(accepts[j]) % 2 == 0) {
      accepts[++j] = accepts[i];
    } else {
      accepts[j] += ',' + accepts[i];
    }
  }

  // trim accepts
  accepts.length = j + 1;

  return accepts;
}

/**
 * Split a string of parameters.
 * @private
 */

function splitParameters(str) {
  var parameters = str.split(';');

  for (var i = 1, j = 0; i < parameters.length; i++) {
    if (quoteCount(parameters[j]) % 2 == 0) {
      parameters[++j] = parameters[i];
    } else {
      parameters[j] += ';' + parameters[i];
    }
  }

  // trim parameters
  parameters.length = j + 1;

  for (var i = 0; i < parameters.length; i++) {
    parameters[i] = parameters[i].trim();
  }

  return parameters;
}


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var Buffer = __webpack_require__(58).Buffer
var contentDisposition = __webpack_require__(59);
var deprecate = __webpack_require__(5)('express');
var encodeUrl = __webpack_require__(27);
var escapeHtml = __webpack_require__(28);
var http = __webpack_require__(4);
var isAbsolute = __webpack_require__(8).isAbsolute;
var onFinished = __webpack_require__(25);
var path = __webpack_require__(2);
var statuses = __webpack_require__(21)
var merge = __webpack_require__(30);
var sign = __webpack_require__(140).sign;
var normalizeType = __webpack_require__(8).normalizeType;
var normalizeTypes = __webpack_require__(8).normalizeTypes;
var setCharset = __webpack_require__(8).setCharset;
var cookie = __webpack_require__(65);
var send = __webpack_require__(40);
var extname = path.extname;
var mime = send.mime;
var resolve = path.resolve;
var vary = __webpack_require__(141);

/**
 * Response prototype.
 * @public
 */

var res = Object.create(http.ServerResponse.prototype)

/**
 * Module exports.
 * @public
 */

module.exports = res

/**
 * Module variables.
 * @private
 */

var charsetRegExp = /;\s*charset\s*=/;

/**
 * Set status `code`.
 *
 * @param {Number} code
 * @return {ServerResponse}
 * @public
 */

res.status = function status(code) {
  this.statusCode = code;
  return this;
};

/**
 * Set Link header field with the given `links`.
 *
 * Examples:
 *
 *    res.links({
 *      next: 'http://api.example.com/users?page=2',
 *      last: 'http://api.example.com/users?page=5'
 *    });
 *
 * @param {Object} links
 * @return {ServerResponse}
 * @public
 */

res.links = function(links){
  var link = this.get('Link') || '';
  if (link) link += ', ';
  return this.set('Link', link + Object.keys(links).map(function(rel){
    return '<' + links[rel] + '>; rel="' + rel + '"';
  }).join(', '));
};

/**
 * Send a response.
 *
 * Examples:
 *
 *     res.send(Buffer.from('wahoo'));
 *     res.send({ some: 'json' });
 *     res.send('<p>some html</p>');
 *
 * @param {string|number|boolean|object|Buffer} body
 * @public
 */

res.send = function send(body) {
  var chunk = body;
  var encoding;
  var req = this.req;
  var type;

  // settings
  var app = this.app;

  // allow status / body
  if (arguments.length === 2) {
    // res.send(body, status) backwards compat
    if (typeof arguments[0] !== 'number' && typeof arguments[1] === 'number') {
      deprecate('res.send(body, status): Use res.status(status).send(body) instead');
      this.statusCode = arguments[1];
    } else {
      deprecate('res.send(status, body): Use res.status(status).send(body) instead');
      this.statusCode = arguments[0];
      chunk = arguments[1];
    }
  }

  // disambiguate res.send(status) and res.send(status, num)
  if (typeof chunk === 'number' && arguments.length === 1) {
    // res.send(status) will set status message as text string
    if (!this.get('Content-Type')) {
      this.type('txt');
    }

    deprecate('res.send(status): Use res.sendStatus(status) instead');
    this.statusCode = chunk;
    chunk = statuses[chunk]
  }

  switch (typeof chunk) {
    // string defaulting to html
    case 'string':
      if (!this.get('Content-Type')) {
        this.type('html');
      }
      break;
    case 'boolean':
    case 'number':
    case 'object':
      if (chunk === null) {
        chunk = '';
      } else if (Buffer.isBuffer(chunk)) {
        if (!this.get('Content-Type')) {
          this.type('bin');
        }
      } else {
        return this.json(chunk);
      }
      break;
  }

  // write strings in utf-8
  if (typeof chunk === 'string') {
    encoding = 'utf8';
    type = this.get('Content-Type');

    // reflect this in content-type
    if (typeof type === 'string') {
      this.set('Content-Type', setCharset(type, 'utf-8'));
    }
  }

  // determine if ETag should be generated
  var etagFn = app.get('etag fn')
  var generateETag = !this.get('ETag') && typeof etagFn === 'function'

  // populate Content-Length
  var len
  if (chunk !== undefined) {
    if (Buffer.isBuffer(chunk)) {
      // get length of Buffer
      len = chunk.length
    } else if (!generateETag && chunk.length < 1000) {
      // just calculate length when no ETag + small chunk
      len = Buffer.byteLength(chunk, encoding)
    } else {
      // convert chunk to Buffer and calculate
      chunk = Buffer.from(chunk, encoding)
      encoding = undefined;
      len = chunk.length
    }

    this.set('Content-Length', len);
  }

  // populate ETag
  var etag;
  if (generateETag && len !== undefined) {
    if ((etag = etagFn(chunk, encoding))) {
      this.set('ETag', etag);
    }
  }

  // freshness
  if (req.fresh) this.statusCode = 304;

  // strip irrelevant headers
  if (204 === this.statusCode || 304 === this.statusCode) {
    this.removeHeader('Content-Type');
    this.removeHeader('Content-Length');
    this.removeHeader('Transfer-Encoding');
    chunk = '';
  }

  if (req.method === 'HEAD') {
    // skip body for HEAD
    this.end();
  } else {
    // respond
    this.end(chunk, encoding);
  }

  return this;
};

/**
 * Send JSON response.
 *
 * Examples:
 *
 *     res.json(null);
 *     res.json({ user: 'tj' });
 *
 * @param {string|number|boolean|object} obj
 * @public
 */

res.json = function json(obj) {
  var val = obj;

  // allow status / body
  if (arguments.length === 2) {
    // res.json(body, status) backwards compat
    if (typeof arguments[1] === 'number') {
      deprecate('res.json(obj, status): Use res.status(status).json(obj) instead');
      this.statusCode = arguments[1];
    } else {
      deprecate('res.json(status, obj): Use res.status(status).json(obj) instead');
      this.statusCode = arguments[0];
      val = arguments[1];
    }
  }

  // settings
  var app = this.app;
  var escape = app.get('json escape')
  var replacer = app.get('json replacer');
  var spaces = app.get('json spaces');
  var body = stringify(val, replacer, spaces, escape)

  // content-type
  if (!this.get('Content-Type')) {
    this.set('Content-Type', 'application/json');
  }

  return this.send(body);
};

/**
 * Send JSON response with JSONP callback support.
 *
 * Examples:
 *
 *     res.jsonp(null);
 *     res.jsonp({ user: 'tj' });
 *
 * @param {string|number|boolean|object} obj
 * @public
 */

res.jsonp = function jsonp(obj) {
  var val = obj;

  // allow status / body
  if (arguments.length === 2) {
    // res.json(body, status) backwards compat
    if (typeof arguments[1] === 'number') {
      deprecate('res.jsonp(obj, status): Use res.status(status).json(obj) instead');
      this.statusCode = arguments[1];
    } else {
      deprecate('res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead');
      this.statusCode = arguments[0];
      val = arguments[1];
    }
  }

  // settings
  var app = this.app;
  var escape = app.get('json escape')
  var replacer = app.get('json replacer');
  var spaces = app.get('json spaces');
  var body = stringify(val, replacer, spaces, escape)
  var callback = this.req.query[app.get('jsonp callback name')];

  // content-type
  if (!this.get('Content-Type')) {
    this.set('X-Content-Type-Options', 'nosniff');
    this.set('Content-Type', 'application/json');
  }

  // fixup callback
  if (Array.isArray(callback)) {
    callback = callback[0];
  }

  // jsonp
  if (typeof callback === 'string' && callback.length !== 0) {
    this.set('X-Content-Type-Options', 'nosniff');
    this.set('Content-Type', 'text/javascript');

    // restrict callback charset
    callback = callback.replace(/[^\[\]\w$.]/g, '');

    // replace chars not allowed in JavaScript that are in JSON
    body = body
      .replace(/\u2028/g, '\\u2028')
      .replace(/\u2029/g, '\\u2029');

    // the /**/ is a specific security mitigation for "Rosetta Flash JSONP abuse"
    // the typeof check is just to reduce client error noise
    body = '/**/ typeof ' + callback + ' === \'function\' && ' + callback + '(' + body + ');';
  }

  return this.send(body);
};

/**
 * Send given HTTP status code.
 *
 * Sets the response status to `statusCode` and the body of the
 * response to the standard description from node's http.STATUS_CODES
 * or the statusCode number if no description.
 *
 * Examples:
 *
 *     res.sendStatus(200);
 *
 * @param {number} statusCode
 * @public
 */

res.sendStatus = function sendStatus(statusCode) {
  var body = statuses[statusCode] || String(statusCode)

  this.statusCode = statusCode;
  this.type('txt');

  return this.send(body);
};

/**
 * Transfer the file at the given `path`.
 *
 * Automatically sets the _Content-Type_ response header field.
 * The callback `callback(err)` is invoked when the transfer is complete
 * or when an error occurs. Be sure to check `res.sentHeader`
 * if you wish to attempt responding, as the header and some data
 * may have already been transferred.
 *
 * Options:
 *
 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
 *   - `root`     root directory for relative filenames
 *   - `headers`  object of headers to serve with file
 *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
 *
 * Other options are passed along to `send`.
 *
 * Examples:
 *
 *  The following example illustrates how `res.sendFile()` may
 *  be used as an alternative for the `static()` middleware for
 *  dynamic situations. The code backing `res.sendFile()` is actually
 *  the same code, so HTTP cache support etc is identical.
 *
 *     app.get('/user/:uid/photos/:file', function(req, res){
 *       var uid = req.params.uid
 *         , file = req.params.file;
 *
 *       req.user.mayViewFilesFrom(uid, function(yes){
 *         if (yes) {
 *           res.sendFile('/uploads/' + uid + '/' + file);
 *         } else {
 *           res.send(403, 'Sorry! you cant see that.');
 *         }
 *       });
 *     });
 *
 * @public
 */

res.sendFile = function sendFile(path, options, callback) {
  var done = callback;
  var req = this.req;
  var res = this;
  var next = req.next;
  var opts = options || {};

  if (!path) {
    throw new TypeError('path argument is required to res.sendFile');
  }

  // support function as second arg
  if (typeof options === 'function') {
    done = options;
    opts = {};
  }

  if (!opts.root && !isAbsolute(path)) {
    throw new TypeError('path must be absolute or specify root to res.sendFile');
  }

  // create file stream
  var pathname = encodeURI(path);
  var file = send(req, pathname, opts);

  // transfer
  sendfile(res, file, opts, function (err) {
    if (done) return done(err);
    if (err && err.code === 'EISDIR') return next();

    // next() all but write errors
    if (err && err.code !== 'ECONNABORTED' && err.syscall !== 'write') {
      next(err);
    }
  });
};

/**
 * Transfer the file at the given `path`.
 *
 * Automatically sets the _Content-Type_ response header field.
 * The callback `callback(err)` is invoked when the transfer is complete
 * or when an error occurs. Be sure to check `res.sentHeader`
 * if you wish to attempt responding, as the header and some data
 * may have already been transferred.
 *
 * Options:
 *
 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
 *   - `root`     root directory for relative filenames
 *   - `headers`  object of headers to serve with file
 *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
 *
 * Other options are passed along to `send`.
 *
 * Examples:
 *
 *  The following example illustrates how `res.sendfile()` may
 *  be used as an alternative for the `static()` middleware for
 *  dynamic situations. The code backing `res.sendfile()` is actually
 *  the same code, so HTTP cache support etc is identical.
 *
 *     app.get('/user/:uid/photos/:file', function(req, res){
 *       var uid = req.params.uid
 *         , file = req.params.file;
 *
 *       req.user.mayViewFilesFrom(uid, function(yes){
 *         if (yes) {
 *           res.sendfile('/uploads/' + uid + '/' + file);
 *         } else {
 *           res.send(403, 'Sorry! you cant see that.');
 *         }
 *       });
 *     });
 *
 * @public
 */

res.sendfile = function (path, options, callback) {
  var done = callback;
  var req = this.req;
  var res = this;
  var next = req.next;
  var opts = options || {};

  // support function as second arg
  if (typeof options === 'function') {
    done = options;
    opts = {};
  }

  // create file stream
  var file = send(req, path, opts);

  // transfer
  sendfile(res, file, opts, function (err) {
    if (done) return done(err);
    if (err && err.code === 'EISDIR') return next();

    // next() all but write errors
    if (err && err.code !== 'ECONNABORTED' && err.syscall !== 'write') {
      next(err);
    }
  });
};

res.sendfile = deprecate.function(res.sendfile,
  'res.sendfile: Use res.sendFile instead');

/**
 * Transfer the file at the given `path` as an attachment.
 *
 * Optionally providing an alternate attachment `filename`,
 * and optional callback `callback(err)`. The callback is invoked
 * when the data transfer is complete, or when an error has
 * ocurred. Be sure to check `res.headersSent` if you plan to respond.
 *
 * Optionally providing an `options` object to use with `res.sendFile()`.
 * This function will set the `Content-Disposition` header, overriding
 * any `Content-Disposition` header passed as header options in order
 * to set the attachment and filename.
 *
 * This method uses `res.sendFile()`.
 *
 * @public
 */

res.download = function download (path, filename, options, callback) {
  var done = callback;
  var name = filename;
  var opts = options || null

  // support function as second or third arg
  if (typeof filename === 'function') {
    done = filename;
    name = null;
    opts = null
  } else if (typeof options === 'function') {
    done = options
    opts = null
  }

  // set Content-Disposition when file is sent
  var headers = {
    'Content-Disposition': contentDisposition(name || path)
  };

  // merge user-provided headers
  if (opts && opts.headers) {
    var keys = Object.keys(opts.headers)
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]
      if (key.toLowerCase() !== 'content-disposition') {
        headers[key] = opts.headers[key]
      }
    }
  }

  // merge user-provided options
  opts = Object.create(opts)
  opts.headers = headers

  // Resolve the full path for sendFile
  var fullPath = resolve(path);

  // send file
  return this.sendFile(fullPath, opts, done)
};

/**
 * Set _Content-Type_ response header with `type` through `mime.lookup()`
 * when it does not contain "/", or set the Content-Type to `type` otherwise.
 *
 * Examples:
 *
 *     res.type('.html');
 *     res.type('html');
 *     res.type('json');
 *     res.type('application/json');
 *     res.type('png');
 *
 * @param {String} type
 * @return {ServerResponse} for chaining
 * @public
 */

res.contentType =
res.type = function contentType(type) {
  var ct = type.indexOf('/') === -1
    ? mime.lookup(type)
    : type;

  return this.set('Content-Type', ct);
};

/**
 * Respond to the Acceptable formats using an `obj`
 * of mime-type callbacks.
 *
 * This method uses `req.accepted`, an array of
 * acceptable types ordered by their quality values.
 * When "Accept" is not present the _first_ callback
 * is invoked, otherwise the first match is used. When
 * no match is performed the server responds with
 * 406 "Not Acceptable".
 *
 * Content-Type is set for you, however if you choose
 * you may alter this within the callback using `res.type()`
 * or `res.set('Content-Type', ...)`.
 *
 *    res.format({
 *      'text/plain': function(){
 *        res.send('hey');
 *      },
 *
 *      'text/html': function(){
 *        res.send('<p>hey</p>');
 *      },
 *
 *      'appliation/json': function(){
 *        res.send({ message: 'hey' });
 *      }
 *    });
 *
 * In addition to canonicalized MIME types you may
 * also use extnames mapped to these types:
 *
 *    res.format({
 *      text: function(){
 *        res.send('hey');
 *      },
 *
 *      html: function(){
 *        res.send('<p>hey</p>');
 *      },
 *
 *      json: function(){
 *        res.send({ message: 'hey' });
 *      }
 *    });
 *
 * By default Express passes an `Error`
 * with a `.status` of 406 to `next(err)`
 * if a match is not made. If you provide
 * a `.default` callback it will be invoked
 * instead.
 *
 * @param {Object} obj
 * @return {ServerResponse} for chaining
 * @public
 */

res.format = function(obj){
  var req = this.req;
  var next = req.next;

  var fn = obj.default;
  if (fn) delete obj.default;
  var keys = Object.keys(obj);

  var key = keys.length > 0
    ? req.accepts(keys)
    : false;

  this.vary("Accept");

  if (key) {
    this.set('Content-Type', normalizeType(key).value);
    obj[key](req, this, next);
  } else if (fn) {
    fn();
  } else {
    var err = new Error('Not Acceptable');
    err.status = err.statusCode = 406;
    err.types = normalizeTypes(keys).map(function(o){ return o.value });
    next(err);
  }

  return this;
};

/**
 * Set _Content-Disposition_ header to _attachment_ with optional `filename`.
 *
 * @param {String} filename
 * @return {ServerResponse}
 * @public
 */

res.attachment = function attachment(filename) {
  if (filename) {
    this.type(extname(filename));
  }

  this.set('Content-Disposition', contentDisposition(filename));

  return this;
};

/**
 * Append additional header `field` with value `val`.
 *
 * Example:
 *
 *    res.append('Link', ['<http://localhost/>', '<http://localhost:3000/>']);
 *    res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');
 *    res.append('Warning', '199 Miscellaneous warning');
 *
 * @param {String} field
 * @param {String|Array} val
 * @return {ServerResponse} for chaining
 * @public
 */

res.append = function append(field, val) {
  var prev = this.get(field);
  var value = val;

  if (prev) {
    // concat the new and prev vals
    value = Array.isArray(prev) ? prev.concat(val)
      : Array.isArray(val) ? [prev].concat(val)
      : [prev, val];
  }

  return this.set(field, value);
};

/**
 * Set header `field` to `val`, or pass
 * an object of header fields.
 *
 * Examples:
 *
 *    res.set('Foo', ['bar', 'baz']);
 *    res.set('Accept', 'application/json');
 *    res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });
 *
 * Aliased as `res.header()`.
 *
 * @param {String|Object} field
 * @param {String|Array} val
 * @return {ServerResponse} for chaining
 * @public
 */

res.set =
res.header = function header(field, val) {
  if (arguments.length === 2) {
    var value = Array.isArray(val)
      ? val.map(String)
      : String(val);

    // add charset to content-type
    if (field.toLowerCase() === 'content-type') {
      if (Array.isArray(value)) {
        throw new TypeError('Content-Type cannot be set to an Array');
      }
      if (!charsetRegExp.test(value)) {
        var charset = mime.charsets.lookup(value.split(';')[0]);
        if (charset) value += '; charset=' + charset.toLowerCase();
      }
    }

    this.setHeader(field, value);
  } else {
    for (var key in field) {
      this.set(key, field[key]);
    }
  }
  return this;
};

/**
 * Get value for header `field`.
 *
 * @param {String} field
 * @return {String}
 * @public
 */

res.get = function(field){
  return this.getHeader(field);
};

/**
 * Clear cookie `name`.
 *
 * @param {String} name
 * @param {Object} [options]
 * @return {ServerResponse} for chaining
 * @public
 */

res.clearCookie = function clearCookie(name, options) {
  var opts = merge({ expires: new Date(1), path: '/' }, options);

  return this.cookie(name, '', opts);
};

/**
 * Set cookie `name` to `value`, with the given `options`.
 *
 * Options:
 *
 *    - `maxAge`   max-age in milliseconds, converted to `expires`
 *    - `signed`   sign the cookie
 *    - `path`     defaults to "/"
 *
 * Examples:
 *
 *    // "Remember Me" for 15 minutes
 *    res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
 *
 *    // save as above
 *    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
 *
 * @param {String} name
 * @param {String|Object} value
 * @param {Object} [options]
 * @return {ServerResponse} for chaining
 * @public
 */

res.cookie = function (name, value, options) {
  var opts = merge({}, options);
  var secret = this.req.secret;
  var signed = opts.signed;

  if (signed && !secret) {
    throw new Error('cookieParser("secret") required for signed cookies');
  }

  var val = typeof value === 'object'
    ? 'j:' + JSON.stringify(value)
    : String(value);

  if (signed) {
    val = 's:' + sign(val, secret);
  }

  if ('maxAge' in opts) {
    opts.expires = new Date(Date.now() + opts.maxAge);
    opts.maxAge /= 1000;
  }

  if (opts.path == null) {
    opts.path = '/';
  }

  this.append('Set-Cookie', cookie.serialize(name, String(val), opts));

  return this;
};

/**
 * Set the location header to `url`.
 *
 * The given `url` can also be "back", which redirects
 * to the _Referrer_ or _Referer_ headers or "/".
 *
 * Examples:
 *
 *    res.location('/foo/bar').;
 *    res.location('http://example.com');
 *    res.location('../login');
 *
 * @param {String} url
 * @return {ServerResponse} for chaining
 * @public
 */

res.location = function location(url) {
  var loc = url;

  // "back" is an alias for the referrer
  if (url === 'back') {
    loc = this.req.get('Referrer') || '/';
  }

  // set location
  return this.set('Location', encodeUrl(loc));
};

/**
 * Redirect to the given `url` with optional response `status`
 * defaulting to 302.
 *
 * The resulting `url` is determined by `res.location()`, so
 * it will play nicely with mounted apps, relative paths,
 * `"back"` etc.
 *
 * Examples:
 *
 *    res.redirect('/foo/bar');
 *    res.redirect('http://example.com');
 *    res.redirect(301, 'http://example.com');
 *    res.redirect('../login'); // /blog/post/1 -> /blog/login
 *
 * @public
 */

res.redirect = function redirect(url) {
  var address = url;
  var body;
  var status = 302;

  // allow status / url
  if (arguments.length === 2) {
    if (typeof arguments[0] === 'number') {
      status = arguments[0];
      address = arguments[1];
    } else {
      deprecate('res.redirect(url, status): Use res.redirect(status, url) instead');
      status = arguments[1];
    }
  }

  // Set location header
  address = this.location(address).get('Location');

  // Support text/{plain,html} by default
  this.format({
    text: function(){
      body = statuses[status] + '. Redirecting to ' + address
    },

    html: function(){
      var u = escapeHtml(address);
      body = '<p>' + statuses[status] + '. Redirecting to <a href="' + u + '">' + u + '</a></p>'
    },

    default: function(){
      body = '';
    }
  });

  // Respond
  this.statusCode = status;
  this.set('Content-Length', Buffer.byteLength(body));

  if (this.req.method === 'HEAD') {
    this.end();
  } else {
    this.end(body);
  }
};

/**
 * Add `field` to Vary. If already present in the Vary set, then
 * this call is simply ignored.
 *
 * @param {Array|String} field
 * @return {ServerResponse} for chaining
 * @public
 */

res.vary = function(field){
  // checks for back-compat
  if (!field || (Array.isArray(field) && !field.length)) {
    deprecate('res.vary(): Provide a field name');
    return this;
  }

  vary(this, field);

  return this;
};

/**
 * Render `view` with the given `options` and optional callback `fn`.
 * When a callback function is given a response will _not_ be made
 * automatically, otherwise a response of _200_ and _text/html_ is given.
 *
 * Options:
 *
 *  - `cache`     boolean hinting to the engine it should cache
 *  - `filename`  filename of the view being rendered
 *
 * @public
 */

res.render = function render(view, options, callback) {
  var app = this.req.app;
  var done = callback;
  var opts = options || {};
  var req = this.req;
  var self = this;

  // support callback function as second arg
  if (typeof options === 'function') {
    done = options;
    opts = {};
  }

  // merge res.locals
  opts._locals = self.locals;

  // default callback to respond
  done = done || function (err, str) {
    if (err) return req.next(err);
    self.send(str);
  };

  // render
  app.render(view, opts, done);
};

// pipe the send file stream
function sendfile(res, file, options, callback) {
  var done = false;
  var streaming;

  // request aborted
  function onaborted() {
    if (done) return;
    done = true;

    var err = new Error('Request aborted');
    err.code = 'ECONNABORTED';
    callback(err);
  }

  // directory
  function ondirectory() {
    if (done) return;
    done = true;

    var err = new Error('EISDIR, read');
    err.code = 'EISDIR';
    callback(err);
  }

  // errors
  function onerror(err) {
    if (done) return;
    done = true;
    callback(err);
  }

  // ended
  function onend() {
    if (done) return;
    done = true;
    callback();
  }

  // file
  function onfile() {
    streaming = false;
  }

  // finished
  function onfinish(err) {
    if (err && err.code === 'ECONNRESET') return onaborted();
    if (err) return onerror(err);
    if (done) return;

    setImmediate(function () {
      if (streaming !== false && !done) {
        onaborted();
        return;
      }

      if (done) return;
      done = true;
      callback();
    });
  }

  // streaming
  function onstream() {
    streaming = true;
  }

  file.on('directory', ondirectory);
  file.on('end', onend);
  file.on('error', onerror);
  file.on('file', onfile);
  file.on('stream', onstream);
  onFinished(res, onfinish);

  if (options.headers) {
    // set headers on successful transfer
    file.on('headers', function headers(res) {
      var obj = options.headers;
      var keys = Object.keys(obj);

      for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        res.setHeader(k, obj[k]);
      }
    });
  }

  // pipe
  file.pipe(res);
}

/**
 * Stringify JSON, like JSON.stringify, but v8 optimized, with the
 * ability to escape characters that can trigger HTML sniffing.
 *
 * @param {*} value
 * @param {function} replaces
 * @param {number} spaces
 * @param {boolean} escape
 * @returns {string}
 * @private
 */

function stringify (value, replacer, spaces, escape) {
  // v8 checks arguments.length for optimizing simple call
  // https://bugs.chromium.org/p/v8/issues/detail?id=4730
  var json = replacer || spaces
    ? JSON.stringify(value, replacer, spaces)
    : JSON.stringify(value);

  if (escape) {
    json = json.replace(/[<>&]/g, function (c) {
      switch (c.charCodeAt(0)) {
        case 0x3c:
          return '\\u003c'
        case 0x3e:
          return '\\u003e'
        case 0x26:
          return '\\u0026'
        default:
          return c
      }
    })
  }

  return json
}


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var crypto = __webpack_require__(12);

/**
 * Sign the given `val` with `secret`.
 *
 * @param {String} val
 * @param {String} secret
 * @return {String}
 * @api private
 */

exports.sign = function(val, secret){
  if ('string' != typeof val) throw new TypeError("Cookie value must be provided as a string.");
  if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
  return val + '.' + crypto
    .createHmac('sha256', secret)
    .update(val)
    .digest('base64')
    .replace(/\=+$/, '');
};

/**
 * Unsign and decode the given `val` with `secret`,
 * returning `false` if the signature is invalid.
 *
 * @param {String} val
 * @param {String} secret
 * @return {String|Boolean}
 * @api private
 */

exports.unsign = function(val, secret){
  if ('string' != typeof val) throw new TypeError("Signed cookie string must be provided.");
  if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
  var str = val.slice(0, val.lastIndexOf('.'))
    , mac = exports.sign(str, secret);
  
  return sha1(mac) == sha1(val) ? str : false;
};

/**
 * Private
 */

function sha1(str){
  return crypto.createHash('sha1').update(str).digest('hex');
}


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 */

module.exports = vary
module.exports.append = append

/**
 * RegExp to match field-name in RFC 7230 sec 3.2
 *
 * field-name    = token
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 */

var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/

/**
 * Append a field to a vary header.
 *
 * @param {String} header
 * @param {String|Array} field
 * @return {String}
 * @public
 */

function append (header, field) {
  if (typeof header !== 'string') {
    throw new TypeError('header argument is required')
  }

  if (!field) {
    throw new TypeError('field argument is required')
  }

  // get fields array
  var fields = !Array.isArray(field)
    ? parse(String(field))
    : field

  // assert on invalid field names
  for (var j = 0; j < fields.length; j++) {
    if (!FIELD_NAME_REGEXP.test(fields[j])) {
      throw new TypeError('field argument contains an invalid header name')
    }
  }

  // existing, unspecified vary
  if (header === '*') {
    return header
  }

  // enumerate current values
  var val = header
  var vals = parse(header.toLowerCase())

  // unspecified vary
  if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
    return '*'
  }

  for (var i = 0; i < fields.length; i++) {
    var fld = fields[i].toLowerCase()

    // append value (case-preserving)
    if (vals.indexOf(fld) === -1) {
      vals.push(fld)
      val = val
        ? val + ', ' + fields[i]
        : fields[i]
    }
  }

  return val
}

/**
 * Parse a vary header into an array.
 *
 * @param {String} header
 * @return {Array}
 * @private
 */

function parse (header) {
  var end = 0
  var list = []
  var start = 0

  // gather tokens
  for (var i = 0, len = header.length; i < len; i++) {
    switch (header.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i + 1
        }
        break
      case 0x2c: /* , */
        list.push(header.substring(start, end))
        start = end = i + 1
        break
      default:
        end = i + 1
        break
    }
  }

  // final token
  list.push(header.substring(start, end))

  return list
}

/**
 * Mark that a request is varied on a header field.
 *
 * @param {Object} res
 * @param {String|Array} field
 * @public
 */

function vary (res, field) {
  if (!res || !res.getHeader || !res.setHeader) {
    // quack quack
    throw new TypeError('res argument is required')
  }

  // get existing header
  var val = res.getHeader('Vary') || ''
  var header = Array.isArray(val)
    ? val.join(', ')
    : String(val)

  // set new header
  if ((val = append(header, field))) {
    res.setHeader('Vary', val)
  }
}


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * serve-static
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var encodeUrl = __webpack_require__(27)
var escapeHtml = __webpack_require__(28)
var parseUrl = __webpack_require__(16)
var resolve = __webpack_require__(2).resolve
var send = __webpack_require__(40)
var url = __webpack_require__(7)

/**
 * Module exports.
 * @public
 */

module.exports = serveStatic
module.exports.mime = send.mime

/**
 * @param {string} root
 * @param {object} [options]
 * @return {function}
 * @public
 */

function serveStatic (root, options) {
  if (!root) {
    throw new TypeError('root path required')
  }

  if (typeof root !== 'string') {
    throw new TypeError('root path must be a string')
  }

  // copy options object
  var opts = Object.create(options || null)

  // fall-though
  var fallthrough = opts.fallthrough !== false

  // default redirect
  var redirect = opts.redirect !== false

  // headers listener
  var setHeaders = opts.setHeaders

  if (setHeaders && typeof setHeaders !== 'function') {
    throw new TypeError('option setHeaders must be function')
  }

  // setup options for send
  opts.maxage = opts.maxage || opts.maxAge || 0
  opts.root = resolve(root)

  // construct directory listener
  var onDirectory = redirect
    ? createRedirectDirectoryListener()
    : createNotFoundDirectoryListener()

  return function serveStatic (req, res, next) {
    if (req.method !== 'GET' && req.method !== 'HEAD') {
      if (fallthrough) {
        return next()
      }

      // method not allowed
      res.statusCode = 405
      res.setHeader('Allow', 'GET, HEAD')
      res.setHeader('Content-Length', '0')
      res.end()
      return
    }

    var forwardError = !fallthrough
    var originalUrl = parseUrl.original(req)
    var path = parseUrl(req).pathname

    // make sure redirect occurs at mount
    if (path === '/' && originalUrl.pathname.substr(-1) !== '/') {
      path = ''
    }

    // create send stream
    var stream = send(req, path, opts)

    // add directory handler
    stream.on('directory', onDirectory)

    // add headers listener
    if (setHeaders) {
      stream.on('headers', setHeaders)
    }

    // add file listener for fallthrough
    if (fallthrough) {
      stream.on('file', function onFile () {
        // once file is determined, always forward error
        forwardError = true
      })
    }

    // forward errors
    stream.on('error', function error (err) {
      if (forwardError || !(err.statusCode < 500)) {
        next(err)
        return
      }

      next()
    })

    // pipe
    stream.pipe(res)
  }
}

/**
 * Collapse all leading slashes into a single slash
 * @private
 */
function collapseLeadingSlashes (str) {
  for (var i = 0; i < str.length; i++) {
    if (str.charCodeAt(i) !== 0x2f /* / */) {
      break
    }
  }

  return i > 1
    ? '/' + str.substr(i)
    : str
}

 /**
 * Create a minimal HTML document.
 *
 * @param {string} title
 * @param {string} body
 * @private
 */

function createHtmlDocument (title, body) {
  return '<!DOCTYPE html>\n' +
    '<html lang="en">\n' +
    '<head>\n' +
    '<meta charset="utf-8">\n' +
    '<title>' + title + '</title>\n' +
    '</head>\n' +
    '<body>\n' +
    '<pre>' + body + '</pre>\n' +
    '</body>\n' +
    '</html>\n'
}

/**
 * Create a directory listener that just 404s.
 * @private
 */

function createNotFoundDirectoryListener () {
  return function notFound () {
    this.error(404)
  }
}

/**
 * Create a directory listener that performs a redirect.
 * @private
 */

function createRedirectDirectoryListener () {
  return function redirect (res) {
    if (this.hasTrailingSlash()) {
      this.error(404)
      return
    }

    // get original URL
    var originalUrl = parseUrl.original(this.req)

    // append trailing slash
    originalUrl.path = null
    originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + '/')

    // reformat the URL
    var loc = encodeUrl(url.format(originalUrl))
    var doc = createHtmlDocument('Redirecting', 'Redirecting to <a href="' + escapeHtml(loc) + '">' +
      escapeHtml(loc) + '</a>')

    // send redirect response
    res.statusCode = 301
    res.setHeader('Content-Type', 'text/html; charset=UTF-8')
    res.setHeader('Content-Length', Buffer.byteLength(doc))
    res.setHeader('Content-Security-Policy', "default-src 'self'")
    res.setHeader('X-Content-Type-Options', 'nosniff')
    res.setHeader('Location', loc)
    res.end(doc)
  }
}


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var SocketServer = /** @class */ (function () {
    function SocketServer(server) {
        var _this = this;
        // kicks player from gape page back to login page with optional message
        this.kickClient = function (socket, message) {
            console.log('kicking');
            socket.emit('kickClient', message);
        };
        // sends message to client
        this.sendMessageToClient = function (socket, message) {
            socket.emit('displayMessage', message);
        };
        // removes lobbies that are empty 
        this.checkLobbies = function () {
            var newLobbies = [];
            _this.lobbies.map(function (l) {
                if (l.players.length > 0)
                    newLobbies.push(l);
            });
            _this.lobbies = newLobbies;
        };
        this.getStandartItemsByRole = function (role) {
            var items;
            for (var i = 0; i < 5; i++) {
                items.push({
                    name: 'itemname',
                    info: 'useless',
                    cssClass: 'testitem',
                    data: 'none',
                    action: {},
                });
            }
            return items;
        };
        this.io = __webpack_require__(144)(server, {
            serveClient: false,
            wsEngine: 'ws' // uws is not supported since it is a native module
        });
        this.lobbies = [];
        this.listen();
    }
    SocketServer.prototype.listen = function () {
        var _this = this;
        this.io.on('connect', function (socket) {
            // sends avaible lobbies to client
            socket.on('getLobbies', function () {
                _this.checkLobbies();
                var res = [];
                _this.lobbies.map(function (l) {
                    res.push({
                        name: l.name,
                        playerCount: l.players.length,
                        maxPlayers: l.maxPlayers,
                        id: l.lobbyId,
                    });
                });
                socket.emit("lobbiesInfo", res);
            });
            socket.on('getLobbyStatus', function () {
                var lobby;
                _this.lobbies.map(function (l) {
                    l.players.map(function (p) {
                        if (p.id = socket.id) {
                            lobby = l;
                        }
                    });
                });
                if (!lobby)
                    _this.kickClient(socket, 'Unexpected error.');
                socket.emit('updateLobbyStatus', lobby);
            });
            // assigns client to lobby
            socket.on('joinLobby', function (data) {
                var kicked = false;
                _this.lobbies.map(function (l) { return l.players.map(function (p) {
                    if (p.id == socket.id) {
                        _this.kickClient(p.socket);
                        kicked = true;
                    }
                }); });
                var lobby = _this.lobbies.find(function (l) { return l.lobbyId == data.lobbyId; });
                if (lobby && !kicked) {
                    if (lobby.maxPlayers > lobby.players.length) {
                        var i_1 = 0;
                        var roles_1 = ['user1', 'user2', 'hacker'];
                        lobby.players.map(function (p) {
                            p.role == roles_1[i_1] ? i_1++ : undefined;
                        });
                        var newPlayer_1 = {
                            id: socket.id,
                            socket: socket,
                            username: data.client.username,
                            role: roles_1[i_1],
                            items: _this.getStandartItemsByRole(roles_1[i_1]),
                        };
                        lobby.players.push(newPlayer_1);
                        lobby.players.map(function (player) {
                            if (player.id !== newPlayer_1.id) {
                                _this.sendMessageToClient(player.socket, data.client.username + " has join the lobby!");
                            }
                        });
                    }
                    else {
                        _this.kickClient(socket, "Lobby is full.");
                    }
                }
                else {
                    _this.kickClient(socket, "Lobby was not found.");
                }
            });
            // creates new lobby
            socket.on('createLobby', function (data) {
                console.log('creating lobby ' + data.lobbyName);
                var newLobby = {
                    players: [],
                    round: 0,
                    name: data.lobbyName,
                    lobbyId: _this.lobbies.length > 0 ? _this.lobbies[_this.lobbies.length - 1].lobbyId + 1 : 0,
                    maxPlayers: 3,
                };
                socket.emit('createdLobby', newLobby.lobbyId);
                _this.lobbies.push(newLobby);
            });
            // detaches client from lobby and deletes lobby if it remains empty
            socket.on('clientLeaving', function () {
                _this.lobbies.map(function (lobby) {
                    lobby.players.map(function (player) {
                        var players = [];
                        var disconnectedUsername;
                        if (player.id != socket.id) {
                            players.push(player);
                        }
                        else {
                            disconnectedUsername = player.username;
                        }
                        console.log(disconnectedUsername + " has left. ");
                        lobby.players = players;
                        lobby.players.map(function (p) { return _this.sendMessageToClient(p.socket, disconnectedUsername + " has disconected."); });
                    });
                });
                _this.checkLobbies();
            });
        });
    };
    return SocketServer;
}());
exports.SocketServer = SocketServer;


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__dirname) {

/**
 * Module dependencies.
 */

var http = __webpack_require__(4);
var read = __webpack_require__(6).readFileSync;
var path = __webpack_require__(2);
var exists = __webpack_require__(6).existsSync;
var engine = __webpack_require__(145);
var clientVersion = __webpack_require__(176).version;
var Client = __webpack_require__(177);
var Emitter = __webpack_require__(1).EventEmitter;
var Namespace = __webpack_require__(79);
var ParentNamespace = __webpack_require__(187);
var Adapter = __webpack_require__(188);
var parser = __webpack_require__(33);
var debug = __webpack_require__(34)('socket.io:server');
var url = __webpack_require__(7);

/**
 * Module exports.
 */

module.exports = Server;

/**
 * Socket.IO client source.
 */

var clientSource = undefined;
var clientSourceMap = undefined;

/**
 * Server constructor.
 *
 * @param {http.Server|Number|Object} srv http server, port or options
 * @param {Object} [opts]
 * @api public
 */

function Server(srv, opts){
  if (!(this instanceof Server)) return new Server(srv, opts);
  if ('object' == typeof srv && srv instanceof Object && !srv.listen) {
    opts = srv;
    srv = null;
  }
  opts = opts || {};
  this.nsps = {};
  this.parentNsps = new Map();
  this.path(opts.path || '/socket.io');
  this.serveClient(false !== opts.serveClient);
  this.parser = opts.parser || parser;
  this.encoder = new this.parser.Encoder();
  this.adapter(opts.adapter || Adapter);
  this.origins(opts.origins || '*:*');
  this.sockets = this.of('/');
  if (srv) this.attach(srv, opts);
}

/**
 * Server request verification function, that checks for allowed origins
 *
 * @param {http.IncomingMessage} req request
 * @param {Function} fn callback to be called with the result: `fn(err, success)`
 */

Server.prototype.checkRequest = function(req, fn) {
  var origin = req.headers.origin || req.headers.referer;

  // file:// URLs produce a null Origin which can't be authorized via echo-back
  if ('null' == origin || null == origin) origin = '*';

  if (!!origin && typeof(this._origins) == 'function') return this._origins(origin, fn);
  if (this._origins.indexOf('*:*') !== -1) return fn(null, true);
  if (origin) {
    try {
      var parts = url.parse(origin);
      var defaultPort = 'https:' == parts.protocol ? 443 : 80;
      parts.port = parts.port != null
        ? parts.port
        : defaultPort;
      var ok =
        ~this._origins.indexOf(parts.protocol + '//' + parts.hostname + ':' + parts.port) ||
        ~this._origins.indexOf(parts.hostname + ':' + parts.port) ||
        ~this._origins.indexOf(parts.hostname + ':*') ||
        ~this._origins.indexOf('*:' + parts.port);
      debug('origin %s is %svalid', origin, !!ok ? '' : 'not ');
      return fn(null, !!ok);
    } catch (ex) {
    }
  }
  fn(null, false);
};

/**
 * Sets/gets whether client code is being served.
 *
 * @param {Boolean} v whether to serve client code
 * @return {Server|Boolean} self when setting or value when getting
 * @api public
 */

Server.prototype.serveClient = function(v){
  if (!arguments.length) return this._serveClient;
  this._serveClient = v;
  var resolvePath = function(file){
    var filepath = path.resolve(__dirname, './../../', file);
    if (exists(filepath)) {
      return filepath;
    }
    return /*require.resolve*/(!(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
  };
  if (v && !clientSource) {
    clientSource = read(resolvePath( 'socket.io-client/dist/socket.io.js'), 'utf-8');
    try {
      clientSourceMap = read(resolvePath( 'socket.io-client/dist/socket.io.js.map'), 'utf-8');
    } catch(err) {
      debug('could not load sourcemap file');
    }
  }
  return this;
};

/**
 * Old settings for backwards compatibility
 */

var oldSettings = {
  "transports": "transports",
  "heartbeat timeout": "pingTimeout",
  "heartbeat interval": "pingInterval",
  "destroy buffer size": "maxHttpBufferSize"
};

/**
 * Backwards compatibility.
 *
 * @api public
 */

Server.prototype.set = function(key, val){
  if ('authorization' == key && val) {
    this.use(function(socket, next) {
      val(socket.request, function(err, authorized) {
        if (err) return next(new Error(err));
        if (!authorized) return next(new Error('Not authorized'));
        next();
      });
    });
  } else if ('origins' == key && val) {
    this.origins(val);
  } else if ('resource' == key) {
    this.path(val);
  } else if (oldSettings[key] && this.eio[oldSettings[key]]) {
    this.eio[oldSettings[key]] = val;
  } else {
    console.error('Option %s is not valid. Please refer to the README.', key);
  }

  return this;
};

/**
 * Executes the middleware for an incoming namespace not already created on the server.
 *
 * @param {String} name name of incoming namespace
 * @param {Object} query the query parameters
 * @param {Function} fn callback
 * @api private
 */

Server.prototype.checkNamespace = function(name, query, fn){
  if (this.parentNsps.size === 0) return fn(false);

  const keysIterator = this.parentNsps.keys();

  const run = () => {
    let nextFn = keysIterator.next();
    if (nextFn.done) {
      return fn(false);
    }
    nextFn.value(name, query, (err, allow) => {
      if (err ||!allow) {
        run();
      } else {
        fn(this.parentNsps.get(nextFn.value).createChild(name));
      }
    });
  };

  run();
};

/**
 * Sets the client serving path.
 *
 * @param {String} v pathname
 * @return {Server|String} self when setting or value when getting
 * @api public
 */

Server.prototype.path = function(v){
  if (!arguments.length) return this._path;
  this._path = v.replace(/\/$/, '');
  return this;
};

/**
 * Sets the adapter for rooms.
 *
 * @param {Adapter} v pathname
 * @return {Server|Adapter} self when setting or value when getting
 * @api public
 */

Server.prototype.adapter = function(v){
  if (!arguments.length) return this._adapter;
  this._adapter = v;
  for (var i in this.nsps) {
    if (this.nsps.hasOwnProperty(i)) {
      this.nsps[i].initAdapter();
    }
  }
  return this;
};

/**
 * Sets the allowed origins for requests.
 *
 * @param {String|String[]} v origins
 * @return {Server|Adapter} self when setting or value when getting
 * @api public
 */

Server.prototype.origins = function(v){
  if (!arguments.length) return this._origins;

  this._origins = v;
  return this;
};

/**
 * Attaches socket.io to a server or port.
 *
 * @param {http.Server|Number} server or port
 * @param {Object} options passed to engine.io
 * @return {Server} self
 * @api public
 */

Server.prototype.listen =
Server.prototype.attach = function(srv, opts){
  if ('function' == typeof srv) {
    var msg = 'You are trying to attach socket.io to an express ' +
    'request handler function. Please pass a http.Server instance.';
    throw new Error(msg);
  }

  // handle a port as a string
  if (Number(srv) == srv) {
    srv = Number(srv);
  }

  if ('number' == typeof srv) {
    debug('creating http server and binding to %d', srv);
    var port = srv;
    srv = http.Server(function(req, res){
      res.writeHead(404);
      res.end();
    });
    srv.listen(port);

  }

  // set engine.io path to `/socket.io`
  opts = opts || {};
  opts.path = opts.path || this.path();
  // set origins verification
  opts.allowRequest = opts.allowRequest || this.checkRequest.bind(this);

  if (this.sockets.fns.length > 0) {
    this.initEngine(srv, opts);
    return this;
  }

  var self = this;
  var connectPacket = { type: parser.CONNECT, nsp: '/' };
  this.encoder.encode(connectPacket, function (encodedPacket){
    // the CONNECT packet will be merged with Engine.IO handshake,
    // to reduce the number of round trips
    opts.initialPacket = encodedPacket;

    self.initEngine(srv, opts);
  });
  return this;
};

/**
 * Initialize engine
 *
 * @param {Object} options passed to engine.io
 * @api private
 */

Server.prototype.initEngine = function(srv, opts){
  // initialize engine
  debug('creating engine.io instance with opts %j', opts);
  this.eio = engine.attach(srv, opts);

  // attach static file serving
  if (this._serveClient) this.attachServe(srv);

  // Export http server
  this.httpServer = srv;

  // bind to engine events
  this.bind(this.eio);
};

/**
 * Attaches the static file serving.
 *
 * @param {Function|http.Server} srv http server
 * @api private
 */

Server.prototype.attachServe = function(srv){
  debug('attaching client serving req handler');
  var url = this._path + '/socket.io.js';
  var urlMap = this._path + '/socket.io.js.map';
  var evs = srv.listeners('request').slice(0);
  var self = this;
  srv.removeAllListeners('request');
  srv.on('request', function(req, res) {
    if (0 === req.url.indexOf(urlMap)) {
      self.serveMap(req, res);
    } else if (0 === req.url.indexOf(url)) {
      self.serve(req, res);
    } else {
      for (var i = 0; i < evs.length; i++) {
        evs[i].call(srv, req, res);
      }
    }
  });
};

/**
 * Handles a request serving `/socket.io.js`
 *
 * @param {http.Request} req
 * @param {http.Response} res
 * @api private
 */

Server.prototype.serve = function(req, res){
  // Per the standard, ETags must be quoted:
  // https://tools.ietf.org/html/rfc7232#section-2.3
  var expectedEtag = '"' + clientVersion + '"';

  var etag = req.headers['if-none-match'];
  if (etag) {
    if (expectedEtag == etag) {
      debug('serve client 304');
      res.writeHead(304);
      res.end();
      return;
    }
  }

  debug('serve client source');
  res.setHeader("Cache-Control", "public, max-age=0");
  res.setHeader('Content-Type', 'application/javascript');
  res.setHeader('ETag', expectedEtag);
  res.writeHead(200);
  res.end(clientSource);
};

/**
 * Handles a request serving `/socket.io.js.map`
 *
 * @param {http.Request} req
 * @param {http.Response} res
 * @api private
 */

Server.prototype.serveMap = function(req, res){
  // Per the standard, ETags must be quoted:
  // https://tools.ietf.org/html/rfc7232#section-2.3
  var expectedEtag = '"' + clientVersion + '"';

  var etag = req.headers['if-none-match'];
  if (etag) {
    if (expectedEtag == etag) {
      debug('serve client 304');
      res.writeHead(304);
      res.end();
      return;
    }
  }

  debug('serve client sourcemap');
  res.setHeader('Content-Type', 'application/json');
  res.setHeader('ETag', expectedEtag);
  res.writeHead(200);
  res.end(clientSourceMap);
};

/**
 * Binds socket.io to an engine.io instance.
 *
 * @param {engine.Server} engine engine.io (or compatible) server
 * @return {Server} self
 * @api public
 */

Server.prototype.bind = function(engine){
  this.engine = engine;
  this.engine.on('connection', this.onconnection.bind(this));
  return this;
};

/**
 * Called with each incoming transport connection.
 *
 * @param {engine.Socket} conn
 * @return {Server} self
 * @api public
 */

Server.prototype.onconnection = function(conn){
  debug('incoming connection with id %s', conn.id);
  var client = new Client(this, conn);
  client.connect('/');
  return this;
};

/**
 * Looks up a namespace.
 *
 * @param {String|RegExp|Function} name nsp name
 * @param {Function} [fn] optional, nsp `connection` ev handler
 * @api public
 */

Server.prototype.of = function(name, fn){
  if (typeof name === 'function' ||name instanceof RegExp) {
    const parentNsp = new ParentNamespace(this);
    debug('initializing parent namespace %s', parentNsp.name);
    if (typeof name === 'function') {
      this.parentNsps.set(name, parentNsp);
    } else {
      this.parentNsps.set((nsp, conn, next) => next(null, name.test(nsp)), parentNsp);
    }
    if (fn) parentNsp.on('connect', fn);
    return parentNsp;
  }

  if (String(name)[0] !== '/') name = '/' + name;

  var nsp = this.nsps[name];
  if (!nsp) {
    debug('initializing namespace %s', name);
    nsp = new Namespace(this, name);
    this.nsps[name] = nsp;
  }
  if (fn) nsp.on('connect', fn);
  return nsp;
};

/**
 * Closes server connection
 *
 * @param {Function} [fn] optional, called as `fn([err])` on error OR all conns closed
 * @api public
 */

Server.prototype.close = function(fn){
  for (var id in this.nsps['/'].sockets) {
    if (this.nsps['/'].sockets.hasOwnProperty(id)) {
      this.nsps['/'].sockets[id].onclose();
    }
  }

  this.engine.close();

  if (this.httpServer) {
    this.httpServer.close(fn);
  } else {
    fn && fn();
  }
};

/**
 * Expose main namespace (/).
 */

var emitterMethods = Object.keys(Emitter.prototype).filter(function(key){
  return typeof Emitter.prototype[key] === 'function';
});

emitterMethods.concat(['to', 'in', 'use', 'send', 'write', 'clients', 'compress', 'binary']).forEach(function(fn){
  Server.prototype[fn] = function(){
    return this.sockets[fn].apply(this.sockets, arguments);
  };
});

Namespace.flags.forEach(function(flag){
  Object.defineProperty(Server.prototype, flag, {
    get: function() {
      this.sockets.flags = this.sockets.flags || {};
      this.sockets.flags[flag] = true;
      return this;
    }
  });
});

/**
 * BC with `io.listen`
 */

Server.listen = Server;

/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var http = __webpack_require__(4);

/**
 * Invoking the library as a function delegates to attach if the first argument
 * is an `http.Server`.
 *
 * If there are no arguments or the first argument is an options object, then
 * a new Server instance is returned.
 *
 * @param {http.Server} server (if specified, will be attached to by the new Server instance)
 * @param {Object} options
 * @return {Server} engine server
 * @api public
 */

exports = module.exports = function () {
  // backwards compatible use as `.attach`
  // if first argument is an http server
  if (arguments.length && arguments[0] instanceof http.Server) {
    return attach.apply(this, arguments);
  }

  // if first argument is not an http server, then just make a regular eio server
  return exports.Server.apply(null, arguments);
};

/**
 * Protocol revision number.
 *
 * @api public
 */

exports.protocol = 1;

/**
 * Expose Server constructor.
 *
 * @api public
 */

exports.Server = __webpack_require__(146);

/**
 * Expose Socket constructor.
 *
 * @api public
 */

exports.Socket = __webpack_require__(69);

/**
 * Expose Transport constructor.
 *
 * @api public
 */

exports.Transport = __webpack_require__(41);

/**
 * Expose mutable list of available transports.
 *
 * @api public
 */

exports.transports = __webpack_require__(66);

/**
 * Exports parser.
 *
 * @api public
 */

exports.parser = __webpack_require__(31);

/**
 * Creates an http.Server exclusively used for WS upgrades.
 *
 * @param {Number} port
 * @param {Function} callback
 * @param {Object} options
 * @return {Server} websocket.io server
 * @api public
 */

exports.listen = listen;

function listen (port, options, fn) {
  if ('function' === typeof options) {
    fn = options;
    options = {};
  }

  var server = http.createServer(function (req, res) {
    res.writeHead(501);
    res.end('Not Implemented');
  });

  // create engine server
  var engine = exports.attach(server, options);
  engine.httpServer = server;

  server.listen(port, fn);

  return engine;
}

/**
 * Captures upgrade requests for a http.Server.
 *
 * @param {http.Server} server
 * @param {Object} options
 * @return {Server} engine server
 * @api public
 */

exports.attach = attach;

function attach (server, options) {
  var engine = new exports.Server(options);
  engine.attach(server, options);
  return engine;
}


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var qs = __webpack_require__(26);
var parse = __webpack_require__(7).parse;
var base64id = __webpack_require__(147);
var transports = __webpack_require__(66);
var EventEmitter = __webpack_require__(1).EventEmitter;
var Socket = __webpack_require__(69);
var util = __webpack_require__(0);
var debug = __webpack_require__(17)('engine');
var cookieMod = __webpack_require__(65);

/**
 * Module exports.
 */

module.exports = Server;

/**
 * Server constructor.
 *
 * @param {Object} options
 * @api public
 */

function Server (opts) {
  if (!(this instanceof Server)) {
    return new Server(opts);
  }

  this.clients = {};
  this.clientsCount = 0;

  opts = opts || {};

  this.wsEngine = opts.wsEngine || process.env.EIO_WS_ENGINE || 'ws';
  this.pingTimeout = opts.pingTimeout || 5000;
  this.pingInterval = opts.pingInterval || 25000;
  this.upgradeTimeout = opts.upgradeTimeout || 10000;
  this.maxHttpBufferSize = opts.maxHttpBufferSize || 10E7;
  this.transports = opts.transports || Object.keys(transports);
  this.allowUpgrades = false !== opts.allowUpgrades;
  this.allowRequest = opts.allowRequest;
  this.cookie = false !== opts.cookie ? (opts.cookie || 'io') : false;
  this.cookiePath = false !== opts.cookiePath ? (opts.cookiePath || '/') : false;
  this.cookieHttpOnly = false !== opts.cookieHttpOnly;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || true) : false;
  this.httpCompression = false !== opts.httpCompression ? (opts.httpCompression || {}) : false;
  this.initialPacket = opts.initialPacket;

  var self = this;

  // initialize compression options
  ['perMessageDeflate', 'httpCompression'].forEach(function (type) {
    var compression = self[type];
    if (true === compression) self[type] = compression = {};
    if (compression && null == compression.threshold) {
      compression.threshold = 1024;
    }
  });

  this.init();
}

/**
 * Protocol errors mappings.
 */

Server.errors = {
  UNKNOWN_TRANSPORT: 0,
  UNKNOWN_SID: 1,
  BAD_HANDSHAKE_METHOD: 2,
  BAD_REQUEST: 3,
  FORBIDDEN: 4
};

Server.errorMessages = {
  0: 'Transport unknown',
  1: 'Session ID unknown',
  2: 'Bad handshake method',
  3: 'Bad request',
  4: 'Forbidden'
};

/**
 * Inherits from EventEmitter.
 */

util.inherits(Server, EventEmitter);

/**
 * Initialize websocket server
 *
 * @api private
 */

Server.prototype.init = function () {
  if (!~this.transports.indexOf('websocket')) return;

  if (this.ws) this.ws.close();

  var wsModule;
  switch (this.wsEngine) {
    case 'uws': wsModule = __webpack_require__(159); break;
    case 'ws': wsModule = __webpack_require__(170); break;
    default: throw new Error('unknown wsEngine');
  }
  this.ws = new wsModule.Server({
    noServer: true,
    clientTracking: false,
    perMessageDeflate: this.perMessageDeflate,
    maxPayload: this.maxHttpBufferSize
  });
};

/**
 * Returns a list of available transports for upgrade given a certain transport.
 *
 * @return {Array}
 * @api public
 */

Server.prototype.upgrades = function (transport) {
  if (!this.allowUpgrades) return [];
  return transports[transport].upgradesTo || [];
};

/**
 * Verifies a request.
 *
 * @param {http.IncomingMessage}
 * @return {Boolean} whether the request is valid
 * @api private
 */

Server.prototype.verify = function (req, upgrade, fn) {
  // transport check
  var transport = req._query.transport;
  if (!~this.transports.indexOf(transport)) {
    debug('unknown transport "%s"', transport);
    return fn(Server.errors.UNKNOWN_TRANSPORT, false);
  }

  // 'Origin' header check
  var isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);
  if (isOriginInvalid) {
    req.headers.origin = null;
    return fn(Server.errors.BAD_REQUEST, false);
  }

  // sid check
  var sid = req._query.sid;
  if (sid) {
    if (!this.clients.hasOwnProperty(sid)) {
      return fn(Server.errors.UNKNOWN_SID, false);
    }
    if (!upgrade && this.clients[sid].transport.name !== transport) {
      debug('bad request: unexpected transport without upgrade');
      return fn(Server.errors.BAD_REQUEST, false);
    }
  } else {
    // handshake is GET only
    if ('GET' !== req.method) return fn(Server.errors.BAD_HANDSHAKE_METHOD, false);
    if (!this.allowRequest) return fn(null, true);
    return this.allowRequest(req, fn);
  }

  fn(null, true);
};

/**
 * Prepares a request by processing the query string.
 *
 * @api private
 */

Server.prototype.prepare = function (req) {
  // try to leverage pre-existing `req._query` (e.g: from connect)
  if (!req._query) {
    req._query = ~req.url.indexOf('?') ? qs.parse(parse(req.url).query) : {};
  }
};

/**
 * Closes all clients.
 *
 * @api public
 */

Server.prototype.close = function () {
  debug('closing all open clients');
  for (var i in this.clients) {
    if (this.clients.hasOwnProperty(i)) {
      this.clients[i].close(true);
    }
  }
  if (this.ws) {
    debug('closing webSocketServer');
    this.ws.close();
    // don't delete this.ws because it can be used again if the http server starts listening again
  }
  return this;
};

/**
 * Handles an Engine.IO HTTP request.
 *
 * @param {http.IncomingMessage} request
 * @param {http.ServerResponse|http.OutgoingMessage} response
 * @api public
 */

Server.prototype.handleRequest = function (req, res) {
  debug('handling "%s" http request "%s"', req.method, req.url);
  this.prepare(req);
  req.res = res;

  var self = this;
  this.verify(req, false, function (err, success) {
    if (!success) {
      sendErrorMessage(req, res, err);
      return;
    }

    if (req._query.sid) {
      debug('setting new request for existing client');
      self.clients[req._query.sid].transport.onRequest(req);
    } else {
      self.handshake(req._query.transport, req);
    }
  });
};

/**
 * Sends an Engine.IO Error Message
 *
 * @param {http.ServerResponse} response
 * @param {code} error code
 * @api private
 */

function sendErrorMessage (req, res, code) {
  var headers = { 'Content-Type': 'application/json' };

  var isForbidden = !Server.errorMessages.hasOwnProperty(code);
  if (isForbidden) {
    res.writeHead(403, headers);
    res.end(JSON.stringify({
      code: Server.errors.FORBIDDEN,
      message: code || Server.errorMessages[Server.errors.FORBIDDEN]
    }));
    return;
  }
  if (req.headers.origin) {
    headers['Access-Control-Allow-Credentials'] = 'true';
    headers['Access-Control-Allow-Origin'] = req.headers.origin;
  } else {
    headers['Access-Control-Allow-Origin'] = '*';
  }
  if (res !== undefined) {
    res.writeHead(400, headers);
    res.end(JSON.stringify({
      code: code,
      message: Server.errorMessages[code]
    }));
  }
}

/**
 * generate a socket id.
 * Overwrite this method to generate your custom socket id
 *
 * @param {Object} request object
 * @api public
 */

Server.prototype.generateId = function (req) {
  return base64id.generateId();
};

/**
 * Handshakes a new client.
 *
 * @param {String} transport name
 * @param {Object} request object
 * @api private
 */

Server.prototype.handshake = function (transportName, req) {
  var id = this.generateId(req);

  debug('handshaking client "%s"', id);

  try {
    var transport = new transports[transportName](req);
    if ('polling' === transportName) {
      transport.maxHttpBufferSize = this.maxHttpBufferSize;
      transport.httpCompression = this.httpCompression;
    } else if ('websocket' === transportName) {
      transport.perMessageDeflate = this.perMessageDeflate;
    }

    if (req._query && req._query.b64) {
      transport.supportsBinary = false;
    } else {
      transport.supportsBinary = true;
    }
  } catch (e) {
    sendErrorMessage(req, req.res, Server.errors.BAD_REQUEST);
    return;
  }
  var socket = new Socket(id, this, transport, req);
  var self = this;

  if (false !== this.cookie) {
    transport.on('headers', function (headers) {
      headers['Set-Cookie'] = cookieMod.serialize(self.cookie, id,
        {
          path: self.cookiePath,
          httpOnly: self.cookiePath ? self.cookieHttpOnly : false
        });
    });
  }

  transport.onRequest(req);

  this.clients[id] = socket;
  this.clientsCount++;

  socket.once('close', function () {
    delete self.clients[id];
    self.clientsCount--;
  });

  this.emit('connection', socket);
};

/**
 * Handles an Engine.IO HTTP Upgrade.
 *
 * @api public
 */

Server.prototype.handleUpgrade = function (req, socket, upgradeHead) {
  this.prepare(req);

  var self = this;
  this.verify(req, true, function (err, success) {
    if (!success) {
      abortConnection(socket, err);
      return;
    }

    var head = Buffer.from(upgradeHead); // eslint-disable-line node/no-deprecated-api
    upgradeHead = null;

    // delegate to ws
    self.ws.handleUpgrade(req, socket, head, function (conn) {
      self.onWebSocket(req, conn);
    });
  });
};

/**
 * Called upon a ws.io connection.
 *
 * @param {ws.Socket} websocket
 * @api private
 */

Server.prototype.onWebSocket = function (req, socket) {
  socket.on('error', onUpgradeError);

  if (transports[req._query.transport] !== undefined && !transports[req._query.transport].prototype.handlesUpgrades) {
    debug('transport doesnt handle upgraded requests');
    socket.close();
    return;
  }

  // get client id
  var id = req._query.sid;

  // keep a reference to the ws.Socket
  req.websocket = socket;

  if (id) {
    var client = this.clients[id];
    if (!client) {
      debug('upgrade attempt for closed client');
      socket.close();
    } else if (client.upgrading) {
      debug('transport has already been trying to upgrade');
      socket.close();
    } else if (client.upgraded) {
      debug('transport had already been upgraded');
      socket.close();
    } else {
      debug('upgrading existing transport');

      // transport error handling takes over
      socket.removeListener('error', onUpgradeError);

      var transport = new transports[req._query.transport](req);
      if (req._query && req._query.b64) {
        transport.supportsBinary = false;
      } else {
        transport.supportsBinary = true;
      }
      transport.perMessageDeflate = this.perMessageDeflate;
      client.maybeUpgrade(transport);
    }
  } else {
    // transport error handling takes over
    socket.removeListener('error', onUpgradeError);

    this.handshake(req._query.transport, req);
  }

  function onUpgradeError () {
    debug('websocket error before upgrade');
    // socket.close() not needed
  }
};

/**
 * Captures upgrade requests for a http.Server.
 *
 * @param {http.Server} server
 * @param {Object} options
 * @api public
 */

Server.prototype.attach = function (server, options) {
  var self = this;
  options = options || {};
  var path = (options.path || '/engine.io').replace(/\/$/, '');

  var destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;

  // normalize path
  path += '/';

  function check (req) {
    if ('OPTIONS' === req.method && false === options.handlePreflightRequest) {
      return false;
    }
    return path === req.url.substr(0, path.length);
  }

  // cache and clean up listeners
  var listeners = server.listeners('request').slice(0);
  server.removeAllListeners('request');
  server.on('close', self.close.bind(self));
  server.on('listening', self.init.bind(self));

  // add request handler
  server.on('request', function (req, res) {
    if (check(req)) {
      debug('intercepting request for path "%s"', path);
      if ('OPTIONS' === req.method && 'function' === typeof options.handlePreflightRequest) {
        options.handlePreflightRequest.call(server, req, res);
      } else {
        self.handleRequest(req, res);
      }
    } else {
      for (var i = 0, l = listeners.length; i < l; i++) {
        listeners[i].call(server, req, res);
      }
    }
  });

  if (~self.transports.indexOf('websocket')) {
    server.on('upgrade', function (req, socket, head) {
      if (check(req)) {
        self.handleUpgrade(req, socket, head);
      } else if (false !== options.destroyUpgrade) {
        // default node behavior is to disconnect when no handlers
        // but by adding a handler, we prevent that
        // and if no eio thing handles the upgrade
        // then the socket needs to die!
        setTimeout(function () {
          if (socket.writable && socket.bytesWritten <= 0) {
            return socket.end();
          }
        }, destroyUpgradeTimeout);
      }
    });
  }
};

/**
 * Closes the connection
 *
 * @param {net.Socket} socket
 * @param {code} error code
 * @api private
 */

function abortConnection (socket, code) {
  if (socket.writable) {
    var message = Server.errorMessages.hasOwnProperty(code) ? Server.errorMessages[code] : String(code || '');
    var length = Buffer.byteLength(message);
    socket.write(
      'HTTP/1.1 400 Bad Request\r\n' +
      'Connection: close\r\n' +
      'Content-type: text/html\r\n' +
      'Content-Length: ' + length + '\r\n' +
      '\r\n' +
      message
    );
  }
  socket.destroy();
}

/* eslint-disable */

/**
 * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354
 *
 * True if val contains an invalid field-vchar
 *  field-value    = *( field-content / obs-fold )
 *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 *  field-vchar    = VCHAR / obs-text
 *
 * checkInvalidHeaderChar() is currently designed to be inlinable by v8,
 * so take care when making changes to the implementation so that the source
 * code size does not exceed v8's default max_inlined_source_size setting.
 **/
var validHdrChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 48 - 63
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, // 112 - 127
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 128 ...
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1  // ... 255
];

function checkInvalidHeaderChar(val) {
  val += '';
  if (val.length < 1)
    return false;
  if (!validHdrChars[val.charCodeAt(0)])
    return true;
  if (val.length < 2)
    return false;
  if (!validHdrChars[val.charCodeAt(1)])
    return true;
  if (val.length < 3)
    return false;
  if (!validHdrChars[val.charCodeAt(2)])
    return true;
  if (val.length < 4)
    return false;
  if (!validHdrChars[val.charCodeAt(3)])
    return true;
  for (var i = 4; i < val.length; ++i) {
    if (!validHdrChars[val.charCodeAt(i)])
      return true;
  }
  return false;
}


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * base64id v0.1.0
 */

/**
 * Module dependencies
 */

var crypto = __webpack_require__(12);

/**
 * Constructor
 */

var Base64Id = function() { };

/**
 * Get random bytes
 *
 * Uses a buffer if available, falls back to crypto.randomBytes
 */

Base64Id.prototype.getRandomBytes = function(bytes) {

  var BUFFER_SIZE = 4096
  var self = this;  
  
  bytes = bytes || 12;

  if (bytes > BUFFER_SIZE) {
    return crypto.randomBytes(bytes);
  }
  
  var bytesInBuffer = parseInt(BUFFER_SIZE/bytes);
  var threshold = parseInt(bytesInBuffer*0.85);

  if (!threshold) {
    return crypto.randomBytes(bytes);
  }

  if (this.bytesBufferIndex == null) {
     this.bytesBufferIndex = -1;
  }

  if (this.bytesBufferIndex == bytesInBuffer) {
    this.bytesBuffer = null;
    this.bytesBufferIndex = -1;
  }

  // No buffered bytes available or index above threshold
  if (this.bytesBufferIndex == -1 || this.bytesBufferIndex > threshold) {
     
    if (!this.isGeneratingBytes) {
      this.isGeneratingBytes = true;
      crypto.randomBytes(BUFFER_SIZE, function(err, bytes) {
        self.bytesBuffer = bytes;
        self.bytesBufferIndex = 0;
        self.isGeneratingBytes = false;
      }); 
    }
    
    // Fall back to sync call when no buffered bytes are available
    if (this.bytesBufferIndex == -1) {
      return crypto.randomBytes(bytes);
    }
  }
  
  var result = this.bytesBuffer.slice(bytes*this.bytesBufferIndex, bytes*(this.bytesBufferIndex+1)); 
  this.bytesBufferIndex++; 
  
  return result;
}

/**
 * Generates a base64 id
 *
 * (Original version from socket.io <http://socket.io>)
 */

Base64Id.prototype.generateId = function () {
  var rand = new Buffer(15); // multiple of 3 for base64
  if (!rand.writeInt32BE) {
    return Math.abs(Math.random() * Math.random() * Date.now() | 0).toString()
      + Math.abs(Math.random() * Math.random() * Date.now() | 0).toString();
  }
  this.sequenceNumber = (this.sequenceNumber + 1) | 0;
  rand.writeInt32BE(this.sequenceNumber, 11);
  if (crypto.randomBytes) {
    this.getRandomBytes(12).copy(rand);
  } else {
    // not secure for node 0.4
    [0, 4, 8].forEach(function(i) {
      rand.writeInt32BE(Math.random() * Math.pow(2, 32) | 0, i);
    });
  }
  return rand.toString('base64').replace(/\//g, '_').replace(/\+/g, '-');
};

/**
 * Export
 */

exports = module.exports = new Base64Id();


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var Polling = __webpack_require__(67);
var util = __webpack_require__(0);

/**
 * Module exports.
 */

module.exports = XHR;

/**
 * Ajax polling transport.
 *
 * @api public
 */

function XHR (req) {
  Polling.call(this, req);
}

/**
 * Inherits from Polling.
 */

util.inherits(XHR, Polling);

/**
 * Overrides `onRequest` to handle `OPTIONS`..
 *
 * @param {http.IncomingMessage}
 * @api private
 */

XHR.prototype.onRequest = function (req) {
  if ('OPTIONS' === req.method) {
    var res = req.res;
    var headers = this.headers(req);
    headers['Access-Control-Allow-Headers'] = 'Content-Type';
    res.writeHead(200, headers);
    res.end();
  } else {
    Polling.prototype.onRequest.call(this, req);
  }
};

/**
 * Returns headers for a response.
 *
 * @param {http.IncomingMessage} request
 * @param {Object} extra headers
 * @api private
 */

XHR.prototype.headers = function (req, headers) {
  headers = headers || {};

  if (req.headers.origin) {
    headers['Access-Control-Allow-Credentials'] = 'true';
    headers['Access-Control-Allow-Origin'] = req.headers.origin;
  } else {
    headers['Access-Control-Allow-Origin'] = '*';
  }

  return Polling.prototype.headers.call(this, req, headers);
};


/***/ }),
/* 149 */
/***/ (function(module, exports) {

/*! https://mths.be/utf8js v2.1.2 by @mathias */

var stringFromCharCode = String.fromCharCode;

// Taken from https://mths.be/punycode
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	var value;
	var extra;
	while (counter < length) {
		value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// high surrogate, and there is a next character
			extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) { // low surrogate
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// unmatched surrogate; only append this code unit, in case the next
				// code unit is the high surrogate of a surrogate pair
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

// Taken from https://mths.be/punycode
function ucs2encode(array) {
	var length = array.length;
	var index = -1;
	var value;
	var output = '';
	while (++index < length) {
		value = array[index];
		if (value > 0xFFFF) {
			value -= 0x10000;
			output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
			value = 0xDC00 | value & 0x3FF;
		}
		output += stringFromCharCode(value);
	}
	return output;
}

function checkScalarValue(codePoint, strict) {
	if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
		if (strict) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
		return false;
	}
	return true;
}
/*--------------------------------------------------------------------------*/

function createByte(codePoint, shift) {
	return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
}

function encodeCodePoint(codePoint, strict) {
	if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
		return stringFromCharCode(codePoint);
	}
	var symbol = '';
	if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
		symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
	}
	else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
		if (!checkScalarValue(codePoint, strict)) {
			codePoint = 0xFFFD;
		}
		symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
		symbol += createByte(codePoint, 6);
	}
	else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
		symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
		symbol += createByte(codePoint, 12);
		symbol += createByte(codePoint, 6);
	}
	symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
	return symbol;
}

function utf8encode(string, opts) {
	opts = opts || {};
	var strict = false !== opts.strict;

	var codePoints = ucs2decode(string);
	var length = codePoints.length;
	var index = -1;
	var codePoint;
	var byteString = '';
	while (++index < length) {
		codePoint = codePoints[index];
		byteString += encodeCodePoint(codePoint, strict);
	}
	return byteString;
}

/*--------------------------------------------------------------------------*/

function readContinuationByte() {
	if (byteIndex >= byteCount) {
		throw Error('Invalid byte index');
	}

	var continuationByte = byteArray[byteIndex] & 0xFF;
	byteIndex++;

	if ((continuationByte & 0xC0) == 0x80) {
		return continuationByte & 0x3F;
	}

	// If we end up here, its not a continuation byte
	throw Error('Invalid continuation byte');
}

function decodeSymbol(strict) {
	var byte1;
	var byte2;
	var byte3;
	var byte4;
	var codePoint;

	if (byteIndex > byteCount) {
		throw Error('Invalid byte index');
	}

	if (byteIndex == byteCount) {
		return false;
	}

	// Read first byte
	byte1 = byteArray[byteIndex] & 0xFF;
	byteIndex++;

	// 1-byte sequence (no continuation bytes)
	if ((byte1 & 0x80) == 0) {
		return byte1;
	}

	// 2-byte sequence
	if ((byte1 & 0xE0) == 0xC0) {
		byte2 = readContinuationByte();
		codePoint = ((byte1 & 0x1F) << 6) | byte2;
		if (codePoint >= 0x80) {
			return codePoint;
		} else {
			throw Error('Invalid continuation byte');
		}
	}

	// 3-byte sequence (may include unpaired surrogates)
	if ((byte1 & 0xF0) == 0xE0) {
		byte2 = readContinuationByte();
		byte3 = readContinuationByte();
		codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
		if (codePoint >= 0x0800) {
			return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
		} else {
			throw Error('Invalid continuation byte');
		}
	}

	// 4-byte sequence
	if ((byte1 & 0xF8) == 0xF0) {
		byte2 = readContinuationByte();
		byte3 = readContinuationByte();
		byte4 = readContinuationByte();
		codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
			(byte3 << 0x06) | byte4;
		if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
			return codePoint;
		}
	}

	throw Error('Invalid UTF-8 detected');
}

var byteArray;
var byteCount;
var byteIndex;
function utf8decode(byteString, opts) {
	opts = opts || {};
	var strict = false !== opts.strict;

	byteArray = ucs2decode(byteString);
	byteCount = byteArray.length;
	byteIndex = 0;
	var codePoints = [];
	var tmp;
	while ((tmp = decodeSymbol(strict)) !== false) {
		codePoints.push(tmp);
	}
	return ucs2encode(codePoints);
}

module.exports = {
	version: '2.1.2',
	encode: utf8encode,
	decode: utf8decode
};


/***/ }),
/* 150 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 151 */
/***/ (function(module, exports) {

module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}


/***/ }),
/* 152 */
/***/ (function(module, exports) {


/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(68);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var tty = __webpack_require__(23);
var util = __webpack_require__(0);

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(68);
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [ 6, 2, 3, 4, 5, 1 ];

try {
  var supportsColor = __webpack_require__(43);
  if (supportsColor && supportsColor.level >= 2) {
    exports.colors = [
      20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68,
      69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134,
      135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171,
      172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204,
      205, 206, 207, 208, 209, 214, 215, 220, 221
    ];
  }
} catch (err) {
  // swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(process.stderr.fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var colorCode = '\u001b[3' + (c < 8 ? c : '8;5;' + c);
    var prefix = '  ' + colorCode + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push(colorCode + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = getDate() + name + ' ' + args[0];
  }
}

function getDate() {
  if (exports.inspectOpts.hideDate) {
    return '';
  } else {
    return new Date().toISOString() + ' ';
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log() {
  return process.stderr.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());


/***/ }),
/* 155 */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = (flag, argv) => {
	argv = argv || process.argv;
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const pos = argv.indexOf(prefix + flag);
	const terminatorPos = argv.indexOf('--');
	return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
};


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var Polling = __webpack_require__(67);
var qs = __webpack_require__(26);
var rDoubleSlashes = /\\\\n/g;
var rSlashes = /(\\)?\\n/g;
var util = __webpack_require__(0);

/**
 * Module exports.
 */

module.exports = JSONP;

/**
 * JSON-P polling transport.
 *
 * @api public
 */

function JSONP (req) {
  Polling.call(this, req);

  this.head = '___eio[' + (req._query.j || '').replace(/[^0-9]/g, '') + '](';
  this.foot = ');';
}

/**
 * Inherits from Polling.
 */

util.inherits(JSONP, Polling);

/**
 * Handles incoming data.
 * Due to a bug in \n handling by browsers, we expect a escaped string.
 *
 * @api private
 */

JSONP.prototype.onData = function (data) {
  // we leverage the qs module so that we get built-in DoS protection
  // and the fast alternative to decodeURIComponent
  data = qs.parse(data).d;
  if ('string' === typeof data) {
    // client will send already escaped newlines as \\\\n and newlines as \\n
    // \\n must be replaced with \n and \\\\n with \\n
    data = data.replace(rSlashes, function (match, slashes) {
      return slashes ? match : '\n';
    });
    Polling.prototype.onData.call(this, data.replace(rDoubleSlashes, '\\n'));
  }
};

/**
 * Performs the write.
 *
 * @api private
 */

JSONP.prototype.doWrite = function (data, options, callback) {
  // we must output valid javascript, not valid json
  // see: http://timelessrepo.com/json-isnt-a-javascript-subset
  var js = JSON.stringify(data)
    .replace(/\u2028/g, '\\u2028')
    .replace(/\u2029/g, '\\u2029');

  // prepare response
  data = this.head + js + this.foot;

  Polling.prototype.doWrite.call(this, data, options, callback);
};


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var Transport = __webpack_require__(41);
var parser = __webpack_require__(31);
var util = __webpack_require__(0);
var debug = __webpack_require__(17)('engine:ws');

/**
 * Export the constructor.
 */

module.exports = WebSocket;

/**
 * WebSocket transport
 *
 * @param {http.IncomingMessage}
 * @api public
 */

function WebSocket (req) {
  Transport.call(this, req);
  var self = this;
  this.socket = req.websocket;
  this.socket.on('message', this.onData.bind(this));
  this.socket.once('close', this.onClose.bind(this));
  this.socket.on('error', this.onError.bind(this));
  this.socket.on('headers', onHeaders);
  this.writable = true;
  this.perMessageDeflate = null;

  function onHeaders (headers) {
    self.emit('headers', headers);
  }
}

/**
 * Inherits from Transport.
 */

util.inherits(WebSocket, Transport);

/**
 * Transport name
 *
 * @api public
 */

WebSocket.prototype.name = 'websocket';

/**
 * Advertise upgrade support.
 *
 * @api public
 */

WebSocket.prototype.handlesUpgrades = true;

/**
 * Advertise framing support.
 *
 * @api public
 */

WebSocket.prototype.supportsFraming = true;

/**
 * Processes the incoming data.
 *
 * @param {String} encoded packet
 * @api private
 */

WebSocket.prototype.onData = function (data) {
  debug('received "%s"', data);
  Transport.prototype.onData.call(this, data);
};

/**
 * Writes a packet payload.
 *
 * @param {Array} packets
 * @api private
 */

WebSocket.prototype.send = function (packets) {
  var self = this;

  for (var i = 0; i < packets.length; i++) {
    var packet = packets[i];
    parser.encodePacket(packet, self.supportsBinary, send);
  }

  function send (data) {
    debug('writing "%s"', data);

    // always creates a new object since ws modifies it
    var opts = {};
    if (packet.options) {
      opts.compress = packet.options.compress;
    }

    if (self.perMessageDeflate) {
      var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;
      if (len < self.perMessageDeflate.threshold) {
        opts.compress = false;
      }
    }

    self.writable = false;
    self.socket.send(data, opts, onEnd);
  }

  function onEnd (err) {
    if (err) return self.onError('write error', err.stack);
    self.writable = true;
    self.emit('drain');
  }
};

/**
 * Closes the transport.
 *
 * @api private
 */

WebSocket.prototype.doClose = function (fn) {
  debug('closing');
  this.socket.close();
  fn && fn();
};


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const http = __webpack_require__(4);
const EventEmitter = __webpack_require__(1);
const EE_ERROR = 'Registering more than one listener to a WebSocket is not supported.';
const DEFAULT_PAYLOAD_LIMIT = 16777216;

let _upgradeReq = null;

function noop() {}

function abortConnection(socket, code, name) {
    socket.end('HTTP/1.1 ' + code + ' ' + name + '\r\n\r\n');
}

function emitConnection(ws) {
    this.emit('connection', ws, _upgradeReq);
}

function onServerMessage(message, webSocket) {
    webSocket.internalOnMessage(message);
}

const native = (() => {
    try {
        try {
            return process.binding('uws_builtin');
        } catch (e) {
            return __webpack_require__(160)(`./uws_${process.platform}_${process.versions.modules}`);
        }
    } catch (e) {
        const version = process.version.substring(1).split('.').map(function(n) {
            return parseInt(n);
        });
        const lessThanSixFour = version[0] < 6 || (version[0] === 6 && version[1] < 4);

        if (process.platform === 'win32' && lessThanSixFour) {
            throw new Error('WebSockets requires Node.js 6.4.0 or greater on Windows.');
        } else {
            throw new Error('Compilation of WebSockets has failed and there is no pre-compiled binary ' +
            'available for your system. Please install a supported C++11 compiler and reinstall the module \'uws\'.');
        }
    }
})();

native.setNoop(noop);

const clientGroup = native.client.group.create(0, DEFAULT_PAYLOAD_LIMIT);

native.client.group.onConnection(clientGroup, (external) => {
    const webSocket = native.getUserData(external);
    webSocket.external = external;
    webSocket.internalOnOpen();
});

native.client.group.onMessage(clientGroup, (message, webSocket) => {
    webSocket.internalOnMessage(message);
});

native.client.group.onDisconnection(clientGroup, (external, code, message, webSocket) => {
    webSocket.external = null;

    process.nextTick(() => {
        webSocket.internalOnClose(code, message);
    });

    native.clearUserData(external);
});

native.client.group.onPing(clientGroup, (message, webSocket) => {
    webSocket.onping(message);
});

native.client.group.onPong(clientGroup, (message, webSocket) => {
    webSocket.onpong(message);
});

native.client.group.onError(clientGroup, (webSocket) => {
    process.nextTick(() => {
        webSocket.internalOnError({
            message: 'uWs client connection error',
            stack: 'uWs client connection error'
        });
    });
});

class WebSocket {
    constructor(external) {
        this.external = external;
        this.internalOnMessage = noop;
        this.internalOnClose = noop;
        this.onping = noop;
        this.onpong = noop;
    }

    get upgradeReq() {
        return _upgradeReq;
    }

    set onmessage(f) {
        if (f) {
            this.internalOnMessage = (message) => {
                f({data: message});
            };
        } else {
            this.internalOnMessage = noop;
        }
    }

    set onopen(f) {
        if (f) {
            this.internalOnOpen = f;
        } else {
            this.internalOnOpen = noop;
        }
    }

    set onclose(f) {
        if (f) {
            this.internalOnClose = (code, message) => {
                f({code: code, reason: message});
            };
        } else {
            this.internalOnClose = noop;
        }
    }

    set onerror(f) {
        if (f && this instanceof WebSocketClient) {
            this.internalOnError = f;
        } else {
            this.internalOnError = noop;
        }
    }

    emit(eventName, arg1, arg2) {
        if (eventName === 'message') {
            this.internalOnMessage(arg1);
        } else if (eventName === 'close') {
            this.internalOnClose(arg1, arg2);
        } else if (eventName === 'ping') {
            this.onping(arg1);
        } else if (eventName === 'pong') {
            this.onpong(arg1);
        }
        return this;
    }

    on(eventName, f) {
        if (eventName === 'message') {
            if (this.internalOnMessage !== noop) {
                throw Error(EE_ERROR);
            }
            this.internalOnMessage = f;
        } else if (eventName === 'close') {
            if (this.internalOnClose !== noop) {
                throw Error(EE_ERROR);
            }
            this.internalOnClose = f;
        } else if (eventName === 'ping') {
            if (this.onping !== noop) {
                throw Error(EE_ERROR);
            }
            this.onping = f;
        } else if (eventName === 'pong') {
            if (this.onpong !== noop) {
                throw Error(EE_ERROR);
            }
            this.onpong = f;
        } else if (eventName === 'open') {
            if (this.internalOnOpen !== noop) {
                throw Error(EE_ERROR);
            }
            this.internalOnOpen = f;
        } else if (eventName === 'error' && this instanceof WebSocketClient) {
            if (this.internalOnError !== noop) {
                throw Error(EE_ERROR);
            }
            this.internalOnError = f;
        }
        return this;
    }

    once(eventName, f) {
        if (eventName === 'message') {
            if (this.internalOnMessage !== noop) {
                throw Error(EE_ERROR);
            }
            this.internalOnMessage = (message) => {
                this.internalOnMessage = noop;
                f(message);
            };
        } else if (eventName === 'open') {
            if (this.internalOnOpen !== noop) {
                throw Error(EE_ERROR);
            }
            this.internalOnOpen = () => {
                this.internalOnOpen = noop;
                f();
            };
        } else if (eventName === 'close') {
            if (this.internalOnClose !== noop) {
                throw Error(EE_ERROR);
            }
            this.internalOnClose = (code, message) => {
                this.internalOnClose = noop;
                f(code, message);
            };
        } else if (eventName === 'ping') {
            if (this.onping !== noop) {
                throw Error(EE_ERROR);
            }
            this.onping = () => {
                this.onping = noop;
                f();
            };
        } else if (eventName === 'pong') {
            if (this.onpong !== noop) {
                throw Error(EE_ERROR);
            }
            this.onpong = () => {
                this.onpong = noop;
                f();
            };
        }
        return this;
    }

    removeAllListeners(eventName) {
        if (!eventName || eventName === 'message') {
            this.internalOnMessage = noop;
        }
        if (!eventName || eventName === 'open') {
            this.internalOnOpen = noop;
        }
        if (!eventName || eventName === 'close') {
            this.internalOnClose = noop;
        }
        if (!eventName || eventName === 'ping') {
            this.onping = noop;
        }
        if (!eventName || eventName === 'pong') {
            this.onpong = noop;
        }
        return this;
    }

    removeListener(eventName, cb) {
        if (eventName === 'message' && this.internalOnMessage === cb) {
            this.internalOnMessage = noop;
        } else if (eventName === 'open' && this.internalOnOpen === cb) {
            this.internalOnOpen = noop;
        } else if (eventName === 'close' && this.internalOnClose === cb) {
            this.internalOnClose = noop;
        } else if (eventName === 'ping' && this.onping === cb) {
            this.onping = noop;
        } else if (eventName === 'pong' && this.onpong === cb) {
            this.onpong = noop;
        }
        return this;
    }

    get OPEN() {
        return WebSocketClient.OPEN;
    }

    get CLOSED() {
        return WebSocketClient.CLOSED;
    }

    get readyState() {
        return this.external ? WebSocketClient.OPEN : WebSocketClient.CLOSED;
    }

    get _socket() {
        const address = this.external ? native.getAddress(this.external) : new Array(3);
        return {
            remotePort: address[0],
            remoteAddress: address[1],
            remoteFamily: address[2]
        };
    }

    // from here down, functions are not common between client and server

    ping(message, options, dontFailWhenClosed) {
        if (this.external) {
            native.server.send(this.external, message, WebSocketClient.OPCODE_PING, false);
        }
    }

    terminate() {
        if (this.external) {
            native.server.terminate(this.external);
            this.external = null;
        }
    }

    send(message, options, cb, compress) {
        if (this.external) {
            if (typeof options === 'function') {
                cb = options;
                options = null;
            }

            const binary = options && typeof options.binary === 'boolean' ? options.binary : typeof message !== 'string';

            native.server.send(this.external, message, binary ? WebSocketClient.OPCODE_BINARY : WebSocketClient.OPCODE_TEXT, cb ? (() => {
                process.nextTick(cb);
            }) : undefined, compress);
        } else if (cb) {
            cb(new Error('not opened'));
        }
    }

    close(code, data) {
        if (this.external) {
            native.server.close(this.external, code, data);
            this.external = null;
        }
    }
}

class WebSocketClient extends WebSocket {
    constructor(uri) {
        super(null);
        this.internalOnOpen = noop;
        this.internalOnError = noop;
        native.connect(clientGroup, uri, this);
    }

    ping(message, options, dontFailWhenClosed) {
        if (this.external) {
            native.client.send(this.external, message, WebSocketClient.OPCODE_PING, false);
        }
    }

    terminate() {
        if (this.external) {
            native.client.terminate(this.external);
            this.external = null;
        }
    }

    send(message, options, cb, compress) {
        if (this.external) {
            if (typeof options === 'function') {
                cb = options;
                options = null;
            }

            const binary = options && typeof options.binary === 'boolean' ? options.binary : typeof message !== 'string';

            native.client.send(this.external, message, binary ? WebSocketClient.OPCODE_BINARY : WebSocketClient.OPCODE_TEXT, cb ? (() => {
                process.nextTick(cb);
            }) : undefined, compress);
        } else if (cb) {
            cb(new Error('not opened'));
        }
    }

    close(code, data) {
        if (this.external) {
            native.client.close(this.external, code, data);
            this.external = null;
        }
    }
}

class Server extends EventEmitter {
    constructor(options, callback) {
        super();

        if (!options) {
            throw new TypeError('missing options');
        }

        if (options.port === undefined && !options.server && !options.noServer) {
            throw new TypeError('invalid options');
        }

        var nativeOptions = 0;
        if (options.perMessageDeflate !== undefined && options.perMessageDeflate !== false) {
            nativeOptions |= WebSocketClient.PERMESSAGE_DEFLATE;

            if (options.perMessageDeflate.serverNoContextTakeover === false) {
                nativeOptions |= WebSocketClient.SLIDING_DEFLATE_WINDOW;
            }
        }

        this.serverGroup = native.server.group.create(nativeOptions, options.maxPayload === undefined ? DEFAULT_PAYLOAD_LIMIT : options.maxPayload);

        // can these be made private?
        this._upgradeCallback = noop;
        this._upgradeListener = null;
        this._noDelay = options.noDelay === undefined ? true : options.noDelay;
        this._lastUpgradeListener = true;
        this._passedHttpServer = options.server;

        if (!options.noServer) {
            this.httpServer = options.server ? options.server : http.createServer((request, response) => {
                // todo: default HTTP response
                response.end();
            });

            if (options.path && (!options.path.length || options.path[0] !== '/')) {
                options.path = '/' + options.path;
            }

            this.httpServer.on('upgrade', this._upgradeListener = ((request, socket, head) => {
                if (!options.path || options.path == request.url.split('?')[0].split('#')[0]) {
                    if (options.verifyClient) {
                        const info = {
                            origin: request.headers.origin,
                            secure: request.connection.authorized !== undefined || request.connection.encrypted !== undefined,
                            req: request
                        };

                        if (options.verifyClient.length === 2) {
                            options.verifyClient(info, (result, code, name) => {
                                if (result) {
                                    this.handleUpgrade(request, socket, head, emitConnection);
                                } else {
                                    abortConnection(socket, code, name);
                                }
                            });
                        } else {
                            if (options.verifyClient(info)) {
                                this.handleUpgrade(request, socket, head, emitConnection);
                            } else {
                                abortConnection(socket, 400, 'Client verification failed');
                            }
                        }
                    } else {
                        this.handleUpgrade(request, socket, head, emitConnection);
                    }
                } else {
                    if (this._lastUpgradeListener) {
                        abortConnection(socket, 400, 'URL not supported');
                    }
                }
            }));

            this.httpServer.on('newListener', (eventName, listener) => {
                if (eventName === 'upgrade') {
                    this._lastUpgradeListener = false;
                }
            });

            this.httpServer.on('error', (err) => {
                this.emit('error', err);
            });
        }

        native.server.group.onDisconnection(this.serverGroup, (external, code, message, webSocket) => {
            webSocket.external = null;

            process.nextTick(() => {
                webSocket.internalOnClose(code, message);
            });

            native.clearUserData(external);
        });

        native.server.group.onMessage(this.serverGroup, onServerMessage);

        native.server.group.onPing(this.serverGroup, (message, webSocket) => {
            webSocket.onping(message);
        });

        native.server.group.onPong(this.serverGroup, (message, webSocket) => {
            webSocket.onpong(message);
        });

        native.server.group.onConnection(this.serverGroup, (external) => {
            const webSocket = new WebSocket(external);

            native.setUserData(external, webSocket);
            this._upgradeCallback(webSocket);
            _upgradeReq = null;
        });

        if (options.port !== undefined) {
            if (options.host) {
                this.httpServer.listen(options.port, options.host, () => {
                    this.emit('listening');
                    callback && callback();
                });
            } else {
                this.httpServer.listen(options.port, () => {
                    this.emit('listening');
                    callback && callback();
                });
            }
        }
    }

    handleUpgrade(request, socket, upgradeHead, callback) {
        if (socket._isNative) {
            if (this.serverGroup) {
                _upgradeReq = request;
                this._upgradeCallback = callback ? callback : noop;
                native.upgrade(this.serverGroup, socket.external, secKey, request.headers['sec-websocket-extensions'], request.headers['sec-websocket-protocol']);
            }
        } else {
            const secKey = request.headers['sec-websocket-key'];
            const socketHandle = socket.ssl ? socket._parent._handle : socket._handle;
            const sslState = socket.ssl ? socket.ssl._external : null;
            if (socketHandle && secKey && secKey.length == 24) {
                socket.setNoDelay(this._noDelay);
                const ticket = native.transfer(socketHandle.fd === -1 ? socketHandle : socketHandle.fd, sslState);
                socket.on('close', (error) => {
                    if (this.serverGroup) {
                        _upgradeReq = request;
                        this._upgradeCallback = callback ? callback : noop;
                        native.upgrade(this.serverGroup, ticket, secKey, request.headers['sec-websocket-extensions'], request.headers['sec-websocket-protocol']);
                    }
                });
            }
            socket.destroy();
        }
    }

    broadcast(message, options) {
        if (this.serverGroup) {
            native.server.group.broadcast(this.serverGroup, message, options && options.binary || false);
        }
    }

    startAutoPing(interval, userMessage) {
        if (this.serverGroup) {
            native.server.group.startAutoPing(this.serverGroup, interval, userMessage);
        }
    }

    close(cb) {
        if (this._upgradeListener && this.httpServer) {
            this.httpServer.removeListener('upgrade', this._upgradeListener);

            if (!this._passedHttpServer) {
                this.httpServer.close();
            }
        }

        if (this.serverGroup) {
            native.server.group.close(this.serverGroup);
            this.serverGroup = null;
        }

        if (typeof cb === 'function') {
            // compatibility hack, 15 seconds timeout
            setTimeout(cb, 20000);
        }
    }

    get clients() {
        if (this.serverGroup) {
            return {
                length: native.server.group.getSize(this.serverGroup),
                forEach: ((cb) => {native.server.group.forEach(this.serverGroup, cb)})
            };
        }
    }
}

WebSocketClient.PERMESSAGE_DEFLATE = 1;
WebSocketClient.SLIDING_DEFLATE_WINDOW = 16;
//WebSocketClient.SERVER_NO_CONTEXT_TAKEOVER = 2;
//WebSocketClient.CLIENT_NO_CONTEXT_TAKEOVER = 4;
WebSocketClient.OPCODE_TEXT = 1;
WebSocketClient.OPCODE_BINARY = 2;
WebSocketClient.OPCODE_PING = 9;
WebSocketClient.OPEN = 1;
WebSocketClient.CLOSED = 0;
WebSocketClient.Server = Server;
WebSocketClient.http = native.httpServer;
WebSocketClient.native = native;
module.exports = WebSocketClient;


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./uws_darwin_57.node": 161,
	"./uws_darwin_59.node": 162,
	"./uws_darwin_64.node": 163,
	"./uws_linux_57.node": 164,
	"./uws_linux_59.node": 165,
	"./uws_linux_64.node": 166,
	"./uws_win32_57.node": 167,
	"./uws_win32_59.node": 168,
	"./uws_win32_64.node": 169
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 160;

/***/ }),
/* 161 */
/***/ (function(module, exports) {

throw new Error("Module parse failed: Unexpected character '' (1:0)\nYou may need an appropriate loader to handle this file type.\n(Source code omitted for this binary file)");

/***/ }),
/* 162 */
/***/ (function(module, exports) {

throw new Error("Module parse failed: Unexpected character '' (1:0)\nYou may need an appropriate loader to handle this file type.\n(Source code omitted for this binary file)");

/***/ }),
/* 163 */
/***/ (function(module, exports) {

throw new Error("Module parse failed: Unexpected character '' (1:0)\nYou may need an appropriate loader to handle this file type.\n(Source code omitted for this binary file)");

/***/ }),
/* 164 */
/***/ (function(module, exports) {

throw new Error("Module parse failed: Unexpected character '' (1:0)\nYou may need an appropriate loader to handle this file type.\n(Source code omitted for this binary file)");

/***/ }),
/* 165 */
/***/ (function(module, exports) {

throw new Error("Module parse failed: Unexpected character '' (1:0)\nYou may need an appropriate loader to handle this file type.\n(Source code omitted for this binary file)");

/***/ }),
/* 166 */
/***/ (function(module, exports) {

throw new Error("Module parse failed: Unexpected character '' (1:0)\nYou may need an appropriate loader to handle this file type.\n(Source code omitted for this binary file)");

/***/ }),
/* 167 */
/***/ (function(module, exports) {

throw new Error("Module parse failed: Unexpected character '' (1:2)\nYou may need an appropriate loader to handle this file type.\n(Source code omitted for this binary file)");

/***/ }),
/* 168 */
/***/ (function(module, exports) {

throw new Error("Module parse failed: Unexpected character '' (1:2)\nYou may need an appropriate loader to handle this file type.\n(Source code omitted for this binary file)");

/***/ }),
/* 169 */
/***/ (function(module, exports) {

throw new Error("Module parse failed: Unexpected character '' (1:2)\nYou may need an appropriate loader to handle this file type.\n(Source code omitted for this binary file)");

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const WebSocket = __webpack_require__(70);

WebSocket.Server = __webpack_require__(175);
WebSocket.Receiver = __webpack_require__(72);
WebSocket.Sender = __webpack_require__(74);

module.exports = WebSocket;


/***/ }),
/* 171 */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),
/* 172 */
/***/ (function(module, exports) {

module.exports = require("tls");

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function Queue(options) {
  if (!(this instanceof Queue)) {
    return new Queue(options);
  }

  options = options || {};
  this.concurrency = options.concurrency || Infinity;
  this.pending = 0;
  this.jobs = [];
  this.cbs = [];
  this._done = done.bind(this);
}

var arrayAddMethods = [
  'push',
  'unshift',
  'splice'
];

arrayAddMethods.forEach(function(method) {
  Queue.prototype[method] = function() {
    var methodResult = Array.prototype[method].apply(this.jobs, arguments);
    this._run();
    return methodResult;
  };
});

Object.defineProperty(Queue.prototype, 'length', {
  get: function() {
    return this.pending + this.jobs.length;
  }
});

Queue.prototype._run = function() {
  if (this.pending === this.concurrency) {
    return;
  }
  if (this.jobs.length) {
    var job = this.jobs.shift();
    this.pending++;
    job(this._done);
    this._run();
  }

  if (this.pending === 0) {
    while (this.cbs.length !== 0) {
      var cb = this.cbs.pop();
      process.nextTick(cb);
    }
  }
};

Queue.prototype.onDone = function(cb) {
  if (typeof cb === 'function') {
    this.cbs.push(cb);
    this._run();
  }
};

function done() {
  this.pending--;
  this._run();
}

module.exports = Queue;


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Class representing an event.
 *
 * @private
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @param {Object} target A reference to the target to which the event was dispatched
   */
  constructor(type, target) {
    this.target = target;
    this.type = type;
  }
}

/**
 * Class representing a message event.
 *
 * @extends Event
 * @private
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor(data, target) {
    super('message', target);

    this.data = data;
  }
}

/**
 * Class representing a close event.
 *
 * @extends Event
 * @private
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {Number} code The status code explaining why the connection is being closed
   * @param {String} reason A human-readable string explaining why the connection is closing
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor(code, reason, target) {
    super('close', target);

    this.wasClean = target._closeFrameReceived && target._closeFrameSent;
    this.reason = reason;
    this.code = code;
  }
}

/**
 * Class representing an open event.
 *
 * @extends Event
 * @private
 */
class OpenEvent extends Event {
  /**
   * Create a new `OpenEvent`.
   *
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor(target) {
    super('open', target);
  }
}

/**
 * Class representing an error event.
 *
 * @extends Event
 * @private
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {Object} error The error that generated this event
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor(error, target) {
    super('error', target);

    this.message = error.message;
    this.error = error;
  }
}

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} method A string representing the event type to listen for
   * @param {Function} listener The listener to add
   * @public
   */
  addEventListener(method, listener) {
    if (typeof listener !== 'function') return;

    function onMessage(data) {
      listener.call(this, new MessageEvent(data, this));
    }

    function onClose(code, message) {
      listener.call(this, new CloseEvent(code, message, this));
    }

    function onError(error) {
      listener.call(this, new ErrorEvent(error, this));
    }

    function onOpen() {
      listener.call(this, new OpenEvent(this));
    }

    if (method === 'message') {
      onMessage._listener = listener;
      this.on(method, onMessage);
    } else if (method === 'close') {
      onClose._listener = listener;
      this.on(method, onClose);
    } else if (method === 'error') {
      onError._listener = listener;
      this.on(method, onError);
    } else if (method === 'open') {
      onOpen._listener = listener;
      this.on(method, onOpen);
    } else {
      this.on(method, listener);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} method A string representing the event type to remove
   * @param {Function} listener The listener to remove
   * @public
   */
  removeEventListener(method, listener) {
    const listeners = this.listeners(method);

    for (var i = 0; i < listeners.length; i++) {
      if (listeners[i] === listener || listeners[i]._listener === listener) {
        this.removeListener(method, listeners[i]);
      }
    }
  }
};

module.exports = EventTarget;


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const EventEmitter = __webpack_require__(1);
const crypto = __webpack_require__(12);
const http = __webpack_require__(4);

const PerMessageDeflate = __webpack_require__(32);
const extension = __webpack_require__(71);
const constants = __webpack_require__(18);
const WebSocket = __webpack_require__(70);

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {String} options.host The hostname where to bind the server
   * @param {Number} options.port The port where to bind the server
   * @param {http.Server} options.server A pre-created HTTP/S server to use
   * @param {Function} options.verifyClient An hook to reject connections
   * @param {Function} options.handleProtocols An hook to handle protocols
   * @param {String} options.path Accept only connections matching this path
   * @param {Boolean} options.noServer Enable no server mode
   * @param {Boolean} options.clientTracking Specifies whether or not to track clients
   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate
   * @param {Number} options.maxPayload The maximum allowed message size
   * @param {Function} callback A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = Object.assign(
      {
        maxPayload: 100 * 1024 * 1024,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        verifyClient: null,
        noServer: false,
        backlog: null, // use default (511 as implemented in net.js)
        server: null,
        host: null,
        path: null,
        port: null
      },
      options
    );

    if (options.port == null && !options.server && !options.noServer) {
      throw new TypeError(
        'One of the "port", "server", or "noServer" options must be specified'
      );
    }

    if (options.port != null) {
      this._server = http.createServer((req, res) => {
        const body = http.STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, (ws) => {
            this.emit('connection', ws, req);
          });
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) this.clients = new Set();
    this.options = options;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Close the server.
   *
   * @param {Function} cb Callback
   * @public
   */
  close(cb) {
    if (cb) this.once('close', cb);

    //
    // Terminate all associated clients.
    //
    if (this.clients) {
      for (const client of this.clients) client.terminate();
    }

    const server = this._server;

    if (server) {
      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // Close the http server if it was internally created.
      //
      if (this.options.port != null) {
        server.close(() => this.emit('close'));
        return;
      }
    }

    process.nextTick(emitClose, this);
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError);

    const version = +req.headers['sec-websocket-version'];
    const extensions = {};

    if (
      req.method !== 'GET' ||
      req.headers.upgrade.toLowerCase() !== 'websocket' ||
      !req.headers['sec-websocket-key'] ||
      (version !== 8 && version !== 13) ||
      !this.shouldHandle(req)
    ) {
      return abortHandshake(socket, 400);
    }

    if (this.options.perMessageDeflate) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = extension.parse(req.headers['sec-websocket-extensions']);

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        return abortHandshake(socket, 400);
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.connection.authorized || req.connection.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(extensions, req, socket, head, cb);
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(extensions, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {Object} extensions The accepted extensions
   * @param {http.IncomingMessage} req The request object
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @private
   */
  completeUpgrade(extensions, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    const key = crypto
      .createHash('sha1')
      .update(req.headers['sec-websocket-key'] + constants.GUID, 'binary')
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${key}`
    ];

    const ws = new WebSocket(null);
    var protocol = req.headers['sec-websocket-protocol'];

    if (protocol) {
      protocol = protocol.trim().split(/ *, */);

      //
      // Optionally call external protocol selection handler.
      //
      if (this.options.handleProtocols) {
        protocol = this.options.handleProtocols(protocol, req);
      } else {
        protocol = protocol[0];
      }

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws.protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = extension.format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, this.options.maxPayload);

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => this.clients.delete(ws));
    }

    cb(ws);
  }
}

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when called
 * @private
 */
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose(server) {
  server.emit('close');
}

/**
 * Handle premature socket errors.
 *
 * @private
 */
function socketOnError() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {net.Socket} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) {
  if (socket.writable) {
    message = message || http.STATUS_CODES[code];
    headers = Object.assign(
      {
        Connection: 'close',
        'Content-type': 'text/html',
        'Content-Length': Buffer.byteLength(message)
      },
      headers
    );

    socket.write(
      `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` +
        Object.keys(headers)
          .map((h) => `${h}: ${headers[h]}`)
          .join('\r\n') +
        '\r\n\r\n' +
        message
    );
  }

  socket.removeListener('error', socketOnError);
  socket.destroy();
}


/***/ }),
/* 176 */
/***/ (function(module, exports) {

module.exports = {"_args":[["socket.io-client@2.2.0","C:\\workspace\\game\\server"]],"_from":"socket.io-client@2.2.0","_id":"socket.io-client@2.2.0","_inBundle":false,"_integrity":"sha512-56ZrkTDbdTLmBIyfFYesgOxsjcLnwAKoN4CiPyTVkMQj3zTUh0QAx3GbvIvLpFEOvQWu92yyWICxB0u7wkVbYA==","_location":"/socket.io-client","_phantomChildren":{"ms":"2.0.0"},"_requested":{"type":"version","registry":true,"raw":"socket.io-client@2.2.0","name":"socket.io-client","escapedName":"socket.io-client","rawSpec":"2.2.0","saveSpec":null,"fetchSpec":"2.2.0"},"_requiredBy":["/socket.io"],"_resolved":"https://registry.npmjs.org/socket.io-client/-/socket.io-client-2.2.0.tgz","_spec":"2.2.0","_where":"C:\\workspace\\game\\server","bugs":{"url":"https://github.com/Automattic/socket.io-client/issues"},"contributors":[{"name":"Guillermo Rauch","email":"rauchg@gmail.com"},{"name":"Arnout Kazemier","email":"info@3rd-eden.com"},{"name":"Vladimir Dronnikov","email":"dronnikov@gmail.com"},{"name":"Einar Otto Stangvik","email":"einaros@gmail.com"}],"dependencies":{"backo2":"1.0.2","base64-arraybuffer":"0.1.5","component-bind":"1.0.0","component-emitter":"1.2.1","debug":"~3.1.0","engine.io-client":"~3.3.1","has-binary2":"~1.0.2","has-cors":"1.1.0","indexof":"0.0.1","object-component":"0.0.3","parseqs":"0.0.5","parseuri":"0.0.5","socket.io-parser":"~3.3.0","to-array":"0.1.4"},"description":"[![Build Status](https://secure.travis-ci.org/socketio/socket.io-client.svg?branch=master)](http://travis-ci.org/socketio/socket.io-client) [![Dependency Status](https://david-dm.org/socketio/socket.io-client.svg)](https://david-dm.org/socketio/socket.io-client) [![devDependency Status](https://david-dm.org/socketio/socket.io-client/dev-status.svg)](https://david-dm.org/socketio/socket.io-client#info=devDependencies) [![NPM version](https://badge.fury.io/js/socket.io-client.svg)](https://www.npmjs.com/package/socket.io-client) ![Downloads](http://img.shields.io/npm/dm/socket.io-client.svg?style=flat) [![](http://slack.socket.io/badge.svg?)](http://slack.socket.io)","devDependencies":{"babel-core":"^6.24.1","babel-eslint":"4.1.7","babel-loader":"7.0.0","babel-preset-es2015":"6.24.1","concat-stream":"^1.6.0","derequire":"^2.0.6","eslint-config-standard":"4.4.0","eslint-plugin-standard":"1.3.1","expect.js":"0.3.1","gulp":"^3.9.1","gulp-eslint":"1.1.1","gulp-file":"^0.3.0","gulp-istanbul":"^1.1.1","gulp-mocha":"^4.3.1","gulp-task-listing":"1.0.1","imports-loader":"^0.7.1","istanbul":"^0.4.5","mocha":"^3.3.0","socket.io":"2.2.0","socket.io-browsers":"^1.0.0","strip-loader":"0.1.2","text-blob-builder":"0.0.1","webpack-merge":"4.1.2","webpack-stream":"3.2.0","zuul":"~3.11.1","zuul-builder-webpack":"^1.2.0","zuul-ngrok":"4.0.0"},"files":["lib/","dist/"],"homepage":"https://github.com/Automattic/socket.io-client#readme","keywords":["realtime","framework","websocket","tcp","events","client"],"license":"MIT","main":"./lib/index","name":"socket.io-client","repository":{"type":"git","url":"git+https://github.com/Automattic/socket.io-client.git"},"scripts":{"test":"gulp test"},"version":"2.2.0"}

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var parser = __webpack_require__(33);
var debug = __webpack_require__(34)('socket.io:client');
var url = __webpack_require__(7);

/**
 * Module exports.
 */

module.exports = Client;

/**
 * Client constructor.
 *
 * @param {Server} server instance
 * @param {Socket} conn
 * @api private
 */

function Client(server, conn){
  this.server = server;
  this.conn = conn;
  this.encoder = server.encoder;
  this.decoder = new server.parser.Decoder();
  this.id = conn.id;
  this.request = conn.request;
  this.setup();
  this.sockets = {};
  this.nsps = {};
  this.connectBuffer = [];
}

/**
 * Sets up event listeners.
 *
 * @api private
 */

Client.prototype.setup = function(){
  this.onclose = this.onclose.bind(this);
  this.ondata = this.ondata.bind(this);
  this.onerror = this.onerror.bind(this);
  this.ondecoded = this.ondecoded.bind(this);

  this.decoder.on('decoded', this.ondecoded);
  this.conn.on('data', this.ondata);
  this.conn.on('error', this.onerror);
  this.conn.on('close', this.onclose);
};

/**
 * Connects a client to a namespace.
 *
 * @param {String} name namespace
 * @param {Object} query the query parameters
 * @api private
 */

Client.prototype.connect = function(name, query){
  if (this.server.nsps[name]) {
    debug('connecting to namespace %s', name);
    return this.doConnect(name, query);
  }

  this.server.checkNamespace(name, query, (dynamicNsp) => {
    if (dynamicNsp) {
      debug('dynamic namespace %s was created', dynamicNsp.name);
      this.doConnect(name, query);
    } else {
      debug('creation of namespace %s was denied', name);
      this.packet({ type: parser.ERROR, nsp: name, data: 'Invalid namespace' });
    }
  });
};

/**
 * Connects a client to a namespace.
 *
 * @param {String} name namespace
 * @param {String} query the query parameters
 * @api private
 */

Client.prototype.doConnect = function(name, query){
  var nsp = this.server.of(name);

  if ('/' != name && !this.nsps['/']) {
    this.connectBuffer.push(name);
    return;
  }

  var self = this;
  var socket = nsp.add(this, query, function(){
    self.sockets[socket.id] = socket;
    self.nsps[nsp.name] = socket;

    if ('/' == nsp.name && self.connectBuffer.length > 0) {
      self.connectBuffer.forEach(self.connect, self);
      self.connectBuffer = [];
    }
  });
};

/**
 * Disconnects from all namespaces and closes transport.
 *
 * @api private
 */

Client.prototype.disconnect = function(){
  for (var id in this.sockets) {
    if (this.sockets.hasOwnProperty(id)) {
      this.sockets[id].disconnect();
    }
  }
  this.sockets = {};
  this.close();
};

/**
 * Removes a socket. Called by each `Socket`.
 *
 * @api private
 */

Client.prototype.remove = function(socket){
  if (this.sockets.hasOwnProperty(socket.id)) {
    var nsp = this.sockets[socket.id].nsp.name;
    delete this.sockets[socket.id];
    delete this.nsps[nsp];
  } else {
    debug('ignoring remove for %s', socket.id);
  }
};

/**
 * Closes the underlying connection.
 *
 * @api private
 */

Client.prototype.close = function(){
  if ('open' == this.conn.readyState) {
    debug('forcing transport close');
    this.conn.close();
    this.onclose('forced server close');
  }
};

/**
 * Writes a packet to the transport.
 *
 * @param {Object} packet object
 * @param {Object} opts
 * @api private
 */

Client.prototype.packet = function(packet, opts){
  opts = opts || {};
  var self = this;

  // this writes to the actual connection
  function writeToEngine(encodedPackets) {
    if (opts.volatile && !self.conn.transport.writable) return;
    for (var i = 0; i < encodedPackets.length; i++) {
      self.conn.write(encodedPackets[i], { compress: opts.compress });
    }
  }

  if ('open' == this.conn.readyState) {
    debug('writing packet %j', packet);
    if (!opts.preEncoded) { // not broadcasting, need to encode
      this.encoder.encode(packet, writeToEngine); // encode, then write results to engine
    } else { // a broadcast pre-encodes a packet
      writeToEngine(packet);
    }
  } else {
    debug('ignoring packet write %j', packet);
  }
};

/**
 * Called with incoming transport data.
 *
 * @api private
 */

Client.prototype.ondata = function(data){
  // try/catch is needed for protocol violations (GH-1880)
  try {
    this.decoder.add(data);
  } catch(e) {
    this.onerror(e);
  }
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Client.prototype.ondecoded = function(packet) {
  if (parser.CONNECT == packet.type) {
    this.connect(url.parse(packet.nsp).pathname, url.parse(packet.nsp, true).query);
  } else {
    var socket = this.nsps[packet.nsp];
    if (socket) {
      process.nextTick(function() {
        socket.onpacket(packet);
      });
    } else {
      debug('no socket for namespace %s', packet.nsp);
    }
  }
};

/**
 * Handles an error.
 *
 * @param {Object} err object
 * @api private
 */

Client.prototype.onerror = function(err){
  for (var id in this.sockets) {
    if (this.sockets.hasOwnProperty(id)) {
      this.sockets[id].onerror(err);
    }
  }
  this.conn.close();
};

/**
 * Called upon transport close.
 *
 * @param {String} reason
 * @api private
 */

Client.prototype.onclose = function(reason){
  debug('client close with reason %s', reason);

  // ignore a potential subsequent `close` event
  this.destroy();

  // `nsps` and `sockets` are cleaned up seamlessly
  for (var id in this.sockets) {
    if (this.sockets.hasOwnProperty(id)) {
      this.sockets[id].onclose(reason);
    }
  }
  this.sockets = {};

  this.decoder.destroy(); // clean up decoder
};

/**
 * Cleans up event listeners.
 *
 * @api private
 */

Client.prototype.destroy = function(){
  this.conn.removeListener('data', this.ondata);
  this.conn.removeListener('error', this.onerror);
  this.conn.removeListener('close', this.onclose);
  this.decoder.removeListener('decoded', this.ondecoded);
};


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer') {
  module.exports = __webpack_require__(179);
} else {
  module.exports = __webpack_require__(180);
}


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(75);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var tty = __webpack_require__(23);
var util = __webpack_require__(0);

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(75);
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [ 6, 2, 3, 4, 5, 1 ];

try {
  var supportsColor = __webpack_require__(43);
  if (supportsColor && supportsColor.level >= 2) {
    exports.colors = [
      20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68,
      69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134,
      135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171,
      172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204,
      205, 206, 207, 208, 209, 214, 215, 220, 221
    ];
  }
} catch (err) {
  // swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(process.stderr.fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var colorCode = '\u001b[3' + (c < 8 ? c : '8;5;' + c);
    var prefix = '  ' + colorCode + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push(colorCode + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = getDate() + name + ' ' + args[0];
  }
}

function getDate() {
  if (exports.inspectOpts.hideDate) {
    return '';
  } else {
    return new Date().toISOString() + ' ';
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log() {
  return process.stderr.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Expose `Emitter`.
 */

if (true) {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = __webpack_require__(76);
var isBuf = __webpack_require__(77);
var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' || (typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]');
var withNativeFile = typeof File === 'function' || (typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (isBuf(data)) {
    var placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (isArray(data)) {
    var newData = new Array(data.length);
    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (typeof data === 'object' && !(data instanceof Date)) {
    var newData = {};
    for (var key in data) {
      newData[key] = _deconstructPacket(data[key], buffers);
    }
    return newData;
  }
  return data;
}

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful
  return packet;
};

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === 'object') {
    for (var key in data) {
      data[key] = _reconstructPacket(data[key], buffers);
    }
  }

  return data;
}

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */
function log(...args) {
	// This hackery is required for IE8/9, where
	// the `console.log` function doesn't have 'apply'
	return typeof console === 'object' &&
		console.log &&
		console.log(...args);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(78)(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),
/* 184 */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

const tty = __webpack_require__(23);
const util = __webpack_require__(0);

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __webpack_require__(43);

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __webpack_require__(78)(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.replace(/\s*\n\s*/g, ' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var Emitter = __webpack_require__(1).EventEmitter;
var parser = __webpack_require__(33);
var hasBin = __webpack_require__(42);
var url = __webpack_require__(7);
var debug = __webpack_require__(34)('socket.io:socket');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Blacklisted events.
 *
 * @api public
 */

exports.events = [
  'error',
  'connect',
  'disconnect',
  'disconnecting',
  'newListener',
  'removeListener'
];

/**
 * Flags.
 *
 * @api private
 */

var flags = [
  'json',
  'volatile',
  'broadcast',
  'local'
];

/**
 * `EventEmitter#emit` reference.
 */

var emit = Emitter.prototype.emit;

/**
 * Interface to a `Client` for a given `Namespace`.
 *
 * @param {Namespace} nsp
 * @param {Client} client
 * @api public
 */

function Socket(nsp, client, query){
  this.nsp = nsp;
  this.server = nsp.server;
  this.adapter = this.nsp.adapter;
  this.id = nsp.name !== '/' ? nsp.name + '#' + client.id : client.id;
  this.client = client;
  this.conn = client.conn;
  this.rooms = {};
  this.acks = {};
  this.connected = true;
  this.disconnected = false;
  this.handshake = this.buildHandshake(query);
  this.fns = [];
  this.flags = {};
  this._rooms = [];
}

/**
 * Inherits from `EventEmitter`.
 */

Socket.prototype.__proto__ = Emitter.prototype;

/**
 * Apply flags from `Socket`.
 */

flags.forEach(function(flag){
  Object.defineProperty(Socket.prototype, flag, {
    get: function() {
      this.flags[flag] = true;
      return this;
    }
  });
});

/**
 * `request` engine.io shortcut.
 *
 * @api public
 */

Object.defineProperty(Socket.prototype, 'request', {
  get: function() {
    return this.conn.request;
  }
});

/**
 * Builds the `handshake` BC object
 *
 * @api private
 */

Socket.prototype.buildHandshake = function(query){
  var self = this;
  function buildQuery(){
    var requestQuery = url.parse(self.request.url, true).query;
    //if socket-specific query exist, replace query strings in requestQuery
    return Object.assign({}, query, requestQuery);
  }
  return {
    headers: this.request.headers,
    time: (new Date) + '',
    address: this.conn.remoteAddress,
    xdomain: !!this.request.headers.origin,
    secure: !!this.request.connection.encrypted,
    issued: +(new Date),
    url: this.request.url,
    query: buildQuery()
  };
};

/**
 * Emits to this client.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function(ev){
  if (~exports.events.indexOf(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = Array.prototype.slice.call(arguments);
  var packet = {
    type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,
    data: args
  };

  // access last argument to see if it's an ACK callback
  if (typeof args[args.length - 1] === 'function') {
    if (this._rooms.length || this.flags.broadcast) {
      throw new Error('Callbacks are not supported when broadcasting');
    }

    debug('emitting packet with ack id %d', this.nsp.ids);
    this.acks[this.nsp.ids] = args.pop();
    packet.id = this.nsp.ids++;
  }

  var rooms = this._rooms.slice(0);
  var flags = Object.assign({}, this.flags);

  // reset flags
  this._rooms = [];
  this.flags = {};

  if (rooms.length || flags.broadcast) {
    this.adapter.broadcast(packet, {
      except: [this.id],
      rooms: rooms,
      flags: flags
    });
  } else {
    // dispatch packet
    this.packet(packet, flags);
  }
  return this;
};

/**
 * Targets a room when broadcasting.
 *
 * @param {String} name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.to =
Socket.prototype.in = function(name){
  if (!~this._rooms.indexOf(name)) this._rooms.push(name);
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send =
Socket.prototype.write = function(){
  var args = Array.prototype.slice.call(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Writes a packet.
 *
 * @param {Object} packet object
 * @param {Object} opts options
 * @api private
 */

Socket.prototype.packet = function(packet, opts){
  packet.nsp = this.nsp.name;
  opts = opts || {};
  opts.compress = false !== opts.compress;
  this.client.packet(packet, opts);
};

/**
 * Joins a room.
 *
 * @param {String|Array} room or array of rooms
 * @param {Function} fn optional, callback
 * @return {Socket} self
 * @api private
 */

Socket.prototype.join = function(rooms, fn){
  debug('joining room %s', rooms);
  var self = this;
  if (!Array.isArray(rooms)) {
    rooms = [rooms];
  }
  rooms = rooms.filter(function (room) {
    return !self.rooms.hasOwnProperty(room);
  });
  if (!rooms.length) {
    fn && fn(null);
    return this;
  }
  this.adapter.addAll(this.id, rooms, function(err){
    if (err) return fn && fn(err);
    debug('joined room %s', rooms);
    rooms.forEach(function (room) {
      self.rooms[room] = room;
    });
    fn && fn(null);
  });
  return this;
};

/**
 * Leaves a room.
 *
 * @param {String} room
 * @param {Function} fn optional, callback
 * @return {Socket} self
 * @api private
 */

Socket.prototype.leave = function(room, fn){
  debug('leave room %s', room);
  var self = this;
  this.adapter.del(this.id, room, function(err){
    if (err) return fn && fn(err);
    debug('left room %s', room);
    delete self.rooms[room];
    fn && fn(null);
  });
  return this;
};

/**
 * Leave all rooms.
 *
 * @api private
 */

Socket.prototype.leaveAll = function(){
  this.adapter.delAll(this.id);
  this.rooms = {};
};

/**
 * Called by `Namespace` upon successful
 * middleware execution (ie: authorization).
 * Socket is added to namespace array before
 * call to join, so adapters can access it.
 *
 * @api private
 */

Socket.prototype.onconnect = function(){
  debug('socket connected - writing packet');
  this.nsp.connected[this.id] = this;
  this.join(this.id);
  var skip = this.nsp.name === '/' && this.nsp.fns.length === 0;
  if (skip) {
    debug('packet already sent in initial handshake');
  } else {
    this.packet({ type: parser.CONNECT });
  }
};

/**
 * Called with each packet. Called by `Client`.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function(packet){
  debug('got packet %j', packet);
  switch (packet.type) {
    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.onerror(new Error(packet.data));
  }
};

/**
 * Called upon event packet.
 *
 * @param {Object} packet object
 * @api private
 */

Socket.prototype.onevent = function(packet){
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  this.dispatch(args);
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @param {Number} id packet id
 * @api private
 */

Socket.prototype.ack = function(id){
  var self = this;
  var sent = false;
  return function(){
    // prevent double callbacks
    if (sent) return;
    var args = Array.prototype.slice.call(arguments);
    debug('sending ack %j', args);

    self.packet({
      id: id,
      type: hasBin(args) ? parser.BINARY_ACK : parser.ACK,
      data: args
    });

    sent = true;
  };
};

/**
 * Called upon ack packet.
 *
 * @api private
 */

Socket.prototype.onack = function(packet){
  var ack = this.acks[packet.id];
  if ('function' == typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon client disconnect packet.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function(){
  debug('got disconnect packet');
  this.onclose('client namespace disconnect');
};

/**
 * Handles a client error.
 *
 * @api private
 */

Socket.prototype.onerror = function(err){
  if (this.listeners('error').length) {
    this.emit('error', err);
  } else {
    console.error('Missing error handler on `socket`.');
    console.error(err.stack);
  }
};

/**
 * Called upon closing. Called by `Client`.
 *
 * @param {String} reason
 * @throw {Error} optional error object
 * @api private
 */

Socket.prototype.onclose = function(reason){
  if (!this.connected) return this;
  debug('closing socket - reason %s', reason);
  this.emit('disconnecting', reason);
  this.leaveAll();
  this.nsp.remove(this);
  this.client.remove(this);
  this.connected = false;
  this.disconnected = true;
  delete this.nsp.connected[this.id];
  this.emit('disconnect', reason);
};

/**
 * Produces an `error` packet.
 *
 * @param {Object} err error object
 * @api private
 */

Socket.prototype.error = function(err){
  this.packet({ type: parser.ERROR, data: err });
};

/**
 * Disconnects this client.
 *
 * @param {Boolean} close if `true`, closes the underlying connection
 * @return {Socket} self
 * @api public
 */

Socket.prototype.disconnect = function(close){
  if (!this.connected) return this;
  if (close) {
    this.client.disconnect();
  } else {
    this.packet({ type: parser.DISCONNECT });
    this.onclose('server namespace disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} compress if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function(compress){
  this.flags.compress = compress;
  return this;
};

/**
 * Sets the binary flag
 *
 * @param {Boolean} Encode as if it has binary data if `true`, Encode as if it doesnt have binary data if `false`
 * @return {Socket} self
 * @api public
 */

 Socket.prototype.binary = function (binary) {
   this.flags.binary = binary;
   return this;
 };

/**
 * Dispatch incoming event to socket listeners.
 *
 * @param {Array} event that will get emitted
 * @api private
 */

Socket.prototype.dispatch = function(event){
  debug('dispatching an event %j', event);
  var self = this;
  function dispatchSocket(err) {
    process.nextTick(function(){
      if (err) {
        return self.error(err.data || err.message);
      }
      emit.apply(self, event);
    });
  }
  this.run(event, dispatchSocket);
};

/**
 * Sets up socket middleware.
 *
 * @param {Function} middleware function (event, next)
 * @return {Socket} self
 * @api public
 */

Socket.prototype.use = function(fn){
  this.fns.push(fn);
  return this;
};

/**
 * Executes the middleware for an incoming event.
 *
 * @param {Array} event that will get emitted
 * @param {Function} last fn call in the middleware
 * @api private
 */
Socket.prototype.run = function(event, fn){
  var fns = this.fns.slice(0);
  if (!fns.length) return fn(null);

  function run(i){
    fns[i](event, function(err){
      // upon error, short-circuit
      if (err) return fn(err);

      // if no middleware left, summon callback
      if (!fns[i + 1]) return fn(null);

      // go on to next
      run(i + 1);
    });
  }

  run(0);
};


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Namespace = __webpack_require__(79);

let count = 0;

class ParentNamespace extends Namespace {

  constructor(server) {
    super(server, '/_' + (count++));
    this.children = new Set();
  }

  initAdapter() {}

  emit() {
    const args = Array.prototype.slice.call(arguments);

    this.children.forEach(nsp => {
      nsp.rooms = this.rooms;
      nsp.flags = this.flags;
      nsp.emit.apply(nsp, args);
    });
    this.rooms = [];
    this.flags = {};
  }

  createChild(name) {
    const namespace = new Namespace(this.server, name);
    namespace.fns = this.fns.slice(0);
    this.listeners('connect').forEach(listener => namespace.on('connect', listener));
    this.listeners('connection').forEach(listener => namespace.on('connection', listener));
    this.children.add(namespace);
    this.server.nsps[name] = namespace;
    return namespace;
  }
}

module.exports = ParentNamespace;


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var Emitter = __webpack_require__(1).EventEmitter;

/**
 * Module exports.
 */

module.exports = Adapter;

/**
 * Memory adapter constructor.
 *
 * @param {Namespace} nsp
 * @api public
 */

function Adapter(nsp){
  this.nsp = nsp;
  this.rooms = {};
  this.sids = {};
  this.encoder = nsp.server.encoder;
}

/**
 * Inherits from `EventEmitter`.
 */

Adapter.prototype.__proto__ = Emitter.prototype;

/**
 * Adds a socket to a room.
 *
 * @param {String} socket id
 * @param {String} room name
 * @param {Function} callback
 * @api public
 */

Adapter.prototype.add = function(id, room, fn){
  return this.addAll(id, [ room ], fn);
};

/**
 * Adds a socket to a list of room.
 *
 * @param {String} socket id
 * @param {String} rooms
 * @param {Function} callback
 * @api public
 */

Adapter.prototype.addAll = function(id, rooms, fn){
  for (var i = 0; i < rooms.length; i++) {
    var room = rooms[i];
    this.sids[id] = this.sids[id] || {};
    this.sids[id][room] = true;
    this.rooms[room] = this.rooms[room] || Room();
    this.rooms[room].add(id);
  }
  if (fn) process.nextTick(fn.bind(null, null));
};

/**
 * Removes a socket from a room.
 *
 * @param {String} socket id
 * @param {String} room name
 * @param {Function} callback
 * @api public
 */

Adapter.prototype.del = function(id, room, fn){
  this.sids[id] = this.sids[id] || {};
  delete this.sids[id][room];
  if (this.rooms.hasOwnProperty(room)) {
    this.rooms[room].del(id);
    if (this.rooms[room].length === 0) delete this.rooms[room];
  }

  if (fn) process.nextTick(fn.bind(null, null));
};

/**
 * Removes a socket from all rooms it's joined.
 *
 * @param {String} socket id
 * @param {Function} callback
 * @api public
 */

Adapter.prototype.delAll = function(id, fn){
  var rooms = this.sids[id];
  if (rooms) {
    for (var room in rooms) {
      if (this.rooms.hasOwnProperty(room)) {
        this.rooms[room].del(id);
        if (this.rooms[room].length === 0) delete this.rooms[room];
      }
    }
  }
  delete this.sids[id];

  if (fn) process.nextTick(fn.bind(null, null));
};

/**
 * Broadcasts a packet.
 *
 * Options:
 *  - `flags` {Object} flags for this packet
 *  - `except` {Array} sids that should be excluded
 *  - `rooms` {Array} list of rooms to broadcast to
 *
 * @param {Object} packet object
 * @api public
 */

Adapter.prototype.broadcast = function(packet, opts){
  var rooms = opts.rooms || [];
  var except = opts.except || [];
  var flags = opts.flags || {};
  var packetOpts = {
    preEncoded: true,
    volatile: flags.volatile,
    compress: flags.compress
  };
  var ids = {};
  var self = this;
  var socket;

  packet.nsp = this.nsp.name;
  this.encoder.encode(packet, function(encodedPackets) {
    if (rooms.length) {
      for (var i = 0; i < rooms.length; i++) {
        var room = self.rooms[rooms[i]];
        if (!room) continue;
        var sockets = room.sockets;
        for (var id in sockets) {
          if (sockets.hasOwnProperty(id)) {
            if (ids[id] || ~except.indexOf(id)) continue;
            socket = self.nsp.connected[id];
            if (socket) {
              socket.packet(encodedPackets, packetOpts);
              ids[id] = true;
            }
          }
        }
      }
    } else {
      for (var id in self.sids) {
        if (self.sids.hasOwnProperty(id)) {
          if (~except.indexOf(id)) continue;
          socket = self.nsp.connected[id];
          if (socket) socket.packet(encodedPackets, packetOpts);
        }
      }
    }
  });
};

/**
 * Gets a list of clients by sid.
 *
 * @param {Array} explicit set of rooms to check.
 * @param {Function} callback
 * @api public
 */

Adapter.prototype.clients = function(rooms, fn){
  if ('function' == typeof rooms){
    fn = rooms;
    rooms = null;
  }

  rooms = rooms || [];

  var ids = {};
  var sids = [];
  var socket;

  if (rooms.length) {
    for (var i = 0; i < rooms.length; i++) {
      var room = this.rooms[rooms[i]];
      if (!room) continue;
      var sockets = room.sockets;
      for (var id in sockets) {
        if (sockets.hasOwnProperty(id)) {
          if (ids[id]) continue;
          socket = this.nsp.connected[id];
          if (socket) {
            sids.push(id);
            ids[id] = true;
          }
        }
      }
    }
  } else {
    for (var id in this.sids) {
      if (this.sids.hasOwnProperty(id)) {
        socket = this.nsp.connected[id];
        if (socket) sids.push(id);
      }
    }
  }

  if (fn) process.nextTick(fn.bind(null, null, sids));
};

/**
 * Gets the list of rooms a given client has joined.
 *
 * @param {String} socket id
 * @param {Function} callback
 * @api public
 */
Adapter.prototype.clientRooms = function(id, fn){
  var rooms = this.sids[id];
  if (fn) process.nextTick(fn.bind(null, null, rooms ? Object.keys(rooms) : null));
};

/**
* Room constructor.
*
* @api private
*/

function Room(){
  if (!(this instanceof Room)) return new Room();
  this.sockets = {};
  this.length = 0;
}

/**
 * Adds a socket to a room.
 *
 * @param {String} socket id
 * @api private
 */

Room.prototype.add = function(id){
  if (!this.sockets.hasOwnProperty(id)) {
    this.sockets[id] = true;
    this.length++;
  }
};

/**
 * Removes a socket from a room.
 *
 * @param {String} socket id
 * @api private
 */

Room.prototype.del = function(id){
  if (this.sockets.hasOwnProperty(id)) {
    delete this.sockets[id];
    this.length--;
  }
};


/***/ }),
/* 189 */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	throw new Error("Cannot find module '" + req + "'.");
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = 189;

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYzQ0YTI5YjZmZjIwMTkzZjhhMzciLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwidXRpbFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImV2ZW50c1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcInBhdGhcIiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2luZGV4LmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcImh0dHBcIiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVwZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJmc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcInVybFwiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9leHByZXNzL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FmZXItYnVmZmVyL3NhZmVyLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcImJ1ZmZlclwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInN0cmVhbVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImNyeXB0b1wiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ieXRlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHR0cC1lcnJvcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGUtaXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BhcnNldXJsL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd3MvbGliL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29udGVudC10eXBlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRwcm90b3R5cGVvZi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RhdHVzZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcInR0eVwiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ib2R5LXBhcnNlci9saWIvcmVhZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb24tZmluaXNoZWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwicXVlcnlzdHJpbmdcIiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5jb2RldXJsL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lc2NhcGUtaHRtbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXJyYXktZmxhdHRlbi9hcnJheS1mbGF0dGVuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dGlscy1tZXJnZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dzL2xpYi9wZXJtZXNzYWdlLWRlZmxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2luZGV4LmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcIm5ldFwiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pY29udi1saXRlL2VuY29kaW5ncy90YWJsZXMvY3A5MzYuanNvbiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ6bGliXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3FzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0aG9kcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2VuZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2xpYi90cmFuc3BvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhcy1iaW5hcnkyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdXBwb3J0cy1jb2xvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd3MvbGliL2J1ZmZlci11dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZXBkL2xpYi9jb21wYXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9kZWJ1Zy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWNvbnYtbGl0ZS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL3RhYmxlcy9nYmstYWRkZWQuanNvbiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWNvbnYtbGl0ZS9lbmNvZGluZ3MvdGFibGVzL2NwOTUwLmpzb24iLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VucGlwZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWltZS10eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXMvbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xcy9saWIvZm9ybWF0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXhwcmVzcy9saWIvcm91dGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9leHByZXNzL2xpYi9yb3V0ZXIvcm91dGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V4cHJlc3MvbGliL3JvdXRlci9sYXllci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXhwcmVzcy9saWIvbWlkZGxld2FyZS9xdWVyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvbnRlbnQtZGlzcG9zaXRpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V0YWcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZyZXNoL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW5nZS1wYXJzZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3h5LWFkZHIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FjY2VwdHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nvb2tpZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2xpYi90cmFuc3BvcnRzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vbGliL3RyYW5zcG9ydHMvcG9sbGluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvZGVidWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9saWIvc29ja2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvd2Vic29ja2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvZXh0ZW5zaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvcmVjZWl2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dzL2xpYi92YWxpZGF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvc2VuZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvZGVidWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvaXMtYnVmZmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9saWIvbmFtZXNwYWNlLmpzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXhwcmVzcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXhwcmVzcy9saWIvZXhwcmVzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYm9keS1wYXJzZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlcGQvbGliL2NvbXBhdC9jYWxsc2l0ZS10b3N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVwZC9saWIvY29tcGF0L2V2ZW50LWxpc3RlbmVyLWNvdW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ib2R5LXBhcnNlci9saWIvdHlwZXMvanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RhdHVzZXMvY29kZXMuanNvbiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmF3LWJvZHkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvbGliL2JvbS1oYW5kbGluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWNvbnYtbGl0ZS9lbmNvZGluZ3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL2ludGVybmFsLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcInN0cmluZ19kZWNvZGVyXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL3V0ZjE2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pY29udi1saXRlL2VuY29kaW5ncy91dGY3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pY29udi1saXRlL2VuY29kaW5ncy9zYmNzLWNvZGVjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pY29udi1saXRlL2VuY29kaW5ncy9zYmNzLWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL3NiY3MtZGF0YS1nZW5lcmF0ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL2RiY3MtY29kZWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL2RiY3MtZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWNvbnYtbGl0ZS9lbmNvZGluZ3MvdGFibGVzL3NoaWZ0amlzLmpzb24iLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL3RhYmxlcy9ldWNqcC5qc29uIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pY29udi1saXRlL2VuY29kaW5ncy90YWJsZXMvZ2IxODAzMC1yYW5nZXMuanNvbiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWNvbnYtbGl0ZS9lbmNvZGluZ3MvdGFibGVzL2NwOTQ5Lmpzb24iLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL3RhYmxlcy9iaWc1LWFkZGVkLmpzb24iLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvbGliL3N0cmVhbXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvbGliL2V4dGVuZC1ub2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lZS1maXJzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWVkaWEtdHlwZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pbWUtZGIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pbWUtZGIvZGIuanNvbiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYm9keS1wYXJzZXIvbGliL3R5cGVzL3Jhdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYm9keS1wYXJzZXIvbGliL3R5cGVzL3RleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JvZHktcGFyc2VyL2xpYi90eXBlcy91cmxlbmNvZGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xcy9saWIvc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xcy9saWIvcGFyc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21lcmdlLWRlc2NyaXB0b3JzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9leHByZXNzL2xpYi9hcHBsaWNhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmluYWxoYW5kbGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXhwcmVzcy9saWIvbWlkZGxld2FyZS9pbml0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9leHByZXNzL2xpYi92aWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9leHByZXNzL2xpYiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVzdHJveS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWltZS9taW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9taW1lL3R5cGVzLmpzb24iLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZvcndhcmRlZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXBhZGRyLmpzL2xpYi9pcGFkZHIuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXhwcmVzcy9saWIvcmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVnb3RpYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVnb3RpYXRvci9saWIvY2hhcnNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVnb3RpYXRvci9saWIvZW5jb2RpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lZ290aWF0b3IvbGliL2xhbmd1YWdlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZWdvdGlhdG9yL2xpYi9tZWRpYVR5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V4cHJlc3MvbGliL3Jlc3BvbnNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb29raWUtc2lnbmF0dXJlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92YXJ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXJ2ZS1zdGF0aWMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NvY2tldFNlcnZlci50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2xpYi9lbmdpbmUuaW8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9saWIvc2VydmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYXNlNjRpZC9saWIvYmFzZTY0aWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLXhoci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIvdXRmOC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzLWJpbmFyeTIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FmdGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcIm9zXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhcy1mbGFnL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vbGliL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2xpYi90cmFuc3BvcnRzL3dlYnNvY2tldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXdzL3V3cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXdzIF5cXC5cXC91d3NfLiokIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJodHRwc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcInRsc1wiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc3luYy1saW1pdGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvZXZlbnQtdGFyZ2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvd2Vic29ja2V0LXNlcnZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9wYWNrYWdlLmpzb24iLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9saWIvY2xpZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvYmluYXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vbGliL3NvY2tldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2xpYi9wYXJlbnQtbmFtZXNwYWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tYWRhcHRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2xpYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUM3REEsaUM7Ozs7OztBQ0FBLG1DOzs7Ozs7QUNBQSxpQzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxFQUFjO0FBQ3pDLENBQUM7QUFDRCxtQkFBbUIsbUJBQU8sQ0FBQyxFQUFXO0FBQ3RDOzs7Ozs7O0FDVEEsaUM7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixtQkFBTyxDQUFDLEVBQWM7QUFDN0MseUJBQXlCLG1CQUFPLENBQUMsRUFBYztBQUMvQyxlQUFlLG1CQUFPLENBQUMsQ0FBTTs7QUFFN0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixpQkFBaUI7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDOztBQUV2QztBQUNBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGlDQUFpQztBQUM1RCxjQUFjLG9CQUFvQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztB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O0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDNWJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLEVBQVE7QUFDN0IsWUFBWSxtQkFBTyxDQUFDLENBQUk7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLEdBQVc7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLEdBQVc7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsaUJBQWlCLGtCQUFrQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxzQkFBc0I7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyxHQUFZO0FBQ3JDLFdBQVcsbUJBQU8sQ0FBQyxFQUFZOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxhQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM3T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QyxpQkFBaUI7QUFDakI7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7Ozs7Ozs7O0FDak1BO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLG1CQUFPLENBQUMsR0FBZTtBQUNqQyxZQUFZLG1CQUFPLENBQUMsR0FBaUI7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLEdBQWE7QUFDbEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLEVBQWM7QUFDdEMsYUFBYSxtQkFBTyxDQUFDLEVBQWtCO0FBQ3ZDLFdBQVcsbUJBQU8sQ0FBQyxFQUFNO0FBQ3pCLGNBQWMsbUJBQU8sQ0FBQyxFQUFTO0FBQy9CLFdBQVcsbUJBQU8sQ0FBQyxDQUFNO0FBQ3pCLFlBQVksbUJBQU8sQ0FBQyxFQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCLHFCQUFxQjtBQUMzQyxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQ3JaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLEVBQUk7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLFNBQVM7QUFDdEIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoT0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBTyxDQUFDLENBQVE7QUFDbkMsV0FBVyxtQkFBTyxDQUFDLENBQU07QUFDekIsWUFBWSxtQkFBTyxDQUFDLEVBQU87O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSx1QkFBdUIsOEJBQThCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3JlYTs7QUFFYixxQkFBcUIsbUJBQU8sQ0FBQyxDQUFRO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxFQUFRO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyxHQUFPO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyxDQUFNO0FBQzNCLFlBQVksbUJBQU8sQ0FBQyxFQUFLO0FBQ3pCLFlBQVksbUJBQU8sQ0FBQyxHQUFLO0FBQ3pCLFlBQVksbUJBQU8sQ0FBQyxDQUFLOztBQUV6QiwwQkFBMEIsbUJBQU8sQ0FBQyxFQUFzQjtBQUN4RCxvQkFBb0IsbUJBQU8sQ0FBQyxHQUFnQjtBQUM1QyxrQkFBa0IsbUJBQU8sQ0FBQyxFQUFhO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLEVBQWE7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsRUFBWTtBQUNyQyxlQUFlLG1CQUFPLENBQUMsRUFBVTs7QUFFakM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QyxhQUFhLGtCQUFrQjtBQUMvQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLGdCQUFnQjtBQUM3RCxjQUFjLDZCQUE2QjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0JBQWdCO0FBQzdELGNBQWMsNkJBQTZCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLGdCQUFnQjtBQUM3RCxjQUFjLDZCQUE2QjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEMsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsd0JBQXdCO0FBQy9ELGdDQUFnQyw0QkFBNEI7QUFDNUQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwQkFBMEIsRUFBRSxpQkFBaUI7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLG1CQUFtQixHQUFHLG1CQUFtQjtBQUMvRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSw2REFBNkQsZUFBZTtBQUM1RSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUNBQXFDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFD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Q0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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QUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN2S2E7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdU5BQXVOLGlFQUFpRSxFQUFFO0FBQzFSLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJKQUEySixpRUFBaUUsRUFBRTtBQUM5TixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHlMQUF5TCxpRUFBaUUsRUFBRTtBQUM1UCxHQUFHO0FBQ0g7QUFDQTtBQUNBLHVOQUF1TixpRUFBaUUsRUFBRTtBQUMxUixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVOQUF1TixnRUFBZ0UsRUFBRTtBQUN6UixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7O0FDbGNhO0FBQ2IsYUFBYSxtQkFBTyxDQUFDLENBQWM7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxXQUFXO0FBQzFCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EOztBQUVwRDtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1Qzs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdDQUF3QztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEIsV0FBVztBQUNyQztBQUNBO0FBQ0EsOEJBQThCLFdBQVc7QUFDekM7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckM7QUFDQSxLO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLE9BQU8sT0FBTztBQUM5Qzs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBLHVDQUF1QztBQUN2QywyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUMsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLFM7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQjtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hELGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQkFBb0I7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7O0FBRUEsYUFBYSx1Q0FBdUM7QUFDcEQ7O0FBRUEsYUFBYSxpQ0FBaUM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxxQ0FBcUM7O0FBRXJDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEUscUVBQXFFO0FBQ3JFLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QywwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7O0FBRWY7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLDhDQUE4QztBQUM5QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQixnQkFBZ0I7QUFDMUM7O0FBRUE7QUFDQTs7QUFFQSx5QjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDemlCYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUSxtQkFBTyxDQUFDLEdBQXdCLEdBQUc7QUFDdEUsb0JBQW9CLCtCQUErQjtBQUNuRCwwQkFBMEIseUJBQXlCO0FBQ25ELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLFFBQVEsbUJBQU8sQ0FBQyxHQUFxQixHQUFHO0FBQ25FLG9CQUFvQiwrQkFBK0I7QUFDbkQsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUSxtQkFBTyxDQUFDLEVBQXFCLEdBQUc7QUFDbkUsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUSxtQkFBTyxDQUFDLEVBQXFCLFNBQVMsbUJBQU8sQ0FBQyxFQUF5QixJQUFJO0FBQzlHLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFFBQVEsbUJBQU8sQ0FBQyxFQUFxQixTQUFTLG1CQUFPLENBQUMsRUFBeUIsSUFBSTtBQUM5Ryw2QkFBNkIsUUFBUSxtQkFBTyxDQUFDLEdBQThCLEdBQUc7QUFDOUU7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQyxLQUFLOztBQUVMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRLG1CQUFPLENBQUMsR0FBcUIsR0FBRztBQUNuRSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRLG1CQUFPLENBQUMsRUFBcUIsR0FBRztBQUNuRSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFFBQVEsbUJBQU8sQ0FBQyxFQUFxQixTQUFTLG1CQUFPLENBQUMsR0FBMEIsSUFBSTtBQUMvRztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMvS0EscXlSOzs7Ozs7QUNBQSw4bGU7Ozs7OztBQ0FBLGtCQUFrQix1cUU7Ozs7OztBQ0FsQiw2cWhCOzs7Ozs7QUNBQSwrMlA7Ozs7Ozs7QUNBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsRUFBUTtBQUM3QixnQkFBZ0IsbUJBQU8sQ0FBQyxFQUFROzs7QUFHaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEIsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG9CQUFvQixFQUFFO0FBQzNEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYyxFQUFFO0FBQ3JEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7Ozs7Ozs7O0FDdkhhO0FBQ2IsYUFBYSxtQkFBTyxDQUFDLEVBQVE7QUFDN0I7O0FBRUE7O0FBRUE7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixtQkFBTyxDQUFDLEVBQVE7O0FBRXpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFPLENBQUMsRUFBUTs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEY7O0FBRTlGOztBQUVBLHlCQUF5QixtQkFBTyxDQUFDLEVBQVE7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsbUJBQU8sQ0FBQyxFQUFROztBQUUzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQ3hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLGtCQUFrQjtBQUNuQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EscUJBQXFCLE1BQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDO0FBQ0EseURBQXlELE1BQU07QUFDL0QscURBQXFELE1BQU07QUFDM0Qsb0RBQW9ELE1BQU0sb0NBQW9DLE1BQU07O0FBRXBHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDN1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLEdBQVc7Ozs7Ozs7QUNWcEMsa0JBQWtCLHdDQUF3QyxnQkFBZ0IsdUNBQXVDLG9DQUFvQyw2QkFBNkIsb0NBQW9DLG9CQUFvQixnQkFBZ0IsOEJBQThCLGdCQUFnQiw4QkFBOEIsb0NBQW9DLGtDQUFrQyxvQ0FBb0Msd0NBQXdDLG9DQUFvQyxvQ0FBb0Msb0NBQW9DLHVDQUF1QyxvQ0FBb0MsNkNBQTZDLG9DQUFvQyx1Q0FBdUMsb0NBQW9DLDZDQUE2QyxvQ0FBb0MsZ0NBQWdDLG9DQUFvQyxxQ0FBcUMsb0NBQW9DLDJDQUEyQyxvQ0FBb0Msb0JBQW9CLGdCQUFnQiw2QkFBNkIsb0NBQW9DLDBCQUEwQixnQkFBZ0IsMkJBQTJCLHNDQUFzQyxvQkFBb0IsZ0JBQWdCLHFCQUFxQixnQkFBZ0IseUJBQXlCLDBEQUEwRCw0QkFBNEIsNkRBQTZELGdDQUFnQyxvQ0FBb0MsMkJBQTJCLGdCQUFnQiw0QkFBNEIsNkRBQTZELDZCQUE2QixvQ0FBb0MsOEJBQThCLG9DQUFvQyw4QkFBOEIsb0NBQW9DLHNCQUFzQixnQkFBZ0IsZ0NBQWdDLG9DQUFvQywrQkFBK0IscUNBQXFDLDJCQUEyQixnQkFBZ0IscUJBQXFCLDJDQUEyQyx5QkFBeUIsb0NBQW9DLDhCQUE4QixvQ0FBb0MsNkJBQTZCLG9DQUFvQyxnQ0FBZ0MsZ0JBQWdCLDBCQUEwQixnQkFBZ0IscUJBQXFCLGdCQUFnQixzQkFBc0IsZ0JBQWdCLHlCQUF5QixvQ0FBb0MsMEJBQTBCLDJEQUEyRCx5QkFBeUIsb0NBQW9DLGdDQUFnQyx1Q0FBdUMsK0JBQStCLHVDQUF1Qyw0QkFBNEIsdUNBQXVDLDRCQUE0Qix1Q0FBdUMsMkJBQTJCLHVDQUF1QyxxQkFBcUIsZ0JBQWdCLG9CQUFvQixnQkFBZ0IsNkJBQTZCLG9DQUFvQywyQkFBMkIsb0NBQW9DLG9CQUFvQixnQkFBZ0IsOEJBQThCLG9DQUFvQyxvQkFBb0IsZ0JBQWdCLHlCQUF5QixvQ0FBb0MsZ0NBQWdDLG9DQUFvQyw2QkFBNkIsZ0JBQWdCLDZCQUE2QixnQkFBZ0Isb0NBQW9DLG9DQUFvQyxxQkFBcUIsZ0JBQWdCLHlCQUF5QixnQkFBZ0IsNkJBQTZCLGdCQUFnQix3QkFBd0Isb0NBQW9DLHlCQUF5QixnQkFBZ0IseUJBQXlCLG9DQUFvQyw2QkFBNkIsb0NBQW9DLDBCQUEwQixvQ0FBb0MseUJBQXlCLHNDQUFzQyxvQkFBb0IsZ0JBQWdCLDBCQUEwQixnQkFBZ0IscUJBQXFCLG9CQUFvQix5QkFBeUIseURBQXlELDBCQUEwQixnQkFBZ0IsNkJBQTZCLDhEQUE4RCx3QkFBd0IsZ0JBQWdCLG9CQUFvQixnQkFBZ0IsdUJBQXVCLGdCQUFnQixnQ0FBZ0Msb0NBQW9DLHNCQUFzQixnQkFBZ0IsMkJBQTJCLG9DQUFvQywwQkFBMEIsb0NBQW9DLG9CQUFvQixnQkFBZ0Isb0JBQW9CLGdCQUFnQixvQkFBb0IsZ0JBQWdCLHlCQUF5QixvQ0FBb0MsNEJBQTRCLGdCQUFnQiw0QkFBNEIsMkRBQTJELDBCQUEwQixvQ0FBb0MseUJBQXlCLHNDQUFzQyx5QkFBeUIsMkRBQTJELHFCQUFxQixnQkFBZ0IsMkJBQTJCLCtEQUErRCw0QkFBNEIsZ0JBQWdCLHdCQUF3QixxQ0FBcUMsd0JBQXdCLHFDQUFxQyxvQkFBb0IsZ0JBQWdCLDhDQUE4QyxvQ0FBb0MsOENBQThDLG9DQUFvQyxpREFBaUQsb0NBQW9DLDRDQUE0QyxnQkFBZ0IsbURBQW1ELG9DQUFvQyxrREFBa0Qsb0NBQW9DLHFEQUFxRCxvQ0FBb0MsMkNBQTJDLG9DQUFvQyx5QkFBeUIsMERBQTBELDhCQUE4QixvQ0FBb0MseUJBQXlCLGdCQUFnQix3QkFBd0Isb0NBQW9DLHlCQUF5QiwyREFBMkQsc0JBQXNCLGdCQUFnQixvQkFBb0IscUNBQXFDLHNDQUFzQyxvQ0FBb0MsNEJBQTRCLGdCQUFnQix5QkFBeUIsZ0JBQWdCLHdCQUF3QixvQ0FBb0MsMEJBQTBCLG9DQUFvQyx5QkFBeUIsb0NBQW9DLHVDQUF1QyxvQkFBb0IscUJBQXFCLGdCQUFnQiwwQkFBMEIsZ0JBQWdCLDJCQUEyQixxQ0FBcUMsMEJBQTBCLHFDQUFxQyx5Q0FBeUMsb0NBQW9DLHlCQUF5Qiw2REFBNkQsNkJBQTZCLGdCQUFnQixtQ0FBbUMsZ0JBQWdCLDZCQUE2QixvQ0FBb0MsNEJBQTRCLGdCQUFnQix3QkFBd0IseURBQXlELHdCQUF3QiwyREFBMkQsb0JBQW9CLHVDQUF1QyxxQkFBcUIseURBQXlELHFCQUFxQixnQkFBZ0IseUJBQXlCLG9DQUFvQyxzQkFBc0IsdUJBQXVCLHFCQUFxQixnQkFBZ0IsNEJBQTRCLHFDQUFxQyxvQ0FBb0Msb0NBQW9DLGtDQUFrQyxvQ0FBb0MsNEJBQTRCLGdCQUFnQixxQkFBcUIsZ0JBQWdCLG1DQUFtQyxvQ0FBb0Msc0JBQXNCLGdCQUFnQiwwQkFBMEIsZ0JBQWdCLDBCQUEwQixnQkFBZ0IsK0JBQStCLGdCQUFnQiwwQkFBMEIsZ0JBQWdCLDBCQUEwQixpRUFBaUUscUJBQXFCLGdCQUFnQixzQkFBc0IsdUNBQXVDLG9CQUFvQixnQkFBZ0IscUJBQXFCLGdCQUFnQix3QkFBd0Isb0NBQW9DLDZCQUE2Qix3RUFBd0UsdUNBQXVDLDREQUE0RCx3QkFBd0IsOERBQThELDJCQUEyQixnRkFBZ0YsNkJBQTZCLG9DQUFvQyxxQkFBcUIsZ0JBQWdCLDBCQUEwQixvQ0FBb0MseUJBQXlCLG9DQUFvQyxxQkFBcUIsa0ZBQWtGLGdDQUFnQyxvQ0FBb0MseUJBQXlCLGdCQUFnQixzQkFBc0IsdUJBQXVCLDRCQUE0Qiw4REFBOEQseUJBQXlCLG9DQUFvQyw2QkFBNkIsb0NBQW9DLG9CQUFvQixnQkFBZ0IsaUNBQWlDLG9DQUFvQyxrQ0FBa0Msb0NBQW9DLHdCQUF3Qiw0REFBNEQsd0JBQXdCLG9DQUFvQyw0QkFBNEIsZ0JBQWdCLGlDQUFpQyxvQ0FBb0MseUJBQXlCLDZEQUE2RCw2QkFBNkIsb0NBQW9DLG9CQUFvQixnQkFBZ0IsNkJBQTZCLHFDQUFxQywrQkFBK0IsdUNBQXVDLDJCQUEyQixnQkFBZ0IseUJBQXlCLDBEQUEwRCw4QkFBOEIsbUVBQW1FLHFCQUFxQixxQ0FBcUMsNEJBQTRCLDBEQUEwRCw0QkFBNEIsOENBQThDLDJCQUEyQiw0REFBNEQsbUNBQW1DLG9DQUFvQyx3Q0FBd0Msb0NBQW9DLDBEQUEwRCxvQ0FBb0Msb0NBQW9DLG9DQUFvQyxrQ0FBa0Msb0NBQW9DLDZCQUE2QixvQ0FBb0Msc0NBQXNDLG9DQUFvQyxnREFBZ0Qsb0NBQW9DLDBDQUEwQyxvQ0FBb0Msa0NBQWtDLG9DQUFvQywyQ0FBMkMsb0NBQW9DLGtDQUFrQyxvQ0FBb0Msa0RBQWtELG9DQUFvQyxxQkFBcUIsc0NBQXNDLHlDQUF5QyxvQ0FBb0Msa0NBQWtDLG9DQUFvQyx1Q0FBdUMsMkRBQTJELGlDQUFpQyxvQ0FBb0MsNkJBQTZCLGdFQUFnRSw4QkFBOEIsMkRBQTJELHlCQUF5QiwwREFBMEQsb0JBQW9CLGdCQUFnQixzQkFBc0IsZ0JBQWdCLDRCQUE0QixvQ0FBb0MsNEJBQTRCLG9DQUFvQyx5QkFBeUIsMERBQTBELDBCQUEwQixnQkFBZ0IsK0JBQStCLGdCQUFnQiw2QkFBNkIsZ0JBQWdCLGdDQUFnQyxnQkFBZ0IscUJBQXFCLDRDQUE0QyxvQkFBb0IsNENBQTRDLDhCQUE4QixnQkFBZ0IsMEJBQTBCLGdCQUFnQiw4QkFBOEIsZ0JBQWdCLGlDQUFpQyxvQ0FBb0MsZ0NBQWdDLG9DQUFvQyw0QkFBNEIsb0NBQW9DLDhCQUE4QixvQ0FBb0MsdUJBQXVCLGdFQUFnRSx5QkFBeUIsb0NBQW9DLG9CQUFvQixxQ0FBcUMsd0JBQXdCLG9DQUFvQywwQkFBMEIsb0NBQW9DLHdCQUF3QixnQkFBZ0IsaUNBQWlDLGdCQUFnQiwrQkFBK0IsZ0JBQWdCLGtDQUFrQyxnQkFBZ0IsMEJBQTBCLG9DQUFvQyxxQkFBcUIsZ0JBQWdCLG9CQUFvQixnQkFBZ0IsNkJBQTZCLGdCQUFnQiw4QkFBOEIsZ0JBQWdCLDZCQUE2QixpTUFBaU0sb0JBQW9CLHFDQUFxQyx3QkFBd0Isb0NBQW9DLG9CQUFvQixnQkFBZ0Isa0NBQWtDLHlEQUF5RCxvQkFBb0IsMERBQTBELDBCQUEwQiw2REFBNkQsd0JBQXdCLHNFQUFzRSx1QkFBdUIsZ0JBQWdCLHFCQUFxQixzQ0FBc0MsZ0NBQWdDLG9DQUFvQywwQkFBMEIsZ0JBQWdCLHlCQUF5QixnQkFBZ0Isb0NBQW9DLHlEQUF5RCxvQkFBb0IsMERBQTBELG9CQUFvQixnQkFBZ0Isc0NBQXNDLGdCQUFnQiw4QkFBOEIsMERBQTBELHlCQUF5QixnQkFBZ0IsOEJBQThCLDJDQUEyQywyQkFBMkIsdUNBQXVDLHlCQUF5QixvQ0FBb0MsOEJBQThCLG9DQUFvQyx1QkFBdUIscUNBQXFDLHVCQUF1QixnQkFBZ0IsMkJBQTJCLDJDQUEyQyxnQ0FBZ0MscUNBQXFDLHNCQUFzQixvQ0FBb0MsZ0NBQWdDLGdCQUFnQiwrQkFBK0Isb0NBQW9DLDBCQUEwQixxQ0FBcUMseUJBQXlCLHFDQUFxQyw2QkFBNkIseUNBQXlDLHdCQUF3QixxQ0FBcUMsd0JBQXdCLHlEQUF5RCxpQ0FBaUMsb0NBQW9DLDJCQUEyQixtRUFBbUUsa0NBQWtDLG9DQUFvQyw2QkFBNkIsb0NBQW9DLDRCQUE0QixvQ0FBb0MsK0JBQStCLG9DQUFvQyw0Q0FBNEMsZ0JBQWdCLHdCQUF3QixxQ0FBcUMsNkJBQTZCLHFDQUFxQywyQkFBMkIsZ0JBQWdCLDRCQUE0QixnQkFBZ0Isa0NBQWtDLGdCQUFnQiw0QkFBNEIsb0NBQW9DLHlCQUF5Qiw2REFBNkQscUJBQXFCLGdCQUFnQiwwQkFBMEIsMENBQTBDLDBCQUEwQixnQkFBZ0IsMEJBQTBCLG9DQUFvQyx3QkFBd0IsK0RBQStELDRCQUE0Qix5REFBeUQsd0NBQXdDLHFDQUFxQyxnQ0FBZ0MsZ0JBQWdCLDZCQUE2QixvQ0FBb0MsbUNBQW1DLHdEQUF3RCx3Q0FBd0MseURBQXlELHdCQUF3QixvQ0FBb0MsdUJBQXVCLGdCQUFnQix5QkFBeUIsb0NBQW9DLGlDQUFpQyx3REFBd0QsOEJBQThCLG9DQUFvQyxpQ0FBaUMsb0NBQW9DLDhCQUE4QixvQ0FBb0Msa0NBQWtDLHFDQUFxQyw4QkFBOEIscUNBQXFDLGlDQUFpQyxnQkFBZ0IseUJBQXlCLHFDQUFxQyw0QkFBNEIsZ0JBQWdCLHdCQUF3QiwyREFBMkQsd0JBQXdCLDJEQUEyRCxvQkFBb0IseURBQXlELDRCQUE0QixnQkFBZ0Isb0JBQW9CLGdCQUFnQixrQ0FBa0Msb0NBQW9DLGlDQUFpQyxvQ0FBb0MseUJBQXlCLDBEQUEwRCwwQkFBMEIsb0NBQW9DLDBCQUEwQixvQ0FBb0MsZ0NBQWdDLHFDQUFxQyxpQ0FBaUMscUNBQXFDLGdDQUFnQyxxQ0FBcUMsaUNBQWlDLHFDQUFxQyxvQkFBb0IscUNBQXFDLDZCQUE2QixnQkFBZ0IsMkJBQTJCLGdCQUFnQiwyQkFBMkIsb0NBQW9DLDBCQUEwQixvQ0FBb0MsMEJBQTBCLGdCQUFnQiw0QkFBNEIsZ0JBQWdCLDRCQUE0QixvQ0FBb0MsMkJBQTJCLG9DQUFvQywyQkFBMkIsZ0JBQWdCLHdCQUF3QixvQ0FBb0Msd0JBQXdCLGdCQUFnQiw2QkFBNkIsZ0JBQWdCLDRCQUE0QixnQkFBZ0IsdUNBQXVDLHdDQUF3QyxpQ0FBaUMsZ0JBQWdCLDRDQUE0Qyx3Q0FBd0MscUJBQXFCLGdCQUFnQixrQ0FBa0MsZ0JBQWdCLHdCQUF3Qix5REFBeUQsc0JBQXNCLDZDQUE2QyxrQ0FBa0Msb0NBQW9DLHVDQUF1QyxnQkFBZ0Isc0NBQXNDLGdCQUFnQixzQkFBc0IsZ0JBQWdCLHFCQUFxQixnQkFBZ0IseUJBQXlCLGdFQUFnRSwwQkFBMEIsZ0JBQWdCLGlDQUFpQyxnQkFBZ0IseUJBQXlCLG9DQUFvQyw2QkFBNkIsb0NBQW9DLG1DQUFtQyx5REFBeUQsa0NBQWtDLG9DQUFvQyxvQkFBb0IsZ0JBQWdCLHFCQUFxQixzQ0FBc0MseUJBQXlCLDJEQUEyRCx3QkFBd0IseURBQXlELHlCQUF5Qiw0REFBNEQseUJBQXlCLDBEQUEwRCwwQkFBMEIsb0NBQW9DLGlDQUFpQyxnQkFBZ0IseUNBQXlDLGdCQUFnQixzQ0FBc0MsZ0JBQWdCLDhDQUE4QyxnQkFBZ0IsMkJBQTJCLGdCQUFnQixxQ0FBcUMsZ0JBQWdCLDZDQUE2QyxnQkFBZ0Isa0NBQWtDLGdCQUFnQixxQ0FBcUMsZ0JBQWdCLDRCQUE0QixnQkFBZ0Isb0NBQW9DLGdCQUFnQixvQkFBb0Isb0JBQW9CLDJCQUEyQixvQ0FBb0Msd0JBQXdCLHFFQUFxRSwwQkFBMEIsZ0JBQWdCLDJCQUEyQix5REFBeUQsZ0NBQWdDLGdCQUFnQixnQ0FBZ0MsZ0JBQWdCLGlDQUFpQyxxQ0FBcUMsNEJBQTRCLGdCQUFnQiw0QkFBNEIsb0NBQW9DLDJCQUEyQixnQkFBZ0Isb0NBQW9DLGdCQUFnQixxQkFBcUIsZ0JBQWdCLHlCQUF5QixvQ0FBb0MsNEJBQTRCLGdCQUFnQixxQkFBcUIsZ0JBQWdCLDBCQUEwQixnQkFBZ0IsdUJBQXVCLGdCQUFnQixpQ0FBaUMsb0NBQW9DLGlDQUFpQyxvQ0FBb0MsbUNBQW1DLG9DQUFvQyxxQ0FBcUMsb0NBQW9DLDJCQUEyQixvQ0FBb0MsMEJBQTBCLG9DQUFvQyxzQkFBc0IsZ0JBQWdCLHFDQUFxQyxrQkFBa0IsaURBQWlELG9DQUFvQyxtQ0FBbUMsb0NBQW9DLHlDQUF5QyxvQ0FBb0MsdURBQXVELGdCQUFnQixvREFBb0Qsb0NBQW9DLGlDQUFpQyxvQ0FBb0Msa0NBQWtDLG9DQUFvQywyQ0FBMkMsZ0JBQWdCLHdEQUF3RCxvQ0FBb0MseUNBQXlDLG9DQUFvQyx3Q0FBd0MsZ0JBQWdCLG1EQUFtRCxvQ0FBb0MsMkNBQTJDLGdCQUFnQiw4Q0FBOEMsb0NBQW9DLGlEQUFpRCxvQ0FBb0MsdURBQXVELG9DQUFvQyxpREFBaUQsb0NBQW9DLHdDQUF3QyxvQ0FBb0MsaURBQWlELG9DQUFvQyxtREFBbUQsb0NBQW9DLGtEQUFrRCxvQ0FBb0MsMENBQTBDLG9DQUFvQyw2Q0FBNkMsb0NBQW9DLGtEQUFrRCxvQ0FBb0MsZ0RBQWdELG9DQUFvQyx5REFBeUQsb0NBQW9DLHNEQUFzRCxvQ0FBb0MsbURBQW1ELG9DQUFvQyxxREFBcUQsb0NBQW9DLG9EQUFvRCxvQ0FBb0MsMERBQTBELG9DQUFvQywrQ0FBK0Msb0NBQW9DLGtEQUFrRCxvQ0FBb0Msc0NBQXNDLG9DQUFvQyxzQ0FBc0MscUNBQXFDLHNDQUFzQyxxQ0FBcUMsb0NBQW9DLHFDQUFxQyw2QkFBNkIsZ0JBQWdCLGlDQUFpQyxvQ0FBb0MsdUNBQXVDLG9DQUFvQyx3Q0FBd0Msb0NBQW9DLGtEQUFrRCxvQ0FBb0Msa0NBQWtDLG9DQUFvQyx3Q0FBd0Msb0NBQW9DLDhCQUE4QixnQkFBZ0IsK0JBQStCLHNDQUFzQyw4Q0FBOEMsZ0JBQWdCLHFDQUFxQyxxQ0FBcUMsc0NBQXNDLHFDQUFxQyxzQ0FBc0MscUNBQXFDLDZCQUE2QixxQ0FBcUMsNEJBQTRCLDZDQUE2QyxnRUFBZ0UsNERBQTRELHNDQUFzQyxnQkFBZ0IsNENBQTRDLHNDQUFzQyw4QkFBOEIsNENBQTRDLHlDQUF5QyxnQkFBZ0Isa0NBQWtDLHlEQUF5RCwrQkFBK0Isc0NBQXNDLCtCQUErQixnQkFBZ0IscUNBQXFDLGdCQUFnQiwrQkFBK0IsZ0JBQWdCLCtCQUErQixnQkFBZ0IsZ0NBQWdDLHVDQUF1QywwQ0FBMEMscUNBQXFDLDBDQUEwQyxxQ0FBcUMsaUNBQWlDLG9DQUFvQyxpQ0FBaUMsdUNBQXVDLHVDQUF1QyxnQkFBZ0IseUNBQXlDLHFDQUFxQyw4QkFBOEIscUNBQXFDLHNDQUFzQyxvQ0FBb0MsNENBQTRDLDREQUE0RCx5QkFBeUIsZ0JBQWdCLDJEQUEyRCxxQ0FBcUMsd0RBQXdELHVDQUF1Qyx5Q0FBeUMscUNBQXFDLHlDQUF5QyxnQkFBZ0IsMENBQTBDLGdCQUFnQix1Q0FBdUMsZ0JBQWdCLDZCQUE2QixvQ0FBb0MsaURBQWlELG9DQUFvQyx3Q0FBd0MsMERBQTBELGtDQUFrQyx5Q0FBeUMsa0NBQWtDLHNDQUFzQyxrQ0FBa0MseUNBQXlDLGdDQUFnQyx1Q0FBdUMsaUNBQWlDLDZDQUE2QyxnQ0FBZ0MsZ0JBQWdCLHVDQUF1QyxxQ0FBcUMsaUNBQWlDLG9DQUFvQyw4QkFBOEIsZ0JBQWdCLDBDQUEwQyxzQ0FBc0MsK0JBQStCLHFDQUFxQyxnQ0FBZ0MsZ0JBQWdCLGdDQUFnQyxvQ0FBb0MsZ0NBQWdDLG9DQUFvQyxzQ0FBc0Msb0NBQW9DLGtDQUFrQyxnQkFBZ0Isc0NBQXNDLGdCQUFnQixnQ0FBZ0MsZ0JBQWdCLHFDQUFxQyxvQ0FBb0Msd0NBQXdDLG9DQUFvQyxxQ0FBcUMsZ0JBQWdCLG1DQUFtQyxvQ0FBb0MsNENBQTRDLGdCQUFnQixzQ0FBc0MscUNBQXFDLHFDQUFxQyxnQkFBZ0IscUNBQXFDLGdCQUFnQix3QkFBd0IscUNBQXFDLG9DQUFvQyxxQ0FBcUMsa0NBQWtDLG9DQUFvQyxnQ0FBZ0MsZ0JBQWdCLCtCQUErQixnQkFBZ0IsK0JBQStCLGdCQUFnQix3Q0FBd0Msb0NBQW9DLCtDQUErQyxnQkFBZ0IsK0NBQStDLGdCQUFnQixpQ0FBaUMsMkRBQTJELDhCQUE4QixnQkFBZ0IseUNBQXlDLHFDQUFxQywrQkFBK0IscUNBQXFDLHFDQUFxQyxnQkFBZ0IsNkNBQTZDLHlEQUF5RCw2QkFBNkIscUNBQXFDLGdDQUFnQyxxQ0FBcUMsa0NBQWtDLDZEQUE2RCxpREFBaUQsd0NBQXdDLHFEQUFxRCx3Q0FBd0MsaUNBQWlDLGdCQUFnQixrREFBa0QsZ0JBQWdCLDJEQUEyRCxnQkFBZ0Isc0RBQXNELGdCQUFnQiwrREFBK0QsZ0JBQWdCLHFEQUFxRCxnQkFBZ0IsOERBQThELGdCQUFnQixvQ0FBb0Msb0NBQW9DLHdDQUF3QyxvQ0FBb0MseUNBQXlDLG9DQUFvQyxrQ0FBa0MscUNBQXFDLGtDQUFrQyxnQkFBZ0Isc0NBQXNDLGdCQUFnQixnQ0FBZ0MscUNBQXFDLGlDQUFpQyx5Q0FBeUMseUNBQXlDLG9DQUFvQyxnQ0FBZ0MscUNBQXFDLGtDQUFrQyxzQ0FBc0MsMkNBQTJDLHNDQUFzQywwQ0FBMEMsc0NBQXNDLDJDQUEyQyxzQ0FBc0MsMkNBQTJDLHNDQUFzQywwQ0FBMEMseURBQXlELDhCQUE4QixxQ0FBcUMsZ0NBQWdDLG9DQUFvQyw2QkFBNkIsZ0JBQWdCLG9DQUFvQyxnQkFBZ0IsNkJBQTZCLHFDQUFxQyxnQ0FBZ0MsZ0JBQWdCLDZCQUE2QixnQkFBZ0IseUJBQXlCLGdCQUFnQiw2QkFBNkIsdUNBQXVDLCtCQUErQix5Q0FBeUMsdUNBQXVDLG9DQUFvQywyQkFBMkIsZ0JBQWdCLDZDQUE2QyxxQ0FBcUMseUJBQXlCLDBEQUEwRCxvQ0FBb0MscUNBQXFDLHFDQUFxQyxvQ0FBb0Msc0NBQXNDLG9DQUFvQywwQ0FBMEMsZ0JBQWdCLDhCQUE4Qix5REFBeUQsa0NBQWtDLGdFQUFnRSxxQ0FBcUMsNENBQTRDLDZCQUE2Qiw0Q0FBNEMsMkNBQTJDLDJDQUEyQyxrQ0FBa0MsZ0JBQWdCLDZDQUE2QyxnQkFBZ0Isc0NBQXNDLG9DQUFvQyx3QkFBd0IscUNBQXFDLGtDQUFrQyxvQ0FBb0MsOEJBQThCLHVDQUF1QyxtQ0FBbUMsZ0JBQWdCLG1DQUFtQyxnQkFBZ0IsdURBQXVELGdCQUFnQiw0QkFBNEIscUNBQXFDLGlDQUFpQyxzQ0FBc0MsK0JBQStCLG9DQUFvQyxnQ0FBZ0Msd0NBQXdDLDhCQUE4QixnQkFBZ0Isb0NBQW9DLGdCQUFnQixtQ0FBbUMsZ0JBQWdCLDRCQUE0QixxQ0FBcUMsNkJBQTZCLGdCQUFnQixxQ0FBcUMsZ0JBQWdCLDJDQUEyQyxnQkFBZ0Isc0NBQXNDLGdCQUFnQix1Q0FBdUMsZ0JBQWdCLG1DQUFtQyxnQkFBZ0Isb0NBQW9DLGdCQUFnQix3Q0FBd0MsZ0JBQWdCLCtDQUErQyxnQkFBZ0IsaURBQWlELG9DQUFvQyw0Q0FBNEMsb0NBQW9DLDBDQUEwQyxvQ0FBb0MsNkNBQTZDLG9DQUFvQywwREFBMEQsb0NBQW9DLDJEQUEyRCxvQ0FBb0MsdUNBQXVDLG9DQUFvQyw0QkFBNEIsZ0JBQWdCLGdDQUFnQyxxQ0FBcUMsd0JBQXdCLGdCQUFnQiw0QkFBNEIscUNBQXFDLHdCQUF3QixnQkFBZ0IsNENBQTRDLGdCQUFnQixpQ0FBaUMsZ0JBQWdCLDZCQUE2QixnQkFBZ0IsaUNBQWlDLHFDQUFxQyx1Q0FBdUMsZ0JBQWdCLHNDQUFzQyxnQkFBZ0Isa0NBQWtDLGdCQUFnQix5Q0FBeUMsZ0JBQWdCLHdDQUF3QyxnQkFBZ0IsNEJBQTRCLGdCQUFnQiw0QkFBNEIsZ0JBQWdCLCtDQUErQyxvQ0FBb0MsNEJBQTRCLHFDQUFxQyxrQ0FBa0MsZ0JBQWdCLHFDQUFxQyxvQ0FBb0MsOEJBQThCLHFDQUFxQyw4QkFBOEIscUNBQXFDLHFDQUFxQyxxQ0FBcUMsK0JBQStCLHFDQUFxQyw4QkFBOEIscUNBQXFDLHVDQUF1QyxnQkFBZ0Isc0NBQXNDLHFDQUFxQyxpQ0FBaUMsK0RBQStELGlDQUFpQyxvQ0FBb0Msb0NBQW9DLHFDQUFxQyxvQ0FBb0MscUNBQXFDLGlDQUFpQyxvQ0FBb0MseUNBQXlDLG9DQUFvQywyQ0FBMkMsb0NBQW9DLHlDQUF5QyxvQ0FBb0Msd0NBQXdDLG9DQUFvQyx5Q0FBeUMsb0NBQW9DLDBDQUEwQyxvQ0FBb0MseUNBQXlDLG9DQUFvQyxzQ0FBc0Msb0NBQW9DLDJDQUEyQyxvQ0FBb0Msa0NBQWtDLG9DQUFvQywrQkFBK0IsZ0JBQWdCLDZEQUE2RCxvQ0FBb0Msa0NBQWtDLG9DQUFvQyxpQ0FBaUMsb0NBQW9DLHNDQUFzQyxvQ0FBb0MseUNBQXlDLGdCQUFnQixpQ0FBaUMsb0NBQW9DLGlDQUFpQyxnQkFBZ0IsZ0NBQWdDLGdCQUFnQix1Q0FBdUMsZ0JBQWdCLHdDQUF3QyxnQkFBZ0IscUNBQXFDLGdCQUFnQix5Q0FBeUMscUNBQXFDLHFDQUFxQyxnQkFBZ0IsZ0NBQWdDLHFDQUFxQyxrQ0FBa0MscUNBQXFDLG9DQUFvQyxnQkFBZ0Isd0NBQXdDLGdCQUFnQix3QkFBd0IscUNBQXFDLCtCQUErQix1Q0FBdUMsOEJBQThCLGlEQUFpRCwwQkFBMEIsZ0JBQWdCLCtCQUErQixnQkFBZ0IsMEJBQTBCLGdCQUFnQiwwQ0FBMEMsZ0JBQWdCLCtCQUErQixxQ0FBcUMsa0NBQWtDLHFDQUFxQyx1Q0FBdUMsZ0JBQWdCLCtCQUErQiwyREFBMkQsZ0NBQWdDLHFDQUFxQyxnQ0FBZ0MscUNBQXFDLGtDQUFrQyxxQ0FBcUMsa0NBQWtDLHFDQUFxQyxtQ0FBbUMscUNBQXFDLG1DQUFtQyxxQ0FBcUMsb0NBQW9DLHFDQUFxQyxxQ0FBcUMscUNBQXFDLHFDQUFxQyxnQkFBZ0IsbUNBQW1DLGdCQUFnQixrQ0FBa0MscUNBQXFDLHdDQUF3QyxxQ0FBcUMsK0NBQStDLHFDQUFxQyxrREFBa0QsZ0JBQWdCLG1DQUFtQyxnQkFBZ0IsK0JBQStCLGdCQUFnQixnQ0FBZ0MsZ0JBQWdCLGdDQUFnQyxvQ0FBb0MsK0JBQStCLHFDQUFxQyxxQ0FBcUMscUNBQXFDLDZCQUE2QixvQ0FBb0MsZ0NBQWdDLG9DQUFvQyxrQ0FBa0MscUNBQXFDLGtDQUFrQyxxQ0FBcUMsc0NBQXNDLDJDQUEyQyw0QkFBNEIscUNBQXFDLDRCQUE0QixxQ0FBcUMsNkJBQTZCLHFDQUFxQywyQkFBMkIsZ0JBQWdCLG9EQUFvRCxnQkFBZ0IsNkRBQTZELGdCQUFnQix3QkFBd0IscUNBQXFDLHlDQUF5QywyQ0FBMkMsNkNBQTZDLDhDQUE4Qyw0Q0FBNEMsNkNBQTZDLHlDQUF5Qyx5REFBeUQscUNBQXFDLDBEQUEwRCxzQ0FBc0Msb0NBQW9DLHNDQUFzQyxxQ0FBcUMsZ0RBQWdELG9DQUFvQywyQkFBMkIsMkNBQTJDLDJCQUEyQixnQkFBZ0IsbUNBQW1DLHFDQUFxQyxnQ0FBZ0MscUNBQXFDLDRDQUE0QyxxQ0FBcUMsb0NBQW9DLHFDQUFxQyx3Q0FBd0MscUNBQXFDLHlDQUF5QyxxQ0FBcUMsaUNBQWlDLHFDQUFxQyw2QkFBNkIsb0NBQW9DLDRCQUE0Qix5REFBeUQsK0NBQStDLHlEQUF5RCx5QkFBeUIsc0NBQXNDLDRCQUE0QixvQ0FBb0Msa0NBQWtDLGdCQUFnQix3QkFBd0IsZ0JBQWdCLGdDQUFnQyxvQ0FBb0Msc0NBQXNDLHFDQUFxQyw0QkFBNEIsc0NBQXNDLDRCQUE0QixzQ0FBc0MsMkJBQTJCLHFDQUFxQyw0QkFBNEIscUNBQXFDLDJCQUEyQixxQ0FBcUMsNkJBQTZCLHVDQUF1Qyw2QkFBNkIsZ0JBQWdCLHlDQUF5QywyQ0FBMkMsK0JBQStCLG9DQUFvQyxvQ0FBb0Msb0NBQW9DLG9DQUFvQyxvQ0FBb0MscUNBQXFDLGdCQUFnQixvQ0FBb0MsZ0JBQWdCLHlDQUF5QyxnQkFBZ0IsZ0NBQWdDLHFDQUFxQywrQkFBK0IsMERBQTBELDBDQUEwQyxxQ0FBcUMseUNBQXlDLG9DQUFvQywrQkFBK0IsMkNBQTJDLDhCQUE4QixnQkFBZ0IsNkJBQTZCLHFDQUFxQywwQ0FBMEMscUNBQXFDLHlDQUF5QyxxQ0FBcUMsb0NBQW9DLHFDQUFxQyxvQ0FBb0MscUNBQXFDLGtDQUFrQyxnQkFBZ0Isa0NBQWtDLGdCQUFnQixrQ0FBa0MsZ0JBQWdCLDJDQUEyQyxvQ0FBb0Msd0RBQXdELG9DQUFvQyw4Q0FBOEMsb0NBQW9DLGlEQUFpRCxvQ0FBb0MsaURBQWlELG9DQUFvQyx3REFBd0Qsb0NBQW9DLDRDQUE0QyxvQ0FBb0MsdUNBQXVDLGdCQUFnQixxQ0FBcUMsZ0JBQWdCLHlDQUF5QyxvQ0FBb0MsK0NBQStDLGdCQUFnQiwrQkFBK0IscUNBQXFDLHFDQUFxQywyQ0FBMkMsNkJBQTZCLHFDQUFxQyx1Q0FBdUMsZ0JBQWdCLG9DQUFvQyxnQkFBZ0IsNkJBQTZCLHFDQUFxQyw2QkFBNkIscUNBQXFDLDRDQUE0QyxvQ0FBb0MsNENBQTRDLG9DQUFvQyw4Q0FBOEMsb0NBQW9DLHlDQUF5QyxvQ0FBb0MsNENBQTRDLG9DQUFvQyw0Q0FBNEMsb0NBQW9DLDZDQUE2QyxvQ0FBb0MsMENBQTBDLDJDQUEyQyw0Q0FBNEMseURBQXlELDJCQUEyQixxQ0FBcUMsNkJBQTZCLHFDQUFxQyx3QkFBd0IscUNBQXFDLCtDQUErQyxnQkFBZ0IsNkNBQTZDLGdCQUFnQiw0Q0FBNEMsZ0JBQWdCLDBDQUEwQyxnQkFBZ0IsaURBQWlELGdCQUFnQiw2Q0FBNkMsZ0JBQWdCLDBDQUEwQyxnQkFBZ0IsaURBQWlELGdCQUFnQiwwQ0FBMEMscUNBQXFDLHlCQUF5QixzQ0FBc0MsdUNBQXVDLHNDQUFzQyxpQ0FBaUMsZ0JBQWdCLDRCQUE0QiwyQ0FBMkMsK0JBQStCLHdDQUF3QywrQkFBK0Isc0NBQXNDLGlDQUFpQyxxQ0FBcUMsOEJBQThCLHFDQUFxQyxnQ0FBZ0MscUNBQXFDLG1DQUFtQywyQ0FBMkMsZ0NBQWdDLHFDQUFxQyw4QkFBOEIsMkNBQTJDLCtCQUErQixzQ0FBc0MsaUNBQWlDLHFDQUFxQywwQkFBMEIsMkNBQTJDLHlCQUF5Qix1REFBdUQscUNBQXFDLHFDQUFxQyxpQ0FBaUMsb0NBQW9DLGdDQUFnQyw0REFBNEQsOEJBQThCLG9DQUFvQyx3Q0FBd0Msb0NBQW9DLHVEQUF1RCxxQ0FBcUMsNERBQTRELHlEQUF5RCxnQ0FBZ0MscUNBQXFDLG1DQUFtQyxxQ0FBcUMsb0NBQW9DLHFDQUFxQyxnQ0FBZ0MscUNBQXFDLG9DQUFvQyxxQ0FBcUMsb0NBQW9DLHFDQUFxQyxrQ0FBa0MscUNBQXFDLHFDQUFxQyx5Q0FBeUMsdUNBQXVDLGdCQUFnQiwrQ0FBK0Msb0NBQW9DLDZDQUE2QyxvQ0FBb0MsMkNBQTJDLG9DQUFvQyxvQ0FBb0MsZ0JBQWdCLCtCQUErQixvQ0FBb0MsdUNBQXVDLGdCQUFnQix3QkFBd0IscUNBQXFDLGdDQUFnQyxxQ0FBcUMsdUNBQXVDLHVDQUF1Qyx1Q0FBdUMsZ0JBQWdCLHlCQUF5QixxQ0FBcUMseUJBQXlCLHFDQUFxQywrQkFBK0Isb0NBQW9DLG1DQUFtQyxxQ0FBcUMsbUNBQW1DLHFDQUFxQyxrREFBa0QsZ0JBQWdCLHNEQUFzRCxnQkFBZ0IsK0JBQStCLG9DQUFvQyx3QkFBd0IscUNBQXFDLHlDQUF5QyxnQkFBZ0Isb0RBQW9ELGdCQUFnQiwrQkFBK0IscUNBQXFDLCtCQUErQixxQ0FBcUMsK0JBQStCLHFDQUFxQywrQkFBK0IscUNBQXFDLCtCQUErQixxQ0FBcUMsK0JBQStCLHFDQUFxQywrQkFBK0IscUNBQXFDLHVDQUF1QyxxQ0FBcUMsdUNBQXVDLHFDQUFxQyx1Q0FBdUMsZ0JBQWdCLDRDQUE0QyxnQkFBZ0IsMkNBQTJDLGdCQUFnQiw2Q0FBNkMsZ0JBQWdCLDJDQUEyQyxnQkFBZ0IsMkNBQTJDLGdCQUFnQiwyQ0FBMkMsZ0JBQWdCLGtDQUFrQyxnQkFBZ0Isb0NBQW9DLHlEQUF5RCxtQ0FBbUMsZ0JBQWdCLGdDQUFnQyxxQ0FBcUMsMkJBQTJCLGdCQUFnQixzQ0FBc0MscUNBQXFDLHdDQUF3QyxrQkFBa0IsNkJBQTZCLHdGQUF3RixtREFBbUQsc0NBQXNDLDBEQUEwRCxzQ0FBc0MsbURBQW1ELHNDQUFzQyxzREFBc0Qsc0NBQXNDLGtDQUFrQyx5REFBeUQsZ0NBQWdDLHFDQUFxQywyQkFBMkIscUNBQXFDLDJCQUEyQixxQ0FBcUMsMENBQTBDLG9DQUFvQyxtQ0FBbUMsc0NBQXNDLGdDQUFnQyxzQ0FBc0MsK0JBQStCLDBDQUEwQyxtREFBbUQsa0JBQWtCLGtDQUFrQyx1Q0FBdUMsK0JBQStCLHVDQUF1QywrQ0FBK0Msb0NBQW9DLGtDQUFrQyxzRUFBc0Usd0RBQXdELHNDQUFzQywrREFBK0Qsc0NBQXNDLHdEQUF3RCxzQ0FBc0MsNERBQTRELHNDQUFzQywyREFBMkQsc0NBQXNDLG1EQUFtRCxvQ0FBb0MsZ0RBQWdELHNDQUFzQyw2Q0FBNkMsb0NBQW9DLCtCQUErQiwyQ0FBMkMsNEJBQTRCLGdCQUFnQiw2Q0FBNkMsZ0JBQWdCLDhDQUE4QyxnQkFBZ0IsOENBQThDLGdCQUFnQix1Q0FBdUMsZ0JBQWdCLDBDQUEwQyxnQkFBZ0Isc0NBQXNDLGdCQUFnQiw0Q0FBNEMsZ0JBQWdCLHdDQUF3QyxnQkFBZ0IscURBQXFELHNDQUFzQyxxREFBcUQsc0NBQXNDLDZCQUE2Qix1REFBdUQsMkJBQTJCLHFDQUFxQyxtQ0FBbUMsMERBQTBELG1DQUFtQyxnQkFBZ0IseUJBQXlCLHNDQUFzQywwQkFBMEIsZ0JBQWdCLG9DQUFvQyxnQkFBZ0Isd0NBQXdDLGdCQUFnQiwrQkFBK0IsZ0JBQWdCLDZCQUE2QixxQ0FBcUMsZ0NBQWdDLHNDQUFzQywwQkFBMEIsd0NBQXdDLGdDQUFnQyxnQkFBZ0Isa0NBQWtDLGdCQUFnQixvQ0FBb0Msb0NBQW9DLDRCQUE0QixnQkFBZ0IsMkJBQTJCLGdCQUFnQixzQ0FBc0MscUNBQXFDLHlCQUF5QixnQkFBZ0IsdUNBQXVDLGdCQUFnQixzQ0FBc0MsZ0JBQWdCLHlCQUF5Qiw0Q0FBNEMsdUNBQXVDLHFDQUFxQyxvQ0FBb0MscUNBQXFDLGlDQUFpQyxxQ0FBcUMsbUNBQW1DLGdCQUFnQixzQ0FBc0MsZ0JBQWdCLG9DQUFvQyxvQ0FBb0MsMENBQTBDLG9DQUFvQyw2Q0FBNkMsZ0JBQWdCLHlDQUF5QyxnQkFBZ0IsdUNBQXVDLG9DQUFvQyxpREFBaUQsb0NBQW9DLHdDQUF3QyxvQ0FBb0Msc0NBQXNDLHVDQUF1QyxpREFBaUQsd0NBQXdDLDhCQUE4QixnQkFBZ0Isb0NBQW9DLGdCQUFnQixrQ0FBa0Msb0NBQW9DLHVDQUF1QyxzQ0FBc0Msd0NBQXdDLHNDQUFzQyxpQ0FBaUMscUNBQXFDLGlDQUFpQyxxQ0FBcUMsaUNBQWlDLHFDQUFxQyw0Q0FBNEMsZ0JBQWdCLDRDQUE0QyxnQkFBZ0IsZ0RBQWdELGdCQUFnQiw0Q0FBNEMsZ0JBQWdCLGdEQUFnRCxnQkFBZ0IsNkNBQTZDLHFDQUFxQyxzREFBc0QscUNBQXFDLGdEQUFnRCxxQ0FBcUMsK0NBQStDLHFDQUFxQyx3REFBd0Qsc0NBQXNDLGdEQUFnRCwwREFBMEQseURBQXlELHFDQUFxQyw2Q0FBNkMscUNBQXFDLHNEQUFzRCxxQ0FBcUMsb0RBQW9ELDBEQUEwRCw2REFBNkQscUNBQXFDLG1EQUFtRCwwREFBMEQsNERBQTRELHFDQUFxQyw0Q0FBNEMsMERBQTBELG1EQUFtRCxxQ0FBcUMscURBQXFELHFDQUFxQyxnREFBZ0QscUNBQXFDLHdCQUF3QixnQkFBZ0IsNkJBQTZCLGdCQUFnQixtQ0FBbUMsb0NBQW9DLG1EQUFtRCxvQ0FBb0Msb0RBQW9ELG9DQUFvQyx3Q0FBd0MsZ0JBQWdCLHFDQUFxQyxvQ0FBb0MsdUNBQXVDLG9DQUFvQyxpREFBaUQsb0NBQW9DLGlDQUFpQyxnQkFBZ0IseUNBQXlDLG9DQUFvQyxxQ0FBcUMsb0NBQW9DLHVDQUF1QyxvQ0FBb0MseUNBQXlDLG9DQUFvQywrQkFBK0Isb0NBQW9DLG9DQUFvQyxnQkFBZ0IsMENBQTBDLGdCQUFnQiwyQ0FBMkMsZ0JBQWdCLGlFQUFpRSxvQ0FBb0MsOENBQThDLG9DQUFvQyxzQ0FBc0Msb0NBQW9DLG1DQUFtQyxnQkFBZ0IsK0NBQStDLG9DQUFvQyxrREFBa0QsZ0JBQWdCLHFDQUFxQyxnQkFBZ0IsdUNBQXVDLG9DQUFvQyxtQ0FBbUMsZ0JBQWdCLHNEQUFzRCxnQkFBZ0Isb0RBQW9ELG9DQUFvQyx3Q0FBd0Msb0NBQW9DLG1DQUFtQyxnQkFBZ0IsNkNBQTZDLG9DQUFvQyxnREFBZ0Qsb0NBQW9DLG9DQUFvQyxvQ0FBb0MsNENBQTRDLG9DQUFvQywyQ0FBMkMsb0NBQW9DLDRCQUE0QixnQkFBZ0IsNkJBQTZCLGdCQUFnQixnQ0FBZ0MseURBQXlELHFDQUFxQyxvQ0FBb0MsNkNBQTZDLG9DQUFvQyxtQ0FBbUMsb0NBQW9DLGtDQUFrQyxnQkFBZ0IsZ0NBQWdDLG9DQUFvQyx5REFBeUQsb0NBQW9DLDZDQUE2QyxvQ0FBb0MsdUNBQXVDLG9DQUFvQyxzREFBc0Qsb0NBQW9DLDBEQUEwRCxvQ0FBb0MsNkJBQTZCLGdCQUFnQiwyQ0FBMkMsb0NBQW9DLDJDQUEyQyxvQ0FBb0Msb0NBQW9DLG9DQUFvQyxtQ0FBbUMsb0NBQW9DLHFDQUFxQyxvQ0FBb0MscUNBQXFDLGdCQUFnQiw2QkFBNkIsZ0JBQWdCLGlDQUFpQyxnQkFBZ0IsaUNBQWlDLGdCQUFnQixnQ0FBZ0MsZ0JBQWdCLGlDQUFpQyxnQkFBZ0IsaUNBQWlDLGdCQUFnQixzQ0FBc0Msb0NBQW9DLHlDQUF5QyxnQkFBZ0IsZ0NBQWdDLGdCQUFnQiw0Q0FBNEMsdUNBQXVDLDJDQUEyQyxvQ0FBb0Msd0VBQXdFLG9DQUFvQywwRUFBMEUsb0NBQW9DLDhEQUE4RCxvQ0FBb0Msc0VBQXNFLG9DQUFvQyw0RUFBNEUsb0NBQW9DLDhFQUE4RSxvQ0FBb0MsNEVBQTRFLG9DQUFvQyw4RUFBOEUsb0NBQW9DLDZFQUE2RSxvQ0FBb0MsMEVBQTBFLG9DQUFvQyxvRkFBb0Ysb0NBQW9DLDhFQUE4RSxvQ0FBb0MsbUZBQW1GLG9DQUFvQyxpRkFBaUYsb0NBQW9DLGdGQUFnRixvQ0FBb0MsOEVBQThFLDJEQUEyRCx1RkFBdUYsb0NBQW9DLCtFQUErRSxvQ0FBb0MsdUVBQXVFLHNDQUFzQywyRUFBMkUsb0NBQW9DLGlGQUFpRixvQ0FBb0MsaUZBQWlGLG9DQUFvQywyRUFBMkUsc0NBQXNDLG9GQUFvRixvQ0FBb0MscUZBQXFGLG9DQUFvQyxpRkFBaUYsb0NBQW9DLDBFQUEwRSxvQ0FBb0MsMEVBQTBFLHNDQUFzQyxtRkFBbUYsb0NBQW9DLCtFQUErRSxvQ0FBb0MsOEVBQThFLG9DQUFvQywrRUFBK0Usb0NBQW9DLDZFQUE2RSxvQ0FBb0MsZ0ZBQWdGLG9DQUFvQyxnRkFBZ0Ysb0NBQW9DLGlGQUFpRixvQ0FBb0MseUZBQXlGLG9DQUFvQyxzRkFBc0Ysb0NBQW9DLCtFQUErRSxvQ0FBb0MsK0VBQStFLG9DQUFvQyxvRkFBb0Ysb0NBQW9DLGdGQUFnRixvQ0FBb0Msa0ZBQWtGLG9DQUFvQyxzRUFBc0UsMkRBQTJELCtFQUErRSxvQ0FBb0Msa0ZBQWtGLG9DQUFvQywyRUFBMkUsb0NBQW9DLDBFQUEwRSxvQ0FBb0MscUZBQXFGLG9DQUFvQyx5RUFBeUUsc0NBQXNDLGtGQUFrRixvQ0FBb0MsOEVBQThFLG9DQUFvQyx5RkFBeUYsb0NBQW9DLDhFQUE4RSxvQ0FBb0MsNERBQTRELG9DQUFvQyxvRUFBb0Usb0NBQW9DLDZEQUE2RCxnQkFBZ0IsZ0ZBQWdGLG9DQUFvQyw0RUFBNEUsMkRBQTJELHlGQUF5RixvQ0FBb0MscUZBQXFGLG9DQUFvQyxnRkFBZ0Ysb0NBQW9DLGlGQUFpRixvQ0FBb0MsOEVBQThFLG9DQUFvQyxpRkFBaUYsb0NBQW9DLGlGQUFpRixvQ0FBb0MsZ0ZBQWdGLG9DQUFvQyw4RUFBOEUsb0NBQW9DLDRFQUE0RSxzQ0FBc0MscUZBQXFGLG9DQUFvQyxtRkFBbUYsb0NBQW9DLCtEQUErRCxvQ0FBb0MsOEVBQThFLG9DQUFvQyw2REFBNkQsb0NBQW9DLHlDQUF5QyxvQ0FBb0Msa0NBQWtDLGdCQUFnQixrQ0FBa0MsZ0JBQWdCLDJDQUEyQyxxQ0FBcUMsZ0NBQWdDLGdCQUFnQiw0QkFBNEIsb0NBQW9DLG1DQUFtQyxxQ0FBcUMsb0NBQW9DLG9DQUFvQyxvQ0FBb0MsZ0JBQWdCLG1DQUFtQyxvQ0FBb0MseUJBQXlCLGtEQUFrRCw0QkFBNEIsZ0JBQWdCLDZCQUE2QixnQkFBZ0IsK0JBQStCLGdCQUFnQixxQ0FBcUMsZ0JBQWdCLDhCQUE4QixxQ0FBcUMseUJBQXlCLGdCQUFnQiw4QkFBOEIscUNBQXFDLDhCQUE4QixxQ0FBcUMsaURBQWlELGdCQUFnQiwyQkFBMkIsc0NBQXNDLCtCQUErQixvQ0FBb0MsZ0RBQWdELG9DQUFvQyxnQ0FBZ0MscUNBQXFDLGtDQUFrQyxxQ0FBcUMsb0NBQW9DLGdCQUFnQixrQ0FBa0MsZ0JBQWdCLG9DQUFvQyxnQkFBZ0IsbUNBQW1DLGdCQUFnQixxQ0FBcUMsZ0JBQWdCLDZCQUE2QixnQkFBZ0IsdUNBQXVDLHFDQUFxQyxxQ0FBcUMscUNBQXFDLHlCQUF5QixnQkFBZ0IsMENBQTBDLHFDQUFxQyw4QkFBOEIsc0NBQXNDLG9DQUFvQyxnQkFBZ0Isd0NBQXdDLG9DQUFvQywwQ0FBMEMsZ0JBQWdCLG1DQUFtQyxnQkFBZ0Isc0NBQXNDLG1FQUFtRSwwQ0FBMEMsZ0JBQWdCLHFDQUFxQyxvQ0FBb0MscUNBQXFDLG9DQUFvQywyQ0FBMkMsb0NBQW9DLGdEQUFnRCxvQ0FBb0MsZ0RBQWdELG9DQUFvQyxrREFBa0Qsb0NBQW9DLGtEQUFrRCxvQ0FBb0MsMENBQTBDLG9DQUFvQyw0Q0FBNEMsb0NBQW9DLGlEQUFpRCxvQ0FBb0MsdURBQXVELG9DQUFvQyx5REFBeUQsb0NBQW9DLGtEQUFrRCxvQ0FBb0MsbURBQW1ELG9DQUFvQyxzREFBc0Qsb0NBQW9DLGtDQUFrQyxnQkFBZ0IsMEJBQTBCLGdCQUFnQix3QkFBd0IsZ0JBQWdCLGdDQUFnQyxxQ0FBcUMsdUNBQXVDLHFDQUFxQywyQ0FBMkMsOERBQThELHFDQUFxQyxnQkFBZ0IsaUNBQWlDLG9DQUFvQyxtQ0FBbUMsNENBQTRDLDRCQUE0Qix1Q0FBdUMsaUNBQWlDLHNDQUFzQyxxQ0FBcUMsd0NBQXdDLHVDQUF1Qyw0REFBNEQsNEJBQTRCLGdCQUFnQixvQ0FBb0MsZ0JBQWdCLDBCQUEwQixnQkFBZ0IseUNBQXlDLG9DQUFvQyw0QkFBNEIsZ0JBQWdCLDZCQUE2QixnQkFBZ0IsNEJBQTRCLGdCQUFnQiwrQkFBK0IsZ0JBQWdCLCtCQUErQixnQkFBZ0IsK0JBQStCLGdCQUFnQiwrQkFBK0IsZ0JBQWdCLCtCQUErQixnQkFBZ0IsK0JBQStCLGdCQUFnQiwrQkFBK0IsZ0JBQWdCLGdDQUFnQyxnQkFBZ0IsK0JBQStCLGdCQUFnQiw4Q0FBOEMsZ0JBQWdCLDZDQUE2QyxnQkFBZ0IsNEJBQTRCLHFDQUFxQyx5QkFBeUIsc0NBQXNDLHlCQUF5QixzQ0FBc0MseUJBQXlCLHNDQUFzQyw0Q0FBNEMscUNBQXFDLGdEQUFnRCxxQ0FBcUMsK0NBQStDLHFDQUFxQywyQ0FBMkMscUNBQXFDLG9DQUFvQyxvQ0FBb0MsbUNBQW1DLGdCQUFnQix1Q0FBdUMsNENBQTRDLCtCQUErQixvQ0FBb0MseUJBQXlCLHFDQUFxQyxtQ0FBbUMsZ0JBQWdCLGtDQUFrQyx5Q0FBeUMsZ0RBQWdELG9DQUFvQyxvREFBb0QsZ0JBQWdCLG9DQUFvQyxpRUFBaUUsaUNBQWlDLHFDQUFxQyxpQ0FBaUMscUNBQXFDLDRCQUE0QixnQkFBZ0IsNEJBQTRCLGdCQUFnQiw0QkFBNEIsZ0JBQWdCLDRCQUE0QixnQkFBZ0Isc0NBQXNDLHVDQUF1QyxzQ0FBc0MsdUNBQXVDLHlDQUF5Qyx1Q0FBdUMsc0NBQXNDLHVDQUF1Qyx3Q0FBd0MsNkNBQTZDLCtDQUErQyx1Q0FBdUMsc0NBQXNDLHVDQUF1Qyx3Q0FBd0Msb0NBQW9DLGtDQUFrQyxnQkFBZ0IsaUNBQWlDLDBEQUEwRCxpQ0FBaUMsdUNBQXVDLDBDQUEwQyx1Q0FBdUMsaUNBQWlDLHVDQUF1QywwQ0FBMEMsdUNBQXVDLG9DQUFvQyx1Q0FBdUMsNkNBQTZDLHVDQUF1QyxpQ0FBaUMsdUNBQXVDLG1DQUFtQyx1Q0FBdUMsMENBQTBDLHVDQUF1Qyw0Q0FBNEMsdUNBQXVDLGlDQUFpQyw0Q0FBNEMsd0JBQXdCLHFDQUFxQyxrQ0FBa0MsZ0JBQWdCLG9DQUFvQyw4Q0FBOEMsK0JBQStCLHlEQUF5RCxvQ0FBb0MscUNBQXFDLGtDQUFrQyx5REFBeUQsMkNBQTJDLGdCQUFnQix1Q0FBdUMsZ0JBQWdCLHFDQUFxQyxvQ0FBb0Msd0NBQXdDLGdCQUFnQixzQ0FBc0Msb0NBQW9DLDJDQUEyQyxnQkFBZ0IscUNBQXFDLG9DQUFvQyw4Q0FBOEMscUNBQXFDLGlDQUFpQyxrREFBa0QsMENBQTBDLG9DQUFvQywwQ0FBMEMsb0NBQW9DLHdCQUF3QixnQkFBZ0IsbUNBQW1DLHFDQUFxQyxrQ0FBa0MsZ0JBQWdCLDZCQUE2QixxQ0FBcUMsaUNBQWlDLHFDQUFxQyw0QkFBNEIscUNBQXFDLDRCQUE0QixnQkFBZ0Isc0NBQXNDLGdCQUFnQix5QkFBeUIsNENBQTRDLDhCQUE4QixxQ0FBcUMsMkJBQTJCLHFDQUFxQywwQkFBMEIsMENBQTBDLDZCQUE2QiwwREFBMEQsa0NBQWtDLGdCQUFnQix3Q0FBd0MsZ0JBQWdCLDBDQUEwQyxnQkFBZ0IsZ0RBQWdELGdCQUFnQixvQ0FBb0MsZ0JBQWdCLDBDQUEwQyxnQkFBZ0Isb0NBQW9DLGdCQUFnQiwwQ0FBMEMsZ0JBQWdCLGlDQUFpQyxnQkFBZ0IsdUNBQXVDLGdCQUFnQixvQ0FBb0MsZ0JBQWdCLDBDQUEwQyxnQkFBZ0IsbUNBQW1DLGdCQUFnQiw0QkFBNEIsZ0JBQWdCLDBDQUEwQyxnQkFBZ0Isd0JBQXdCLHFDQUFxQyw2QkFBNkIsZ0JBQWdCLGdDQUFnQyxnQkFBZ0IsNkJBQTZCLG9DQUFvQyxvQ0FBb0MsZ0JBQWdCLGlDQUFpQyxnQkFBZ0IsMENBQTBDLGdCQUFnQiwwQkFBMEIsdURBQXVELDhCQUE4QixxQ0FBcUMseUNBQXlDLGdCQUFnQix3QkFBd0IscUNBQXFDLDRCQUE0QixnQkFBZ0IsNEJBQTRCLGdCQUFnQiw4QkFBOEIsdUNBQXVDLDZCQUE2QixzQ0FBc0MsbUNBQW1DLHVDQUF1Qyw2QkFBNkIscUNBQXFDLDRCQUE0QixnQkFBZ0IsNEJBQTRCLGdCQUFnQiwwQ0FBMEMsZ0JBQWdCLHdCQUF3QixnQkFBZ0Isa0NBQWtDLGdCQUFnQix3Q0FBd0MsZ0JBQWdCLGdEQUFnRCxnQkFBZ0IsbUNBQW1DLHFDQUFxQyxnQ0FBZ0MscUNBQXFDLHdCQUF3QixxQ0FBcUMsd0NBQXdDLGdCQUFnQiwyQkFBMkIscUNBQXFDLGlDQUFpQyxnQkFBZ0IsK0JBQStCLG9DQUFvQywrQkFBK0Isb0NBQW9DLCtCQUErQixvQ0FBb0MseUJBQXlCLHFDQUFxQyx5QkFBeUIsc0NBQXNDLGlDQUFpQyxnQkFBZ0IsNEJBQTRCLG9DQUFvQywrQkFBK0IsZ0JBQWdCLCtCQUErQixnQkFBZ0IsK0JBQStCLGdCQUFnQiwrQkFBK0IsZ0JBQWdCLCtCQUErQixnQkFBZ0Isa0NBQWtDLHFDQUFxQyxxQ0FBcUMscUNBQXFDLG9DQUFvQyxxQ0FBcUMsMkNBQTJDLHFDQUFxQyxzREFBc0QsNERBQTRELHdDQUF3QyxnQkFBZ0Isc0NBQXNDLHFDQUFxQyx1Q0FBdUMscUNBQXFDLHVDQUF1QyxnQkFBZ0IsMkNBQTJDLGdCQUFnQiw0QkFBNEIsZ0JBQWdCLDRDQUE0QyxxQ0FBcUMsK0JBQStCLGdCQUFnQix3QkFBd0IsNENBQTRDLG1DQUFtQyx5REFBeUQsNkJBQTZCLDBEQUEwRCxpQ0FBaUMsb0NBQW9DLDBCQUEwQixnQkFBZ0IscUJBQXFCLDBDQUEwQyxnQ0FBZ0Msb0NBQW9DLHFDQUFxQyxvQ0FBb0MsOEJBQThCLGdCQUFnQixpQ0FBaUMsZ0JBQWdCLHVCQUF1QixxQ0FBcUMsdUJBQXVCLHVDQUF1QyxxQkFBcUIsZ0JBQWdCLCtCQUErQixnQkFBZ0IseUJBQXlCLDBEQUEwRCw2QkFBNkIsOERBQThELGdDQUFnQywyREFBMkQsMEJBQTBCLHVDQUF1QyxpQ0FBaUMsdUNBQXVDLHNCQUFzQixrQkFBa0Isa0NBQWtDLHVDQUF1QyxzQkFBc0IsMENBQTBDLGlDQUFpQyx5REFBeUQsaUNBQWlDLHVDQUF1QyxpQ0FBaUMsdUNBQXVDLHdCQUF3Qix5Q0FBeUMsdUJBQXVCLDJDQUEyQyw2QkFBNkIsMkNBQTJDLHdCQUF3QiwrQ0FBK0MsdUJBQXVCLDJEQUEyRCx3QkFBd0Isa0VBQWtFLHNCQUFzQiwrREFBK0QseUJBQXlCLHVDQUF1QyxpQ0FBaUMsdUNBQXVDLHVCQUF1Qix3Q0FBd0MsNEJBQTRCLHVDQUF1QyxtQ0FBbUMscUJBQXFCLHdCQUF3QixzQ0FBc0MsMkJBQTJCLGtCQUFrQiw2QkFBNkIsdUNBQXVDLHVCQUF1Qix3Q0FBd0Msc0JBQXNCLHVDQUF1QyxzQkFBc0IscUJBQXFCLGlDQUFpQyw4Q0FBOEMsaUNBQWlDLHVDQUF1QywyQkFBMkIsdUZBQXVGLHVCQUF1Qix1Q0FBdUMsNkJBQTZCLDJEQUEyRCw2QkFBNkIsMkRBQTJELGtDQUFrQywyREFBMkQsc0JBQXNCLDREQUE0RCx3QkFBd0IsdUNBQXVDLHNCQUFzQix1Q0FBdUMsMkJBQTJCLHVDQUF1QywyQkFBMkIsa0JBQWtCLGtDQUFrQyxrQkFBa0IsbUNBQW1DLHVDQUF1Qyw4QkFBOEIsa0JBQWtCLGlDQUFpQyx1Q0FBdUMsMkJBQTJCLHVDQUF1QywyQkFBMkIsdUNBQXVDLDhCQUE4QixrQkFBa0Isa0NBQWtDLGtCQUFrQiw2QkFBNkIseURBQXlELDZCQUE2QixrQkFBa0IsMEJBQTBCLHVDQUF1QywrQkFBK0IsdUNBQXVDLGlDQUFpQyx1Q0FBdUMsd0JBQXdCLHVDQUF1QywyQkFBMkIsNENBQTRDLDZCQUE2QiwwQ0FBMEMsdUJBQXVCLHdDQUF3Qyx1QkFBdUIsa0JBQWtCLHNCQUFzQix1Q0FBdUMsNEJBQTRCLHlDQUF5Qyx1Q0FBdUMsMkNBQTJDLGdDQUFnQyx1Q0FBdUMsb0NBQW9DLDBDQUEwQyxpQ0FBaUMsNkRBQTZELDZCQUE2QixvQkFBb0Isd0JBQXdCLDhEQUE4RCwrQkFBK0Isc0JBQXNCLGlDQUFpQyw2Q0FBNkMsMkJBQTJCLHNDQUFzQyxzQkFBc0IsdUNBQXVDLG1DQUFtQyw4Q0FBOEMsMEJBQTBCLHFCQUFxQixpQ0FBaUMsK0NBQStDLDhCQUE4Qix1Q0FBdUMseUJBQXlCLHVDQUF1Qyx5QkFBeUIsdUNBQXVDLDBCQUEwQix3Q0FBd0MsMkJBQTJCLHVDQUF1QywyQkFBMkIsdUNBQXVDLDZCQUE2Qix1Q0FBdUMseUJBQXlCLHVDQUF1QyxnQ0FBZ0MscUJBQXFCLDZCQUE2QiwrREFBK0QsOEJBQThCLG1EQUFtRCw2QkFBNkIseURBQXlELDBCQUEwQix1Q0FBdUMsOEJBQThCLHVDQUF1Qyw2QkFBNkIsdUNBQXVDLDZCQUE2Qix1Q0FBdUMsMEJBQTBCLHVDQUF1Qyx5QkFBeUIsNENBQTRDLHNDQUFzQyx5Q0FBeUMsc0JBQXNCLHVDQUF1Qyx1QkFBdUIsMENBQTBDLHdCQUF3Qiw0Q0FBNEMseUJBQXlCLGtFQUFrRSxxQ0FBcUMsNkNBQTZDLG9DQUFvQyx1Q0FBdUMsaUNBQWlDLDREQUE0RCx5Q0FBeUMsc0NBQXNDLHdDQUF3Qyx1Q0FBdUMsc0JBQXNCLHNDQUFzQyxxQkFBcUIsMERBQTBELHVCQUF1Qix3Q0FBd0Msa0NBQWtDLDREQUE0RCxrQ0FBa0MsdUNBQXVDLHNCQUFzQix1Q0FBdUMsMEJBQTBCLDREQUE0RCwyQkFBMkIsd0NBQXdDLHlCQUF5Qix1Q0FBdUMsMEJBQTBCLDJDQUEyQyx5QkFBeUIsMENBQTBDLDZCQUE2QixzQ0FBc0MsdUJBQXVCLHVDQUF1QyxzQkFBc0IsMkRBQTJELHNCQUFzQiw0Q0FBNEMsc0JBQXNCLHVDQUF1QywwQkFBMEIsdUNBQXVDLDBCQUEwQixrREFBa0QsdUJBQXVCLHVDQUF1Qyx3QkFBd0IseUNBQXlDLGlDQUFpQyx5Q0FBeUMsaUNBQWlDLHlDQUF5QyxpQ0FBaUMseUNBQXlDLGtDQUFrQywwQ0FBMEMsMENBQTBDLG1EQUFtRCxpQ0FBaUMseUNBQXlDLGlDQUFpQyx5Q0FBeUMsa0NBQWtDLDBDQUEwQyw4QkFBOEIsdUNBQXVDLHdDQUF3Qyw0Q0FBNEMsc0NBQXNDLG9DQUFvQywrQkFBK0IsbURBQW1ELHVCQUF1Qix1Q0FBdUMsNEJBQTRCLDJEQUEyRCw0QkFBNEIsNERBQTRELHFCQUFxQixzQ0FBc0MsMkJBQTJCLHlFQUF5RSx3QkFBd0IsZ0JBQWdCLDBCQUEwQixvQ0FBb0MseUJBQXlCLDREQUE0RCw2QkFBNkIsb0NBQW9DLDhCQUE4QixvQ0FBb0MsOEJBQThCLHlEQUF5RCw0QkFBNEIsb0NBQW9DLCtCQUErQixvQ0FBb0MsNEJBQTRCLG9DQUFvQyx5Q0FBeUMsb0NBQW9DLDhDQUE4QyxvQ0FBb0MseUJBQXlCLDBEQUEwRCwwQkFBMEIsaUVBQWlFLGdDQUFnQyxzQ0FBc0MsMEJBQTBCLG9DQUFvQyxvQkFBb0IsMkVBQTJFLHdCQUF3Qix5REFBeUQsMkNBQTJDLGdCQUFnQiw4QkFBOEIsb0NBQW9DLHlCQUF5QixvQ0FBb0Msd0JBQXdCLHlEQUF5RCwwQkFBMEIsMkRBQTJELHlCQUF5QiwwREFBMEQseUJBQXlCLDREQUE0RCx1QkFBdUIsK0VBQStFLHFCQUFxQixzQ0FBc0MsK0JBQStCLG9DQUFvQyw4QkFBOEIsb0NBQW9DLGdDQUFnQyxvQ0FBb0MsK0JBQStCLG9DQUFvQyx3QkFBd0IseURBQXlELG9CQUFvQiwwREFBMEQscUJBQXFCLGdCQUFnQixxQkFBcUIsZ0JBQWdCLG1DQUFtQyxnQkFBZ0IsbUJBQW1CLGdCQUFnQixlQUFlLDJEQUEyRCxnQkFBZ0IsZ0JBQWdCLGNBQWMsZ0JBQWdCLGNBQWMsZ0JBQWdCLGdCQUFnQix1Q0FBdUMsY0FBYyxnQkFBZ0IsaUJBQWlCLGdCQUFnQixrQkFBa0IsZ0JBQWdCLGVBQWUsZ0JBQWdCLGNBQWMsZ0JBQWdCLGtDQUFrQyxnQkFBZ0Isa0JBQWtCLGdCQUFnQixpQkFBaUIsZ0JBQWdCLGdCQUFnQiwrREFBK0QsZUFBZSxnQkFBZ0IsZUFBZSxnQkFBZ0Isb0JBQW9CLGdCQUFnQixhQUFhLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGNBQWMsZ0JBQWdCLHVCQUF1QixnQkFBZ0IsdUJBQXVCLGdCQUFnQix1QkFBdUIsZ0JBQWdCLHVCQUF1QixnQkFBZ0IsYUFBYSxnQkFBZ0IsZUFBZSxnQkFBZ0IsZUFBZSxnQkFBZ0IsbUJBQW1CLGdCQUFnQixlQUFlLGdCQUFnQixtQkFBbUIsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGlCQUFpQixnQkFBZ0IsaUJBQWlCLGdCQUFnQixpQkFBaUIsZ0JBQWdCLGtCQUFrQixnQkFBZ0Isa0JBQWtCLGdCQUFnQixpQkFBaUIsZ0JBQWdCLGtCQUFrQixnQkFBZ0Isa0JBQWtCLGdCQUFnQixjQUFjLGdCQUFnQixpQkFBaUIsZ0JBQWdCLGlCQUFpQixnQkFBZ0IsZUFBZSxnQkFBZ0IsZUFBZSxnQkFBZ0IsZ0JBQWdCLGdCQUFnQixlQUFlLGdCQUFnQixrQkFBa0IsZ0JBQWdCLGtCQUFrQixnQkFBZ0Isa0JBQWtCLGdCQUFnQixrQkFBa0IsZ0JBQWdCLGVBQWUsZ0JBQWdCLGVBQWUsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGNBQWMsZ0JBQWdCLGtCQUFrQixnQkFBZ0Isb0JBQW9CLGdCQUFnQixlQUFlLGdCQUFnQixxQkFBcUIsZ0JBQWdCLGVBQWUsa0JBQWtCLGNBQWMsZ0JBQWdCLGNBQWMsZ0JBQWdCLGNBQWMscUNBQXFDLGFBQWEsZ0JBQWdCLGNBQWMsZ0JBQWdCLGVBQWUsZ0JBQWdCLG1CQUFtQixnQkFBZ0IsbUJBQW1CLGdCQUFnQixrQkFBa0IsZ0JBQWdCLGVBQWUsMERBQTBELHFCQUFxQixnQkFBZ0IsY0FBYywwQ0FBMEMsY0FBYyxpRUFBaUUsb0JBQW9CLGdCQUFnQixjQUFjLGdCQUFnQixxQkFBcUIsZ0JBQWdCLGVBQWUsMEZBQTBGLHdCQUF3QixnQkFBZ0IsbUJBQW1CLGtCQUFrQixjQUFjLHNFQUFzRSxlQUFlLGdCQUFnQixvQkFBb0IsZ0JBQWdCLGVBQWUsZ0JBQWdCLGtCQUFrQixnQkFBZ0IsZUFBZSxnQkFBZ0Isa0JBQWtCLGdCQUFnQixrQkFBa0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0Isb0JBQW9CLGdCQUFnQixjQUFjLGdCQUFnQiwyQkFBMkIsZ0JBQWdCLG1CQUFtQixnQkFBZ0Isc0JBQXNCLGdCQUFnQixjQUFjLGdCQUFnQixjQUFjLHVDQUF1QyxlQUFlLHVDQUF1QyxjQUFjLGdCQUFnQixrQkFBa0IsZ0JBQWdCLGVBQWUsZ0JBQWdCLGtCQUFrQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGNBQWMsZ0JBQWdCLDBCQUEwQixnQkFBZ0Isc0JBQXNCLGdCQUFnQixlQUFlLGdCQUFnQixrQkFBa0IsZ0JBQWdCLGlCQUFpQixnQkFBZ0IsZUFBZSxnQkFBZ0IsZUFBZSxnQkFBZ0IsaUJBQWlCLGdCQUFnQix3QkFBd0IsZ0JBQWdCLGtCQUFrQixnQkFBZ0IsdUJBQXVCLGdCQUFnQixtQkFBbUIsZ0JBQWdCLHdCQUF3QixnQkFBZ0IsaUNBQWlDLGdCQUFnQix1QkFBdUIsZ0JBQWdCLHVCQUF1QixnQkFBZ0IseUJBQXlCLDRDQUE0Qyw0QkFBNEIscUNBQXFDLHdCQUF3QixnQkFBZ0IsNEJBQTRCLGdCQUFnQiw0QkFBNEIsZ0JBQWdCLHdCQUF3QixnQkFBZ0Isd0JBQXdCLGdCQUFnQix3QkFBd0IsZ0JBQWdCLHlCQUF5QixnQkFBZ0IseUJBQXlCLGdCQUFnQiw0QkFBNEIsZ0JBQWdCLGtCQUFrQixxQ0FBcUMsa0JBQWtCLHFDQUFxQyxxQkFBcUIsdUNBQXVDLHNCQUFzQixnQkFBZ0IsdUJBQXVCLGdCQUFnQix5QkFBeUIsZ0JBQWdCLHdCQUF3QixnQkFBZ0IsMkJBQTJCLHFDQUFxQyxxQ0FBcUMscUNBQXFDLCtCQUErQixnQkFBZ0IseUJBQXlCLGdCQUFnQiw4QkFBOEIsMkNBQTJDLDhCQUE4QiwyQ0FBMkMsOEJBQThCLDJDQUEyQyx3QkFBd0IsZ0JBQWdCLGtDQUFrQyxnQkFBZ0Isb0JBQW9CLGdCQUFnQixnQ0FBZ0MsZ0JBQWdCLGtCQUFrQixxQ0FBcUMsMkJBQTJCLHFCQUFxQix3Q0FBd0MsZ0JBQWdCLHVCQUF1QixnQkFBZ0IsbUJBQW1CLHFCQUFxQixpQkFBaUIscUNBQXFDLHdCQUF3QixnQkFBZ0IsY0FBYywwQ0FBMEMsZUFBZSwwQ0FBMEMsZUFBZSw2REFBNkQsZ0JBQWdCLDREQUE0RCxpQkFBaUIscURBQXFELGdCQUFnQiw0REFBNEQsaUJBQWlCLHdDQUF3QyxnQkFBZ0Isc0NBQXNDLHFCQUFxQix1Q0FBdUMsb0JBQW9CLHVDQUF1QyxtQkFBbUIsdUNBQXVDLG1CQUFtQix1Q0FBdUMseUJBQXlCLDRDQUE0QyxnQ0FBZ0MsdUNBQXVDLHNCQUFzQixxQ0FBcUMsZ0JBQWdCLGtCQUFrQixnQkFBZ0IsdUNBQXVDLGFBQWEsc0NBQXNDLG1CQUFtQix1Q0FBdUMsbUJBQW1CLHVDQUF1QyxvQkFBb0Isd0NBQXdDLG1CQUFtQix1Q0FBdUMsb0JBQW9CLHdDQUF3QyxtQkFBbUIsa0JBQWtCLG1CQUFtQix1Q0FBdUMsb0JBQW9CLHFDQUFxQyxhQUFhLHlEQUF5RCxjQUFjLGdCQUFnQixhQUFhLHFDQUFxQyxjQUFjLHNDQUFzQyxlQUFlLHVDQUF1QyxlQUFlLHFDQUFxQyxlQUFlLDJDQUEyQyxlQUFlLGdCQUFnQixlQUFlLGdCQUFnQixjQUFjLHlEQUF5RCxjQUFjLHFDQUFxQyxvQkFBb0Isc0NBQXNDLGNBQWMscUNBQXFDLGVBQWUsc0NBQXNDLGdCQUFnQixvQ0FBb0MsY0FBYywwREFBMEQsZUFBZSxzQ0FBc0Msd0JBQXdCLHVDQUF1QyxlQUFlLHNDQUFzQyx3QkFBd0IsdUNBQXVDLGNBQWMscUNBQXFDLGNBQWMscUNBQXFDLGNBQWMsaUVBQWlFLGVBQWUsdUVBQXVFLGNBQWMsMERBQTBELGNBQWMsZ0VBQWdFLGNBQWMscUNBQXFDLGNBQWMscUNBQXFDLGlCQUFpQixnQkFBZ0IsZ0JBQWdCLHFCQUFxQixjQUFjLDBEQUEwRCxtQkFBbUIsc0NBQXNDLGtCQUFrQixxQ0FBcUMscUJBQXFCLGdCQUFnQixjQUFjLHVDQUF1QyxrQkFBa0IsZ0VBQWdFLGNBQWMscUNBQXFDLGVBQWUsaUVBQWlFLGtCQUFrQixxQ0FBcUMsOEJBQThCLHlEQUF5RCxxQ0FBcUMscUNBQXFDLHVCQUF1QixnQkFBZ0IsMkJBQTJCLHlEQUF5RCxtQkFBbUIsNENBQTRDLDJCQUEyQixxQ0FBcUMsa0JBQWtCLHFDQUFxQyxrQkFBa0IscUNBQXFDLDJCQUEyQixxQ0FBcUMsa0JBQWtCLHFDQUFxQyxrQkFBa0IscUNBQXFDLG1DQUFtQyxxQ0FBcUMsbUNBQW1DLHFDQUFxQyxpQ0FBaUMsZ0JBQWdCLDZCQUE2QixxQ0FBcUMsa0JBQWtCLGdCQUFnQiwyQkFBMkIsZ0JBQWdCLHNCQUFzQixxQ0FBcUMsdUJBQXVCLHVDQUF1QyxzQkFBc0IscUNBQXFDLHVCQUF1QixnQkFBZ0IseUJBQXlCLGdCQUFnQix1Q0FBdUMsZ0JBQWdCLHVDQUF1QyxnQkFBZ0Isa0JBQWtCLGdCQUFnQiwwQkFBMEIscUNBQXFDLG1DQUFtQyxxQ0FBcUMsdUJBQXVCLHNDQUFzQyxtQkFBbUIscUNBQXFDLHlCQUF5QixxQ0FBcUMsZUFBZSx3Q0FBd0MsY0FBYyxxQ0FBcUMsZ0JBQWdCLHVDQUF1Qyx1QkFBdUIsdUNBQXVDLGdCQUFnQix1Q0FBdUMscUJBQXFCLDhEQUE4RCxpQkFBaUIsMkRBQTJELGdCQUFnQixzQ0FBc0Msd0JBQXdCLHVDQUF1QyxtQkFBbUIsMERBQTBELGdCQUFnQix1Q0FBdUMsaUJBQWlCLDZDQUE2Qyw0QkFBNEIsdUNBQXVDLDRCQUE0Qix1Q0FBdUMsNkJBQTZCLHVDQUF1Qyw0QkFBNEIsdUNBQXVDLGdCQUFnQix1Q0FBdUMsZ0JBQWdCLHVDQUF1QyxvQkFBb0IsdUNBQXVDLGdCQUFnQixxQkFBcUIsb0JBQW9CLHVDQUF1Qyx3QkFBd0IsdUNBQXVDLGlCQUFpQixnQkFBZ0IsNEJBQTRCLGdCQUFnQixxQ0FBcUMsMERBQTBELDBCQUEwQixnQkFBZ0IsNEJBQTRCLGdCQUFnQixtQkFBbUIsdUNBQXVDLG1DQUFtQyx1Q0FBdUMsNENBQTRDLHVDQUF1QywyQkFBMkIsdUNBQXVDLGlCQUFpQixxQ0FBcUMscUJBQXFCLG9DQUFvQyxpQkFBaUIsZ0JBQWdCLG9CQUFvQixxQ0FBcUMsbUJBQW1CLGdFQUFnRSxtQkFBbUIsZ0JBQWdCLGdCQUFnQixnQkFBZ0Isb0JBQW9CLGdCQUFnQiw0QkFBNEIsZ0JBQWdCLHdCQUF3QixnQkFBZ0Isd0JBQXdCLHFDQUFxQyxjQUFjLHFDQUFxQyxvQkFBb0IsMERBQTBELHNCQUFzQix5REFBeUQsZUFBZSxpRUFBaUUsZUFBZSx3RUFBd0UsY0FBYyxxQ0FBcUMsMEJBQTBCLHlEQUF5RCxrQkFBa0IscUNBQXFDLDRCQUE0QixnQkFBZ0Isa0JBQWtCLHFDQUFxQyxxQkFBcUIsa0JBQWtCLHFCQUFxQixnQkFBZ0Isa0JBQWtCLHFDQUFxQyx1QkFBdUIsb0NBQW9DLGtCQUFrQixxQ0FBcUMsc0JBQXNCLHNDQUFzQyx3Q0FBd0MscUNBQXFDLHNDQUFzQyxxQ0FBcUMsMkNBQTJDLGdCQUFnQix1QkFBdUIsMkRBQTJELHdDQUF3QyxxQ0FBcUMsa0JBQWtCLHFDQUFxQyxlQUFlLGlFQUFpRSxxQkFBcUIscUVBQXFFLDBCQUEwQixzQ0FBc0MsbUJBQW1CLHFFQUFxRSxrQkFBa0IsZ0VBQWdFLG1CQUFtQixzQ0FBc0MsMEJBQTBCLHFDQUFxQywwQkFBMEIsZ0JBQWdCLHlCQUF5QixnQkFBZ0IscUJBQXFCLGdCQUFnQix3QkFBd0IscUNBQXFDLHdCQUF3QixxQ0FBcUMseUJBQXlCLGdCQUFnQixvQkFBb0IscUNBQXFDLDJCQUEyQixnQkFBZ0IsdUJBQXVCLGdCQUFnQixzQkFBc0IscUNBQXFDLHFCQUFxQixnQkFBZ0IscUJBQXFCLHFDQUFxQyxnQ0FBZ0MsZ0JBQWdCLDRCQUE0QixnQkFBZ0IsOEJBQThCLGdCQUFnQixrQ0FBa0MsZ0JBQWdCLHdCQUF3Qix5RUFBeUUsa0JBQWtCLDJDQUEyQyxrQkFBa0Isb0JBQW9CLGFBQWEsb0JBQW9CLHNCQUFzQixvQ0FBb0MsYUFBYSwyRUFBMkUsYUFBYSx5REFBeUQsb0JBQW9CLGdCQUFnQixtQkFBbUIsZ0JBQWdCLGFBQWEsZ0JBQWdCLG9CQUFvQixnQkFBZ0Isa0JBQWtCLGdCQUFnQixrQkFBa0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsMEJBQTBCLGdCQUFnQixjQUFjLHdFQUF3RSxjQUFjLHNCQUFzQixvQkFBb0Isb0NBQW9DLGlCQUFpQixnQkFBZ0IsYUFBYSx5Q0FBeUMsY0FBYywwQ0FBMEMsa0JBQWtCLG1FQUFtRSxnQkFBZ0Isc0NBQXNDLGFBQWEseUNBQXlDLGVBQWUsZ0JBQWdCLFlBQVksd0RBQXdELG9CQUFvQixnQkFBZ0IsbUJBQW1CLGdCQUFnQixlQUFlLHFHQUFxRyw2QkFBNkIsZ0JBQWdCLDZCQUE2QixnQkFBZ0IsdUJBQXVCLHFDQUFxQyx3QkFBd0IsZ0JBQWdCLG1CQUFtQixnQkFBZ0IsYUFBYSxnQkFBZ0Isd0JBQXdCLGdCQUFnQixrQkFBa0IseURBQXlELGFBQWEseURBQXlELDBCQUEwQixnQkFBZ0IscUJBQXFCLGdCQUFnQixhQUFhLGdCQUFnQixjQUFjLDRDQUE0QyxjQUFjLHNCQUFzQixjQUFjLDRCQUE0QixpQkFBaUIsZ0JBQWdCLGdCQUFnQiwrQkFBK0IsY0FBYyxnQkFBZ0IsOEJBQThCLHlEQUF5RCxlQUFlLCtEQUErRCxnQkFBZ0IsdURBQXVELGdCQUFnQixnQkFBZ0Isa0JBQWtCLHVFQUF1RSxlQUFlLDJEQUEyRCxlQUFlLGdCQUFnQixpQkFBaUIsZ0JBQWdCLHVCQUF1QixnQkFBZ0Isa0JBQWtCLHNDQUFzQyx3QkFBd0IseUNBQXlDLHdCQUF3Qix5Q0FBeUMsd0JBQXdCLHlDQUF5Qyw4QkFBOEIsZ0JBQWdCLDRCQUE0QixnQkFBZ0IsMEJBQTBCLHFDQUFxQyx1Q0FBdUMsZ0JBQWdCLGlCQUFpQixxQ0FBcUMsMEJBQTBCLHFDQUFxQyxpQkFBaUIsZ0JBQWdCLHNCQUFzQixvQ0FBb0MsaUJBQWlCLGdCQUFnQix1QkFBdUIsc0NBQXNDLHVCQUF1QixzQ0FBc0MseUJBQXlCLGdCQUFnQix1QkFBdUIsZ0JBQWdCLHFCQUFxQixnQkFBZ0IsNkJBQTZCLGdCQUFnQiw2QkFBNkIsZ0JBQWdCLDBDQUEwQyxnQkFBZ0IsdUNBQXVDLGdCQUFnQiw2QkFBNkIsZ0JBQWdCLDZCQUE2QixnQkFBZ0IscUNBQXFDLHFDQUFxQyxnQ0FBZ0MsZ0JBQWdCLG9CQUFvQixnQkFBZ0Isb0JBQW9CLGdCQUFnQixxQkFBcUIscUNBQXFDLDJCQUEyQixzQ0FBc0MsYUFBYSwyREFBMkQsZUFBZSwyQ0FBMkMsYUFBYSxxRUFBcUUscUJBQXFCLHNDQUFzQyxtQkFBbUIsdURBQXVELG1CQUFtQixvQkFBb0IsK0JBQStCLHFCQUFxQix1QkFBdUIsd0NBQXdDLHVCQUF1QixvQkFBb0IsZUFBZSxxQkFBcUIsb0JBQW9CLHlDQUF5QyxlQUFlLHVDQUF1QyxnQkFBZ0Isd0NBQXdDLGVBQWUseUNBQXlDLGtCQUFrQiwyQ0FBMkMsc0JBQXNCLHlDQUF5QyxnQkFBZ0Isc0JBQXNCLGdCQUFnQixzQkFBc0Isa0JBQWtCLHVDQUF1QyxlQUFlLHVDQUF1QyxvQkFBb0IseUNBQXlDLG9CQUFvQixzQ0FBc0MscUJBQXFCLHVDQUF1QyxpQkFBaUIsdUNBQXVDLGFBQWEseURBQXlELG9DQUFvQyxnQkFBZ0IsY0FBYyw0QkFBNEIsbUNBQW1DLGdCQUFnQixlQUFlLDRDQUE0QyxrQkFBa0IsZ0JBQWdCLGdCQUFnQixxQ0FBcUMsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGVBQWUsZ0JBQWdCLGFBQWEsZ0JBQWdCLG1CQUFtQixnQkFBZ0IsZUFBZSxzQ0FBc0MsZUFBZSxzQ0FBc0Msb0JBQW9CLGdCQUFnQixvQkFBb0IsZ0JBQWdCLGVBQWUsc0NBQXNDLG9CQUFvQixnQkFBZ0IsbUJBQW1CLGdCQUFnQixlQUFlLGdCQUFnQixzQkFBc0IsZ0JBQWdCLGVBQWUsc0NBQXNDLG1CQUFtQixnQkFBZ0IsY0FBYyw4Q0FBOEMsY0FBYyw0Q0FBNEMsZUFBZSxnQkFBZ0IsZUFBZSxnQkFBZ0IsZUFBZSxvQ0FBb0MsY0FBYyx3RUFBd0Usa0JBQWtCLGdCQUFnQixlQUFlLG1GQUFtRix3QkFBd0IsZ0JBQWdCLGNBQWMsZ0JBQWdCLGFBQWEsZ0JBQWdCLGNBQWMsMERBQTBELG9CQUFvQixnQkFBZ0Isa0JBQWtCLGdCQUFnQixvQkFBb0IsK0RBQStELG9CQUFvQixnQkFBZ0IsY0FBYyxnQkFBZ0IsMkJBQTJCLGdCQUFnQixzQkFBc0IsZ0JBQWdCLGNBQWMsZ0JBQWdCLG1CQUFtQixnQkFBZ0Isb0JBQW9CLGdCQUFnQixpQkFBaUIsZ0JBQWdCLGNBQWMsZ0JBQWdCLGNBQWMsZ0JBQWdCLG1CQUFtQixnQkFBZ0Isc0JBQXNCLDRDQUE0QywwQkFBMEIsNENBQTRDLHVCQUF1QixnQkFBZ0Isc0JBQXNCLDRDQUE0QyxzQkFBc0IsNENBQTRDLHlCQUF5Qiw0Q0FBNEMsMkJBQTJCLGdCQUFnQiwrQkFBK0IsZ0JBQWdCLDRCQUE0QixnQkFBZ0IsdUJBQXVCLHFDQUFxQyxrQkFBa0IscUNBQXFDLHdCQUF3QixnQkFBZ0IseUNBQXlDLGdCQUFnQix5Q0FBeUMsZ0JBQWdCLHlDQUF5QyxnQkFBZ0IseUNBQXlDLGdCQUFnQiwrQkFBK0IsZ0JBQWdCLGlDQUFpQyxnQkFBZ0IsNkJBQTZCLGdCQUFnQiw4QkFBOEIsZ0JBQWdCLHNCQUFzQiwyQ0FBMkMscUNBQXFDLHFDQUFxQywyQ0FBMkMsZ0JBQWdCLDBCQUEwQixnQkFBZ0IsOEJBQThCLGdCQUFnQiwwQkFBMEIsZ0JBQWdCLGlDQUFpQyxnQkFBZ0Isb0NBQW9DLGdCQUFnQiwyQkFBMkIsZ0JBQWdCLDJCQUEyQixnQkFBZ0IseUJBQXlCLGdCQUFnQix1Q0FBdUMsZ0JBQWdCLHVCQUF1Qiw0Q0FBNEMsbUJBQW1CLHFDQUFxQyxjQUFjLGdCQUFnQixlQUFlLDZEQUE2RCxnQkFBZ0IsdUNBQXVDLGdCQUFnQix1Q0FBdUMsZ0JBQWdCLDREQUE0RCxnQkFBZ0IsdUNBQXVDLHFCQUFxQix5RUFBeUUsZ0JBQWdCLHVDQUF1QyxtQkFBbUIsNkNBQTZDLG1CQUFtQix1Q0FBdUMsa0JBQWtCLHNDQUFzQyxtQkFBbUIsNERBQTRELG1CQUFtQix1Q0FBdUMsbUJBQW1CLHVDQUF1QyxvQkFBb0IsdUNBQXVDLHNCQUFzQix5Q0FBeUMsZ0JBQWdCLHVDQUF1Qyw0QkFBNEIsdUNBQXVDLHdCQUF3QixvQkFBb0Isc0JBQXNCLHFCOzs7Ozs7O0FDQWgwbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFWTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxtQkFBTyxDQUFDLEVBQU87QUFDM0IsWUFBWSxtQkFBTyxDQUFDLENBQU87QUFDM0IsV0FBVyxtQkFBTyxDQUFDLEVBQVM7QUFDNUIsYUFBYSxtQkFBTyxDQUFDLEVBQVM7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVo7QUFDQTtBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxFQUFPO0FBQzNCLGtCQUFrQixtQkFBTyxDQUFDLEVBQWM7QUFDeEMsWUFBWSxtQkFBTyxDQUFDLENBQU87QUFDM0IsV0FBVyxtQkFBTyxDQUFDLEVBQVM7QUFDNUIsYUFBYSxtQkFBTyxDQUFDLEVBQVM7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsRUFBTztBQUMzQixrQkFBa0IsbUJBQU8sQ0FBQyxFQUFjO0FBQ3hDLGtCQUFrQixtQkFBTyxDQUFDLEVBQWE7QUFDdkMsWUFBWSxtQkFBTyxDQUFDLENBQU87QUFDM0IsZ0JBQWdCLG1CQUFPLENBQUMsQ0FBTTtBQUM5QixXQUFXLG1CQUFPLENBQUMsRUFBUztBQUM1QixhQUFhLG1CQUFPLENBQUMsRUFBUzs7QUFFOUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLEVBQUk7QUFDeEI7QUFDQTtBQUNBLFlBQVksbUJBQU8sQ0FBQyxFQUFhO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLDhDQUE4Qyx3QkFBd0I7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM1JhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxFQUFTO0FBQzdCLGNBQWMsbUJBQU8sQ0FBQyxFQUFXOztBQUVqQztBQUNBLHlDQUF5QztBQUN6QztBQUNBLEtBQUs7QUFDTCw0Q0FBNEM7QUFDNUM7QUFDQSxLQUFLO0FBQ0wscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixvQkFBb0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ2pOYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsRUFBUzs7QUFFN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixrQkFBa0I7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQzdLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7Ozs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsbUJBQU8sQ0FBQyxHQUFjO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyxFQUFVO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyxFQUFTO0FBQy9CLGlCQUFpQixtQkFBTyxDQUFDLEdBQW1CO0FBQzVDLFlBQVksbUJBQU8sQ0FBQyxFQUFvQjtBQUN4QyxZQUFZLG1CQUFPLENBQUMsQ0FBTztBQUMzQixXQUFXLG1CQUFPLENBQUMsR0FBUTtBQUMzQixXQUFXLG1CQUFPLENBQUMsQ0FBTTtBQUN6QixrQkFBa0IsbUJBQU8sQ0FBQyxDQUFTO0FBQ25DLHlCQUF5QixtQkFBTyxDQUFDLENBQVM7QUFDMUMsbUJBQW1CLG1CQUFPLENBQUMsQ0FBUztBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyxDQUFNO0FBQzlCLGNBQWMsbUJBQU8sQ0FBQyxFQUFlO0FBQ3JDLFlBQVksbUJBQU8sQ0FBQyxFQUFhO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyxDQUFNO0FBQzVCLHFCQUFxQixtQkFBTyxDQUFDLEVBQWdCO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDM0VBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxD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RUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7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RUEseUNBQXlDLFNBQVMsWUFBWTs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0Isb0JBQW9CO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCOztBQUVsQixpQkFBaUIscUJBQXFCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztB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QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0EsV0FBVyw2QkFBNkI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0EsV0FBVyw2QkFBNkI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLGVBQWU7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixZQUFZLGVBQWU7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLEtBQUs7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzdqQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsRUFBUTs7QUFFN0I7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEU7QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9HO0FBQ0EsMEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDckdBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLG1CQUFPLENBQUMsRUFBVztBQUNqQyxXQUFXLG1CQUFPLENBQUMsQ0FBTTs7QUFFekI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDcEVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLElBQUk7QUFDSiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNqTkEsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7Ozs7Ozs7QUNKQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLG1CQUFPLENBQUMsRUFBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNB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O0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsa0RBQWtEO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDamtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekJhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLEVBQWlCOztBQUUzQyxtQkFBbUIsbUJBQU8sQ0FBQyxHQUF3QjtBQUNuRCxxQkFBcUIsbUJBQU8sQ0FBQyxFQUFnQjtBQUM3QyxtQkFBbUIsbUJBQU8sQ0FBQyxFQUFjOztBQUV6Qzs7Ozs7OztBQ1JBLGtDOzs7Ozs7QUNBQSxnQzs7Ozs7OztBQ0FhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ2xFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUNBQXFDO0FBQ2xELGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7QUNsTUE7QUFDQTtBQUNBOztBQUVB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Syx5QkFBeUI7QUFDOUIscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EsS0FBSyxtREFBbUQ7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzVJQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyxFQUFVOztBQUVuQyxPQUFPLFdBQVc7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOzs7Ozs7O0FDdlFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksTUFBTTtBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDaktBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsRUFBSztBQUN6QixhQUFhLG1CQUFPLENBQUMsQ0FBTTs7QUFFM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsRUFBZ0I7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNERBQTREO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUMsSUFBSTs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSwyQkFBMkI7O0FBRW5DO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRCxzQkFBc0IsV0FBVyxJQUFJLEtBQUs7O0FBRTFDO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsRUFBVTs7QUFFbkMsT0FBTyxXQUFXOztBQUVsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDL1BBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLG1CQUFPLENBQUMsQ0FBUTtBQUM5QixhQUFhLG1CQUFPLENBQUMsRUFBa0I7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLEVBQWE7QUFDbEMsVUFBVSxtQkFBTyxDQUFDLENBQUs7QUFDdkIsWUFBWSxtQkFBTyxDQUFDLEVBQU87O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsU0FBUztBQUNwQixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxpQkFBaUIsMEJBQTBCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOzs7Ozs7OztBQzNqQmE7O0FBRWIsa0JBQWtCLG1CQUFPLENBQUMsRUFBYTs7QUFFdkM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDckNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLG1CQUFPLENBQUMsQ0FBUTs7QUFFOUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsTUFBTTtBQUN0QixlQUFlLE1BQU07QUFDckI7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN0UUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBLDZCIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDgwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBjNDRhMjliNmZmMjAxOTNmOGEzNyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInV0aWxcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ1dGlsXCJcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZXZlbnRzXCJcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicGF0aFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInBhdGhcIlxuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIERldGVjdCBFbGVjdHJvbiByZW5kZXJlciBwcm9jZXNzLCB3aGljaCBpcyBub2RlLCBidXQgd2Ugc2hvdWxkXG4gKiB0cmVhdCBhcyBhIGJyb3dzZXIuXG4gKi9cblxuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Jyb3dzZXIuanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9ub2RlLmpzJyk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaHR0cFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImh0dHBcIlxuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGRlcGRcbiAqIENvcHlyaWdodChjKSAyMDE0LTIwMTcgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgY2FsbFNpdGVUb1N0cmluZyA9IHJlcXVpcmUoJy4vbGliL2NvbXBhdCcpLmNhbGxTaXRlVG9TdHJpbmdcbnZhciBldmVudExpc3RlbmVyQ291bnQgPSByZXF1aXJlKCcuL2xpYi9jb21wYXQnKS5ldmVudExpc3RlbmVyQ291bnRcbnZhciByZWxhdGl2ZSA9IHJlcXVpcmUoJ3BhdGgnKS5yZWxhdGl2ZVxuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwZFxuXG4vKipcbiAqIEdldCB0aGUgcGF0aCB0byBiYXNlIGZpbGVzIG9uLlxuICovXG5cbnZhciBiYXNlUGF0aCA9IHByb2Nlc3MuY3dkKClcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgbmFtZXNwYWNlIGlzIGNvbnRhaW5lZCBpbiB0aGUgc3RyaW5nLlxuICovXG5cbmZ1bmN0aW9uIGNvbnRhaW5zTmFtZXNwYWNlIChzdHIsIG5hbWVzcGFjZSkge1xuICB2YXIgdmFscyA9IHN0ci5zcGxpdCgvWyAsXSsvKVxuICB2YXIgbnMgPSBTdHJpbmcobmFtZXNwYWNlKS50b0xvd2VyQ2FzZSgpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbCA9IHZhbHNbaV1cblxuICAgIC8vIG5hbWVzcGFjZSBjb250YWluZWRcbiAgICBpZiAodmFsICYmICh2YWwgPT09ICcqJyB8fCB2YWwudG9Mb3dlckNhc2UoKSA9PT0gbnMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBkYXRhIGRlc2NyaXB0b3IgdG8gYWNjZXNzb3IgZGVzY3JpcHRvci5cbiAqL1xuXG5mdW5jdGlvbiBjb252ZXJ0RGF0YURlc2NyaXB0b3JUb0FjY2Vzc29yIChvYmosIHByb3AsIG1lc3NhZ2UpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcClcbiAgdmFyIHZhbHVlID0gZGVzY3JpcHRvci52YWx1ZVxuXG4gIGRlc2NyaXB0b3IuZ2V0ID0gZnVuY3Rpb24gZ2V0dGVyICgpIHsgcmV0dXJuIHZhbHVlIH1cblxuICBpZiAoZGVzY3JpcHRvci53cml0YWJsZSkge1xuICAgIGRlc2NyaXB0b3Iuc2V0ID0gZnVuY3Rpb24gc2V0dGVyICh2YWwpIHsgcmV0dXJuICh2YWx1ZSA9IHZhbCkgfVxuICB9XG5cbiAgZGVsZXRlIGRlc2NyaXB0b3IudmFsdWVcbiAgZGVsZXRlIGRlc2NyaXB0b3Iud3JpdGFibGVcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCBkZXNjcmlwdG9yKVxuXG4gIHJldHVybiBkZXNjcmlwdG9yXG59XG5cbi8qKlxuICogQ3JlYXRlIGFyZ3VtZW50cyBzdHJpbmcgdG8ga2VlcCBhcml0eS5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVBcmd1bWVudHNTdHJpbmcgKGFyaXR5KSB7XG4gIHZhciBzdHIgPSAnJ1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJpdHk7IGkrKykge1xuICAgIHN0ciArPSAnLCBhcmcnICsgaVxuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHIoMilcbn1cblxuLyoqXG4gKiBDcmVhdGUgc3RhY2sgc3RyaW5nIGZyb20gc3RhY2suXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlU3RhY2tTdHJpbmcgKHN0YWNrKSB7XG4gIHZhciBzdHIgPSB0aGlzLm5hbWUgKyAnOiAnICsgdGhpcy5uYW1lc3BhY2VcblxuICBpZiAodGhpcy5tZXNzYWdlKSB7XG4gICAgc3RyICs9ICcgZGVwcmVjYXRlZCAnICsgdGhpcy5tZXNzYWdlXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgc3RyICs9ICdcXG4gICAgYXQgJyArIGNhbGxTaXRlVG9TdHJpbmcoc3RhY2tbaV0pXG4gIH1cblxuICByZXR1cm4gc3RyXG59XG5cbi8qKlxuICogQ3JlYXRlIGRlcHJlY2F0ZSBmb3IgbmFtZXNwYWNlIGluIGNhbGxlci5cbiAqL1xuXG5mdW5jdGlvbiBkZXBkIChuYW1lc3BhY2UpIHtcbiAgaWYgKCFuYW1lc3BhY2UpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBuYW1lc3BhY2UgaXMgcmVxdWlyZWQnKVxuICB9XG5cbiAgdmFyIHN0YWNrID0gZ2V0U3RhY2soKVxuICB2YXIgc2l0ZSA9IGNhbGxTaXRlTG9jYXRpb24oc3RhY2tbMV0pXG4gIHZhciBmaWxlID0gc2l0ZVswXVxuXG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZSAobWVzc2FnZSkge1xuICAgIC8vIGNhbGwgdG8gc2VsZiBhcyBsb2dcbiAgICBsb2cuY2FsbChkZXByZWNhdGUsIG1lc3NhZ2UpXG4gIH1cblxuICBkZXByZWNhdGUuX2ZpbGUgPSBmaWxlXG4gIGRlcHJlY2F0ZS5faWdub3JlZCA9IGlzaWdub3JlZChuYW1lc3BhY2UpXG4gIGRlcHJlY2F0ZS5fbmFtZXNwYWNlID0gbmFtZXNwYWNlXG4gIGRlcHJlY2F0ZS5fdHJhY2VkID0gaXN0cmFjZWQobmFtZXNwYWNlKVxuICBkZXByZWNhdGUuX3dhcm5lZCA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBkZXByZWNhdGUuZnVuY3Rpb24gPSB3cmFwZnVuY3Rpb25cbiAgZGVwcmVjYXRlLnByb3BlcnR5ID0gd3JhcHByb3BlcnR5XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZVxufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBuYW1lc3BhY2UgaXMgaWdub3JlZC5cbiAqL1xuXG5mdW5jdGlvbiBpc2lnbm9yZWQgKG5hbWVzcGFjZSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogdGVzdGVkIGluIGEgY2hpbGQgcHJvY2Vzc3MgKi9cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbikge1xuICAgIC8vIC0tbm8tZGVwcmVjYXRpb24gc3VwcG9ydFxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB2YXIgc3RyID0gcHJvY2Vzcy5lbnYuTk9fREVQUkVDQVRJT04gfHwgJydcblxuICAvLyBuYW1lc3BhY2UgaWdub3JlZFxuICByZXR1cm4gY29udGFpbnNOYW1lc3BhY2Uoc3RyLCBuYW1lc3BhY2UpXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIG5hbWVzcGFjZSBpcyB0cmFjZWQuXG4gKi9cblxuZnVuY3Rpb24gaXN0cmFjZWQgKG5hbWVzcGFjZSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogdGVzdGVkIGluIGEgY2hpbGQgcHJvY2Vzc3MgKi9cbiAgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgIC8vIC0tdHJhY2UtZGVwcmVjYXRpb24gc3VwcG9ydFxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB2YXIgc3RyID0gcHJvY2Vzcy5lbnYuVFJBQ0VfREVQUkVDQVRJT04gfHwgJydcblxuICAvLyBuYW1lc3BhY2UgdHJhY2VkXG4gIHJldHVybiBjb250YWluc05hbWVzcGFjZShzdHIsIG5hbWVzcGFjZSlcbn1cblxuLyoqXG4gKiBEaXNwbGF5IGRlcHJlY2F0aW9uIG1lc3NhZ2UuXG4gKi9cblxuZnVuY3Rpb24gbG9nIChtZXNzYWdlLCBzaXRlKSB7XG4gIHZhciBoYXNsaXN0ZW5lcnMgPSBldmVudExpc3RlbmVyQ291bnQocHJvY2VzcywgJ2RlcHJlY2F0aW9uJykgIT09IDBcblxuICAvLyBhYm9ydCBlYXJseSBpZiBubyBkZXN0aW5hdGlvblxuICBpZiAoIWhhc2xpc3RlbmVycyAmJiB0aGlzLl9pZ25vcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2FsbGVyXG4gIHZhciBjYWxsRmlsZVxuICB2YXIgY2FsbFNpdGVcbiAgdmFyIGRlcFNpdGVcbiAgdmFyIGkgPSAwXG4gIHZhciBzZWVuID0gZmFsc2VcbiAgdmFyIHN0YWNrID0gZ2V0U3RhY2soKVxuICB2YXIgZmlsZSA9IHRoaXMuX2ZpbGVcblxuICBpZiAoc2l0ZSkge1xuICAgIC8vIHByb3ZpZGVkIHNpdGVcbiAgICBkZXBTaXRlID0gc2l0ZVxuICAgIGNhbGxTaXRlID0gY2FsbFNpdGVMb2NhdGlvbihzdGFja1sxXSlcbiAgICBjYWxsU2l0ZS5uYW1lID0gZGVwU2l0ZS5uYW1lXG4gICAgZmlsZSA9IGNhbGxTaXRlWzBdXG4gIH0gZWxzZSB7XG4gICAgLy8gZ2V0IGNhbGwgc2l0ZVxuICAgIGkgPSAyXG4gICAgZGVwU2l0ZSA9IGNhbGxTaXRlTG9jYXRpb24oc3RhY2tbaV0pXG4gICAgY2FsbFNpdGUgPSBkZXBTaXRlXG4gIH1cblxuICAvLyBnZXQgY2FsbGVyIG9mIGRlcHJlY2F0ZWQgdGhpbmcgaW4gcmVsYXRpb24gdG8gZmlsZVxuICBmb3IgKDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgY2FsbGVyID0gY2FsbFNpdGVMb2NhdGlvbihzdGFja1tpXSlcbiAgICBjYWxsRmlsZSA9IGNhbGxlclswXVxuXG4gICAgaWYgKGNhbGxGaWxlID09PSBmaWxlKSB7XG4gICAgICBzZWVuID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoY2FsbEZpbGUgPT09IHRoaXMuX2ZpbGUpIHtcbiAgICAgIGZpbGUgPSB0aGlzLl9maWxlXG4gICAgfSBlbHNlIGlmIChzZWVuKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIHZhciBrZXkgPSBjYWxsZXJcbiAgICA/IGRlcFNpdGUuam9pbignOicpICsgJ19fJyArIGNhbGxlci5qb2luKCc6JylcbiAgICA6IHVuZGVmaW5lZFxuXG4gIGlmIChrZXkgIT09IHVuZGVmaW5lZCAmJiBrZXkgaW4gdGhpcy5fd2FybmVkKSB7XG4gICAgLy8gYWxyZWFkeSB3YXJuZWRcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRoaXMuX3dhcm5lZFtrZXldID0gdHJ1ZVxuXG4gIC8vIGdlbmVyYXRlIGF1dG9tYXRpYyBtZXNzYWdlIGZyb20gY2FsbCBzaXRlXG4gIHZhciBtc2cgPSBtZXNzYWdlXG4gIGlmICghbXNnKSB7XG4gICAgbXNnID0gY2FsbFNpdGUgPT09IGRlcFNpdGUgfHwgIWNhbGxTaXRlLm5hbWVcbiAgICAgID8gZGVmYXVsdE1lc3NhZ2UoZGVwU2l0ZSlcbiAgICAgIDogZGVmYXVsdE1lc3NhZ2UoY2FsbFNpdGUpXG4gIH1cblxuICAvLyBlbWl0IGRlcHJlY2F0aW9uIGlmIGxpc3RlbmVycyBleGlzdFxuICBpZiAoaGFzbGlzdGVuZXJzKSB7XG4gICAgdmFyIGVyciA9IERlcHJlY2F0aW9uRXJyb3IodGhpcy5fbmFtZXNwYWNlLCBtc2csIHN0YWNrLnNsaWNlKGkpKVxuICAgIHByb2Nlc3MuZW1pdCgnZGVwcmVjYXRpb24nLCBlcnIpXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBmb3JtYXQgYW5kIHdyaXRlIG1lc3NhZ2VcbiAgdmFyIGZvcm1hdCA9IHByb2Nlc3Muc3RkZXJyLmlzVFRZXG4gICAgPyBmb3JtYXRDb2xvclxuICAgIDogZm9ybWF0UGxhaW5cbiAgdmFyIG91dHB1dCA9IGZvcm1hdC5jYWxsKHRoaXMsIG1zZywgY2FsbGVyLCBzdGFjay5zbGljZShpKSlcbiAgcHJvY2Vzcy5zdGRlcnIud3JpdGUob3V0cHV0ICsgJ1xcbicsICd1dGY4Jylcbn1cblxuLyoqXG4gKiBHZXQgY2FsbCBzaXRlIGxvY2F0aW9uIGFzIGFycmF5LlxuICovXG5cbmZ1bmN0aW9uIGNhbGxTaXRlTG9jYXRpb24gKGNhbGxTaXRlKSB7XG4gIHZhciBmaWxlID0gY2FsbFNpdGUuZ2V0RmlsZU5hbWUoKSB8fCAnPGFub255bW91cz4nXG4gIHZhciBsaW5lID0gY2FsbFNpdGUuZ2V0TGluZU51bWJlcigpXG4gIHZhciBjb2xtID0gY2FsbFNpdGUuZ2V0Q29sdW1uTnVtYmVyKClcblxuICBpZiAoY2FsbFNpdGUuaXNFdmFsKCkpIHtcbiAgICBmaWxlID0gY2FsbFNpdGUuZ2V0RXZhbE9yaWdpbigpICsgJywgJyArIGZpbGVcbiAgfVxuXG4gIHZhciBzaXRlID0gW2ZpbGUsIGxpbmUsIGNvbG1dXG5cbiAgc2l0ZS5jYWxsU2l0ZSA9IGNhbGxTaXRlXG4gIHNpdGUubmFtZSA9IGNhbGxTaXRlLmdldEZ1bmN0aW9uTmFtZSgpXG5cbiAgcmV0dXJuIHNpdGVcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGRlZmF1bHQgbWVzc2FnZSBmcm9tIHRoZSBzaXRlLlxuICovXG5cbmZ1bmN0aW9uIGRlZmF1bHRNZXNzYWdlIChzaXRlKSB7XG4gIHZhciBjYWxsU2l0ZSA9IHNpdGUuY2FsbFNpdGVcbiAgdmFyIGZ1bmNOYW1lID0gc2l0ZS5uYW1lXG5cbiAgLy8gbWFrZSB1c2VmdWwgYW5vbnltb3VzIG5hbWVcbiAgaWYgKCFmdW5jTmFtZSkge1xuICAgIGZ1bmNOYW1lID0gJzxhbm9ueW1vdXNAJyArIGZvcm1hdExvY2F0aW9uKHNpdGUpICsgJz4nXG4gIH1cblxuICB2YXIgY29udGV4dCA9IGNhbGxTaXRlLmdldFRoaXMoKVxuICB2YXIgdHlwZU5hbWUgPSBjb250ZXh0ICYmIGNhbGxTaXRlLmdldFR5cGVOYW1lKClcblxuICAvLyBpZ25vcmUgdXNlbGVzcyB0eXBlIG5hbWVcbiAgaWYgKHR5cGVOYW1lID09PSAnT2JqZWN0Jykge1xuICAgIHR5cGVOYW1lID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBtYWtlIHVzZWZ1bCB0eXBlIG5hbWVcbiAgaWYgKHR5cGVOYW1lID09PSAnRnVuY3Rpb24nKSB7XG4gICAgdHlwZU5hbWUgPSBjb250ZXh0Lm5hbWUgfHwgdHlwZU5hbWVcbiAgfVxuXG4gIHJldHVybiB0eXBlTmFtZSAmJiBjYWxsU2l0ZS5nZXRNZXRob2ROYW1lKClcbiAgICA/IHR5cGVOYW1lICsgJy4nICsgZnVuY05hbWVcbiAgICA6IGZ1bmNOYW1lXG59XG5cbi8qKlxuICogRm9ybWF0IGRlcHJlY2F0aW9uIG1lc3NhZ2Ugd2l0aG91dCBjb2xvci5cbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRQbGFpbiAobXNnLCBjYWxsZXIsIHN0YWNrKSB7XG4gIHZhciB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvVVRDU3RyaW5nKClcblxuICB2YXIgZm9ybWF0dGVkID0gdGltZXN0YW1wICtcbiAgICAnICcgKyB0aGlzLl9uYW1lc3BhY2UgK1xuICAgICcgZGVwcmVjYXRlZCAnICsgbXNnXG5cbiAgLy8gYWRkIHN0YWNrIHRyYWNlXG4gIGlmICh0aGlzLl90cmFjZWQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3JtYXR0ZWQgKz0gJ1xcbiAgICBhdCAnICsgY2FsbFNpdGVUb1N0cmluZyhzdGFja1tpXSlcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ybWF0dGVkXG4gIH1cblxuICBpZiAoY2FsbGVyKSB7XG4gICAgZm9ybWF0dGVkICs9ICcgYXQgJyArIGZvcm1hdExvY2F0aW9uKGNhbGxlcilcbiAgfVxuXG4gIHJldHVybiBmb3JtYXR0ZWRcbn1cblxuLyoqXG4gKiBGb3JtYXQgZGVwcmVjYXRpb24gbWVzc2FnZSB3aXRoIGNvbG9yLlxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdENvbG9yIChtc2csIGNhbGxlciwgc3RhY2spIHtcbiAgdmFyIGZvcm1hdHRlZCA9ICdcXHgxYlszNjsxbScgKyB0aGlzLl9uYW1lc3BhY2UgKyAnXFx4MWJbMjI7MzltJyArIC8vIGJvbGQgY3lhblxuICAgICcgXFx4MWJbMzM7MW1kZXByZWNhdGVkXFx4MWJbMjI7MzltJyArIC8vIGJvbGQgeWVsbG93XG4gICAgJyBcXHgxYlswbScgKyBtc2cgKyAnXFx4MWJbMzltJyAvLyByZXNldFxuXG4gIC8vIGFkZCBzdGFjayB0cmFjZVxuICBpZiAodGhpcy5fdHJhY2VkKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgZm9ybWF0dGVkICs9ICdcXG4gICAgXFx4MWJbMzZtYXQgJyArIGNhbGxTaXRlVG9TdHJpbmcoc3RhY2tbaV0pICsgJ1xceDFiWzM5bScgLy8gY3lhblxuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXR0ZWRcbiAgfVxuXG4gIGlmIChjYWxsZXIpIHtcbiAgICBmb3JtYXR0ZWQgKz0gJyBcXHgxYlszNm0nICsgZm9ybWF0TG9jYXRpb24oY2FsbGVyKSArICdcXHgxYlszOW0nIC8vIGN5YW5cbiAgfVxuXG4gIHJldHVybiBmb3JtYXR0ZWRcbn1cblxuLyoqXG4gKiBGb3JtYXQgY2FsbCBzaXRlIGxvY2F0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdExvY2F0aW9uIChjYWxsU2l0ZSkge1xuICByZXR1cm4gcmVsYXRpdmUoYmFzZVBhdGgsIGNhbGxTaXRlWzBdKSArXG4gICAgJzonICsgY2FsbFNpdGVbMV0gK1xuICAgICc6JyArIGNhbGxTaXRlWzJdXG59XG5cbi8qKlxuICogR2V0IHRoZSBzdGFjayBhcyBhcnJheSBvZiBjYWxsIHNpdGVzLlxuICovXG5cbmZ1bmN0aW9uIGdldFN0YWNrICgpIHtcbiAgdmFyIGxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0XG4gIHZhciBvYmogPSB7fVxuICB2YXIgcHJlcCA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmVwYXJlT2JqZWN0U3RhY2tUcmFjZVxuICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBNYXRoLm1heCgxMCwgbGltaXQpXG5cbiAgLy8gY2FwdHVyZSB0aGUgc3RhY2tcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2Uob2JqKVxuXG4gIC8vIHNsaWNlIHRoaXMgZnVuY3Rpb24gb2ZmIHRoZSB0b3BcbiAgdmFyIHN0YWNrID0gb2JqLnN0YWNrLnNsaWNlKDEpXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmVwXG4gIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0XG5cbiAgcmV0dXJuIHN0YWNrXG59XG5cbi8qKlxuICogQ2FwdHVyZSBjYWxsIHNpdGUgc3RhY2sgZnJvbSB2OC5cbiAqL1xuXG5mdW5jdGlvbiBwcmVwYXJlT2JqZWN0U3RhY2tUcmFjZSAob2JqLCBzdGFjaykge1xuICByZXR1cm4gc3RhY2tcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSB3cmFwcGVkIGZ1bmN0aW9uIGluIGEgZGVwcmVjYXRpb24gbWVzc2FnZS5cbiAqL1xuXG5mdW5jdGlvbiB3cmFwZnVuY3Rpb24gKGZuLCBtZXNzYWdlKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBmbiBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICB9XG5cbiAgdmFyIGFyZ3MgPSBjcmVhdGVBcmd1bWVudHNTdHJpbmcoZm4ubGVuZ3RoKVxuICB2YXIgZGVwcmVjYXRlID0gdGhpcyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBzdGFjayA9IGdldFN0YWNrKClcbiAgdmFyIHNpdGUgPSBjYWxsU2l0ZUxvY2F0aW9uKHN0YWNrWzFdKVxuXG4gIHNpdGUubmFtZSA9IGZuLm5hbWVcblxuICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV2YWxcbiAgdmFyIGRlcHJlY2F0ZWRmbiA9IGV2YWwoJyhmdW5jdGlvbiAoJyArIGFyZ3MgKyAnKSB7XFxuJyArXG4gICAgJ1widXNlIHN0cmljdFwiXFxuJyArXG4gICAgJ2xvZy5jYWxsKGRlcHJlY2F0ZSwgbWVzc2FnZSwgc2l0ZSlcXG4nICtcbiAgICAncmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcXG4nICtcbiAgICAnfSknKVxuXG4gIHJldHVybiBkZXByZWNhdGVkZm5cbn1cblxuLyoqXG4gKiBXcmFwIHByb3BlcnR5IGluIGEgZGVwcmVjYXRpb24gbWVzc2FnZS5cbiAqL1xuXG5mdW5jdGlvbiB3cmFwcHJvcGVydHkgKG9iaiwgcHJvcCwgbWVzc2FnZSkge1xuICBpZiAoIW9iaiB8fCAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iaiAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBvYmogbXVzdCBiZSBvYmplY3QnKVxuICB9XG5cbiAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcClcblxuICBpZiAoIWRlc2NyaXB0b3IpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IGNhbGwgcHJvcGVydHkgb24gb3duZXIgb2JqZWN0JylcbiAgfVxuXG4gIGlmICghZGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcm9wZXJ0eSBtdXN0IGJlIGNvbmZpZ3VyYWJsZScpXG4gIH1cblxuICB2YXIgZGVwcmVjYXRlID0gdGhpc1xuICB2YXIgc3RhY2sgPSBnZXRTdGFjaygpXG4gIHZhciBzaXRlID0gY2FsbFNpdGVMb2NhdGlvbihzdGFja1sxXSlcblxuICAvLyBzZXQgc2l0ZSBuYW1lXG4gIHNpdGUubmFtZSA9IHByb3BcblxuICAvLyBjb252ZXJ0IGRhdGEgZGVzY3JpcHRvclxuICBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSB7XG4gICAgZGVzY3JpcHRvciA9IGNvbnZlcnREYXRhRGVzY3JpcHRvclRvQWNjZXNzb3Iob2JqLCBwcm9wLCBtZXNzYWdlKVxuICB9XG5cbiAgdmFyIGdldCA9IGRlc2NyaXB0b3IuZ2V0XG4gIHZhciBzZXQgPSBkZXNjcmlwdG9yLnNldFxuXG4gIC8vIHdyYXAgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZGVzY3JpcHRvci5nZXQgPSBmdW5jdGlvbiBnZXR0ZXIgKCkge1xuICAgICAgbG9nLmNhbGwoZGVwcmVjYXRlLCBtZXNzYWdlLCBzaXRlKVxuICAgICAgcmV0dXJuIGdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG5cbiAgLy8gd3JhcCBzZXR0ZXJcbiAgaWYgKHR5cGVvZiBzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBkZXNjcmlwdG9yLnNldCA9IGZ1bmN0aW9uIHNldHRlciAoKSB7XG4gICAgICBsb2cuY2FsbChkZXByZWNhdGUsIG1lc3NhZ2UsIHNpdGUpXG4gICAgICByZXR1cm4gc2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCBkZXNjcmlwdG9yKVxufVxuXG4vKipcbiAqIENyZWF0ZSBEZXByZWNhdGlvbkVycm9yIGZvciBkZXByZWNhdGlvblxuICovXG5cbmZ1bmN0aW9uIERlcHJlY2F0aW9uRXJyb3IgKG5hbWVzcGFjZSwgbWVzc2FnZSwgc3RhY2spIHtcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKClcbiAgdmFyIHN0YWNrU3RyaW5nXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVycm9yLCAnY29uc3RydWN0b3InLCB7XG4gICAgdmFsdWU6IERlcHJlY2F0aW9uRXJyb3JcbiAgfSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3IsICdtZXNzYWdlJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogbWVzc2FnZSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvciwgJ25hbWUnLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiAnRGVwcmVjYXRpb25FcnJvcicsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3IsICduYW1lc3BhY2UnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBuYW1lc3BhY2UsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3IsICdzdGFjaycsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc3RhY2tTdHJpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tTdHJpbmdcbiAgICAgIH1cblxuICAgICAgLy8gcHJlcGFyZSBzdGFjayB0cmFjZVxuICAgICAgcmV0dXJuIChzdGFja1N0cmluZyA9IGNyZWF0ZVN0YWNrU3RyaW5nLmNhbGwodGhpcywgc3RhY2spKVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXR0ZXIgKHZhbCkge1xuICAgICAgc3RhY2tTdHJpbmcgPSB2YWxcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIGVycm9yXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kZXBkL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImZzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZnNcIlxuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1cmxcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ1cmxcIlxuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGV4cHJlc3NcbiAqIENvcHlyaWdodChjKSAyMDA5LTIwMTMgVEogSG9sb3dheWNodWtcbiAqIENvcHlyaWdodChjKSAyMDE0LTIwMTUgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgY29udGVudERpc3Bvc2l0aW9uID0gcmVxdWlyZSgnY29udGVudC1kaXNwb3NpdGlvbicpO1xudmFyIGNvbnRlbnRUeXBlID0gcmVxdWlyZSgnY29udGVudC10eXBlJyk7XG52YXIgZGVwcmVjYXRlID0gcmVxdWlyZSgnZGVwZCcpKCdleHByZXNzJyk7XG52YXIgZmxhdHRlbiA9IHJlcXVpcmUoJ2FycmF5LWZsYXR0ZW4nKTtcbnZhciBtaW1lID0gcmVxdWlyZSgnc2VuZCcpLm1pbWU7XG52YXIgZXRhZyA9IHJlcXVpcmUoJ2V0YWcnKTtcbnZhciBwcm94eWFkZHIgPSByZXF1aXJlKCdwcm94eS1hZGRyJyk7XG52YXIgcXMgPSByZXF1aXJlKCdxcycpO1xudmFyIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuLyoqXG4gKiBSZXR1cm4gc3Ryb25nIEVUYWcgZm9yIGBib2R5YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xCdWZmZXJ9IGJvZHlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZW5jb2RpbmddXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmV0YWcgPSBjcmVhdGVFVGFnR2VuZXJhdG9yKHsgd2VhazogZmFsc2UgfSlcblxuLyoqXG4gKiBSZXR1cm4gd2VhayBFVGFnIGZvciBgYm9keWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QnVmZmVyfSBib2R5XG4gKiBAcGFyYW0ge1N0cmluZ30gW2VuY29kaW5nXVxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy53ZXRhZyA9IGNyZWF0ZUVUYWdHZW5lcmF0b3IoeyB3ZWFrOiB0cnVlIH0pXG5cbi8qKlxuICogQ2hlY2sgaWYgYHBhdGhgIGxvb2tzIGFic29sdXRlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCl7XG4gIGlmICgnLycgPT09IHBhdGhbMF0pIHJldHVybiB0cnVlO1xuICBpZiAoJzonID09PSBwYXRoWzFdICYmICgnXFxcXCcgPT09IHBhdGhbMl0gfHwgJy8nID09PSBwYXRoWzJdKSkgcmV0dXJuIHRydWU7IC8vIFdpbmRvd3MgZGV2aWNlIHBhdGhcbiAgaWYgKCdcXFxcXFxcXCcgPT09IHBhdGguc3Vic3RyaW5nKDAsIDIpKSByZXR1cm4gdHJ1ZTsgLy8gTWljcm9zb2Z0IEF6dXJlIGFic29sdXRlIHBhdGhcbn07XG5cbi8qKlxuICogRmxhdHRlbiB0aGUgZ2l2ZW4gYGFycmAuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZmxhdHRlbiA9IGRlcHJlY2F0ZS5mdW5jdGlvbihmbGF0dGVuLFxuICAndXRpbHMuZmxhdHRlbjogdXNlIGFycmF5LWZsYXR0ZW4gbnBtIG1vZHVsZSBpbnN0ZWFkJyk7XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBgdHlwZWAsIGZvciBleGFtcGxlIFwiaHRtbFwiIGJlY29tZXMgXCJ0ZXh0L2h0bWxcIi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5ub3JtYWxpemVUeXBlID0gZnVuY3Rpb24odHlwZSl7XG4gIHJldHVybiB+dHlwZS5pbmRleE9mKCcvJylcbiAgICA/IGFjY2VwdFBhcmFtcyh0eXBlKVxuICAgIDogeyB2YWx1ZTogbWltZS5sb29rdXAodHlwZSksIHBhcmFtczoge30gfTtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGB0eXBlc2AsIGZvciBleGFtcGxlIFwiaHRtbFwiIGJlY29tZXMgXCJ0ZXh0L2h0bWxcIi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB0eXBlc1xuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLm5vcm1hbGl6ZVR5cGVzID0gZnVuY3Rpb24odHlwZXMpe1xuICB2YXIgcmV0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7ICsraSkge1xuICAgIHJldC5wdXNoKGV4cG9ydHMubm9ybWFsaXplVHlwZSh0eXBlc1tpXSkpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgQ29udGVudC1EaXNwb3NpdGlvbiBoZWFkZXIgYXBwcm9wcmlhdGUgZm9yIHRoZSBmaWxlbmFtZS5cbiAqIG5vbi1hc2NpaSBmaWxlbmFtZXMgYXJlIHVybGVuY29kZWQgYW5kIGEgZmlsZW5hbWUqIHBhcmFtZXRlciBpcyBhZGRlZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZVxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5jb250ZW50RGlzcG9zaXRpb24gPSBkZXByZWNhdGUuZnVuY3Rpb24oY29udGVudERpc3Bvc2l0aW9uLFxuICAndXRpbHMuY29udGVudERpc3Bvc2l0aW9uOiB1c2UgY29udGVudC1kaXNwb3NpdGlvbiBucG0gbW9kdWxlIGluc3RlYWQnKTtcblxuLyoqXG4gKiBQYXJzZSBhY2NlcHQgcGFyYW1zIGBzdHJgIHJldHVybmluZyBhblxuICogb2JqZWN0IHdpdGggYC52YWx1ZWAsIGAucXVhbGl0eWAgYW5kIGAucGFyYW1zYC5cbiAqIGFsc28gaW5jbHVkZXMgYC5vcmlnaW5hbEluZGV4YCBmb3Igc3RhYmxlIHNvcnRpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBhY2NlcHRQYXJhbXMoc3RyLCBpbmRleCkge1xuICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoLyAqOyAqLyk7XG4gIHZhciByZXQgPSB7IHZhbHVlOiBwYXJ0c1swXSwgcXVhbGl0eTogMSwgcGFyYW1zOiB7fSwgb3JpZ2luYWxJbmRleDogaW5kZXggfTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBtcyA9IHBhcnRzW2ldLnNwbGl0KC8gKj0gKi8pO1xuICAgIGlmICgncScgPT09IHBtc1swXSkge1xuICAgICAgcmV0LnF1YWxpdHkgPSBwYXJzZUZsb2F0KHBtc1sxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldC5wYXJhbXNbcG1zWzBdXSA9IHBtc1sxXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIENvbXBpbGUgXCJldGFnXCIgdmFsdWUgdG8gZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtICB7Qm9vbGVhbnxTdHJpbmd8RnVuY3Rpb259IHZhbFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmNvbXBpbGVFVGFnID0gZnVuY3Rpb24odmFsKSB7XG4gIHZhciBmbjtcblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBzd2l0Y2ggKHZhbCkge1xuICAgIGNhc2UgdHJ1ZTpcbiAgICAgIGZuID0gZXhwb3J0cy53ZXRhZztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmFsc2U6XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzdHJvbmcnOlxuICAgICAgZm4gPSBleHBvcnRzLmV0YWc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd3ZWFrJzpcbiAgICAgIGZuID0gZXhwb3J0cy53ZXRhZztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmtub3duIHZhbHVlIGZvciBldGFnIGZ1bmN0aW9uOiAnICsgdmFsKTtcbiAgfVxuXG4gIHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBDb21waWxlIFwicXVlcnkgcGFyc2VyXCIgdmFsdWUgdG8gZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfEZ1bmN0aW9ufSB2YWxcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5jb21waWxlUXVlcnlQYXJzZXIgPSBmdW5jdGlvbiBjb21waWxlUXVlcnlQYXJzZXIodmFsKSB7XG4gIHZhciBmbjtcblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBzd2l0Y2ggKHZhbCkge1xuICAgIGNhc2UgdHJ1ZTpcbiAgICAgIGZuID0gcXVlcnlzdHJpbmcucGFyc2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZhbHNlOlxuICAgICAgZm4gPSBuZXdPYmplY3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdleHRlbmRlZCc6XG4gICAgICBmbiA9IHBhcnNlRXh0ZW5kZWRRdWVyeVN0cmluZztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NpbXBsZSc6XG4gICAgICBmbiA9IHF1ZXJ5c3RyaW5nLnBhcnNlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Vua25vd24gdmFsdWUgZm9yIHF1ZXJ5IHBhcnNlciBmdW5jdGlvbjogJyArIHZhbCk7XG4gIH1cblxuICByZXR1cm4gZm47XG59XG5cbi8qKlxuICogQ29tcGlsZSBcInByb3h5IHRydXN0XCIgdmFsdWUgdG8gZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtICB7Qm9vbGVhbnxTdHJpbmd8TnVtYmVyfEFycmF5fEZ1bmN0aW9ufSB2YWxcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5jb21waWxlVHJ1c3QgPSBmdW5jdGlvbih2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHJldHVybiB2YWw7XG5cbiAgaWYgKHZhbCA9PT0gdHJ1ZSkge1xuICAgIC8vIFN1cHBvcnQgcGxhaW4gdHJ1ZS9mYWxzZVxuICAgIHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gdHJ1ZSB9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgLy8gU3VwcG9ydCB0cnVzdGluZyBob3AgY291bnRcbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgaSl7IHJldHVybiBpIDwgdmFsIH07XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBTdXBwb3J0IGNvbW1hLXNlcGFyYXRlZCB2YWx1ZXNcbiAgICB2YWwgPSB2YWwuc3BsaXQoLyAqLCAqLyk7XG4gIH1cblxuICByZXR1cm4gcHJveHlhZGRyLmNvbXBpbGUodmFsIHx8IFtdKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNoYXJzZXQgaW4gYSBnaXZlbiBDb250ZW50LVR5cGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gY2hhcnNldFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5zZXRDaGFyc2V0ID0gZnVuY3Rpb24gc2V0Q2hhcnNldCh0eXBlLCBjaGFyc2V0KSB7XG4gIGlmICghdHlwZSB8fCAhY2hhcnNldCkge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgLy8gcGFyc2UgdHlwZVxuICB2YXIgcGFyc2VkID0gY29udGVudFR5cGUucGFyc2UodHlwZSk7XG5cbiAgLy8gc2V0IGNoYXJzZXRcbiAgcGFyc2VkLnBhcmFtZXRlcnMuY2hhcnNldCA9IGNoYXJzZXQ7XG5cbiAgLy8gZm9ybWF0IHR5cGVcbiAgcmV0dXJuIGNvbnRlbnRUeXBlLmZvcm1hdChwYXJzZWQpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRVRhZyBnZW5lcmF0b3IgZnVuY3Rpb24sIGdlbmVyYXRpbmcgRVRhZ3Mgd2l0aFxuICogdGhlIGdpdmVuIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFVGFnR2VuZXJhdG9yIChvcHRpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZW5lcmF0ZUVUYWcgKGJvZHksIGVuY29kaW5nKSB7XG4gICAgdmFyIGJ1ZiA9ICFCdWZmZXIuaXNCdWZmZXIoYm9keSlcbiAgICAgID8gQnVmZmVyLmZyb20oYm9keSwgZW5jb2RpbmcpXG4gICAgICA6IGJvZHlcblxuICAgIHJldHVybiBldGFnKGJ1Ziwgb3B0aW9ucylcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGFuIGV4dGVuZGVkIHF1ZXJ5IHN0cmluZyB3aXRoIHFzLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VFeHRlbmRlZFF1ZXJ5U3RyaW5nKHN0cikge1xuICByZXR1cm4gcXMucGFyc2Uoc3RyLCB7XG4gICAgYWxsb3dQcm90b3R5cGVzOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFJldHVybiBuZXcgZW1wdHkgb2JqZWN0LlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG5ld09iamVjdCgpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZXhwcmVzcy9saWIvdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG52YXIgc2FmZXIgPSB7fVxuXG52YXIga2V5XG5cbmZvciAoa2V5IGluIGJ1ZmZlcikge1xuICBpZiAoIWJ1ZmZlci5oYXNPd25Qcm9wZXJ0eShrZXkpKSBjb250aW51ZVxuICBpZiAoa2V5ID09PSAnU2xvd0J1ZmZlcicgfHwga2V5ID09PSAnQnVmZmVyJykgY29udGludWVcbiAgc2FmZXJba2V5XSA9IGJ1ZmZlcltrZXldXG59XG5cbnZhciBTYWZlciA9IHNhZmVyLkJ1ZmZlciA9IHt9XG5mb3IgKGtleSBpbiBCdWZmZXIpIHtcbiAgaWYgKCFCdWZmZXIuaGFzT3duUHJvcGVydHkoa2V5KSkgY29udGludWVcbiAgaWYgKGtleSA9PT0gJ2FsbG9jVW5zYWZlJyB8fCBrZXkgPT09ICdhbGxvY1Vuc2FmZVNsb3cnKSBjb250aW51ZVxuICBTYWZlcltrZXldID0gQnVmZmVyW2tleV1cbn1cblxuc2FmZXIuQnVmZmVyLnByb3RvdHlwZSA9IEJ1ZmZlci5wcm90b3R5cGVcblxuaWYgKCFTYWZlci5mcm9tIHx8IFNhZmVyLmZyb20gPT09IFVpbnQ4QXJyYXkuZnJvbSkge1xuICBTYWZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHZhbHVlKVxuICAgIH1cbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgdmFsdWUpXG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxufVxuXG5pZiAoIVNhZmVyLmFsbG9jKSB7XG4gIFNhZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzaXplKVxuICAgIH1cbiAgICBpZiAoc2l6ZSA8IDAgfHwgc2l6ZSA+PSAyICogKDEgPDwgMzApKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgICB9XG4gICAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICAgIGlmICghZmlsbCB8fCBmaWxsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYnVmLmZpbGwoMClcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgICByZXR1cm4gYnVmXG4gIH1cbn1cblxuaWYgKCFzYWZlci5rU3RyaW5nTWF4TGVuZ3RoKSB7XG4gIHRyeSB7XG4gICAgc2FmZXIua1N0cmluZ01heExlbmd0aCA9IHByb2Nlc3MuYmluZGluZygnYnVmZmVyJykua1N0cmluZ01heExlbmd0aFxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gd2UgY2FuJ3QgZGV0ZXJtaW5lIGtTdHJpbmdNYXhMZW5ndGggaW4gZW52aXJvbm1lbnRzIHdoZXJlIHByb2Nlc3MuYmluZGluZ1xuICAgIC8vIGlzIHVuc3VwcG9ydGVkLCBzbyBsZXQncyBub3Qgc2V0IGl0XG4gIH1cbn1cblxuaWYgKCFzYWZlci5jb25zdGFudHMpIHtcbiAgc2FmZXIuY29uc3RhbnRzID0ge1xuICAgIE1BWF9MRU5HVEg6IHNhZmVyLmtNYXhMZW5ndGhcbiAgfVxuICBpZiAoc2FmZXIua1N0cmluZ01heExlbmd0aCkge1xuICAgIHNhZmVyLmNvbnN0YW50cy5NQVhfU1RSSU5HX0xFTkdUSCA9IHNhZmVyLmtTdHJpbmdNYXhMZW5ndGhcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNhZmVyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zYWZlci1idWZmZXIvc2FmZXIuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYnVmZmVyXCJcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInN0cmVhbVwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInN0cmVhbVwiXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJjcnlwdG9cIlxuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBieXRlc1xuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBUSiBIb2xvd2F5Y2h1a1xuICogQ29weXJpZ2h0KGMpIDIwMTUgSmVkIFdhdHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gYnl0ZXM7XG5tb2R1bGUuZXhwb3J0cy5mb3JtYXQgPSBmb3JtYXQ7XG5tb2R1bGUuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBmb3JtYXRUaG91c2FuZHNSZWdFeHAgPSAvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZztcblxudmFyIGZvcm1hdERlY2ltYWxzUmVnRXhwID0gLyg/OlxcLjAqfChcXC5bXjBdKykwKykkLztcblxudmFyIG1hcCA9IHtcbiAgYjogIDEsXG4gIGtiOiAxIDw8IDEwLFxuICBtYjogMSA8PCAyMCxcbiAgZ2I6IDEgPDwgMzAsXG4gIHRiOiAoKDEgPDwgMzApICogMTAyNClcbn07XG5cbnZhciBwYXJzZVJlZ0V4cCA9IC9eKCgtfFxcKyk/KFxcZCsoPzpcXC5cXGQrKT8pKSAqKGtifG1ifGdifHRiKSQvaTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiB2YWx1ZSBpbiBieXRlcyBpbnRvIGEgc3RyaW5nIG9yIHBhcnNlIHRvIHN0cmluZyB0byBhbiBpbnRlZ2VyIGluIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7e1xuICogIGNhc2U6IFtzdHJpbmddLFxuICogIGRlY2ltYWxQbGFjZXM6IFtudW1iZXJdXG4gKiAgZml4ZWREZWNpbWFsczogW2Jvb2xlYW5dXG4gKiAgdGhvdXNhbmRzU2VwYXJhdG9yOiBbc3RyaW5nXVxuICogIHVuaXRTZXBhcmF0b3I6IFtzdHJpbmddXG4gKiAgfX0gW29wdGlvbnNdIGJ5dGVzIG9wdGlvbnMuXG4gKlxuICogQHJldHVybnMge3N0cmluZ3xudW1iZXJ8bnVsbH1cbiAqL1xuXG5mdW5jdGlvbiBieXRlcyh2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZSh2YWx1ZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBmb3JtYXQodmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRm9ybWF0IHRoZSBnaXZlbiB2YWx1ZSBpbiBieXRlcyBpbnRvIGEgc3RyaW5nLlxuICpcbiAqIElmIHRoZSB2YWx1ZSBpcyBuZWdhdGl2ZSwgaXQgaXMga2VwdCBhcyBzdWNoLiBJZiBpdCBpcyBhIGZsb2F0LFxuICogaXQgaXMgcm91bmRlZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5kZWNpbWFsUGxhY2VzPTJdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZml4ZWREZWNpbWFscz1mYWxzZV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50aG91c2FuZHNTZXBhcmF0b3I9XVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnVuaXQ9XVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnVuaXRTZXBhcmF0b3I9XVxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH1cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXQodmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWFnID0gTWF0aC5hYnModmFsdWUpO1xuICB2YXIgdGhvdXNhbmRzU2VwYXJhdG9yID0gKG9wdGlvbnMgJiYgb3B0aW9ucy50aG91c2FuZHNTZXBhcmF0b3IpIHx8ICcnO1xuICB2YXIgdW5pdFNlcGFyYXRvciA9IChvcHRpb25zICYmIG9wdGlvbnMudW5pdFNlcGFyYXRvcikgfHwgJyc7XG4gIHZhciBkZWNpbWFsUGxhY2VzID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWNpbWFsUGxhY2VzICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5kZWNpbWFsUGxhY2VzIDogMjtcbiAgdmFyIGZpeGVkRGVjaW1hbHMgPSBCb29sZWFuKG9wdGlvbnMgJiYgb3B0aW9ucy5maXhlZERlY2ltYWxzKTtcbiAgdmFyIHVuaXQgPSAob3B0aW9ucyAmJiBvcHRpb25zLnVuaXQpIHx8ICcnO1xuXG4gIGlmICghdW5pdCB8fCAhbWFwW3VuaXQudG9Mb3dlckNhc2UoKV0pIHtcbiAgICBpZiAobWFnID49IG1hcC50Yikge1xuICAgICAgdW5pdCA9ICdUQic7XG4gICAgfSBlbHNlIGlmIChtYWcgPj0gbWFwLmdiKSB7XG4gICAgICB1bml0ID0gJ0dCJztcbiAgICB9IGVsc2UgaWYgKG1hZyA+PSBtYXAubWIpIHtcbiAgICAgIHVuaXQgPSAnTUInO1xuICAgIH0gZWxzZSBpZiAobWFnID49IG1hcC5rYikge1xuICAgICAgdW5pdCA9ICdLQic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXQgPSAnQic7XG4gICAgfVxuICB9XG5cbiAgdmFyIHZhbCA9IHZhbHVlIC8gbWFwW3VuaXQudG9Mb3dlckNhc2UoKV07XG4gIHZhciBzdHIgPSB2YWwudG9GaXhlZChkZWNpbWFsUGxhY2VzKTtcblxuICBpZiAoIWZpeGVkRGVjaW1hbHMpIHtcbiAgICBzdHIgPSBzdHIucmVwbGFjZShmb3JtYXREZWNpbWFsc1JlZ0V4cCwgJyQxJyk7XG4gIH1cblxuICBpZiAodGhvdXNhbmRzU2VwYXJhdG9yKSB7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoZm9ybWF0VGhvdXNhbmRzUmVnRXhwLCB0aG91c2FuZHNTZXBhcmF0b3IpO1xuICB9XG5cbiAgcmV0dXJuIHN0ciArIHVuaXRTZXBhcmF0b3IgKyB1bml0O1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBzdHJpbmcgdmFsdWUgaW50byBhbiBpbnRlZ2VyIGluIGJ5dGVzLlxuICpcbiAqIElmIG5vIHVuaXQgaXMgZ2l2ZW4sIGl0IGlzIGFzc3VtZWQgdGhlIHZhbHVlIGlzIGluIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsXG4gKlxuICogQHJldHVybnMge251bWJlcnxudWxsfVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHZhbCkge1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbCkpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBUZXN0IGlmIHRoZSBzdHJpbmcgcGFzc2VkIGlzIHZhbGlkXG4gIHZhciByZXN1bHRzID0gcGFyc2VSZWdFeHAuZXhlYyh2YWwpO1xuICB2YXIgZmxvYXRWYWx1ZTtcbiAgdmFyIHVuaXQgPSAnYic7XG5cbiAgaWYgKCFyZXN1bHRzKSB7XG4gICAgLy8gTm90aGluZyBjb3VsZCBiZSBleHRyYWN0ZWQgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nXG4gICAgZmxvYXRWYWx1ZSA9IHBhcnNlSW50KHZhbCwgMTApO1xuICAgIHVuaXQgPSAnYidcbiAgfSBlbHNlIHtcbiAgICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWUgYW5kIHRoZSB1bml0XG4gICAgZmxvYXRWYWx1ZSA9IHBhcnNlRmxvYXQocmVzdWx0c1sxXSk7XG4gICAgdW5pdCA9IHJlc3VsdHNbNF0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLmZsb29yKG1hcFt1bml0XSAqIGZsb2F0VmFsdWUpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYnl0ZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogaHR0cC1lcnJvcnNcbiAqIENvcHlyaWdodChjKSAyMDE0IEpvbmF0aGFuIE9uZ1xuICogQ29weXJpZ2h0KGMpIDIwMTYgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBkZXByZWNhdGUgPSByZXF1aXJlKCdkZXBkJykoJ2h0dHAtZXJyb3JzJylcbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ3NldHByb3RvdHlwZW9mJylcbnZhciBzdGF0dXNlcyA9IHJlcXVpcmUoJ3N0YXR1c2VzJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUVycm9yXG5tb2R1bGUuZXhwb3J0cy5IdHRwRXJyb3IgPSBjcmVhdGVIdHRwRXJyb3JDb25zdHJ1Y3RvcigpXG5cbi8vIFBvcHVsYXRlIGV4cG9ydHMgZm9yIGFsbCBjb25zdHJ1Y3RvcnNcbnBvcHVsYXRlQ29uc3RydWN0b3JFeHBvcnRzKG1vZHVsZS5leHBvcnRzLCBzdGF0dXNlcy5jb2RlcywgbW9kdWxlLmV4cG9ydHMuSHR0cEVycm9yKVxuXG4vKipcbiAqIEdldCB0aGUgY29kZSBjbGFzcyBvZiBhIHN0YXR1cyBjb2RlLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2RlQ2xhc3MgKHN0YXR1cykge1xuICByZXR1cm4gTnVtYmVyKFN0cmluZyhzdGF0dXMpLmNoYXJBdCgwKSArICcwMCcpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IEhUVFAgRXJyb3IuXG4gKlxuICogQHJldHVybnMge0Vycm9yfVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yICgpIHtcbiAgLy8gc28gbXVjaCBhcml0eSBnb2luZyBvbiB+X35cbiAgdmFyIGVyclxuICB2YXIgbXNnXG4gIHZhciBzdGF0dXMgPSA1MDBcbiAgdmFyIHByb3BzID0ge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldXG4gICAgaWYgKGFyZyBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBlcnIgPSBhcmdcbiAgICAgIHN0YXR1cyA9IGVyci5zdGF0dXMgfHwgZXJyLnN0YXR1c0NvZGUgfHwgc3RhdHVzXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiBhcmcpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIG1zZyA9IGFyZ1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgc3RhdHVzID0gYXJnXG4gICAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgICAgZGVwcmVjYXRlKCdub24tZmlyc3QtYXJndW1lbnQgc3RhdHVzIGNvZGU7IHJlcGxhY2Ugd2l0aCBjcmVhdGVFcnJvcignICsgYXJnICsgJywgLi4uKScpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHByb3BzID0gYXJnXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBzdGF0dXMgPT09ICdudW1iZXInICYmIChzdGF0dXMgPCA0MDAgfHwgc3RhdHVzID49IDYwMCkpIHtcbiAgICBkZXByZWNhdGUoJ25vbi1lcnJvciBzdGF0dXMgY29kZTsgdXNlIG9ubHkgNHh4IG9yIDV4eCBzdGF0dXMgY29kZXMnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBzdGF0dXMgIT09ICdudW1iZXInIHx8XG4gICAgKCFzdGF0dXNlc1tzdGF0dXNdICYmIChzdGF0dXMgPCA0MDAgfHwgc3RhdHVzID49IDYwMCkpKSB7XG4gICAgc3RhdHVzID0gNTAwXG4gIH1cblxuICAvLyBjb25zdHJ1Y3RvclxuICB2YXIgSHR0cEVycm9yID0gY3JlYXRlRXJyb3Jbc3RhdHVzXSB8fCBjcmVhdGVFcnJvcltjb2RlQ2xhc3Moc3RhdHVzKV1cblxuICBpZiAoIWVycikge1xuICAgIC8vIGNyZWF0ZSBlcnJvclxuICAgIGVyciA9IEh0dHBFcnJvclxuICAgICAgPyBuZXcgSHR0cEVycm9yKG1zZylcbiAgICAgIDogbmV3IEVycm9yKG1zZyB8fCBzdGF0dXNlc1tzdGF0dXNdKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgY3JlYXRlRXJyb3IpXG4gIH1cblxuICBpZiAoIUh0dHBFcnJvciB8fCAhKGVyciBpbnN0YW5jZW9mIEh0dHBFcnJvcikgfHwgZXJyLnN0YXR1cyAhPT0gc3RhdHVzKSB7XG4gICAgLy8gYWRkIHByb3BlcnRpZXMgdG8gZ2VuZXJpYyBlcnJvclxuICAgIGVyci5leHBvc2UgPSBzdGF0dXMgPCA1MDBcbiAgICBlcnIuc3RhdHVzID0gZXJyLnN0YXR1c0NvZGUgPSBzdGF0dXNcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIGlmIChrZXkgIT09ICdzdGF0dXMnICYmIGtleSAhPT0gJ3N0YXR1c0NvZGUnKSB7XG4gICAgICBlcnJba2V5XSA9IHByb3BzW2tleV1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXJyXG59XG5cbi8qKlxuICogQ3JlYXRlIEhUVFAgZXJyb3IgYWJzdHJhY3QgYmFzZSBjbGFzcy5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlSHR0cEVycm9yQ29uc3RydWN0b3IgKCkge1xuICBmdW5jdGlvbiBIdHRwRXJyb3IgKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCBjb25zdHJ1Y3QgYWJzdHJhY3QgY2xhc3MnKVxuICB9XG5cbiAgaW5oZXJpdHMoSHR0cEVycm9yLCBFcnJvcilcblxuICByZXR1cm4gSHR0cEVycm9yXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY29uc3RydWN0b3IgZm9yIGEgY2xpZW50IGVycm9yLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVDbGllbnRFcnJvckNvbnN0cnVjdG9yIChIdHRwRXJyb3IsIG5hbWUsIGNvZGUpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IG5hbWUubWF0Y2goL0Vycm9yJC8pID8gbmFtZSA6IG5hbWUgKyAnRXJyb3InXG5cbiAgZnVuY3Rpb24gQ2xpZW50RXJyb3IgKG1lc3NhZ2UpIHtcbiAgICAvLyBjcmVhdGUgdGhlIGVycm9yIG9iamVjdFxuICAgIHZhciBtc2cgPSBtZXNzYWdlICE9IG51bGwgPyBtZXNzYWdlIDogc3RhdHVzZXNbY29kZV1cbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZylcblxuICAgIC8vIGNhcHR1cmUgYSBzdGFjayB0cmFjZSB0byB0aGUgY29uc3RydWN0aW9uIHBvaW50XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBDbGllbnRFcnJvcilcblxuICAgIC8vIGFkanVzdCB0aGUgW1tQcm90b3R5cGVdXVxuICAgIHNldFByb3RvdHlwZU9mKGVyciwgQ2xpZW50RXJyb3IucHJvdG90eXBlKVxuXG4gICAgLy8gcmVkZWZpbmUgdGhlIGVycm9yIG1lc3NhZ2VcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCAnbWVzc2FnZScsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogbXNnLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KVxuXG4gICAgLy8gcmVkZWZpbmUgdGhlIGVycm9yIG5hbWVcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCAnbmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGNsYXNzTmFtZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSlcblxuICAgIHJldHVybiBlcnJcbiAgfVxuXG4gIGluaGVyaXRzKENsaWVudEVycm9yLCBIdHRwRXJyb3IpXG5cbiAgQ2xpZW50RXJyb3IucHJvdG90eXBlLnN0YXR1cyA9IGNvZGVcbiAgQ2xpZW50RXJyb3IucHJvdG90eXBlLnN0YXR1c0NvZGUgPSBjb2RlXG4gIENsaWVudEVycm9yLnByb3RvdHlwZS5leHBvc2UgPSB0cnVlXG5cbiAgcmV0dXJuIENsaWVudEVycm9yXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY29uc3RydWN0b3IgZm9yIGEgc2VydmVyIGVycm9yLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVTZXJ2ZXJFcnJvckNvbnN0cnVjdG9yIChIdHRwRXJyb3IsIG5hbWUsIGNvZGUpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IG5hbWUubWF0Y2goL0Vycm9yJC8pID8gbmFtZSA6IG5hbWUgKyAnRXJyb3InXG5cbiAgZnVuY3Rpb24gU2VydmVyRXJyb3IgKG1lc3NhZ2UpIHtcbiAgICAvLyBjcmVhdGUgdGhlIGVycm9yIG9iamVjdFxuICAgIHZhciBtc2cgPSBtZXNzYWdlICE9IG51bGwgPyBtZXNzYWdlIDogc3RhdHVzZXNbY29kZV1cbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZylcblxuICAgIC8vIGNhcHR1cmUgYSBzdGFjayB0cmFjZSB0byB0aGUgY29uc3RydWN0aW9uIHBvaW50XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBTZXJ2ZXJFcnJvcilcblxuICAgIC8vIGFkanVzdCB0aGUgW1tQcm90b3R5cGVdXVxuICAgIHNldFByb3RvdHlwZU9mKGVyciwgU2VydmVyRXJyb3IucHJvdG90eXBlKVxuXG4gICAgLy8gcmVkZWZpbmUgdGhlIGVycm9yIG1lc3NhZ2VcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCAnbWVzc2FnZScsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogbXNnLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KVxuXG4gICAgLy8gcmVkZWZpbmUgdGhlIGVycm9yIG5hbWVcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCAnbmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGNsYXNzTmFtZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSlcblxuICAgIHJldHVybiBlcnJcbiAgfVxuXG4gIGluaGVyaXRzKFNlcnZlckVycm9yLCBIdHRwRXJyb3IpXG5cbiAgU2VydmVyRXJyb3IucHJvdG90eXBlLnN0YXR1cyA9IGNvZGVcbiAgU2VydmVyRXJyb3IucHJvdG90eXBlLnN0YXR1c0NvZGUgPSBjb2RlXG4gIFNlcnZlckVycm9yLnByb3RvdHlwZS5leHBvc2UgPSBmYWxzZVxuXG4gIHJldHVybiBTZXJ2ZXJFcnJvclxufVxuXG4vKipcbiAqIFBvcHVsYXRlIHRoZSBleHBvcnRzIG9iamVjdCB3aXRoIGNvbnN0cnVjdG9ycyBmb3IgZXZlcnkgZXJyb3IgY2xhc3MuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBvcHVsYXRlQ29uc3RydWN0b3JFeHBvcnRzIChleHBvcnRzLCBjb2RlcywgSHR0cEVycm9yKSB7XG4gIGNvZGVzLmZvckVhY2goZnVuY3Rpb24gZm9yRWFjaENvZGUgKGNvZGUpIHtcbiAgICB2YXIgQ29kZUVycm9yXG4gICAgdmFyIG5hbWUgPSB0b0lkZW50aWZpZXIoc3RhdHVzZXNbY29kZV0pXG5cbiAgICBzd2l0Y2ggKGNvZGVDbGFzcyhjb2RlKSkge1xuICAgICAgY2FzZSA0MDA6XG4gICAgICAgIENvZGVFcnJvciA9IGNyZWF0ZUNsaWVudEVycm9yQ29uc3RydWN0b3IoSHR0cEVycm9yLCBuYW1lLCBjb2RlKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSA1MDA6XG4gICAgICAgIENvZGVFcnJvciA9IGNyZWF0ZVNlcnZlckVycm9yQ29uc3RydWN0b3IoSHR0cEVycm9yLCBuYW1lLCBjb2RlKVxuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIGlmIChDb2RlRXJyb3IpIHtcbiAgICAgIC8vIGV4cG9ydCB0aGUgY29uc3RydWN0b3JcbiAgICAgIGV4cG9ydHNbY29kZV0gPSBDb2RlRXJyb3JcbiAgICAgIGV4cG9ydHNbbmFtZV0gPSBDb2RlRXJyb3JcbiAgICB9XG4gIH0pXG5cbiAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHlcbiAgZXhwb3J0c1tcIkknbWF0ZWFwb3RcIl0gPSBkZXByZWNhdGUuZnVuY3Rpb24oZXhwb3J0cy5JbUFUZWFwb3QsXG4gICAgJ1wiSVxcJ21hdGVhcG90XCI7IHVzZSBcIkltQVRlYXBvdFwiIGluc3RlYWQnKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBzdHJpbmcgb2Ygd29yZHMgdG8gYSBKYXZhU2NyaXB0IGlkZW50aWZpZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHRvSWRlbnRpZmllciAoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgcmV0dXJuIHRva2VuLnNsaWNlKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyB0b2tlbi5zbGljZSgxKVxuICB9KS5qb2luKCcnKS5yZXBsYWNlKC9bXiBfMC05YS16XS9naSwgJycpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9odHRwLWVycm9ycy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiB0eXBlLWlzXG4gKiBDb3B5cmlnaHQoYykgMjAxNCBKb25hdGhhbiBPbmdcbiAqIENvcHlyaWdodChjKSAyMDE0LTIwMTUgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciB0eXBlciA9IHJlcXVpcmUoJ21lZGlhLXR5cGVyJylcbnZhciBtaW1lID0gcmVxdWlyZSgnbWltZS10eXBlcycpXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2ZyZXF1ZXN0XG5tb2R1bGUuZXhwb3J0cy5pcyA9IHR5cGVpc1xubW9kdWxlLmV4cG9ydHMuaGFzQm9keSA9IGhhc2JvZHlcbm1vZHVsZS5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZVxubW9kdWxlLmV4cG9ydHMubWF0Y2ggPSBtaW1lTWF0Y2hcblxuLyoqXG4gKiBDb21wYXJlIGEgYHZhbHVlYCBjb250ZW50LXR5cGUgd2l0aCBgdHlwZXNgLlxuICogRWFjaCBgdHlwZWAgY2FuIGJlIGFuIGV4dGVuc2lvbiBsaWtlIGBodG1sYCxcbiAqIGEgc3BlY2lhbCBzaG9ydGN1dCBsaWtlIGBtdWx0aXBhcnRgIG9yIGB1cmxlbmNvZGVkYCxcbiAqIG9yIGEgbWltZSB0eXBlLlxuICpcbiAqIElmIG5vIHR5cGVzIG1hdGNoLCBgZmFsc2VgIGlzIHJldHVybmVkLlxuICogT3RoZXJ3aXNlLCB0aGUgZmlyc3QgYHR5cGVgIHRoYXQgbWF0Y2hlcyBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7QXJyYXl9IHR5cGVzXG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gdHlwZWlzICh2YWx1ZSwgdHlwZXNfKSB7XG4gIHZhciBpXG4gIHZhciB0eXBlcyA9IHR5cGVzX1xuXG4gIC8vIHJlbW92ZSBwYXJhbWV0ZXJzIGFuZCBub3JtYWxpemVcbiAgdmFyIHZhbCA9IHRyeU5vcm1hbGl6ZVR5cGUodmFsdWUpXG5cbiAgLy8gbm8gdHlwZSBvciBpbnZhbGlkXG4gIGlmICghdmFsKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBzdXBwb3J0IGZsYXR0ZW5lZCBhcmd1bWVudHNcbiAgaWYgKHR5cGVzICYmICFBcnJheS5pc0FycmF5KHR5cGVzKSkge1xuICAgIHR5cGVzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKVxuICAgIGZvciAoaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdHlwZXNbaV0gPSBhcmd1bWVudHNbaSArIDFdXG4gICAgfVxuICB9XG5cbiAgLy8gbm8gdHlwZXMsIHJldHVybiB0aGUgY29udGVudCB0eXBlXG4gIGlmICghdHlwZXMgfHwgIXR5cGVzLmxlbmd0aCkge1xuICAgIHJldHVybiB2YWxcbiAgfVxuXG4gIHZhciB0eXBlXG4gIGZvciAoaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChtaW1lTWF0Y2gobm9ybWFsaXplKHR5cGUgPSB0eXBlc1tpXSksIHZhbCkpIHtcbiAgICAgIHJldHVybiB0eXBlWzBdID09PSAnKycgfHwgdHlwZS5pbmRleE9mKCcqJykgIT09IC0xXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogdHlwZVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vIG1hdGNoZXNcbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSByZXF1ZXN0IGhhcyBhIHJlcXVlc3QgYm9keS5cbiAqIEEgcmVxdWVzdCB3aXRoIGEgYm9keSBfX211c3RfXyBlaXRoZXIgaGF2ZSBgdHJhbnNmZXItZW5jb2RpbmdgXG4gKiBvciBgY29udGVudC1sZW5ndGhgIGhlYWRlcnMgc2V0LlxuICogaHR0cDovL3d3dy53My5vcmcvUHJvdG9jb2xzL3JmYzI2MTYvcmZjMjYxNi1zZWM0Lmh0bWwjc2VjNC4zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gaGFzYm9keSAocmVxKSB7XG4gIHJldHVybiByZXEuaGVhZGVyc1sndHJhbnNmZXItZW5jb2RpbmcnXSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgIWlzTmFOKHJlcS5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBpbmNvbWluZyByZXF1ZXN0IGNvbnRhaW5zIHRoZSBcIkNvbnRlbnQtVHlwZVwiXG4gKiBoZWFkZXIgZmllbGQsIGFuZCBpdCBjb250YWlucyBhbnkgb2YgdGhlIGdpdmUgbWltZSBgdHlwZWBzLlxuICogSWYgdGhlcmUgaXMgbm8gcmVxdWVzdCBib2R5LCBgbnVsbGAgaXMgcmV0dXJuZWQuXG4gKiBJZiB0aGVyZSBpcyBubyBjb250ZW50IHR5cGUsIGBmYWxzZWAgaXMgcmV0dXJuZWQuXG4gKiBPdGhlcndpc2UsIGl0IHJldHVybnMgdGhlIGZpcnN0IGB0eXBlYCB0aGF0IG1hdGNoZXMuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgIC8vIFdpdGggQ29udGVudC1UeXBlOiB0ZXh0L2h0bWw7IGNoYXJzZXQ9dXRmLThcbiAqICAgICB0aGlzLmlzKCdodG1sJyk7IC8vID0+ICdodG1sJ1xuICogICAgIHRoaXMuaXMoJ3RleHQvaHRtbCcpOyAvLyA9PiAndGV4dC9odG1sJ1xuICogICAgIHRoaXMuaXMoJ3RleHQvKicsICdhcHBsaWNhdGlvbi9qc29uJyk7IC8vID0+ICd0ZXh0L2h0bWwnXG4gKlxuICogICAgIC8vIFdoZW4gQ29udGVudC1UeXBlIGlzIGFwcGxpY2F0aW9uL2pzb25cbiAqICAgICB0aGlzLmlzKCdqc29uJywgJ3VybGVuY29kZWQnKTsgLy8gPT4gJ2pzb24nXG4gKiAgICAgdGhpcy5pcygnYXBwbGljYXRpb24vanNvbicpOyAvLyA9PiAnYXBwbGljYXRpb24vanNvbidcbiAqICAgICB0aGlzLmlzKCdodG1sJywgJ2FwcGxpY2F0aW9uLyonKTsgLy8gPT4gJ2FwcGxpY2F0aW9uL2pzb24nXG4gKlxuICogICAgIHRoaXMuaXMoJ2h0bWwnKTsgLy8gPT4gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gdHlwZXMuLi5cbiAqIEByZXR1cm4ge1N0cmluZ3xmYWxzZXxudWxsfVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHR5cGVvZnJlcXVlc3QgKHJlcSwgdHlwZXNfKSB7XG4gIHZhciB0eXBlcyA9IHR5cGVzX1xuXG4gIC8vIG5vIGJvZHlcbiAgaWYgKCFoYXNib2R5KHJlcSkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gc3VwcG9ydCBmbGF0dGVuZWQgYXJndW1lbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgIHR5cGVzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHR5cGVzW2ldID0gYXJndW1lbnRzW2kgKyAxXVxuICAgIH1cbiAgfVxuXG4gIC8vIHJlcXVlc3QgY29udGVudCB0eXBlXG4gIHZhciB2YWx1ZSA9IHJlcS5oZWFkZXJzWydjb250ZW50LXR5cGUnXVxuXG4gIHJldHVybiB0eXBlaXModmFsdWUsIHR5cGVzKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIG1pbWUgdHlwZS5cbiAqIElmIGl0J3MgYSBzaG9ydGhhbmQsIGV4cGFuZCBpdCB0byBhIHZhbGlkIG1pbWUgdHlwZS5cbiAqXG4gKiBJbiBnZW5lcmFsLCB5b3UgcHJvYmFibHkgd2FudDpcbiAqXG4gKiAgIHZhciB0eXBlID0gaXMocmVxLCBbJ3VybGVuY29kZWQnLCAnanNvbicsICdtdWx0aXBhcnQnXSk7XG4gKlxuICogVGhlbiB1c2UgdGhlIGFwcHJvcHJpYXRlIGJvZHkgcGFyc2Vycy5cbiAqIFRoZXNlIHRocmVlIGFyZSB0aGUgbW9zdCBjb21tb24gcmVxdWVzdCBib2R5IHR5cGVzXG4gKiBhbmQgYXJlIHRodXMgZW5zdXJlZCB0byB3b3JrLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSAodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gaW52YWxpZCB0eXBlXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd1cmxlbmNvZGVkJzpcbiAgICAgIHJldHVybiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xuICAgIGNhc2UgJ211bHRpcGFydCc6XG4gICAgICByZXR1cm4gJ211bHRpcGFydC8qJ1xuICB9XG5cbiAgaWYgKHR5cGVbMF0gPT09ICcrJykge1xuICAgIC8vIFwiK2pzb25cIiAtPiBcIiovKitqc29uXCIgZXhwYW5kb1xuICAgIHJldHVybiAnKi8qJyArIHR5cGVcbiAgfVxuXG4gIHJldHVybiB0eXBlLmluZGV4T2YoJy8nKSA9PT0gLTFcbiAgICA/IG1pbWUubG9va3VwKHR5cGUpXG4gICAgOiB0eXBlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYGV4cGVjdGVkYCBtaW1lIHR5cGVcbiAqIG1hdGNoZXMgYGFjdHVhbGAgbWltZSB0eXBlIHdpdGhcbiAqIHdpbGRjYXJkIGFuZCArc3VmZml4IHN1cHBvcnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cGVjdGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0dWFsXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaW1lTWF0Y2ggKGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgLy8gaW52YWxpZCB0eXBlXG4gIGlmIChleHBlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIHNwbGl0IHR5cGVzXG4gIHZhciBhY3R1YWxQYXJ0cyA9IGFjdHVhbC5zcGxpdCgnLycpXG4gIHZhciBleHBlY3RlZFBhcnRzID0gZXhwZWN0ZWQuc3BsaXQoJy8nKVxuXG4gIC8vIGludmFsaWQgZm9ybWF0XG4gIGlmIChhY3R1YWxQYXJ0cy5sZW5ndGggIT09IDIgfHwgZXhwZWN0ZWRQYXJ0cy5sZW5ndGggIT09IDIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIHZhbGlkYXRlIHR5cGVcbiAgaWYgKGV4cGVjdGVkUGFydHNbMF0gIT09ICcqJyAmJiBleHBlY3RlZFBhcnRzWzBdICE9PSBhY3R1YWxQYXJ0c1swXSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gdmFsaWRhdGUgc3VmZml4IHdpbGRjYXJkXG4gIGlmIChleHBlY3RlZFBhcnRzWzFdLnN1YnN0cigwLCAyKSA9PT0gJyorJykge1xuICAgIHJldHVybiBleHBlY3RlZFBhcnRzWzFdLmxlbmd0aCA8PSBhY3R1YWxQYXJ0c1sxXS5sZW5ndGggKyAxICYmXG4gICAgICBleHBlY3RlZFBhcnRzWzFdLnN1YnN0cigxKSA9PT0gYWN0dWFsUGFydHNbMV0uc3Vic3RyKDEgLSBleHBlY3RlZFBhcnRzWzFdLmxlbmd0aClcbiAgfVxuXG4gIC8vIHZhbGlkYXRlIHN1YnR5cGVcbiAgaWYgKGV4cGVjdGVkUGFydHNbMV0gIT09ICcqJyAmJiBleHBlY3RlZFBhcnRzWzFdICE9PSBhY3R1YWxQYXJ0c1sxXSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0eXBlIGFuZCByZW1vdmUgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplVHlwZSAodmFsdWUpIHtcbiAgLy8gcGFyc2UgdGhlIHR5cGVcbiAgdmFyIHR5cGUgPSB0eXBlci5wYXJzZSh2YWx1ZSlcblxuICAvLyByZW1vdmUgdGhlIHBhcmFtZXRlcnNcbiAgdHlwZS5wYXJhbWV0ZXJzID0gdW5kZWZpbmVkXG5cbiAgLy8gcmVmb3JtYXQgaXRcbiAgcmV0dXJuIHR5cGVyLmZvcm1hdCh0eXBlKVxufVxuXG4vKipcbiAqIFRyeSB0byBub3JtYWxpemUgYSB0eXBlIGFuZCByZW1vdmUgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gdHJ5Tm9ybWFsaXplVHlwZSAodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBub3JtYWxpemVUeXBlKHZhbHVlKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy90eXBlLWlzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIHBhcnNldXJsXG4gKiBDb3B5cmlnaHQoYykgMjAxNCBKb25hdGhhbiBPbmdcbiAqIENvcHlyaWdodChjKSAyMDE0LTIwMTcgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKVxudmFyIHBhcnNlID0gdXJsLnBhcnNlXG52YXIgVXJsID0gdXJsLlVybFxuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2V1cmxcbm1vZHVsZS5leHBvcnRzLm9yaWdpbmFsID0gb3JpZ2luYWx1cmxcblxuLyoqXG4gKiBQYXJzZSB0aGUgYHJlcWAgdXJsIHdpdGggbWVtb2l6YXRpb24uXG4gKlxuICogQHBhcmFtIHtTZXJ2ZXJSZXF1ZXN0fSByZXFcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZXVybCAocmVxKSB7XG4gIHZhciB1cmwgPSByZXEudXJsXG5cbiAgaWYgKHVybCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gVVJMIGlzIHVuZGVmaW5lZFxuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHZhciBwYXJzZWQgPSByZXEuX3BhcnNlZFVybFxuXG4gIGlmIChmcmVzaCh1cmwsIHBhcnNlZCkpIHtcbiAgICAvLyBSZXR1cm4gY2FjaGVkIFVSTCBwYXJzZVxuICAgIHJldHVybiBwYXJzZWRcbiAgfVxuXG4gIC8vIFBhcnNlIHRoZSBVUkxcbiAgcGFyc2VkID0gZmFzdHBhcnNlKHVybClcbiAgcGFyc2VkLl9yYXcgPSB1cmxcblxuICByZXR1cm4gKHJlcS5fcGFyc2VkVXJsID0gcGFyc2VkKVxufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgYHJlcWAgb3JpZ2luYWwgdXJsIHdpdGggZmFsbGJhY2sgYW5kIG1lbW9pemF0aW9uLlxuICpcbiAqIEBwYXJhbSB7U2VydmVyUmVxdWVzdH0gcmVxXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gb3JpZ2luYWx1cmwgKHJlcSkge1xuICB2YXIgdXJsID0gcmVxLm9yaWdpbmFsVXJsXG5cbiAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gRmFsbGJhY2tcbiAgICByZXR1cm4gcGFyc2V1cmwocmVxKVxuICB9XG5cbiAgdmFyIHBhcnNlZCA9IHJlcS5fcGFyc2VkT3JpZ2luYWxVcmxcblxuICBpZiAoZnJlc2godXJsLCBwYXJzZWQpKSB7XG4gICAgLy8gUmV0dXJuIGNhY2hlZCBVUkwgcGFyc2VcbiAgICByZXR1cm4gcGFyc2VkXG4gIH1cblxuICAvLyBQYXJzZSB0aGUgVVJMXG4gIHBhcnNlZCA9IGZhc3RwYXJzZSh1cmwpXG4gIHBhcnNlZC5fcmF3ID0gdXJsXG5cbiAgcmV0dXJuIChyZXEuX3BhcnNlZE9yaWdpbmFsVXJsID0gcGFyc2VkKVxufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgYHN0cmAgdXJsIHdpdGggZmFzdC1wYXRoIHNob3J0LWN1dC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZhc3RwYXJzZSAoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJyB8fCBzdHIuY2hhckNvZGVBdCgwKSAhPT0gMHgyZiAvKiAvICovKSB7XG4gICAgcmV0dXJuIHBhcnNlKHN0cilcbiAgfVxuXG4gIHZhciBwYXRobmFtZSA9IHN0clxuICB2YXIgcXVlcnkgPSBudWxsXG4gIHZhciBzZWFyY2ggPSBudWxsXG5cbiAgLy8gVGhpcyB0YWtlcyB0aGUgcmVnZXhwIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL3B1bGwvNzg3OFxuICAvLyBXaGljaCBpcyAvXihcXC9bXj8jXFxzXSopKFxcP1teI1xcc10qKT8kL1xuICAvLyBBbmQgdW5yb2xscyBpdCBpbnRvIGEgZm9yIGxvb3BcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGkpKSB7XG4gICAgICBjYXNlIDB4M2Y6IC8qID8gICovXG4gICAgICAgIGlmIChzZWFyY2ggPT09IG51bGwpIHtcbiAgICAgICAgICBwYXRobmFtZSA9IHN0ci5zdWJzdHJpbmcoMCwgaSlcbiAgICAgICAgICBxdWVyeSA9IHN0ci5zdWJzdHJpbmcoaSArIDEpXG4gICAgICAgICAgc2VhcmNoID0gc3RyLnN1YnN0cmluZyhpKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDB4MDk6IC8qIFxcdCAqL1xuICAgICAgY2FzZSAweDBhOiAvKiBcXG4gKi9cbiAgICAgIGNhc2UgMHgwYzogLyogXFxmICovXG4gICAgICBjYXNlIDB4MGQ6IC8qIFxcciAqL1xuICAgICAgY2FzZSAweDIwOiAvKiAgICAqL1xuICAgICAgY2FzZSAweDIzOiAvKiAjICAqL1xuICAgICAgY2FzZSAweGEwOlxuICAgICAgY2FzZSAweGZlZmY6XG4gICAgICAgIHJldHVybiBwYXJzZShzdHIpXG4gICAgfVxuICB9XG5cbiAgdmFyIHVybCA9IFVybCAhPT0gdW5kZWZpbmVkXG4gICAgPyBuZXcgVXJsKClcbiAgICA6IHt9XG5cbiAgdXJsLnBhdGggPSBzdHJcbiAgdXJsLmhyZWYgPSBzdHJcbiAgdXJsLnBhdGhuYW1lID0gcGF0aG5hbWVcblxuICBpZiAoc2VhcmNoICE9PSBudWxsKSB7XG4gICAgdXJsLnF1ZXJ5ID0gcXVlcnlcbiAgICB1cmwuc2VhcmNoID0gc2VhcmNoXG4gIH1cblxuICByZXR1cm4gdXJsXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHBhcnNlZCBpcyBzdGlsbCBmcmVzaCBmb3IgdXJsLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJzZWRVcmxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZyZXNoICh1cmwsIHBhcnNlZFVybCkge1xuICByZXR1cm4gdHlwZW9mIHBhcnNlZFVybCA9PT0gJ29iamVjdCcgJiZcbiAgICBwYXJzZWRVcmwgIT09IG51bGwgJiZcbiAgICAoVXJsID09PSB1bmRlZmluZWQgfHwgcGFyc2VkVXJsIGluc3RhbmNlb2YgVXJsKSAmJlxuICAgIHBhcnNlZFVybC5fcmF3ID09PSB1cmxcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3BhcnNldXJsL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIERldGVjdCBFbGVjdHJvbiByZW5kZXJlciBwcm9jZXNzLCB3aGljaCBpcyBub2RlLCBidXQgd2Ugc2hvdWxkXG4gKiB0cmVhdCBhcyBhIGJyb3dzZXIuXG4gKi9cblxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCBwcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Jyb3dzZXIuanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9ub2RlLmpzJyk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQklOQVJZX1RZUEVTOiBbJ25vZGVidWZmZXInLCAnYXJyYXlidWZmZXInLCAnZnJhZ21lbnRzJ10sXG4gIEdVSUQ6ICcyNThFQUZBNS1FOTE0LTQ3REEtOTVDQS1DNUFCMERDODVCMTEnLFxuICBrU3RhdHVzQ29kZTogU3ltYm9sKCdzdGF0dXMtY29kZScpLFxuICBrV2ViU29ja2V0OiBTeW1ib2woJ3dlYnNvY2tldCcpLFxuICBFTVBUWV9CVUZGRVI6IEJ1ZmZlci5hbGxvYygwKSxcbiAgTk9PUDogKCkgPT4ge31cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy93cy9saWIvY29uc3RhbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGNvbnRlbnQtdHlwZVxuICogQ29weXJpZ2h0KGMpIDIwMTUgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIFJlZ0V4cCB0byBtYXRjaCAqKCBcIjtcIiBwYXJhbWV0ZXIgKSBpbiBSRkMgNzIzMSBzZWMgMy4xLjEuMVxuICpcbiAqIHBhcmFtZXRlciAgICAgPSB0b2tlbiBcIj1cIiAoIHRva2VuIC8gcXVvdGVkLXN0cmluZyApXG4gKiB0b2tlbiAgICAgICAgID0gMSp0Y2hhclxuICogdGNoYXIgICAgICAgICA9IFwiIVwiIC8gXCIjXCIgLyBcIiRcIiAvIFwiJVwiIC8gXCImXCIgLyBcIidcIiAvIFwiKlwiXG4gKiAgICAgICAgICAgICAgIC8gXCIrXCIgLyBcIi1cIiAvIFwiLlwiIC8gXCJeXCIgLyBcIl9cIiAvIFwiYFwiIC8gXCJ8XCIgLyBcIn5cIlxuICogICAgICAgICAgICAgICAvIERJR0lUIC8gQUxQSEFcbiAqICAgICAgICAgICAgICAgOyBhbnkgVkNIQVIsIGV4Y2VwdCBkZWxpbWl0ZXJzXG4gKiBxdW90ZWQtc3RyaW5nID0gRFFVT1RFICooIHFkdGV4dCAvIHF1b3RlZC1wYWlyICkgRFFVT1RFXG4gKiBxZHRleHQgICAgICAgID0gSFRBQiAvIFNQIC8gJXgyMSAvICV4MjMtNUIgLyAleDVELTdFIC8gb2JzLXRleHRcbiAqIG9icy10ZXh0ICAgICAgPSAleDgwLUZGXG4gKiBxdW90ZWQtcGFpciAgID0gXCJcXFwiICggSFRBQiAvIFNQIC8gVkNIQVIgLyBvYnMtdGV4dCApXG4gKi9cbnZhciBQQVJBTV9SRUdFWFAgPSAvOyAqKFshIyQlJicqKy5eX2B8fjAtOUEtWmEtei1dKykgKj0gKihcIig/OltcXHUwMDBiXFx1MDAyMFxcdTAwMjFcXHUwMDIzLVxcdTAwNWJcXHUwMDVkLVxcdTAwN2VcXHUwMDgwLVxcdTAwZmZdfFxcXFxbXFx1MDAwYlxcdTAwMjAtXFx1MDBmZl0pKlwifFshIyQlJicqKy5eX2B8fjAtOUEtWmEtei1dKykgKi9nXG52YXIgVEVYVF9SRUdFWFAgPSAvXltcXHUwMDBiXFx1MDAyMC1cXHUwMDdlXFx1MDA4MC1cXHUwMGZmXSskL1xudmFyIFRPS0VOX1JFR0VYUCA9IC9eWyEjJCUmJyorLl5fYHx+MC05QS1aYS16LV0rJC9cblxuLyoqXG4gKiBSZWdFeHAgdG8gbWF0Y2ggcXVvdGVkLXBhaXIgaW4gUkZDIDcyMzAgc2VjIDMuMi42XG4gKlxuICogcXVvdGVkLXBhaXIgPSBcIlxcXCIgKCBIVEFCIC8gU1AgLyBWQ0hBUiAvIG9icy10ZXh0IClcbiAqIG9icy10ZXh0ICAgID0gJXg4MC1GRlxuICovXG52YXIgUUVTQ19SRUdFWFAgPSAvXFxcXChbXFx1MDAwYlxcdTAwMjAtXFx1MDBmZl0pL2dcblxuLyoqXG4gKiBSZWdFeHAgdG8gbWF0Y2ggY2hhcnMgdGhhdCBtdXN0IGJlIHF1b3RlZC1wYWlyIGluIFJGQyA3MjMwIHNlYyAzLjIuNlxuICovXG52YXIgUVVPVEVfUkVHRVhQID0gLyhbXFxcXFwiXSkvZ1xuXG4vKipcbiAqIFJlZ0V4cCB0byBtYXRjaCB0eXBlIGluIFJGQyA3MjMxIHNlYyAzLjEuMS4xXG4gKlxuICogbWVkaWEtdHlwZSA9IHR5cGUgXCIvXCIgc3VidHlwZVxuICogdHlwZSAgICAgICA9IHRva2VuXG4gKiBzdWJ0eXBlICAgID0gdG9rZW5cbiAqL1xudmFyIFRZUEVfUkVHRVhQID0gL15bISMkJSYnKisuXl9gfH4wLTlBLVphLXotXStcXC9bISMkJSYnKisuXl9gfH4wLTlBLVphLXotXSskL1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZm9ybWF0ID0gZm9ybWF0XG5leHBvcnRzLnBhcnNlID0gcGFyc2VcblxuLyoqXG4gKiBGb3JtYXQgb2JqZWN0IHRvIG1lZGlhIHR5cGUuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9ialxuICogQHJldHVybiB7c3RyaW5nfVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdCAob2JqKSB7XG4gIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgb2JqIGlzIHJlcXVpcmVkJylcbiAgfVxuXG4gIHZhciBwYXJhbWV0ZXJzID0gb2JqLnBhcmFtZXRlcnNcbiAgdmFyIHR5cGUgPSBvYmoudHlwZVxuXG4gIGlmICghdHlwZSB8fCAhVFlQRV9SRUdFWFAudGVzdCh0eXBlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgdHlwZScpXG4gIH1cblxuICB2YXIgc3RyaW5nID0gdHlwZVxuXG4gIC8vIGFwcGVuZCBwYXJhbWV0ZXJzXG4gIGlmIChwYXJhbWV0ZXJzICYmIHR5cGVvZiBwYXJhbWV0ZXJzID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBwYXJhbVxuICAgIHZhciBwYXJhbXMgPSBPYmplY3Qua2V5cyhwYXJhbWV0ZXJzKS5zb3J0KClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXJhbSA9IHBhcmFtc1tpXVxuXG4gICAgICBpZiAoIVRPS0VOX1JFR0VYUC50ZXN0KHBhcmFtKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhcmFtZXRlciBuYW1lJylcbiAgICAgIH1cblxuICAgICAgc3RyaW5nICs9ICc7ICcgKyBwYXJhbSArICc9JyArIHFzdHJpbmcocGFyYW1ldGVyc1twYXJhbV0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZ1xufVxuXG4vKipcbiAqIFBhcnNlIG1lZGlhIHR5cGUgdG8gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gc3RyaW5nXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gcGFyc2UgKHN0cmluZykge1xuICBpZiAoIXN0cmluZykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHN0cmluZyBpcyByZXF1aXJlZCcpXG4gIH1cblxuICAvLyBzdXBwb3J0IHJlcS9yZXMtbGlrZSBvYmplY3RzIGFzIGFyZ3VtZW50XG4gIHZhciBoZWFkZXIgPSB0eXBlb2Ygc3RyaW5nID09PSAnb2JqZWN0J1xuICAgID8gZ2V0Y29udGVudHR5cGUoc3RyaW5nKVxuICAgIDogc3RyaW5nXG5cbiAgaWYgKHR5cGVvZiBoZWFkZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc3RyaW5nIGlzIHJlcXVpcmVkIHRvIGJlIGEgc3RyaW5nJylcbiAgfVxuXG4gIHZhciBpbmRleCA9IGhlYWRlci5pbmRleE9mKCc7JylcbiAgdmFyIHR5cGUgPSBpbmRleCAhPT0gLTFcbiAgICA/IGhlYWRlci5zdWJzdHIoMCwgaW5kZXgpLnRyaW0oKVxuICAgIDogaGVhZGVyLnRyaW0oKVxuXG4gIGlmICghVFlQRV9SRUdFWFAudGVzdCh0eXBlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgbWVkaWEgdHlwZScpXG4gIH1cblxuICB2YXIgb2JqID0gbmV3IENvbnRlbnRUeXBlKHR5cGUudG9Mb3dlckNhc2UoKSlcblxuICAvLyBwYXJzZSBwYXJhbWV0ZXJzXG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICB2YXIga2V5XG4gICAgdmFyIG1hdGNoXG4gICAgdmFyIHZhbHVlXG5cbiAgICBQQVJBTV9SRUdFWFAubGFzdEluZGV4ID0gaW5kZXhcblxuICAgIHdoaWxlICgobWF0Y2ggPSBQQVJBTV9SRUdFWFAuZXhlYyhoZWFkZXIpKSkge1xuICAgICAgaWYgKG1hdGNoLmluZGV4ICE9PSBpbmRleCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhcmFtZXRlciBmb3JtYXQnKVxuICAgICAgfVxuXG4gICAgICBpbmRleCArPSBtYXRjaFswXS5sZW5ndGhcbiAgICAgIGtleSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKClcbiAgICAgIHZhbHVlID0gbWF0Y2hbMl1cblxuICAgICAgaWYgKHZhbHVlWzBdID09PSAnXCInKSB7XG4gICAgICAgIC8vIHJlbW92ZSBxdW90ZXMgYW5kIGVzY2FwZXNcbiAgICAgICAgdmFsdWUgPSB2YWx1ZVxuICAgICAgICAgIC5zdWJzdHIoMSwgdmFsdWUubGVuZ3RoIC0gMilcbiAgICAgICAgICAucmVwbGFjZShRRVNDX1JFR0VYUCwgJyQxJylcbiAgICAgIH1cblxuICAgICAgb2JqLnBhcmFtZXRlcnNba2V5XSA9IHZhbHVlXG4gICAgfVxuXG4gICAgaWYgKGluZGV4ICE9PSBoZWFkZXIubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhcmFtZXRlciBmb3JtYXQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmpcbn1cblxuLyoqXG4gKiBHZXQgY29udGVudC10eXBlIGZyb20gcmVxL3JlcyBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fVxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRjb250ZW50dHlwZSAob2JqKSB7XG4gIHZhciBoZWFkZXJcblxuICBpZiAodHlwZW9mIG9iai5nZXRIZWFkZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyByZXMtbGlrZVxuICAgIGhlYWRlciA9IG9iai5nZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScpXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iai5oZWFkZXJzID09PSAnb2JqZWN0Jykge1xuICAgIC8vIHJlcS1saWtlXG4gICAgaGVhZGVyID0gb2JqLmhlYWRlcnMgJiYgb2JqLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddXG4gIH1cblxuICBpZiAodHlwZW9mIGhlYWRlciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjb250ZW50LXR5cGUgaGVhZGVyIGlzIG1pc3NpbmcgZnJvbSBvYmplY3QnKVxuICB9XG5cbiAgcmV0dXJuIGhlYWRlclxufVxuXG4vKipcbiAqIFF1b3RlIGEgc3RyaW5nIGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHFzdHJpbmcgKHZhbCkge1xuICB2YXIgc3RyID0gU3RyaW5nKHZhbClcblxuICAvLyBubyBuZWVkIHRvIHF1b3RlIHRva2Vuc1xuICBpZiAoVE9LRU5fUkVHRVhQLnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBzdHJcbiAgfVxuXG4gIGlmIChzdHIubGVuZ3RoID4gMCAmJiAhVEVYVF9SRUdFWFAudGVzdChzdHIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXJhbWV0ZXIgdmFsdWUnKVxuICB9XG5cbiAgcmV0dXJuICdcIicgKyBzdHIucmVwbGFjZShRVU9URV9SRUdFWFAsICdcXFxcJDEnKSArICdcIidcbn1cblxuLyoqXG4gKiBDbGFzcyB0byByZXByZXNlbnQgYSBjb250ZW50IHR5cGUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBDb250ZW50VHlwZSAodHlwZSkge1xuICB0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHRoaXMudHlwZSA9IHR5cGVcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvbnRlbnQtdHlwZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKHtfX3Byb3RvX186W119IGluc3RhbmNlb2YgQXJyYXkgPyBzZXRQcm90b09mIDogbWl4aW5Qcm9wZXJ0aWVzKTtcblxuZnVuY3Rpb24gc2V0UHJvdG9PZihvYmosIHByb3RvKSB7XG5cdG9iai5fX3Byb3RvX18gPSBwcm90bztcblx0cmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gbWl4aW5Qcm9wZXJ0aWVzKG9iaiwgcHJvdG8pIHtcblx0Zm9yICh2YXIgcHJvcCBpbiBwcm90bykge1xuXHRcdGlmICghb2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG5cdFx0XHRvYmpbcHJvcF0gPSBwcm90b1twcm9wXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG9iajtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NldHByb3RvdHlwZW9mL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIHN0YXR1c2VzXG4gKiBDb3B5cmlnaHQoYykgMjAxNCBKb25hdGhhbiBPbmdcbiAqIENvcHlyaWdodChjKSAyMDE2IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgY29kZXMgPSByZXF1aXJlKCcuL2NvZGVzLmpzb24nKVxuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gc3RhdHVzXG5cbi8vIHN0YXR1cyBjb2RlIHRvIG1lc3NhZ2UgbWFwXG5zdGF0dXMuU1RBVFVTX0NPREVTID0gY29kZXNcblxuLy8gYXJyYXkgb2Ygc3RhdHVzIGNvZGVzXG5zdGF0dXMuY29kZXMgPSBwb3B1bGF0ZVN0YXR1c2VzTWFwKHN0YXR1cywgY29kZXMpXG5cbi8vIHN0YXR1cyBjb2RlcyBmb3IgcmVkaXJlY3RzXG5zdGF0dXMucmVkaXJlY3QgPSB7XG4gIDMwMDogdHJ1ZSxcbiAgMzAxOiB0cnVlLFxuICAzMDI6IHRydWUsXG4gIDMwMzogdHJ1ZSxcbiAgMzA1OiB0cnVlLFxuICAzMDc6IHRydWUsXG4gIDMwODogdHJ1ZVxufVxuXG4vLyBzdGF0dXMgY29kZXMgZm9yIGVtcHR5IGJvZGllc1xuc3RhdHVzLmVtcHR5ID0ge1xuICAyMDQ6IHRydWUsXG4gIDIwNTogdHJ1ZSxcbiAgMzA0OiB0cnVlXG59XG5cbi8vIHN0YXR1cyBjb2RlcyBmb3Igd2hlbiB5b3Ugc2hvdWxkIHJldHJ5IHRoZSByZXF1ZXN0XG5zdGF0dXMucmV0cnkgPSB7XG4gIDUwMjogdHJ1ZSxcbiAgNTAzOiB0cnVlLFxuICA1MDQ6IHRydWVcbn1cblxuLyoqXG4gKiBQb3B1bGF0ZSB0aGUgc3RhdHVzZXMgbWFwIGZvciBnaXZlbiBjb2Rlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcG9wdWxhdGVTdGF0dXNlc01hcCAoc3RhdHVzZXMsIGNvZGVzKSB7XG4gIHZhciBhcnIgPSBbXVxuXG4gIE9iamVjdC5rZXlzKGNvZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIGZvckVhY2hDb2RlIChjb2RlKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBjb2Rlc1tjb2RlXVxuICAgIHZhciBzdGF0dXMgPSBOdW1iZXIoY29kZSlcblxuICAgIC8vIFBvcHVsYXRlIHByb3BlcnRpZXNcbiAgICBzdGF0dXNlc1tzdGF0dXNdID0gbWVzc2FnZVxuICAgIHN0YXR1c2VzW21lc3NhZ2VdID0gc3RhdHVzXG4gICAgc3RhdHVzZXNbbWVzc2FnZS50b0xvd2VyQ2FzZSgpXSA9IHN0YXR1c1xuXG4gICAgLy8gQWRkIHRvIGFycmF5XG4gICAgYXJyLnB1c2goc3RhdHVzKVxuICB9KVxuXG4gIHJldHVybiBhcnJcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHN0YXR1cyBjb2RlLlxuICpcbiAqIEdpdmVuIGEgbnVtYmVyLCB0aGlzIHdpbGwgdGhyb3cgaWYgaXQgaXMgbm90IGEga25vd24gc3RhdHVzXG4gKiBjb2RlLCBvdGhlcndpc2UgdGhlIGNvZGUgd2lsbCBiZSByZXR1cm5lZC4gR2l2ZW4gYSBzdHJpbmcsXG4gKiB0aGUgc3RyaW5nIHdpbGwgYmUgcGFyc2VkIGZvciBhIG51bWJlciBhbmQgcmV0dXJuIHRoZSBjb2RlXG4gKiBpZiB2YWxpZCwgb3RoZXJ3aXNlIHdpbGwgbG9va3VwIHRoZSBjb2RlIGFzc3VtaW5nIHRoaXMgaXNcbiAqIHRoZSBzdGF0dXMgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGNvZGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gc3RhdHVzIChjb2RlKSB7XG4gIGlmICh0eXBlb2YgY29kZSA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoIXN0YXR1c1tjb2RlXSkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN0YXR1cyBjb2RlOiAnICsgY29kZSlcbiAgICByZXR1cm4gY29kZVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjb2RlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvZGUgbXVzdCBiZSBhIG51bWJlciBvciBzdHJpbmcnKVxuICB9XG5cbiAgLy8gJzQwMydcbiAgdmFyIG4gPSBwYXJzZUludChjb2RlLCAxMClcbiAgaWYgKCFpc05hTihuKSkge1xuICAgIGlmICghc3RhdHVzW25dKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3RhdHVzIGNvZGU6ICcgKyBuKVxuICAgIHJldHVybiBuXG4gIH1cblxuICBuID0gc3RhdHVzW2NvZGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFuKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3RhdHVzIG1lc3NhZ2U6IFwiJyArIGNvZGUgKyAnXCInKVxuICByZXR1cm4gblxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3RhdHVzZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtcyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHxcbiAgICBwbHVyYWwobXMsIGgsICdob3VyJykgfHxcbiAgICBwbHVyYWwobXMsIG0sICdtaW51dGUnKSB8fFxuICAgIHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8XG4gICAgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIH1cbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ0dHlcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ0dHlcIlxuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBib2R5LXBhcnNlclxuICogQ29weXJpZ2h0KGMpIDIwMTQtMjAxNSBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnaHR0cC1lcnJvcnMnKVxudmFyIGdldEJvZHkgPSByZXF1aXJlKCdyYXctYm9keScpXG52YXIgaWNvbnYgPSByZXF1aXJlKCdpY29udi1saXRlJylcbnZhciBvbkZpbmlzaGVkID0gcmVxdWlyZSgnb24tZmluaXNoZWQnKVxudmFyIHpsaWIgPSByZXF1aXJlKCd6bGliJylcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWRcblxuLyoqXG4gKiBSZWFkIGEgcmVxdWVzdCBpbnRvIGEgYnVmZmVyIGFuZCBwYXJzZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcmVxXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBuZXh0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBwYXJzZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gZGVidWdcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHJlYWQgKHJlcSwgcmVzLCBuZXh0LCBwYXJzZSwgZGVidWcsIG9wdGlvbnMpIHtcbiAgdmFyIGxlbmd0aFxuICB2YXIgb3B0cyA9IG9wdGlvbnNcbiAgdmFyIHN0cmVhbVxuXG4gIC8vIGZsYWcgYXMgcGFyc2VkXG4gIHJlcS5fYm9keSA9IHRydWVcblxuICAvLyByZWFkIG9wdGlvbnNcbiAgdmFyIGVuY29kaW5nID0gb3B0cy5lbmNvZGluZyAhPT0gbnVsbFxuICAgID8gb3B0cy5lbmNvZGluZ1xuICAgIDogbnVsbFxuICB2YXIgdmVyaWZ5ID0gb3B0cy52ZXJpZnlcblxuICB0cnkge1xuICAgIC8vIGdldCB0aGUgY29udGVudCBzdHJlYW1cbiAgICBzdHJlYW0gPSBjb250ZW50c3RyZWFtKHJlcSwgZGVidWcsIG9wdHMuaW5mbGF0ZSlcbiAgICBsZW5ndGggPSBzdHJlYW0ubGVuZ3RoXG4gICAgc3RyZWFtLmxlbmd0aCA9IHVuZGVmaW5lZFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gbmV4dChlcnIpXG4gIH1cblxuICAvLyBzZXQgcmF3LWJvZHkgb3B0aW9uc1xuICBvcHRzLmxlbmd0aCA9IGxlbmd0aFxuICBvcHRzLmVuY29kaW5nID0gdmVyaWZ5XG4gICAgPyBudWxsXG4gICAgOiBlbmNvZGluZ1xuXG4gIC8vIGFzc2VydCBjaGFyc2V0IGlzIHN1cHBvcnRlZFxuICBpZiAob3B0cy5lbmNvZGluZyA9PT0gbnVsbCAmJiBlbmNvZGluZyAhPT0gbnVsbCAmJiAhaWNvbnYuZW5jb2RpbmdFeGlzdHMoZW5jb2RpbmcpKSB7XG4gICAgcmV0dXJuIG5leHQoY3JlYXRlRXJyb3IoNDE1LCAndW5zdXBwb3J0ZWQgY2hhcnNldCBcIicgKyBlbmNvZGluZy50b1VwcGVyQ2FzZSgpICsgJ1wiJywge1xuICAgICAgY2hhcnNldDogZW5jb2RpbmcudG9Mb3dlckNhc2UoKSxcbiAgICAgIHR5cGU6ICdjaGFyc2V0LnVuc3VwcG9ydGVkJ1xuICAgIH0pKVxuICB9XG5cbiAgLy8gcmVhZCBib2R5XG4gIGRlYnVnKCdyZWFkIGJvZHknKVxuICBnZXRCb2R5KHN0cmVhbSwgb3B0cywgZnVuY3Rpb24gKGVycm9yLCBib2R5KSB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB2YXIgX2Vycm9yXG5cbiAgICAgIGlmIChlcnJvci50eXBlID09PSAnZW5jb2RpbmcudW5zdXBwb3J0ZWQnKSB7XG4gICAgICAgIC8vIGVjaG8gYmFjayBjaGFyc2V0XG4gICAgICAgIF9lcnJvciA9IGNyZWF0ZUVycm9yKDQxNSwgJ3Vuc3VwcG9ydGVkIGNoYXJzZXQgXCInICsgZW5jb2RpbmcudG9VcHBlckNhc2UoKSArICdcIicsIHtcbiAgICAgICAgICBjaGFyc2V0OiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgIHR5cGU6ICdjaGFyc2V0LnVuc3VwcG9ydGVkJ1xuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2V0IHN0YXR1cyBjb2RlIG9uIGVycm9yXG4gICAgICAgIF9lcnJvciA9IGNyZWF0ZUVycm9yKDQwMCwgZXJyb3IpXG4gICAgICB9XG5cbiAgICAgIC8vIHJlYWQgb2ZmIGVudGlyZSByZXF1ZXN0XG4gICAgICBzdHJlYW0ucmVzdW1lKClcbiAgICAgIG9uRmluaXNoZWQocmVxLCBmdW5jdGlvbiBvbmZpbmlzaGVkICgpIHtcbiAgICAgICAgbmV4dChjcmVhdGVFcnJvcig0MDAsIF9lcnJvcikpXG4gICAgICB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gdmVyaWZ5XG4gICAgaWYgKHZlcmlmeSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGVidWcoJ3ZlcmlmeSBib2R5JylcbiAgICAgICAgdmVyaWZ5KHJlcSwgcmVzLCBib2R5LCBlbmNvZGluZylcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBuZXh0KGNyZWF0ZUVycm9yKDQwMywgZXJyLCB7XG4gICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICB0eXBlOiBlcnIudHlwZSB8fCAnZW50aXR5LnZlcmlmeS5mYWlsZWQnXG4gICAgICAgIH0pKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwYXJzZVxuICAgIHZhciBzdHIgPSBib2R5XG4gICAgdHJ5IHtcbiAgICAgIGRlYnVnKCdwYXJzZSBib2R5JylcbiAgICAgIHN0ciA9IHR5cGVvZiBib2R5ICE9PSAnc3RyaW5nJyAmJiBlbmNvZGluZyAhPT0gbnVsbFxuICAgICAgICA/IGljb252LmRlY29kZShib2R5LCBlbmNvZGluZylcbiAgICAgICAgOiBib2R5XG4gICAgICByZXEuYm9keSA9IHBhcnNlKHN0cilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIG5leHQoY3JlYXRlRXJyb3IoNDAwLCBlcnIsIHtcbiAgICAgICAgYm9keTogc3RyLFxuICAgICAgICB0eXBlOiBlcnIudHlwZSB8fCAnZW50aXR5LnBhcnNlLmZhaWxlZCdcbiAgICAgIH0pKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbmV4dCgpXG4gIH0pXG59XG5cbi8qKlxuICogR2V0IHRoZSBjb250ZW50IHN0cmVhbSBvZiB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcmVxXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkZWJ1Z1xuICogQHBhcmFtIHtib29sZWFufSBbaW5mbGF0ZT10cnVlXVxuICogQHJldHVybiB7b2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29udGVudHN0cmVhbSAocmVxLCBkZWJ1ZywgaW5mbGF0ZSkge1xuICB2YXIgZW5jb2RpbmcgPSAocmVxLmhlYWRlcnNbJ2NvbnRlbnQtZW5jb2RpbmcnXSB8fCAnaWRlbnRpdHknKS50b0xvd2VyQ2FzZSgpXG4gIHZhciBsZW5ndGggPSByZXEuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXVxuICB2YXIgc3RyZWFtXG5cbiAgZGVidWcoJ2NvbnRlbnQtZW5jb2RpbmcgXCIlc1wiJywgZW5jb2RpbmcpXG5cbiAgaWYgKGluZmxhdGUgPT09IGZhbHNlICYmIGVuY29kaW5nICE9PSAnaWRlbnRpdHknKSB7XG4gICAgdGhyb3cgY3JlYXRlRXJyb3IoNDE1LCAnY29udGVudCBlbmNvZGluZyB1bnN1cHBvcnRlZCcsIHtcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIHR5cGU6ICdlbmNvZGluZy51bnN1cHBvcnRlZCdcbiAgICB9KVxuICB9XG5cbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2RlZmxhdGUnOlxuICAgICAgc3RyZWFtID0gemxpYi5jcmVhdGVJbmZsYXRlKClcbiAgICAgIGRlYnVnKCdpbmZsYXRlIGJvZHknKVxuICAgICAgcmVxLnBpcGUoc3RyZWFtKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdnemlwJzpcbiAgICAgIHN0cmVhbSA9IHpsaWIuY3JlYXRlR3VuemlwKClcbiAgICAgIGRlYnVnKCdndW56aXAgYm9keScpXG4gICAgICByZXEucGlwZShzdHJlYW0pXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2lkZW50aXR5JzpcbiAgICAgIHN0cmVhbSA9IHJlcVxuICAgICAgc3RyZWFtLmxlbmd0aCA9IGxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoNDE1LCAndW5zdXBwb3J0ZWQgY29udGVudCBlbmNvZGluZyBcIicgKyBlbmNvZGluZyArICdcIicsIHtcbiAgICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgICB0eXBlOiAnZW5jb2RpbmcudW5zdXBwb3J0ZWQnXG4gICAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHN0cmVhbVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYm9keS1wYXJzZXIvbGliL3JlYWQuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogb24tZmluaXNoZWRcbiAqIENvcHlyaWdodChjKSAyMDEzIEpvbmF0aGFuIE9uZ1xuICogQ29weXJpZ2h0KGMpIDIwMTQgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gb25GaW5pc2hlZFxubW9kdWxlLmV4cG9ydHMuaXNGaW5pc2hlZCA9IGlzRmluaXNoZWRcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgZmlyc3QgPSByZXF1aXJlKCdlZS1maXJzdCcpXG5cbi8qKlxuICogVmFyaWFibGVzLlxuICogQHByaXZhdGVcbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xudmFyIGRlZmVyID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IHNldEltbWVkaWF0ZVxuICA6IGZ1bmN0aW9uKGZuKXsgcHJvY2Vzcy5uZXh0VGljayhmbi5iaW5kLmFwcGx5KGZuLCBhcmd1bWVudHMpKSB9XG5cbi8qKlxuICogSW52b2tlIGNhbGxiYWNrIHdoZW4gdGhlIHJlc3BvbnNlIGhhcyBmaW5pc2hlZCwgdXNlZnVsIGZvclxuICogY2xlYW5pbmcgdXAgcmVzb3VyY2VzIGFmdGVyd2FyZHMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG1zZ1xuICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXJcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBvbkZpbmlzaGVkKG1zZywgbGlzdGVuZXIpIHtcbiAgaWYgKGlzRmluaXNoZWQobXNnKSAhPT0gZmFsc2UpIHtcbiAgICBkZWZlcihsaXN0ZW5lciwgbnVsbCwgbXNnKVxuICAgIHJldHVybiBtc2dcbiAgfVxuXG4gIC8vIGF0dGFjaCB0aGUgbGlzdGVuZXIgdG8gdGhlIG1lc3NhZ2VcbiAgYXR0YWNoTGlzdGVuZXIobXNnLCBsaXN0ZW5lcilcblxuICByZXR1cm4gbXNnXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIG1lc3NhZ2UgaXMgYWxyZWFkeSBmaW5pc2hlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbXNnXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGlzRmluaXNoZWQobXNnKSB7XG4gIHZhciBzb2NrZXQgPSBtc2cuc29ja2V0XG5cbiAgaWYgKHR5cGVvZiBtc2cuZmluaXNoZWQgPT09ICdib29sZWFuJykge1xuICAgIC8vIE91dGdvaW5nTWVzc2FnZVxuICAgIHJldHVybiBCb29sZWFuKG1zZy5maW5pc2hlZCB8fCAoc29ja2V0ICYmICFzb2NrZXQud3JpdGFibGUpKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBtc2cuY29tcGxldGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEluY29taW5nTWVzc2FnZVxuICAgIHJldHVybiBCb29sZWFuKG1zZy51cGdyYWRlIHx8ICFzb2NrZXQgfHwgIXNvY2tldC5yZWFkYWJsZSB8fCAobXNnLmNvbXBsZXRlICYmICFtc2cucmVhZGFibGUpKVxuICB9XG5cbiAgLy8gZG9uJ3Qga25vd1xuICByZXR1cm4gdW5kZWZpbmVkXG59XG5cbi8qKlxuICogQXR0YWNoIGEgZmluaXNoZWQgbGlzdGVuZXIgdG8gdGhlIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG1zZ1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gYXR0YWNoRmluaXNoZWRMaXN0ZW5lcihtc2csIGNhbGxiYWNrKSB7XG4gIHZhciBlZU1zZ1xuICB2YXIgZWVTb2NrZXRcbiAgdmFyIGZpbmlzaGVkID0gZmFsc2VcblxuICBmdW5jdGlvbiBvbkZpbmlzaChlcnJvcikge1xuICAgIGVlTXNnLmNhbmNlbCgpXG4gICAgZWVTb2NrZXQuY2FuY2VsKClcblxuICAgIGZpbmlzaGVkID0gdHJ1ZVxuICAgIGNhbGxiYWNrKGVycm9yKVxuICB9XG5cbiAgLy8gZmluaXNoZWQgb24gZmlyc3QgbWVzc2FnZSBldmVudFxuICBlZU1zZyA9IGVlU29ja2V0ID0gZmlyc3QoW1ttc2csICdlbmQnLCAnZmluaXNoJ11dLCBvbkZpbmlzaClcblxuICBmdW5jdGlvbiBvblNvY2tldChzb2NrZXQpIHtcbiAgICAvLyByZW1vdmUgbGlzdGVuZXJcbiAgICBtc2cucmVtb3ZlTGlzdGVuZXIoJ3NvY2tldCcsIG9uU29ja2V0KVxuXG4gICAgaWYgKGZpbmlzaGVkKSByZXR1cm5cbiAgICBpZiAoZWVNc2cgIT09IGVlU29ja2V0KSByZXR1cm5cblxuICAgIC8vIGZpbmlzaGVkIG9uIGZpcnN0IHNvY2tldCBldmVudFxuICAgIGVlU29ja2V0ID0gZmlyc3QoW1tzb2NrZXQsICdlcnJvcicsICdjbG9zZSddXSwgb25GaW5pc2gpXG4gIH1cblxuICBpZiAobXNnLnNvY2tldCkge1xuICAgIC8vIHNvY2tldCBhbHJlYWR5IGFzc2lnbmVkXG4gICAgb25Tb2NrZXQobXNnLnNvY2tldClcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIHdhaXQgZm9yIHNvY2tldCB0byBiZSBhc3NpZ25lZFxuICBtc2cub24oJ3NvY2tldCcsIG9uU29ja2V0KVxuXG4gIGlmIChtc2cuc29ja2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBub2RlLmpzIDAuOCBwYXRjaFxuICAgIHBhdGNoQXNzaWduU29ja2V0KG1zZywgb25Tb2NrZXQpXG4gIH1cbn1cblxuLyoqXG4gKiBBdHRhY2ggdGhlIGxpc3RlbmVyIHRvIHRoZSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBtc2dcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBhdHRhY2hMaXN0ZW5lcihtc2csIGxpc3RlbmVyKSB7XG4gIHZhciBhdHRhY2hlZCA9IG1zZy5fX29uRmluaXNoZWRcblxuICAvLyBjcmVhdGUgYSBwcml2YXRlIHNpbmdsZSBsaXN0ZW5lciB3aXRoIHF1ZXVlXG4gIGlmICghYXR0YWNoZWQgfHwgIWF0dGFjaGVkLnF1ZXVlKSB7XG4gICAgYXR0YWNoZWQgPSBtc2cuX19vbkZpbmlzaGVkID0gY3JlYXRlTGlzdGVuZXIobXNnKVxuICAgIGF0dGFjaEZpbmlzaGVkTGlzdGVuZXIobXNnLCBhdHRhY2hlZClcbiAgfVxuXG4gIGF0dGFjaGVkLnF1ZXVlLnB1c2gobGlzdGVuZXIpXG59XG5cbi8qKlxuICogQ3JlYXRlIGxpc3RlbmVyIG9uIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG1zZ1xuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUxpc3RlbmVyKG1zZykge1xuICBmdW5jdGlvbiBsaXN0ZW5lcihlcnIpIHtcbiAgICBpZiAobXNnLl9fb25GaW5pc2hlZCA9PT0gbGlzdGVuZXIpIG1zZy5fX29uRmluaXNoZWQgPSBudWxsXG4gICAgaWYgKCFsaXN0ZW5lci5xdWV1ZSkgcmV0dXJuXG5cbiAgICB2YXIgcXVldWUgPSBsaXN0ZW5lci5xdWV1ZVxuICAgIGxpc3RlbmVyLnF1ZXVlID0gbnVsbFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgcXVldWVbaV0oZXJyLCBtc2cpXG4gICAgfVxuICB9XG5cbiAgbGlzdGVuZXIucXVldWUgPSBbXVxuXG4gIHJldHVybiBsaXN0ZW5lclxufVxuXG4vKipcbiAqIFBhdGNoIFNlcnZlclJlc3BvbnNlLnByb3RvdHlwZS5hc3NpZ25Tb2NrZXQgZm9yIG5vZGUuanMgMC44LlxuICpcbiAqIEBwYXJhbSB7U2VydmVyUmVzcG9uc2V9IHJlc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGF0Y2hBc3NpZ25Tb2NrZXQocmVzLCBjYWxsYmFjaykge1xuICB2YXIgYXNzaWduU29ja2V0ID0gcmVzLmFzc2lnblNvY2tldFxuXG4gIGlmICh0eXBlb2YgYXNzaWduU29ja2V0ICE9PSAnZnVuY3Rpb24nKSByZXR1cm5cblxuICAvLyByZXMub24oJ3NvY2tldCcsIGNhbGxiYWNrKSBpcyBicm9rZW4gaW4gMC44XG4gIHJlcy5hc3NpZ25Tb2NrZXQgPSBmdW5jdGlvbiBfYXNzaWduU29ja2V0KHNvY2tldCkge1xuICAgIGFzc2lnblNvY2tldC5jYWxsKHRoaXMsIHNvY2tldClcbiAgICBjYWxsYmFjayhzb2NrZXQpXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL29uLWZpbmlzaGVkL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJxdWVyeXN0cmluZ1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInF1ZXJ5c3RyaW5nXCJcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogZW5jb2RldXJsXG4gKiBDb3B5cmlnaHQoYykgMjAxNiBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBlbmNvZGVVcmxcblxuLyoqXG4gKiBSZWdFeHAgdG8gbWF0Y2ggbm9uLVVSTCBjb2RlIHBvaW50cywgKmFmdGVyKiBlbmNvZGluZyAoaS5lLiBub3QgaW5jbHVkaW5nIFwiJVwiKVxuICogYW5kIGluY2x1ZGluZyBpbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBFTkNPREVfQ0hBUlNfUkVHRVhQID0gLyg/OlteXFx4MjFcXHgyNVxceDI2LVxceDNCXFx4M0RcXHgzRi1cXHg1QlxceDVEXFx4NUZcXHg2MS1cXHg3QVxceDdFXXwlKD86W14wLTlBLUZhLWZdfFswLTlBLUZhLWZdW14wLTlBLUZhLWZdfCQpKSsvZ1xuXG4vKipcbiAqIFJlZ0V4cCB0byBtYXRjaCB1bm1hdGNoZWQgc3Vycm9nYXRlIHBhaXIuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBVTk1BVENIRURfU1VSUk9HQVRFX1BBSVJfUkVHRVhQID0gLyhefFteXFx1RDgwMC1cXHVEQkZGXSlbXFx1REMwMC1cXHVERkZGXXxbXFx1RDgwMC1cXHVEQkZGXShbXlxcdURDMDAtXFx1REZGRl18JCkvZ1xuXG4vKipcbiAqIFN0cmluZyB0byByZXBsYWNlIHVubWF0Y2hlZCBzdXJyb2dhdGUgcGFpciB3aXRoLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgVU5NQVRDSEVEX1NVUlJPR0FURV9QQUlSX1JFUExBQ0UgPSAnJDFcXHVGRkZEJDInXG5cbi8qKlxuICogRW5jb2RlIGEgVVJMIHRvIGEgcGVyY2VudC1lbmNvZGVkIGZvcm0sIGV4Y2x1ZGluZyBhbHJlYWR5LWVuY29kZWQgc2VxdWVuY2VzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCB0YWtlIGFuIGFscmVhZHktZW5jb2RlZCBVUkwgYW5kIGVuY29kZSBhbGwgdGhlIG5vbi1VUkxcbiAqIGNvZGUgcG9pbnRzLiBUaGlzIGZ1bmN0aW9uIHdpbGwgbm90IGVuY29kZSB0aGUgXCIlXCIgY2hhcmFjdGVyIHVubGVzcyBpdCBpc1xuICogbm90IHBhcnQgb2YgYSB2YWxpZCBzZXF1ZW5jZSAoYCUyMGAgd2lsbCBiZSBsZWZ0IGFzLWlzLCBidXQgYCVmb29gIHdpbGxcbiAqIGJlIGVuY29kZWQgYXMgYCUyNWZvb2ApLlxuICpcbiAqIFRoaXMgZW5jb2RlIGlzIG1lYW50IHRvIGJlIFwic2FmZVwiIGFuZCBkb2VzIG5vdCB0aHJvdyBlcnJvcnMuIEl0IHdpbGwgdHJ5IGFzXG4gKiBoYXJkIGFzIGl0IGNhbiB0byBwcm9wZXJseSBlbmNvZGUgdGhlIGdpdmVuIFVSTCwgaW5jbHVkaW5nIHJlcGxhY2luZyBhbnkgcmF3LFxuICogdW5wYWlyZWQgc3Vycm9nYXRlIHBhaXJzIHdpdGggdGhlIFVuaWNvZGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIHByaW9yIHRvXG4gKiBlbmNvZGluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlVXJsICh1cmwpIHtcbiAgcmV0dXJuIFN0cmluZyh1cmwpXG4gICAgLnJlcGxhY2UoVU5NQVRDSEVEX1NVUlJPR0FURV9QQUlSX1JFR0VYUCwgVU5NQVRDSEVEX1NVUlJPR0FURV9QQUlSX1JFUExBQ0UpXG4gICAgLnJlcGxhY2UoRU5DT0RFX0NIQVJTX1JFR0VYUCwgZW5jb2RlVVJJKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZW5jb2RldXJsL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGVzY2FwZS1odG1sXG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDEzIFRKIEhvbG93YXljaHVrXG4gKiBDb3B5cmlnaHQoYykgMjAxNSBBbmRyZWFzIEx1YmJlXG4gKiBDb3B5cmlnaHQoYykgMjAxNSBUaWFuY2hlbmcgXCJUaW1vdGh5XCIgR3VcbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgdmFyaWFibGVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgbWF0Y2hIdG1sUmVnRXhwID0gL1tcIicmPD5dLztcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVzY2FwZUh0bWw7XG5cbi8qKlxuICogRXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyBpbiB0aGUgZ2l2ZW4gc3RyaW5nIG9mIGh0bWwuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBlc2NhcGUgZm9yIGluc2VydGluZyBpbnRvIEhUTUxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICB2YXIgc3RyID0gJycgKyBzdHJpbmc7XG4gIHZhciBtYXRjaCA9IG1hdGNoSHRtbFJlZ0V4cC5leGVjKHN0cik7XG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICB2YXIgZXNjYXBlO1xuICB2YXIgaHRtbCA9ICcnO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEluZGV4ID0gMDtcblxuICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICBjYXNlIDM0OiAvLyBcIlxuICAgICAgICBlc2NhcGUgPSAnJnF1b3Q7JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM4OiAvLyAmXG4gICAgICAgIGVzY2FwZSA9ICcmYW1wOyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOTogLy8gJ1xuICAgICAgICBlc2NhcGUgPSAnJiMzOTsnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjA6IC8vIDxcbiAgICAgICAgZXNjYXBlID0gJyZsdDsnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjI6IC8vID5cbiAgICAgICAgZXNjYXBlID0gJyZndDsnO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChsYXN0SW5kZXggIT09IGluZGV4KSB7XG4gICAgICBodG1sICs9IHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCk7XG4gICAgfVxuXG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgIGh0bWwgKz0gZXNjYXBlO1xuICB9XG5cbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gaW5kZXhcbiAgICA/IGh0bWwgKyBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpXG4gICAgOiBodG1sO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZXNjYXBlLWh0bWwvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEV4cG9zZSBgYXJyYXlGbGF0dGVuYC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBhcnJheUZsYXR0ZW5cblxuLyoqXG4gKiBSZWN1cnNpdmUgZmxhdHRlbiBmdW5jdGlvbiB3aXRoIGRlcHRoLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSAgYXJyYXlcbiAqIEBwYXJhbSAge0FycmF5fSAgcmVzdWx0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGRlcHRoXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbldpdGhEZXB0aCAoYXJyYXksIHJlc3VsdCwgZGVwdGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2ldXG5cbiAgICBpZiAoZGVwdGggPiAwICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBmbGF0dGVuV2l0aERlcHRoKHZhbHVlLCByZXN1bHQsIGRlcHRoIC0gMSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZSBmbGF0dGVuIGZ1bmN0aW9uLiBPbWl0dGluZyBkZXB0aCBpcyBzbGlnaHRseSBmYXN0ZXIuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGFycmF5XG4gKiBAcGFyYW0gIHtBcnJheX0gcmVzdWx0XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkZvcmV2ZXIgKGFycmF5LCByZXN1bHQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2ldXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGZsYXR0ZW5Gb3JldmVyKHZhbHVlLCByZXN1bHQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGFuIGFycmF5LCB3aXRoIHRoZSBhYmlsaXR5IHRvIGRlZmluZSBhIGRlcHRoLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSAgYXJyYXlcbiAqIEBwYXJhbSAge051bWJlcn0gZGVwdGhcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBhcnJheUZsYXR0ZW4gKGFycmF5LCBkZXB0aCkge1xuICBpZiAoZGVwdGggPT0gbnVsbCkge1xuICAgIHJldHVybiBmbGF0dGVuRm9yZXZlcihhcnJheSwgW10pXG4gIH1cblxuICByZXR1cm4gZmxhdHRlbldpdGhEZXB0aChhcnJheSwgW10sIGRlcHRoKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXJyYXktZmxhdHRlbi9hcnJheS1mbGF0dGVuLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIE1lcmdlIG9iamVjdCBiIHdpdGggb2JqZWN0IGEuXG4gKlxuICogICAgIHZhciBhID0geyBmb286ICdiYXInIH1cbiAqICAgICAgICwgYiA9IHsgYmFyOiAnYmF6JyB9O1xuICpcbiAqICAgICBtZXJnZShhLCBiKTtcbiAqICAgICAvLyA9PiB7IGZvbzogJ2JhcicsIGJhcjogJ2JheicgfVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcGFyYW0ge09iamVjdH0gYlxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhLCBiKXtcbiAgaWYgKGEgJiYgYikge1xuICAgIGZvciAodmFyIGtleSBpbiBiKSB7XG4gICAgICBhW2tleV0gPSBiW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3V0aWxzLW1lcmdlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHV0ZjggPSByZXF1aXJlKCcuL3V0ZjgnKTtcbnZhciBoYXNCaW5hcnkgPSByZXF1aXJlKCdoYXMtYmluYXJ5MicpO1xudmFyIGFmdGVyID0gcmVxdWlyZSgnYWZ0ZXInKTtcbnZhciBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3VycmVudCBwcm90b2NvbCB2ZXJzaW9uLlxuICovXG5leHBvcnRzLnByb3RvY29sID0gMztcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKi9cblxudmFyIHBhY2tldHMgPSBleHBvcnRzLnBhY2tldHMgPSB7XG4gICAgb3BlbjogICAgIDAgICAgLy8gbm9uLXdzXG4gICwgY2xvc2U6ICAgIDEgICAgLy8gbm9uLXdzXG4gICwgcGluZzogICAgIDJcbiAgLCBwb25nOiAgICAgM1xuICAsIG1lc3NhZ2U6ICA0XG4gICwgdXBncmFkZTogIDVcbiAgLCBub29wOiAgICAgNlxufTtcblxudmFyIHBhY2tldHNsaXN0ID0ga2V5cyhwYWNrZXRzKTtcblxuLyoqXG4gKiBQcmVtYWRlIGVycm9yIHBhY2tldC5cbiAqL1xuXG52YXIgZXJyID0geyB0eXBlOiAnZXJyb3InLCBkYXRhOiAncGFyc2VyIGVycm9yJyB9O1xuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQuXG4gKlxuICogICAgIDxwYWNrZXQgdHlwZSBpZD4gWyA8ZGF0YT4gXVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDVoZWxsbyB3b3JsZFxuICogICAgIDNcbiAqICAgICA0XG4gKlxuICogQmluYXJ5IGlzIGVuY29kZWQgaW4gYW4gaWRlbnRpY2FsIHByaW5jaXBsZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHV0ZjhlbmNvZGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdXRmOGVuY29kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gdXRmOGVuY29kZTtcbiAgICB1dGY4ZW5jb2RlID0gbnVsbDtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIocGFja2V0LmRhdGEpKSB7XG4gICAgcmV0dXJuIGVuY29kZUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAocGFja2V0LmRhdGEgJiYgKHBhY2tldC5kYXRhLmJ1ZmZlciB8fCBwYWNrZXQuZGF0YSkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBlbmNvZGVCdWZmZXIoeyB0eXBlOiBwYWNrZXQudHlwZSwgZGF0YTogYXJyYXlCdWZmZXJUb0J1ZmZlcihwYWNrZXQuZGF0YSkgfSwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFNlbmRpbmcgZGF0YSBhcyBhIHV0Zi04IHN0cmluZ1xuICB2YXIgZW5jb2RlZCA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuXG4gIC8vIGRhdGEgZnJhZ21lbnQgaXMgb3B0aW9uYWxcbiAgaWYgKHVuZGVmaW5lZCAhPT0gcGFja2V0LmRhdGEpIHtcbiAgICBlbmNvZGVkICs9IHV0ZjhlbmNvZGUgPyB1dGY4LmVuY29kZShTdHJpbmcocGFja2V0LmRhdGEpLCB7IHN0cmljdDogZmFsc2UgfSkgOiBTdHJpbmcocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKCcnICsgZW5jb2RlZCk7XG59O1xuXG4vKipcbiAqIEVuY29kZSBCdWZmZXIgZGF0YVxuICovXG5cbmZ1bmN0aW9uIGVuY29kZUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBwYWNrZXQuZGF0YTtcbiAgdmFyIHR5cGVCdWZmZXIgPSBuZXcgQnVmZmVyKDEpO1xuICB0eXBlQnVmZmVyWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG4gIHJldHVybiBjYWxsYmFjayhCdWZmZXIuY29uY2F0KFt0eXBlQnVmZmVyLCBkYXRhXSkpO1xufVxuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQgd2l0aCBiaW5hcnkgZGF0YSBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0LCBoYXMgYHR5cGVgIGFuZCBgZGF0YWBcbiAqIEByZXR1cm4ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBjYWxsYmFjayl7XG4gIHZhciBkYXRhID0gQnVmZmVyLmlzQnVmZmVyKHBhY2tldC5kYXRhKSA/IHBhY2tldC5kYXRhIDogYXJyYXlCdWZmZXJUb0J1ZmZlcihwYWNrZXQuZGF0YSk7XG4gIHZhciBtZXNzYWdlID0gJ2InICsgcGFja2V0c1twYWNrZXQudHlwZV07XG4gIG1lc3NhZ2UgKz0gZGF0YS50b1N0cmluZygnYmFzZTY0Jyk7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldC4gRGF0YSBhbHNvIGF2YWlsYWJsZSBhcyBhbiBBcnJheUJ1ZmZlciBpZiByZXF1ZXN0ZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBhY2tldCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCB1dGY4ZGVjb2RlKSB7XG4gIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZXJyO1xuICB9XG5cbiAgdmFyIHR5cGU7XG5cbiAgLy8gU3RyaW5nIGRhdGFcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuXG4gICAgdHlwZSA9IGRhdGEuY2hhckF0KDApO1xuXG4gICAgaWYgKHR5cGUgPT09ICdiJykge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0KGRhdGEuc3Vic3RyKDEpLCBiaW5hcnlUeXBlKTtcbiAgICB9XG5cbiAgICBpZiAodXRmOGRlY29kZSkge1xuICAgICAgZGF0YSA9IHRyeURlY29kZShkYXRhKTtcbiAgICAgIGlmIChkYXRhID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG4gICAgfVxuICB9XG5cbiAgLy8gQmluYXJ5IGRhdGFcbiAgaWYgKGJpbmFyeVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAvLyB3cmFwIEJ1ZmZlci9BcnJheUJ1ZmZlciBkYXRhIGludG8gYW4gVWludDhBcnJheVxuICAgIHZhciBpbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgIHR5cGUgPSBpbnRBcnJheVswXTtcbiAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogaW50QXJyYXkuYnVmZmVyLnNsaWNlKDEpIH07XG4gIH1cblxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgZGF0YSA9IGFycmF5QnVmZmVyVG9CdWZmZXIoZGF0YSk7XG4gIH1cbiAgdHlwZSA9IGRhdGFbMF07XG4gIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiBkYXRhLnNsaWNlKDEpIH07XG59O1xuXG5mdW5jdGlvbiB0cnlEZWNvZGUoZGF0YSkge1xuICB0cnkge1xuICAgIGRhdGEgPSB1dGY4LmRlY29kZShkYXRhLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldCBlbmNvZGVkIGluIGEgYmFzZTY0IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihtc2csIGJpbmFyeVR5cGUpIHtcbiAgdmFyIHR5cGUgPSBwYWNrZXRzbGlzdFttc2cuY2hhckF0KDApXTtcbiAgdmFyIGRhdGEgPSBuZXcgQnVmZmVyKG1zZy5zdWJzdHIoMSksICdiYXNlNjQnKTtcbiAgaWYgKGJpbmFyeVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICB2YXIgYWJ2ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWJ2Lmxlbmd0aDsgaSsrKXtcbiAgICAgIGFidltpXSA9IGRhdGFbaV07XG4gICAgfVxuICAgIGRhdGEgPSBhYnYuYnVmZmVyO1xuICB9XG4gIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkuXG4gKlxuICogICAgIDxsZW5ndGg+OmRhdGFcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAxMTpoZWxsbyB3b3JsZDI6aGlcbiAqXG4gKiBJZiBhbnkgY29udGVudHMgYXJlIGJpbmFyeSwgdGhleSB3aWxsIGJlIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ3MuIEJhc2U2NFxuICogZW5jb2RlZCBzdHJpbmdzIGFyZSBtYXJrZWQgd2l0aCBhIGIgYmVmb3JlIHRoZSBsZW5ndGggc3BlY2lmaWVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKHBhY2tldHMsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IG51bGw7XG4gIH1cblxuICBpZiAoc3VwcG9ydHNCaW5hcnkgJiYgaGFzQmluYXJ5KHBhY2tldHMpKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmluYXJ5KHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soJzA6Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBmYWxzZSwgZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSk7XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0cy5qb2luKCcnKSk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIG1lc3NhZ2UubGVuZ3RoICsgJzonICsgbWVzc2FnZTtcbn1cblxuLyoqXG4gKiBBc3luYyBhcnJheSBtYXAgdXNpbmcgYWZ0ZXJcbiAqL1xuXG5mdW5jdGlvbiBtYXAoYXJ5LCBlYWNoLCBkb25lKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoYXJ5Lmxlbmd0aCk7XG4gIHZhciBuZXh0ID0gYWZ0ZXIoYXJ5Lmxlbmd0aCwgZG9uZSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICBlYWNoKGFyeVtpXSwgZnVuY3Rpb24oZXJyb3IsIG1zZykge1xuICAgICAgcmVzdWx0W2ldID0gbXNnO1xuICAgICAgbmV4dChlcnJvciwgcmVzdWx0KTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBQb3NzaWJsZSBiaW5hcnkgY29udGVudHMgYXJlXG4gKiBkZWNvZGVkIGZyb20gdGhlaXIgYmFzZTY0IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBheWxvYWQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBleHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeShkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gIH1cblxuICBpZiAoZGF0YSA9PT0gJycpIHtcbiAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gJycsIG4sIG1zZywgcGFja2V0O1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG5cbiAgICBpZiAoY2hyICE9PSAnOicpIHtcbiAgICAgIGxlbmd0aCArPSBjaHI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoID09PSAnJyB8fCAobGVuZ3RoICE9IChuID0gTnVtYmVyKGxlbmd0aCkpKSkge1xuICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgfVxuXG4gICAgbXNnID0gZGF0YS5zdWJzdHIoaSArIDEsIG4pO1xuXG4gICAgaWYgKGxlbmd0aCAhPSBtc2cubGVuZ3RoKSB7XG4gICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICB9XG5cbiAgICBpZiAobXNnLmxlbmd0aCkge1xuICAgICAgcGFja2V0ID0gZXhwb3J0cy5kZWNvZGVQYWNrZXQobXNnLCBiaW5hcnlUeXBlLCBmYWxzZSk7XG5cbiAgICAgIGlmIChlcnIudHlwZSA9PT0gcGFja2V0LnR5cGUgJiYgZXJyLmRhdGEgPT09IHBhY2tldC5kYXRhKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciBpbiBpbmRpdmlkdWFsIHBhY2tldCAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtb3JlID0gY2FsbGJhY2socGFja2V0LCBpICsgbiwgbCk7XG4gICAgICBpZiAoZmFsc2UgPT09IG1vcmUpIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBhZHZhbmNlIGN1cnNvclxuICAgIGkgKz0gbjtcbiAgICBsZW5ndGggPSAnJztcbiAgfVxuXG4gIGlmIChsZW5ndGggIT09ICcnKSB7XG4gICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICB9XG5cbn07XG5cbi8qKlxuICpcbiAqIENvbnZlcnRzIGEgYnVmZmVyIHRvIGEgdXRmOC5qcyBlbmNvZGVkIHN0cmluZ1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGJ1ZmZlclRvU3RyaW5nKGJ1ZmZlcikge1xuICB2YXIgc3RyID0gJyc7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYnVmZmVyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZlcltpXSk7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKlxuICogQ29udmVydHMgYSB1dGY4LmpzIGVuY29kZWQgc3RyaW5nIHRvIGEgYnVmZmVyXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc3RyaW5nVG9CdWZmZXIoc3RyaW5nKSB7XG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHN0cmluZy5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBidWYud3JpdGVVSW50OChzdHJpbmcuY2hhckNvZGVBdChpKSwgaSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn1cblxuLyoqXG4gKlxuICogQ29udmVydHMgYW4gQXJyYXlCdWZmZXIgdG8gYSBCdWZmZXJcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBhcnJheUJ1ZmZlclRvQnVmZmVyKGRhdGEpIHtcbiAgLy8gZGF0YSBpcyBlaXRoZXIgYW4gQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3LlxuICB2YXIgYXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciB8fCBkYXRhKTtcbiAgdmFyIGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCB8fCBkYXRhLmxlbmd0aDtcbiAgdmFyIG9mZnNldCA9IGRhdGEuYnl0ZU9mZnNldCB8fCAwO1xuICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcihsZW5ndGgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBidWZmZXJbaV0gPSBhcnJheVtvZmZzZXQgKyBpXTtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufVxuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpIGFzIGJpbmFyeS5cbiAqXG4gKiA8MSA9IGJpbmFyeSwgMCA9IHN0cmluZz48bnVtYmVyIGZyb20gMC05PjxudW1iZXIgZnJvbSAwLTk+Wy4uLl08bnVtYmVyXG4gKiAyNTU+PGRhdGE+XG4gKlxuICogRXhhbXBsZTpcbiAqIDEgMyAyNTUgMSAyIDMsIGlmIHRoZSBiaW5hcnkgY29udGVudHMgYXJlIGludGVycHJldGVkIGFzIDggYml0IGludGVnZXJzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQHJldHVybiB7QnVmZmVyfSBlbmNvZGVkIHBheWxvYWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmluYXJ5ID0gZnVuY3Rpb24gKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEJ1ZmZlcigwKSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lQmluYXJ5UGFja2V0LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soQnVmZmVyLmNvbmNhdChyZXN1bHRzKSk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZW5jb2RlT25lQmluYXJ5UGFja2V0KHAsIGRvbmVDYWxsYmFjaykge1xuXG4gIGZ1bmN0aW9uIG9uQmluYXJ5UGFja2V0RW5jb2RlKHBhY2tldCkge1xuXG4gICAgdmFyIGVuY29kaW5nTGVuZ3RoID0gJycgKyBwYWNrZXQubGVuZ3RoO1xuICAgIHZhciBzaXplQnVmZmVyO1xuXG4gICAgaWYgKHR5cGVvZiBwYWNrZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzaXplQnVmZmVyID0gbmV3IEJ1ZmZlcihlbmNvZGluZ0xlbmd0aC5sZW5ndGggKyAyKTtcbiAgICAgIHNpemVCdWZmZXJbMF0gPSAwOyAvLyBpcyBhIHN0cmluZyAobm90IHRydWUgYmluYXJ5ID0gMClcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RpbmdMZW5ndGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2l6ZUJ1ZmZlcltpICsgMV0gPSBwYXJzZUludChlbmNvZGluZ0xlbmd0aFtpXSwgMTApO1xuICAgICAgfVxuICAgICAgc2l6ZUJ1ZmZlcltzaXplQnVmZmVyLmxlbmd0aCAtIDFdID0gMjU1O1xuICAgICAgcmV0dXJuIGRvbmVDYWxsYmFjayhudWxsLCBCdWZmZXIuY29uY2F0KFtzaXplQnVmZmVyLCBzdHJpbmdUb0J1ZmZlcihwYWNrZXQpXSkpO1xuICAgIH1cblxuICAgIHNpemVCdWZmZXIgPSBuZXcgQnVmZmVyKGVuY29kaW5nTGVuZ3RoLmxlbmd0aCArIDIpO1xuICAgIHNpemVCdWZmZXJbMF0gPSAxOyAvLyBpcyBiaW5hcnkgKHRydWUgYmluYXJ5ID0gMSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kaW5nTGVuZ3RoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzaXplQnVmZmVyW2kgKyAxXSA9IHBhcnNlSW50KGVuY29kaW5nTGVuZ3RoW2ldLCAxMCk7XG4gICAgfVxuICAgIHNpemVCdWZmZXJbc2l6ZUJ1ZmZlci5sZW5ndGggLSAxXSA9IDI1NTtcblxuICAgIGRvbmVDYWxsYmFjayhudWxsLCBCdWZmZXIuY29uY2F0KFtzaXplQnVmZmVyLCBwYWNrZXRdKSk7XG4gIH1cblxuICBleHBvcnRzLmVuY29kZVBhY2tldChwLCB0cnVlLCB0cnVlLCBvbkJpbmFyeVBhY2tldEVuY29kZSk7XG5cbn1cblxuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBTdHJpbmdzIGFyZSBkZWNvZGVkIGJ5XG4gKiBpbnRlcnByZXRpbmcgZWFjaCBieXRlIGFzIGEga2V5IGNvZGUgZm9yIGVudHJpZXMgbWFya2VkIHRvIHN0YXJ0IHdpdGggMC4gU2VlXG4gKiBkZXNjcmlwdGlvbiBvZiBlbmNvZGVQYXlsb2FkQXNCaW5hcnlcblxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeSA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gIH1cblxuICB2YXIgYnVmZmVyVGFpbCA9IGRhdGE7XG4gIHZhciBidWZmZXJzID0gW107XG4gIHZhciBpO1xuXG4gIHdoaWxlIChidWZmZXJUYWlsLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgc3RyTGVuID0gJyc7XG4gICAgdmFyIGlzU3RyaW5nID0gYnVmZmVyVGFpbFswXSA9PT0gMDtcbiAgICBmb3IgKGkgPSAxOyA7IGkrKykge1xuICAgICAgaWYgKGJ1ZmZlclRhaWxbaV0gPT09IDI1NSkgIGJyZWFrO1xuICAgICAgLy8gMzEwID0gY2hhciBsZW5ndGggb2YgTnVtYmVyLk1BWF9WQUxVRVxuICAgICAgaWYgKHN0ckxlbi5sZW5ndGggPiAzMTApIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG4gICAgICBzdHJMZW4gKz0gJycgKyBidWZmZXJUYWlsW2ldO1xuICAgIH1cbiAgICBidWZmZXJUYWlsID0gYnVmZmVyVGFpbC5zbGljZShzdHJMZW4ubGVuZ3RoICsgMSk7XG5cbiAgICB2YXIgbXNnTGVuZ3RoID0gcGFyc2VJbnQoc3RyTGVuLCAxMCk7XG5cbiAgICB2YXIgbXNnID0gYnVmZmVyVGFpbC5zbGljZSgxLCBtc2dMZW5ndGggKyAxKTtcbiAgICBpZiAoaXNTdHJpbmcpIG1zZyA9IGJ1ZmZlclRvU3RyaW5nKG1zZyk7XG4gICAgYnVmZmVycy5wdXNoKG1zZyk7XG4gICAgYnVmZmVyVGFpbCA9IGJ1ZmZlclRhaWwuc2xpY2UobXNnTGVuZ3RoICsgMSk7XG4gIH1cblxuICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcbiAgZm9yIChpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICB2YXIgYnVmZmVyID0gYnVmZmVyc1tpXTtcbiAgICBjYWxsYmFjayhleHBvcnRzLmRlY29kZVBhY2tldChidWZmZXIsIGJpbmFyeVR5cGUsIHRydWUpLCBpLCB0b3RhbCk7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBMaW1pdGVyID0gcmVxdWlyZSgnYXN5bmMtbGltaXRlcicpO1xuY29uc3QgemxpYiA9IHJlcXVpcmUoJ3psaWInKTtcblxuY29uc3QgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcbmNvbnN0IHsga1N0YXR1c0NvZGUsIE5PT1AgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IFRSQUlMRVIgPSBCdWZmZXIuZnJvbShbMHgwMCwgMHgwMCwgMHhmZiwgMHhmZl0pO1xuY29uc3QgRU1QVFlfQkxPQ0sgPSBCdWZmZXIuZnJvbShbMHgwMF0pO1xuXG5jb25zdCBrUGVyTWVzc2FnZURlZmxhdGUgPSBTeW1ib2woJ3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3Qga1RvdGFsTGVuZ3RoID0gU3ltYm9sKCd0b3RhbC1sZW5ndGgnKTtcbmNvbnN0IGtDYWxsYmFjayA9IFN5bWJvbCgnY2FsbGJhY2snKTtcbmNvbnN0IGtCdWZmZXJzID0gU3ltYm9sKCdidWZmZXJzJyk7XG5jb25zdCBrRXJyb3IgPSBTeW1ib2woJ2Vycm9yJyk7XG5cbi8vXG4vLyBXZSBsaW1pdCB6bGliIGNvbmN1cnJlbmN5LCB3aGljaCBwcmV2ZW50cyBzZXZlcmUgbWVtb3J5IGZyYWdtZW50YXRpb25cbi8vIGFzIGRvY3VtZW50ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy84ODcxI2lzc3VlY29tbWVudC0yNTA5MTU5MTNcbi8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTIwMlxuLy9cbi8vIEludGVudGlvbmFsbHkgZ2xvYmFsOyBpdCdzIHRoZSBnbG9iYWwgdGhyZWFkIHBvb2wgdGhhdCdzIGFuIGlzc3VlLlxuLy9cbmxldCB6bGliTGltaXRlcjtcblxuLyoqXG4gKiBwZXJtZXNzYWdlLWRlZmxhdGUgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIFBlck1lc3NhZ2VEZWZsYXRlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQZXJNZXNzYWdlRGVmbGF0ZSBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3ZlciBSZXF1ZXN0L2FjY2VwdCBkaXNhYmxpbmdcbiAgICogICAgIG9mIHNlcnZlciBjb250ZXh0IHRha2VvdmVyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3ZlciBBZHZlcnRpc2UvYWNrbm93bGVkZ2VcbiAgICogICAgIGRpc2FibGluZyBvZiBjbGllbnQgY29udGV4dCB0YWtlb3ZlclxuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IG9wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cyBSZXF1ZXN0L2NvbmZpcm0gdGhlXG4gICAqICAgICB1c2Ugb2YgYSBjdXN0b20gc2VydmVyIHdpbmRvdyBzaXplXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzIEFkdmVydGlzZSBzdXBwb3J0XG4gICAqICAgICBmb3IsIG9yIHJlcXVlc3QsIGEgY3VzdG9tIGNsaWVudCB3aW5kb3cgc2l6ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy56bGliRGVmbGF0ZU9wdGlvbnMgT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb24gZGVmbGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy56bGliSW5mbGF0ZU9wdGlvbnMgT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb24gaW5mbGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy50aHJlc2hvbGQgU2l6ZSAoaW4gYnl0ZXMpIGJlbG93IHdoaWNoIG1lc3NhZ2VzXG4gICAqICAgICBzaG91bGQgbm90IGJlIGNvbXByZXNzZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuY29uY3VycmVuY3lMaW1pdCBUaGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgY2FsbHMgdG9cbiAgICogICAgIHpsaWJcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1NlcnZlciBDcmVhdGUgdGhlIGluc3RhbmNlIGluIGVpdGhlciBzZXJ2ZXIgb3IgY2xpZW50XG4gICAqICAgICBtb2RlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhQYXlsb2FkIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBsZW5ndGhcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGlzU2VydmVyLCBtYXhQYXlsb2FkKSB7XG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuX3RocmVzaG9sZCA9XG4gICAgICB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQgOiAxMDI0O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFpc1NlcnZlcjtcbiAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcbiAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcblxuICAgIHRoaXMucGFyYW1zID0gbnVsbDtcblxuICAgIGlmICghemxpYkxpbWl0ZXIpIHtcbiAgICAgIGNvbnN0IGNvbmN1cnJlbmN5ID1cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHRoaXMuX29wdGlvbnMuY29uY3VycmVuY3lMaW1pdFxuICAgICAgICAgIDogMTA7XG4gICAgICB6bGliTGltaXRlciA9IG5ldyBMaW1pdGVyKHsgY29uY3VycmVuY3kgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGV4dGVuc2lvbk5hbWUoKSB7XG4gICAgcmV0dXJuICdwZXJtZXNzYWdlLWRlZmxhdGUnO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gRXh0ZW5zaW9uIHBhcmFtZXRlcnNcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgb2ZmZXIoKSB7XG4gICAgY29uc3QgcGFyYW1zID0ge307XG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgcGFyYW1zLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHMpIHtcbiAgICAgIHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PSBudWxsKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHQgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyL3Jlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWd1cmF0aW9ucyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVycy9yZXBvbnNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHVibGljXG4gICAqL1xuICBhY2NlcHQoY29uZmlndXJhdGlvbnMpIHtcbiAgICBjb25maWd1cmF0aW9ucyA9IHRoaXMubm9ybWFsaXplUGFyYW1zKGNvbmZpZ3VyYXRpb25zKTtcblxuICAgIHRoaXMucGFyYW1zID0gdGhpcy5faXNTZXJ2ZXJcbiAgICAgID8gdGhpcy5hY2NlcHRBc1NlcnZlcihjb25maWd1cmF0aW9ucylcbiAgICAgIDogdGhpcy5hY2NlcHRBc0NsaWVudChjb25maWd1cmF0aW9ucyk7XG5cbiAgICByZXR1cm4gdGhpcy5wYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgYWxsIHJlc291cmNlcyB1c2VkIGJ5IHRoZSBleHRlbnNpb24uXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuX2luZmxhdGUpIHtcbiAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kZWZsYXRlKSB7XG4gICAgICB0aGlzLl9kZWZsYXRlLmNsb3NlKCk7XG4gICAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogIEFjY2VwdCBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IG9mZmVycyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFjY2VwdEFzU2VydmVyKG9mZmVycykge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLl9vcHRpb25zO1xuICAgIGNvbnN0IGFjY2VwdGVkID0gb2ZmZXJzLmZpbmQoKHBhcmFtcykgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICAob3B0cy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3ZlciA9PT0gZmFsc2UgJiZcbiAgICAgICAgICBwYXJhbXMuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIpIHx8XG4gICAgICAgIChwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cyAmJlxuICAgICAgICAgIChvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAodHlwZW9mIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID4gcGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMpKSkgfHxcbiAgICAgICAgKHR5cGVvZiBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgIXBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICBpZiAoIWFjY2VwdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbmUgb2YgdGhlIGV4dGVuc2lvbiBvZmZlcnMgY2FuIGJlIGFjY2VwdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIGFjY2VwdGVkLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdHMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIGFjY2VwdGVkLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICBhY2NlcHRlZC5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzID0gb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPT09IHRydWUgfHxcbiAgICAgIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gZmFsc2VcbiAgICApIHtcbiAgICAgIGRlbGV0ZSBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzO1xuICAgIH1cblxuICAgIHJldHVybiBhY2NlcHRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHQgdGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiByZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gcmVzcG9uc2UgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiByZXNwb25zZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFjY2VwdEFzQ2xpZW50KHJlc3BvbnNlKSB7XG4gICAgY29uc3QgcGFyYW1zID0gcmVzcG9uc2VbMF07XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLl9vcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyID09PSBmYWxzZSAmJlxuICAgICAgcGFyYW1zLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgcGFyYW1ldGVyIFwiY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXJcIicpO1xuICAgIH1cblxuICAgIGlmICghcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSBmYWxzZSB8fFxuICAgICAgKHR5cGVvZiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXG4gICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID4gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVW5leHBlY3RlZCBvciBpbnZhbGlkIHBhcmFtZXRlciBcImNsaWVudF9tYXhfd2luZG93X2JpdHNcIidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY29uZmlndXJhdGlvbnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnMvcmVwb25zZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIG9mZmVycy9yZXNwb25zZSB3aXRoIG5vcm1hbGl6ZWQgcGFyYW1ldGVyc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbm9ybWFsaXplUGFyYW1zKGNvbmZpZ3VyYXRpb25zKSB7XG4gICAgY29uZmlndXJhdGlvbnMuZm9yRWFjaCgocGFyYW1zKSA9PiB7XG4gICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbXNba2V5XTtcblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGFyYW1ldGVyIFwiJHtrZXl9XCIgbXVzdCBoYXZlIG9ubHkgYSBzaW5nbGUgdmFsdWVgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gdmFsdWVbMF07XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsaWVudF9tYXhfd2luZG93X2JpdHMnKSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBudW0gPSArdmFsdWU7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobnVtKSB8fCBudW0gPCA4IHx8IG51bSA+IDE1KSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gbnVtO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzU2VydmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnc2VydmVyX21heF93aW5kb3dfYml0cycpIHtcbiAgICAgICAgICBjb25zdCBudW0gPSArdmFsdWU7XG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG51bSkgfHwgbnVtIDwgOCB8fCBudW0gPiAxNSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gbnVtO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ2NsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3NlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyJ1xuICAgICAgICApIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gcGFyYW1ldGVyIFwiJHtrZXl9XCJgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjb25maWd1cmF0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzIGRhdGEuIENvbmN1cnJlbmN5IGxpbWl0ZWQgYnkgYXN5bmMtbGltaXRlci5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGRlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLnB1c2goKGRvbmUpID0+IHtcbiAgICAgIHRoaXMuX2RlY29tcHJlc3MoZGF0YSwgZmluLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wcmVzcyBkYXRhLiBDb25jdXJyZW5jeSBsaW1pdGVkIGJ5IGFzeW5jLWxpbWl0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIERhdGEgdG8gY29tcHJlc3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLnB1c2goKGRvbmUpID0+IHtcbiAgICAgIHRoaXMuX2NvbXByZXNzKGRhdGEsIGZpbiwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wcmVzcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZWNvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBlbmRwb2ludCA9IHRoaXMuX2lzU2VydmVyID8gJ2NsaWVudCcgOiAnc2VydmVyJztcblxuICAgIGlmICghdGhpcy5faW5mbGF0ZSkge1xuICAgICAgY29uc3Qga2V5ID0gYCR7ZW5kcG9pbnR9X21heF93aW5kb3dfYml0c2A7XG4gICAgICBjb25zdCB3aW5kb3dCaXRzID1cbiAgICAgICAgdHlwZW9mIHRoaXMucGFyYW1zW2tleV0gIT09ICdudW1iZXInXG4gICAgICAgICAgPyB6bGliLlpfREVGQVVMVF9XSU5ET1dCSVRTXG4gICAgICAgICAgOiB0aGlzLnBhcmFtc1trZXldO1xuXG4gICAgICB0aGlzLl9pbmZsYXRlID0gemxpYi5jcmVhdGVJbmZsYXRlUmF3KFxuICAgICAgICBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9vcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9ucywgeyB3aW5kb3dCaXRzIH0pXG4gICAgICApO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrUGVyTWVzc2FnZURlZmxhdGVdID0gdGhpcztcbiAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuICAgICAgdGhpcy5faW5mbGF0ZS5vbignZXJyb3InLCBpbmZsYXRlT25FcnJvcik7XG4gICAgICB0aGlzLl9pbmZsYXRlLm9uKCdkYXRhJywgaW5mbGF0ZU9uRGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5faW5mbGF0ZVtrQ2FsbGJhY2tdID0gY2FsbGJhY2s7XG5cbiAgICB0aGlzLl9pbmZsYXRlLndyaXRlKGRhdGEpO1xuICAgIGlmIChmaW4pIHRoaXMuX2luZmxhdGUud3JpdGUoVFJBSUxFUik7XG5cbiAgICB0aGlzLl9pbmZsYXRlLmZsdXNoKCgpID0+IHtcbiAgICAgIGNvbnN0IGVyciA9IHRoaXMuX2luZmxhdGVba0Vycm9yXTtcblxuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBidWZmZXJVdGlsLmNvbmNhdChcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10sXG4gICAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXVxuICAgICAgKTtcblxuICAgICAgaWYgKGZpbiAmJiB0aGlzLnBhcmFtc1tgJHtlbmRwb2ludH1fbm9fY29udGV4dF90YWtlb3ZlcmBdKSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wcmVzcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaywgbnVsbCwgRU1QVFlfQkxPQ0spO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnc2VydmVyJyA6ICdjbGllbnQnO1xuXG4gICAgaWYgKCF0aGlzLl9kZWZsYXRlKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcbiAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPVxuICAgICAgICB0eXBlb2YgdGhpcy5wYXJhbXNba2V5XSAhPT0gJ251bWJlcidcbiAgICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUgPSB6bGliLmNyZWF0ZURlZmxhdGVSYXcoXG4gICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX29wdGlvbnMuemxpYkRlZmxhdGVPcHRpb25zLCB7IHdpbmRvd0JpdHMgfSlcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICAvL1xuICAgICAgLy8gQW4gYCdlcnJvcidgIGV2ZW50IGlzIGVtaXR0ZWQsIG9ubHkgb24gTm9kZS5qcyA8IDEwLjAuMCwgaWYgdGhlXG4gICAgICAvLyBgemxpYi5EZWZsYXRlUmF3YCBpbnN0YW5jZSBpcyBjbG9zZWQgd2hpbGUgZGF0YSBpcyBiZWluZyBwcm9jZXNzZWQuXG4gICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgYFBlck1lc3NhZ2VEZWZsYXRlI2NsZWFudXAoKWAgaXMgY2FsbGVkIGF0IHRoZSB3cm9uZ1xuICAgICAgLy8gdGltZSBkdWUgdG8gYW4gYWJub3JtYWwgV2ViU29ja2V0IGNsb3N1cmUuXG4gICAgICAvL1xuICAgICAgdGhpcy5fZGVmbGF0ZS5vbignZXJyb3InLCBOT09QKTtcbiAgICAgIHRoaXMuX2RlZmxhdGUub24oJ2RhdGEnLCBkZWZsYXRlT25EYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kZWZsYXRlLndyaXRlKGRhdGEpO1xuICAgIHRoaXMuX2RlZmxhdGUuZmx1c2goemxpYi5aX1NZTkNfRkxVU0gsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBUaGlzIGBpZmAgc3RhdGVtZW50IGlzIG9ubHkgbmVlZGVkIGZvciBOb2RlLmpzIDwgMTAuMC4wIGJlY2F1c2UgYXMgb2ZcbiAgICAgICAgLy8gY29tbWl0IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvNWUzZjUxNjQsIHRoZSBmbHVzaFxuICAgICAgICAvLyBjYWxsYmFjayBpcyBubyBsb25nZXIgY2FsbGVkIGlmIHRoZSBkZWZsYXRlIHN0cmVhbSBpcyBjbG9zZWQgd2hpbGVcbiAgICAgICAgLy8gZGF0YSBpcyBiZWluZyBwcm9jZXNzZWQuXG4gICAgICAgIC8vXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGEgPSBidWZmZXJVdGlsLmNvbmNhdChcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10sXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXVxuICAgICAgKTtcblxuICAgICAgaWYgKGZpbikgZGF0YSA9IGRhdGEuc2xpY2UoMCwgZGF0YS5sZW5ndGggLSA0KTtcblxuICAgICAgaWYgKGZpbiAmJiB0aGlzLnBhcmFtc1tgJHtlbmRwb2ludH1fbm9fY29udGV4dF90YWtlb3ZlcmBdKSB7XG4gICAgICAgIHRoaXMuX2RlZmxhdGUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5fZGVmbGF0ZSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBlck1lc3NhZ2VEZWZsYXRlO1xuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuRGVmbGF0ZVJhd2Agc3RyZWFtIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVPbkRhdGEoY2h1bmspIHtcbiAgdGhpc1trQnVmZmVyc10ucHVzaChjaHVuayk7XG4gIHRoaXNba1RvdGFsTGVuZ3RoXSArPSBjaHVuay5sZW5ndGg7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5JbmZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5mbGF0ZU9uRGF0YShjaHVuaykge1xuICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xuXG4gIGlmIChcbiAgICB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX21heFBheWxvYWQgPCAxIHx8XG4gICAgdGhpc1trVG90YWxMZW5ndGhdIDw9IHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5fbWF4UGF5bG9hZFxuICApIHtcbiAgICB0aGlzW2tCdWZmZXJzXS5wdXNoKGNodW5rKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzW2tFcnJvcl0gPSBuZXcgUmFuZ2VFcnJvcignTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcpO1xuICB0aGlzW2tFcnJvcl1ba1N0YXR1c0NvZGVdID0gMTAwOTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIGluZmxhdGVPbkRhdGEpO1xuICB0aGlzLnJlc2V0KCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5JbmZsYXRlUmF3YCBzdHJlYW0gYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZW1pdHRlZCBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5mbGF0ZU9uRXJyb3IoZXJyKSB7XG4gIC8vXG4gIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsbCBgWmxpYiNjbG9zZSgpYCBhcyB0aGUgaGFuZGxlIGlzIGF1dG9tYXRpY2FsbHlcbiAgLy8gY2xvc2VkIHdoZW4gYW4gZXJyb3IgaXMgZW1pdHRlZC5cbiAgLy9cbiAgdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9pbmZsYXRlID0gbnVsbDtcbiAgZXJyW2tTdGF0dXNDb2RlXSA9IDEwMDc7XG4gIHRoaXNba0NhbGxiYWNrXShlcnIpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvd3MvbGliL3Blcm1lc3NhZ2UtZGVmbGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGJpbmFyeSA9IHJlcXVpcmUoJy4vYmluYXJ5Jyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbnZhciBpc0J1ZiA9IHJlcXVpcmUoJy4vaXMtYnVmZmVyJyk7XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudHlwZXMgPSBbXG4gICdDT05ORUNUJyxcbiAgJ0RJU0NPTk5FQ1QnLFxuICAnRVZFTlQnLFxuICAnQUNLJyxcbiAgJ0VSUk9SJyxcbiAgJ0JJTkFSWV9FVkVOVCcsXG4gICdCSU5BUllfQUNLJ1xuXTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgY29ubmVjdGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkNPTk5FQ1QgPSAwO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBkaXNjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRElTQ09OTkVDVCA9IDE7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGV2ZW50YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVZFTlQgPSAyO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBhY2tgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5BQ0sgPSAzO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBlcnJvcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVSUk9SID0gNDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSAnYmluYXJ5IGV2ZW50J1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5CSU5BUllfRVZFTlQgPSA1O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBiaW5hcnkgYWNrYC4gRm9yIGFja3Mgd2l0aCBiaW5hcnkgYXJndW1lbnRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5CSU5BUllfQUNLID0gNjtcblxuLyoqXG4gKiBFbmNvZGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FbmNvZGVyID0gRW5jb2RlcjtcblxuLyoqXG4gKiBEZWNvZGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5EZWNvZGVyID0gRGVjb2RlcjtcblxuLyoqXG4gKiBBIHNvY2tldC5pbyBFbmNvZGVyIGluc3RhbmNlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbmNvZGVyKCkge31cblxudmFyIEVSUk9SX1BBQ0tFVCA9IGV4cG9ydHMuRVJST1IgKyAnXCJlbmNvZGUgZXJyb3JcIic7XG5cbi8qKlxuICogRW5jb2RlIGEgcGFja2V0IGFzIGEgc2luZ2xlIHN0cmluZyBpZiBub24tYmluYXJ5LCBvciBhcyBhXG4gKiBidWZmZXIgc2VxdWVuY2UsIGRlcGVuZGluZyBvbiBwYWNrZXQgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gcGFja2V0IG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBmdW5jdGlvbiB0byBoYW5kbGUgZW5jb2RpbmdzIChsaWtlbHkgZW5naW5lLndyaXRlKVxuICogQHJldHVybiBDYWxscyBjYWxsYmFjayB3aXRoIEFycmF5IG9mIGVuY29kaW5nc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihvYmosIGNhbGxiYWNrKXtcbiAgZGVidWcoJ2VuY29kaW5nIHBhY2tldCAlaicsIG9iaik7XG5cbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IG9iai50eXBlKSB7XG4gICAgZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVuY29kaW5nID0gZW5jb2RlQXNTdHJpbmcob2JqKTtcbiAgICBjYWxsYmFjayhbZW5jb2RpbmddKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGFzIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFzU3RyaW5nKG9iaikge1xuXG4gIC8vIGZpcnN0IGlzIHR5cGVcbiAgdmFyIHN0ciA9ICcnICsgb2JqLnR5cGU7XG5cbiAgLy8gYXR0YWNobWVudHMgaWYgd2UgaGF2ZSB0aGVtXG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBvYmoudHlwZSkge1xuICAgIHN0ciArPSBvYmouYXR0YWNobWVudHMgKyAnLSc7XG4gIH1cblxuICAvLyBpZiB3ZSBoYXZlIGEgbmFtZXNwYWNlIG90aGVyIHRoYW4gYC9gXG4gIC8vIHdlIGFwcGVuZCBpdCBmb2xsb3dlZCBieSBhIGNvbW1hIGAsYFxuICBpZiAob2JqLm5zcCAmJiAnLycgIT09IG9iai5uc3ApIHtcbiAgICBzdHIgKz0gb2JqLm5zcCArICcsJztcbiAgfVxuXG4gIC8vIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IHRoZSBpZFxuICBpZiAobnVsbCAhPSBvYmouaWQpIHtcbiAgICBzdHIgKz0gb2JqLmlkO1xuICB9XG5cbiAgLy8ganNvbiBkYXRhXG4gIGlmIChudWxsICE9IG9iai5kYXRhKSB7XG4gICAgdmFyIHBheWxvYWQgPSB0cnlTdHJpbmdpZnkob2JqLmRhdGEpO1xuICAgIGlmIChwYXlsb2FkICE9PSBmYWxzZSkge1xuICAgICAgc3RyICs9IHBheWxvYWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBFUlJPUl9QQUNLRVQ7XG4gICAgfVxuICB9XG5cbiAgZGVidWcoJ2VuY29kZWQgJWogYXMgJXMnLCBvYmosIHN0cik7XG4gIHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIHRyeVN0cmluZ2lmeShzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RyKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGFzICdidWZmZXIgc2VxdWVuY2UnIGJ5IHJlbW92aW5nIGJsb2JzLCBhbmRcbiAqIGRlY29uc3RydWN0aW5nIHBhY2tldCBpbnRvIG9iamVjdCB3aXRoIHBsYWNlaG9sZGVycyBhbmRcbiAqIGEgbGlzdCBvZiBidWZmZXJzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0J1ZmZlcn0gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjaykge1xuXG4gIGZ1bmN0aW9uIHdyaXRlRW5jb2RpbmcoYmxvYmxlc3NEYXRhKSB7XG4gICAgdmFyIGRlY29uc3RydWN0aW9uID0gYmluYXJ5LmRlY29uc3RydWN0UGFja2V0KGJsb2JsZXNzRGF0YSk7XG4gICAgdmFyIHBhY2sgPSBlbmNvZGVBc1N0cmluZyhkZWNvbnN0cnVjdGlvbi5wYWNrZXQpO1xuICAgIHZhciBidWZmZXJzID0gZGVjb25zdHJ1Y3Rpb24uYnVmZmVycztcblxuICAgIGJ1ZmZlcnMudW5zaGlmdChwYWNrKTsgLy8gYWRkIHBhY2tldCBpbmZvIHRvIGJlZ2lubmluZyBvZiBkYXRhIGxpc3RcbiAgICBjYWxsYmFjayhidWZmZXJzKTsgLy8gd3JpdGUgYWxsIHRoZSBidWZmZXJzXG4gIH1cblxuICBiaW5hcnkucmVtb3ZlQmxvYnMob2JqLCB3cml0ZUVuY29kaW5nKTtcbn1cblxuLyoqXG4gKiBBIHNvY2tldC5pbyBEZWNvZGVyIGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBkZWNvZGVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIERlY29kZXIoKSB7XG4gIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYCB3aXRoIERlY29kZXIuXG4gKi9cblxuRW1pdHRlcihEZWNvZGVyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogRGVjb2RlcyBhbiBlbmNvZGVkIHBhY2tldCBzdHJpbmcgaW50byBwYWNrZXQgSlNPTi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb2JqIC0gZW5jb2RlZCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgcGFja2V0O1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICBwYWNrZXQgPSBkZWNvZGVTdHJpbmcob2JqKTtcbiAgICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IHBhY2tldC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PT0gcGFja2V0LnR5cGUpIHsgLy8gYmluYXJ5IHBhY2tldCdzIGpzb25cbiAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG5ldyBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCk7XG5cbiAgICAgIC8vIG5vIGF0dGFjaG1lbnRzLCBsYWJlbGVkIGJpbmFyeSBidXQgbm8gYmluYXJ5IGRhdGEgdG8gZm9sbG93XG4gICAgICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yLnJlY29uUGFjay5hdHRhY2htZW50cyA9PT0gMCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIG5vbi1iaW5hcnkgZnVsbCBwYWNrZXRcbiAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQnVmKG9iaikgfHwgb2JqLmJhc2U2NCkgeyAvLyByYXcgYmluYXJ5IGRhdGFcbiAgICBpZiAoIXRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnb3QgYmluYXJ5IGRhdGEgd2hlbiBub3QgcmVjb25zdHJ1Y3RpbmcgYSBwYWNrZXQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFja2V0ID0gdGhpcy5yZWNvbnN0cnVjdG9yLnRha2VCaW5hcnlEYXRhKG9iaik7XG4gICAgICBpZiAocGFja2V0KSB7IC8vIHJlY2VpdmVkIGZpbmFsIGJ1ZmZlclxuICAgICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xuICAgICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZTogJyArIG9iaik7XG4gIH1cbn07XG5cbi8qKlxuICogRGVjb2RlIGEgcGFja2V0IFN0cmluZyAoSlNPTiBkYXRhKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBkZWNvZGVTdHJpbmcoc3RyKSB7XG4gIHZhciBpID0gMDtcbiAgLy8gbG9vayB1cCB0eXBlXG4gIHZhciBwID0ge1xuICAgIHR5cGU6IE51bWJlcihzdHIuY2hhckF0KDApKVxuICB9O1xuXG4gIGlmIChudWxsID09IGV4cG9ydHMudHlwZXNbcC50eXBlXSkge1xuICAgIHJldHVybiBlcnJvcigndW5rbm93biBwYWNrZXQgdHlwZSAnICsgcC50eXBlKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAgYXR0YWNobWVudHMgaWYgdHlwZSBiaW5hcnlcbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBwLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBwLnR5cGUpIHtcbiAgICB2YXIgYnVmID0gJyc7XG4gICAgd2hpbGUgKHN0ci5jaGFyQXQoKytpKSAhPT0gJy0nKSB7XG4gICAgICBidWYgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoYnVmICE9IE51bWJlcihidWYpIHx8IHN0ci5jaGFyQXQoaSkgIT09ICctJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGF0dGFjaG1lbnRzJyk7XG4gICAgfVxuICAgIHAuYXR0YWNobWVudHMgPSBOdW1iZXIoYnVmKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAgbmFtZXNwYWNlIChpZiBhbnkpXG4gIGlmICgnLycgPT09IHN0ci5jaGFyQXQoaSArIDEpKSB7XG4gICAgcC5uc3AgPSAnJztcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoJywnID09PSBjKSBicmVhaztcbiAgICAgIHAubnNwICs9IGM7XG4gICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHAubnNwID0gJy8nO1xuICB9XG5cbiAgLy8gbG9vayB1cCBpZFxuICB2YXIgbmV4dCA9IHN0ci5jaGFyQXQoaSArIDEpO1xuICBpZiAoJycgIT09IG5leHQgJiYgTnVtYmVyKG5leHQpID09IG5leHQpIHtcbiAgICBwLmlkID0gJyc7XG4gICAgd2hpbGUgKCsraSkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKG51bGwgPT0gYyB8fCBOdW1iZXIoYykgIT0gYykge1xuICAgICAgICAtLWk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcC5pZCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBwLmlkID0gTnVtYmVyKHAuaWQpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBqc29uIGRhdGFcbiAgaWYgKHN0ci5jaGFyQXQoKytpKSkge1xuICAgIHZhciBwYXlsb2FkID0gdHJ5UGFyc2Uoc3RyLnN1YnN0cihpKSk7XG4gICAgdmFyIGlzUGF5bG9hZFZhbGlkID0gcGF5bG9hZCAhPT0gZmFsc2UgJiYgKHAudHlwZSA9PT0gZXhwb3J0cy5FUlJPUiB8fCBpc0FycmF5KHBheWxvYWQpKTtcbiAgICBpZiAoaXNQYXlsb2FkVmFsaWQpIHtcbiAgICAgIHAuZGF0YSA9IHBheWxvYWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlcnJvcignaW52YWxpZCBwYXlsb2FkJyk7XG4gICAgfVxuICB9XG5cbiAgZGVidWcoJ2RlY29kZWQgJXMgYXMgJWonLCBzdHIsIHApO1xuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gdHJ5UGFyc2Uoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWFsbG9jYXRlcyBhIHBhcnNlcidzIHJlc291cmNlc1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgdGhpcy5yZWNvbnN0cnVjdG9yLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBIG1hbmFnZXIgb2YgYSBiaW5hcnkgZXZlbnQncyAnYnVmZmVyIHNlcXVlbmNlJy4gU2hvdWxkXG4gKiBiZSBjb25zdHJ1Y3RlZCB3aGVuZXZlciBhIHBhY2tldCBvZiB0eXBlIEJJTkFSWV9FVkVOVCBpc1xuICogZGVjb2RlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtCaW5hcnlSZWNvbnN0cnVjdG9yfSBpbml0aWFsaXplZCByZWNvbnN0cnVjdG9yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCkge1xuICB0aGlzLnJlY29uUGFjayA9IHBhY2tldDtcbiAgdGhpcy5idWZmZXJzID0gW107XG59XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGNhbGxlZCB3aGVuIGJpbmFyeSBkYXRhIHJlY2VpdmVkIGZyb20gY29ubmVjdGlvblxuICogYWZ0ZXIgYSBCSU5BUllfRVZFTlQgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyIHwgQXJyYXlCdWZmZXJ9IGJpbkRhdGEgLSB0aGUgcmF3IGJpbmFyeSBkYXRhIHJlY2VpdmVkXG4gKiBAcmV0dXJuIHtudWxsIHwgT2JqZWN0fSByZXR1cm5zIG51bGwgaWYgbW9yZSBiaW5hcnkgZGF0YSBpcyBleHBlY3RlZCBvclxuICogICBhIHJlY29uc3RydWN0ZWQgcGFja2V0IG9iamVjdCBpZiBhbGwgYnVmZmVycyBoYXZlIGJlZW4gcmVjZWl2ZWQuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5CaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS50YWtlQmluYXJ5RGF0YSA9IGZ1bmN0aW9uKGJpbkRhdGEpIHtcbiAgdGhpcy5idWZmZXJzLnB1c2goYmluRGF0YSk7XG4gIGlmICh0aGlzLmJ1ZmZlcnMubGVuZ3RoID09PSB0aGlzLnJlY29uUGFjay5hdHRhY2htZW50cykgeyAvLyBkb25lIHdpdGggYnVmZmVyIGxpc3RcbiAgICB2YXIgcGFja2V0ID0gYmluYXJ5LnJlY29uc3RydWN0UGFja2V0KHRoaXMucmVjb25QYWNrLCB0aGlzLmJ1ZmZlcnMpO1xuICAgIHRoaXMuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICAgIHJldHVybiBwYWNrZXQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBiaW5hcnkgcGFja2V0IHJlY29uc3RydWN0aW9uIHZhcmlhYmxlcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5CaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS5maW5pc2hlZFJlY29uc3RydWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVjb25QYWNrID0gbnVsbDtcbiAgdGhpcy5idWZmZXJzID0gW107XG59O1xuXG5mdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBleHBvcnRzLkVSUk9SLFxuICAgIGRhdGE6ICdwYXJzZXIgZXJyb3I6ICcgKyBtc2dcbiAgfTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogRGV0ZWN0IEVsZWN0cm9uIHJlbmRlcmVyIC8gbndqcyBwcm9jZXNzLCB3aGljaCBpcyBub2RlLCBidXQgd2Ugc2hvdWxkXG4gKiB0cmVhdCBhcyBhIGJyb3dzZXIuXG4gKi9cblxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCBwcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgcHJvY2Vzcy5icm93c2VyID09PSB0cnVlIHx8IHByb2Nlc3MuX19ud2pzKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9icm93c2VyLmpzJyk7XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbm9kZS5qcycpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm5ldFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcIm5ldFwiXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFtbXCIwXCIsXCJcXHUwMDAwXCIsMTI3LFwi4oKsXCJdLFtcIjgxNDBcIixcIuS4guS4hOS4heS4huS4j+S4kuS4l+S4n+S4oOS4oeS4o+S4puS4qeS4ruS4r+S4seS4s+S4teS4t+S4vOS5gOS5geS5guS5hOS5huS5iuS5keS5leS5l+S5muS5m+S5ouS5o+S5pOS5peS5p+S5qOS5qlwiLDUsXCLkubLkubRcIiw5LFwi5Lm/XCIsNixcIuS6h+S6ilwiXSxbXCI4MTgwXCIsXCLkupDkupbkupfkupnkupzkup3kup7kuqPkuqrkuq/kurDkurHkurTkurbkurfkurjkurnkurzkur3kur7ku4jku4zku4/ku5Dku5Lku5rku5vku5zku6Dku6Lku6bku6fku6nku63ku67ku6/ku7Hku7Tku7jku7nku7rku7zku77kvIDkvIJcIiw2LFwi5LyL5LyM5LySXCIsNCxcIuS8nOS8neS8oeS8o+S8qOS8qeS8rOS8reS8ruS8seS8s+S8teS8t+S8ueS8u+S8vlwiLDQsXCLkvYTkvYXkvYdcIiw1LFwi5L2S5L2U5L2W5L2h5L2i5L2m5L2o5L2q5L2r5L2t5L2u5L2x5L2y5L215L235L245L255L265L295L6A5L6B5L6C5L6F5L6G5L6H5L6K5L6M5L6O5L6Q5L6S5L6T5L6V5L6W5L6Y5L6Z5L6a5L6c5L6e5L6f5L6h5L6iXCJdLFtcIjgyNDBcIixcIuS+pOS+q+S+reS+sFwiLDQsXCLkvrZcIiw4LFwi5L+A5L+B5L+C5L+G5L+H5L+I5L+J5L+L5L+M5L+N5L+SXCIsNCxcIuS/meS/m+S/oOS/ouS/pOS/peS/p+S/q+S/rOS/sOS/suS/tOS/teS/tuS/t+S/ueS/u+S/vOS/veS/v1wiLDExXSxbXCI4MjgwXCIsXCLlgIvlgI7lgJDlgJHlgJPlgJXlgJblgJflgJvlgJ3lgJ7lgKDlgKLlgKPlgKTlgKflgKvlgK9cIiwxMCxcIuWAu+WAveWAv+WBgOWBgeWBguWBhOWBheWBhuWBieWBiuWBi+WBjeWBkFwiLDQsXCLlgZblgZflgZjlgZnlgZvlgZ1cIiw3LFwi5YGmXCIsNSxcIuWBrVwiLDgsXCLlgbjlgbnlgbrlgbzlgb3lgoHlgoLlgoPlgoTlgoblgoflgonlgorlgovlgozlgo5cIiwyMCxcIuWCpOWCpuWCquWCq+WCrVwiLDQsXCLlgrNcIiw2LFwi5YK8XCJdLFtcIjgzNDBcIixcIuWCvVwiLDE3LFwi5YOQXCIsNSxcIuWDl+WDmOWDmeWDm1wiLDEwLFwi5YOo5YOp5YOq5YOr5YOv5YOw5YOx5YOy5YO05YO2XCIsNCxcIuWDvFwiLDksXCLlhIhcIl0sW1wiODM4MFwiLFwi5YSJ5YSK5YSMXCIsNSxcIuWEk1wiLDEzLFwi5YSiXCIsMjgsXCLlhYLlhYflhYrlhYzlhY7lhY/lhZDlhZLlhZPlhZflhZjlhZnlhZvlhZ1cIiw0LFwi5YWj5YWk5YWm5YWn5YWp5YWq5YWv5YWy5YW65YW+5YW/5YaD5YaE5YaG5YaH5YaK5YaL5YaO5YaP5YaQ5YaR5YaT5YaU5YaY5Yaa5Yad5Yae5Yaf5Yah5Yaj5YamXCIsNCxcIuWGreWGruWGtOWGuOWGueWGuuWGvuWGv+WHgeWHguWHg+WHheWHiOWHiuWHjeWHjuWHkOWHklwiLDVdLFtcIjg0NDBcIixcIuWHmOWHmeWHmuWHnOWHnuWHn+WHouWHo+WHpVwiLDUsXCLlh6zlh67lh7Hlh7Llh7Tlh7flh77liITliIXliInliIvliIzliI/liJDliJPliJTliJXliJzliJ7liJ/liKHliKLliKPliKXliKbliKfliKrliKzliK/liLHliLLliLTliLXliLzliL7liYRcIiw1LFwi5YmL5YmO5YmP5YmS5YmT5YmV5YmX5YmYXCJdLFtcIjg0ODBcIixcIuWJmeWJmuWJm+WJneWJn+WJoOWJouWJo+WJpOWJpuWJqOWJq+WJrOWJreWJruWJsOWJseWJs1wiLDksXCLlib7lioDlioNcIiw0LFwi5YqJXCIsNixcIuWKkeWKkuWKlFwiLDYsXCLlipzliqTliqXliqbliqfliq7liq/lirDlirRcIiw5LFwi5YuA5YuB5YuC5YuE5YuF5YuG5YuI5YuK5YuM5YuN5YuO5YuP5YuR5YuT5YuU5YuV5YuX5YuZXCIsNSxcIuWLoOWLoeWLouWLo+WLpVwiLDEwLFwi5YuxXCIsNyxcIuWLu+WLvOWLveWMgeWMguWMg+WMhOWMh+WMieWMiuWMi+WMjOWMjlwiXSxbXCI4NTQwXCIsXCLljJHljJLljJPljJTljJjljJvljJzljJ7ljJ/ljKLljKTljKXljKfljKjljKnljKvljKzljK3ljK9cIiw5LFwi5Yy85Yy95Y2A5Y2C5Y2E5Y2G5Y2L5Y2M5Y2N5Y2Q5Y2U5Y2Y5Y2Z5Y2b5Y2d5Y2l5Y2o5Y2q5Y2s5Y2t5Y2y5Y225Y255Y275Y285Y295Y2+5Y6A5Y6B5Y6D5Y6H5Y6I5Y6K5Y6O5Y6PXCJdLFtcIjg1ODBcIixcIuWOkFwiLDQsXCLljpbljpfljpnljpvljpzljp7ljqDljqHljqTljqfljqrljqvljqzljq3ljq9cIiw2LFwi5Y635Y645Y655Y665Y685Y695Y6+5Y+A5Y+DXCIsNCxcIuWPjuWPj+WPkOWPkuWPk+WPleWPmuWPnOWPneWPnuWPoeWPouWPp+WPtOWPuuWPvuWPv+WQgOWQguWQheWQh+WQi+WQlOWQmOWQmeWQmuWQnOWQouWQpOWQpeWQquWQsOWQs+WQtuWQt+WQuuWQveWQv+WRgeWRguWRhOWRheWRh+WRieWRjOWRjeWRjuWRj+WRkeWRmuWRnVwiLDQsXCLlkaPlkaXlkaflkalcIiw3LFwi5ZG05ZG55ZG65ZG+5ZG/5ZKB5ZKD5ZKF5ZKH5ZKI5ZKJ5ZKK5ZKN5ZKR5ZKT5ZKX5ZKY5ZKc5ZKe5ZKf5ZKg5ZKhXCJdLFtcIjg2NDBcIixcIuWSouWSpeWSruWSsOWSsuWSteWStuWSt+WSueWSuuWSvOWSvuWTg+WTheWTiuWTi+WTluWTmOWTm+WToFwiLDQsXCLlk6vlk6zlk6/lk7Dlk7Hlk7RcIiw1LFwi5ZO75ZO+5ZSA5ZSC5ZSD5ZSE5ZSF5ZSI5ZSKXCIsNCxcIuWUkuWUk+WUlVwiLDUsXCLllJzllJ3llJ7llJ/llKHllKXllKZcIl0sW1wiODY4MFwiLFwi5ZSo5ZSp5ZSr5ZSt5ZSy5ZS05ZS15ZS25ZS45ZS55ZS65ZS75ZS95ZWA5ZWC5ZWF5ZWH5ZWI5ZWLXCIsNCxcIuWVkeWVkuWVk+WVlOWVl1wiLDQsXCLllZ3llZ7llZ/llaDllaLllaPllajllanllavlla9cIiw1LFwi5ZW55ZW65ZW95ZW/5ZaF5ZaG5ZaM5ZaN5ZaO5ZaQ5ZaS5ZaT5ZaV5ZaW5ZaX5Zaa5Zab5Zae5ZagXCIsNixcIuWWqFwiLDgsXCLllrLllrTllrbllrjllrrllrzllr9cIiw0LFwi5ZeG5ZeH5ZeI5ZeK5ZeL5ZeO5ZeP5ZeQ5ZeV5ZeXXCIsNCxcIuWXnuWXoOWXouWXp+WXqeWXreWXruWXsOWXseWXtOWXtuWXuFwiLDQsXCLll7/lmILlmIPlmITlmIVcIl0sW1wiODc0MFwiLFwi5ZiG5ZiH5ZiK5ZiL5ZiN5ZiQXCIsNyxcIuWYmeWYmuWYnOWYneWYoOWYoeWYouWYpeWYpuWYqOWYqeWYquWYq+WYruWYr+WYsOWYs+WYteWYt+WYuOWYuuWYvOWYveWYvuWZgFwiLDExLFwi5ZmPXCIsNCxcIuWZleWZluWZmuWZm+WZnVwiLDRdLFtcIjg3ODBcIixcIuWZo+WZpeWZpuWZp+WZreWZruWZr+WZsOWZsuWZs+WZtOWZteWZt+WZuOWZueWZuuWZvVwiLDcsXCLlmodcIiw2LFwi5ZqQ5ZqR5ZqS5ZqUXCIsMTQsXCLlmqRcIiwxMCxcIuWasFwiLDYsXCLlmrjlmrnlmrrlmrvlmr1cIiwxMixcIuWbi1wiLDgsXCLlm5Xlm5blm5jlm5nlm5zlm6Plm6VcIiw1LFwi5Zus5Zuu5Zuv5Zuy5Zuz5Zu25Zu35Zu45Zu75Zu85ZyA5ZyB5ZyC5ZyF5ZyH5ZyLXCIsNl0sW1wiODg0MFwiLFwi5ZySXCIsOSxcIuWcneWcnuWcoOWcoeWcouWcpOWcpeWcpuWcp+Wcq+WcseWcsuWctFwiLDQsXCLlnLzlnL3lnL/lnYHlnYPlnYTlnYXlnYblnYjlnYnlnYvlnZJcIiw0LFwi5Z2Y5Z2Z5Z2i5Z2j5Z2l5Z2n5Z2s5Z2u5Z2w5Z2x5Z2y5Z205Z215Z245Z255Z265Z295Z2+5Z2/5Z6AXCJdLFtcIjg4ODBcIixcIuWegeWeh+WeiOWeieWeiuWejVwiLDQsXCLlnpRcIiw2LFwi5Z6c5Z6d5Z6e5Z6f5Z6l5Z6o5Z6q5Z6s5Z6v5Z6w5Z6x5Z6z5Z615Z625Z635Z65XCIsOCxcIuWfhFwiLDYsXCLln4zln43ln5Dln5Hln5Pln5bln5fln5vln5zln57ln6Hln6Lln6Pln6VcIiw3LFwi5Z+u5Z+w5Z+x5Z+y5Z+z5Z+15Z+25Z+35Z+75Z+85Z++5Z+/5aCB5aCD5aCE5aCF5aCI5aCJ5aCK5aCM5aCO5aCP5aCQ5aCS5aCT5aCU5aCW5aCX5aCY5aCa5aCb5aCc5aCd5aCf5aCi5aCj5aClXCIsNCxcIuWgq1wiLDQsXCLloLHloLLloLPloLTloLZcIiw3XSxbXCI4OTQwXCIsXCLloL5cIiw1LFwi5aGFXCIsNixcIuWhjuWhj+WhkOWhkuWhk+WhleWhluWhl+WhmVwiLDQsXCLloZ9cIiw1LFwi5aGmXCIsNCxcIuWhrVwiLDE2LFwi5aG/5aKC5aKE5aKG5aKH5aKI5aKK5aKL5aKMXCJdLFtcIjg5ODBcIixcIuWijVwiLDQsXCLlopRcIiw0LFwi5aKb5aKc5aKd5aKgXCIsNyxcIuWiqlwiLDE3LFwi5aK95aK+5aK/5aOA5aOC5aOD5aOE5aOGXCIsMTAsXCLlo5Llo5Plo5Tlo5ZcIiwxMyxcIuWjpVwiLDUsXCLlo63lo6/lo7Hlo7Llo7Tlo7Xlo7flo7jlo7pcIiw3LFwi5aSD5aSF5aSG5aSIXCIsNCxcIuWkjuWkkOWkkeWkkuWkk+Wkl+WkmOWkm+WkneWknuWkoOWkoeWkouWko+WkpuWkqOWkrOWksOWksuWks+WkteWktuWku1wiXSxbXCI4YTQwXCIsXCLlpL3lpL7lpL/lpYDlpYPlpYXlpYblpYrlpYzlpY3lpZDlpZLlpZPlpZnlpZtcIiw0LFwi5aWh5aWj5aWk5aWmXCIsMTIsXCLlpbXlpbflpbrlpbvlpbzlpb7lpb/lpoDlpoXlponlpovlpozlpo7lpo/lppDlppHlppTlppXlppjlpprlppvlppzlpp3lpp/lpqDlpqHlpqLlpqZcIl0sW1wiOGE4MFwiLFwi5aan5aas5aat5aaw5aax5aazXCIsNSxcIuWmuuWmvOWmveWmv1wiLDYsXCLlp4flp4jlp4nlp4zlp43lp47lp4/lp5Xlp5blp5nlp5vlp55cIiw0LFwi5aek5aem5aen5aep5aeq5aer5aetXCIsMTEsXCLlp7rlp7zlp73lp77lqIDlqILlqIrlqIvlqI3lqI7lqI/lqJDlqJLlqJTlqJXlqJblqJflqJnlqJrlqJvlqJ3lqJ7lqKHlqKLlqKTlqKblqKflqKjlqKpcIiw2LFwi5aiz5ai15ai3XCIsNCxcIuWoveWovuWov+WpgVwiLDQsXCLlqYflqYjlqYtcIiw5LFwi5amW5amX5amY5amZ5ambXCIsNV0sW1wiOGI0MFwiLFwi5amh5amj5amk5aml5amm5amo5amp5amrXCIsOCxcIuWpuOWpueWpu+WpvOWpveWpvuWqgFwiLDE3LFwi5aqTXCIsNixcIuWqnFwiLDEzLFwi5aqr5aqsXCJdLFtcIjhiODBcIixcIuWqrVwiLDQsXCLlqrTlqrblqrflqrlcIiw0LFwi5aq/5auA5auDXCIsNSxcIuWriuWri+WrjVwiLDQsXCLlq5Plq5Xlq5flq5nlq5rlq5vlq53lq57lq5/lq6Llq6Tlq6Xlq6flq6jlq6rlq6xcIiw0LFwi5auyXCIsMjIsXCLlrIpcIiwxMSxcIuWsmFwiLDI1LFwi5ayz5ay15ay25ay4XCIsNyxcIuWtgVwiLDZdLFtcIjhjNDBcIixcIuWtiFwiLDcsXCLlrZLlrZblrZ7lraDlraHlraflrajlravlra3lra7lra/lrbLlrbTlrbblrbflrbjlrbnlrbvlrbzlrb7lrb/lroLlroblrorlro3lro7lrpDlrpHlrpLlrpTlrpblrp/lrqflrqjlrqnlrqzlrq3lrq7lrq/lrrHlrrLlrrflrrrlrrvlrrzlr4Dlr4Hlr4Plr4jlr4nlr4rlr4vlr43lr47lr49cIl0sW1wiOGM4MFwiLFwi5a+R5a+UXCIsOCxcIuWvoOWvouWvo+WvpuWvp+WvqVwiLDQsXCLlr6/lr7FcIiw2LFwi5a+95a++5bCA5bCC5bCD5bCF5bCH5bCI5bCL5bCM5bCN5bCO5bCQ5bCS5bCT5bCX5bCZ5bCb5bCe5bCf5bCg5bCh5bCj5bCm5bCo5bCp5bCq5bCr5bCt5bCu5bCv5bCw5bCy5bCz5bC15bC25bC35bGD5bGE5bGG5bGH5bGM5bGN5bGS5bGT5bGU5bGW5bGX5bGY5bGa5bGb5bGc5bGd5bGf5bGi5bGk5bGnXCIsNixcIuWxsOWxslwiLDYsXCLlsbvlsbzlsb3lsb7lsoDlsoNcIiw0LFwi5bKJ5bKK5bKL5bKO5bKP5bKS5bKT5bKV5bKdXCIsNCxcIuWypFwiLDRdLFtcIjhkNDBcIixcIuWyquWyruWyr+WysOWysuWytOWytuWyueWyuuWyu+WyvOWyvuWzgOWzguWzg+WzhVwiLDUsXCLls4xcIiw1LFwi5bOTXCIsNSxcIuWzmlwiLDYsXCLls6Lls6Pls6fls6nls6vls6zls67ls6/ls7FcIiw5LFwi5bO8XCIsNF0sW1wiOGQ4MFwiLFwi5bSB5bSE5bSF5bSIXCIsNSxcIuW0j1wiLDQsXCLltJXltJfltJjltJnltJrltJzltJ3ltJ9cIiw0LFwi5bSl5bSo5bSq5bSr5bSs5bSvXCIsNCxcIuW0tVwiLDcsXCLltL9cIiw3LFwi5bWI5bWJ5bWNXCIsMTAsXCLltZnltZrltZzltZ5cIiwxMCxcIuW1quW1reW1ruW1sOW1seW1suW1s+W1tVwiLDEyLFwi5baDXCIsMjEsXCLltprltpvltpzltp7ltp/ltqBcIl0sW1wiOGU0MFwiLFwi5bahXCIsMjEsXCLltrhcIiwxMixcIuW3hlwiLDYsXCLlt45cIiwxMixcIuW3nOW3n+W3oOW3o+W3pOW3quW3rOW3rVwiXSxbXCI4ZTgwXCIsXCLlt7Dlt7Xlt7blt7hcIiw0LFwi5be/5biA5biE5biH5biJ5biK5biL5biN5biO5biS5biT5biX5bieXCIsNyxcIuW4qFwiLDQsXCLluK/luLDluLJcIiw0LFwi5bi55bi65bi+5bi/5bmA5bmB5bmD5bmGXCIsNSxcIuW5jVwiLDYsXCLluZZcIiw0LFwi5bmc5bmd5bmf5bmg5bmjXCIsMTQsXCLlubXlubflubnlub7luoHluoLluoPluoXluojluonluozluo3luo7lupLlupjlupvlup3luqHluqLluqPluqTluqhcIiw0LFwi5bquXCIsNCxcIuW6tOW6uuW6u+W6vOW6veW6v1wiLDZdLFtcIjhmNDBcIixcIuW7huW7h+W7iOW7i1wiLDUsXCLlu5Tlu5Xlu5flu5jlu5nlu5rlu5xcIiwxMSxcIuW7qeW7q1wiLDgsXCLlu7Xlu7jlu7nlu7vlu7zlu73lvIXlvIblvIflvInlvIzlvI3lvI7lvJDlvJLlvJTlvJblvJnlvJrlvJzlvJ3lvJ7lvKHlvKLlvKPlvKRcIl0sW1wiOGY4MFwiLFwi5byo5byr5bys5byu5byw5byyXCIsNixcIuW8u+W8veW8vuW8v+W9gVwiLDE0LFwi5b2R5b2U5b2Z5b2a5b2b5b2c5b2e5b2f5b2g5b2j5b2l5b2n5b2o5b2r5b2u5b2v5b2y5b205b215b225b245b265b295b2+5b2/5b6D5b6G5b6N5b6O5b6P5b6R5b6T5b6U5b6W5b6a5b6b5b6d5b6e5b6f5b6g5b6iXCIsNSxcIuW+qeW+q+W+rOW+r1wiLDUsXCLlvrblvrjlvrnlvrrlvrvlvr5cIiw0LFwi5b+H5b+I5b+K5b+L5b+O5b+T5b+U5b+V5b+a5b+b5b+c5b+e5b+f5b+i5b+j5b+l5b+m5b+o5b+p5b+s5b+v5b+w5b+y5b+z5b+05b+25b+35b+55b+65b+85oCHXCJdLFtcIjkwNDBcIixcIuaAiOaAieaAi+aAjOaAkOaAkeaAk+aAl+aAmOaAmuaAnuaAn+aAouaAo+aApOaArOaAreaAruaAsFwiLDQsXCLmgLZcIiw0LFwi5oC95oC+5oGA5oGEXCIsNixcIuaBjOaBjuaBj+aBkeaBk+aBlOaBluaBl+aBmOaBm+aBnOaBnuaBn+aBoOaBoeaBpeaBpuaBruaBseaBsuaBtOaBteaBt+aBvuaCgFwiXSxbXCI5MDgwXCIsXCLmgoHmgoLmgoXmgobmgofmgojmgormgovmgo7mgo/mgpDmgpHmgpPmgpXmgpfmgpjmgpnmgpzmgp7mgqHmgqLmgqTmgqXmgqfmgqnmgqrmgq7mgrDmgrPmgrXmgrbmgrfmgrnmgrrmgr1cIiw3LFwi5oOH5oOI5oOJ5oOMXCIsNCxcIuaDkuaDk+aDlOaDluaDl+aDmeaDm+aDnuaDoVwiLDQsXCLmg6rmg7Hmg7Lmg7Xmg7fmg7jmg7tcIiw0LFwi5oSC5oSD5oSE5oSF5oSH5oSK5oSL5oSM5oSQXCIsNCxcIuaEluaEl+aEmOaEmeaEm+aEnOaEneaEnuaEoeaEouaEpeaEqOaEqeaEquaErFwiLDE4LFwi5oWAXCIsNl0sW1wiOTE0MFwiLFwi5oWH5oWJ5oWL5oWN5oWP5oWQ5oWS5oWT5oWU5oWWXCIsNixcIuaFnuaFn+aFoOaFoeaFo+aFpOaFpeaFpuaFqVwiLDYsXCLmhbHmhbLmhbPmhbTmhbbmhbhcIiwxOCxcIuaGjOaGjeaGj1wiLDQsXCLmhpVcIl0sW1wiOTE4MFwiLFwi5oaWXCIsNixcIuaGnlwiLDgsXCLmhqrmhqvmhq1cIiw5LFwi5oa4XCIsNSxcIuaGv+aHgOaHgeaHg1wiLDQsXCLmh4nmh4xcIiw0LFwi5oeT5oeVXCIsMTYsXCLmh6dcIiwxMyxcIuaHtlwiLDgsXCLmiIBcIiw1LFwi5oiH5oiJ5oiT5oiU5oiZ5oic5oid5oie5oig5oij5oim5oin5oio5oip5oir5oit5oiv5oiw5oix5oiy5oi15oi25oi4XCIsNCxcIuaJguaJhOaJheaJhuaJilwiXSxbXCI5MjQwXCIsXCLmiY/miZDmiZXmiZbmiZfmiZnmiZrmiZxcIiw2LFwi5omk5oml5omo5omx5omy5om05om15om35om45om65om75om95oqB5oqC5oqD5oqF5oqG5oqH5oqI5oqLXCIsNSxcIuaKlOaKmeaKnOaKneaKnuaKo+aKpuaKp+aKqeaKquaKreaKruaKr+aKsOaKsuaKs+aKtOaKtuaKt+aKuOaKuuaKvuaLgOaLgVwiXSxbXCI5MjgwXCIsXCLmi4Pmi4vmi4/mi5Hmi5Xmi53mi57mi6Dmi6Hmi6Tmi6rmi6vmi7Dmi7Lmi7Xmi7jmi7nmi7rmi7vmjIDmjIPmjITmjIXmjIbmjIrmjIvmjIzmjI3mjI/mjJDmjJLmjJPmjJTmjJXmjJfmjJjmjJnmjJzmjKbmjKfmjKnmjKzmjK3mjK7mjLDmjLHmjLNcIiw1LFwi5oy75oy85oy+5oy/5o2A5o2B5o2E5o2H5o2I5o2K5o2R5o2S5o2T5o2U5o2WXCIsNyxcIuaNoOaNpOaNpeaNpuaNqOaNquaNq+aNrOaNr+aNsOaNsuaNs+aNtOaNteaNuOaNueaNvOaNveaNvuaNv+aOgeaOg+aOhOaOheaOhuaOi+aOjeaOkeaOk+aOlOaOleaOl+aOmVwiLDYsXCLmjqHmjqTmjqbmjqvmjq/mjrHmjrLmjrXmjrbmjrnmjrvmjr3mjr/mj4BcIl0sW1wiOTM0MFwiLFwi5o+B5o+C5o+D5o+F5o+H5o+I5o+K5o+L5o+M5o+R5o+T5o+U5o+V5o+XXCIsNixcIuaPn+aPouaPpFwiLDQsXCLmj6vmj6zmj67mj6/mj7Dmj7Hmj7Pmj7Xmj7fmj7nmj7rmj7vmj7zmj77mkIPmkITmkIZcIiw0LFwi5pCN5pCO5pCR5pCS5pCVXCIsNSxcIuaQneaQn+aQouaQo+aQpFwiXSxbXCI5MzgwXCIsXCLmkKXmkKfmkKjmkKnmkKvmkK5cIiw1LFwi5pC1XCIsNCxcIuaQu+aQvOaQvuaRgOaRguaRg+aRieaRi1wiLDYsXCLmkZPmkZXmkZbmkZfmkZlcIiw0LFwi5pGfXCIsNyxcIuaRqOaRquaRq+aRrOaRrlwiLDksXCLmkbtcIiw2LFwi5pKD5pKG5pKIXCIsOCxcIuaSk+aSlOaSl+aSmOaSmuaSm+aSnOaSneaSn1wiLDQsXCLmkqXmkqbmkqfmkqjmkqrmkqvmkq/mkrHmkrLmkrPmkrTmkrbmkrnmkrvmkr3mkr7mkr/mk4Hmk4Pmk4Tmk4ZcIiw2LFwi5pOP5pOR5pOT5pOU5pOV5pOW5pOZ5pOaXCJdLFtcIjk0NDBcIixcIuaTm+aTnOaTneaTn+aToOaToeaTo+aTpeaTp1wiLDI0LFwi5pSBXCIsNyxcIuaUilwiLDcsXCLmlJNcIiw0LFwi5pSZXCIsOF0sW1wiOTQ4MFwiLFwi5pSi5pSj5pSk5pSmXCIsNCxcIuaUrOaUreaUsOaUseaUsuaUs+aUt+aUuuaUvOaUveaVgFwiLDQsXCLmlYbmlYfmlYrmlYvmlY3mlY7mlZDmlZLmlZPmlZTmlZfmlZjmlZrmlZzmlZ/mlaDmlaHmlaTmlaXmlafmlajmlanmlarmla3mla7mla/mlbHmlbPmlbXmlbbmlbhcIiwxNCxcIuaWiOaWieaWiuaWjeaWjuaWj+aWkuaWlOaWleaWluaWmOaWmuaWneaWnuaWoOaWouaWo+aWpuaWqOaWquaWrOaWruaWsVwiLDcsXCLmlrrmlrvmlr7mlr/ml4Dml4Lml4fml4jml4nml4rml43ml5Dml5Hml5Pml5Tml5Xml5hcIiw3LFwi5peh5pej5pek5peq5perXCJdLFtcIjk1NDBcIixcIuaXsuaXs+aXtOaXteaXuOaXueaXu1wiLDQsXCLmmIHmmITmmIXmmIfmmIjmmInmmIvmmI3mmJDmmJHmmJLmmJbmmJfmmJjmmJrmmJvmmJzmmJ7mmKHmmKLmmKPmmKTmmKbmmKnmmKrmmKvmmKzmmK7mmLDmmLLmmLPmmLdcIiw0LFwi5pi95pi/5pmA5pmC5pmEXCIsNixcIuaZjeaZjuaZkOaZkeaZmFwiXSxbXCI5NTgwXCIsXCLmmZnmmZvmmZzmmZ3mmZ7mmaDmmaLmmaPmmaXmmafmmalcIiw0LFwi5pmx5pmy5pmz5pm15pm45pm55pm75pm85pm95pm/5pqA5pqB5pqD5pqF5pqG5pqI5pqJ5pqK5pqL5pqN5pqO5pqP5pqQ5pqS5pqT5pqU5pqV5pqYXCIsNCxcIuaanlwiLDgsXCLmmqlcIiw0LFwi5pqvXCIsNCxcIuaateaatuaat+aauOaauuaau+aavOaaveaav1wiLDI1LFwi5pua5pueXCIsNyxcIuabp+abqOabqlwiLDUsXCLmm7Hmm7Xmm7bmm7jmm7rmm7vmm73mnIHmnILmnINcIl0sW1wiOTY0MFwiLFwi5pyE5pyF5pyG5pyH5pyM5pyO5pyP5pyR5pyS5pyT5pyW5pyY5pyZ5pya5pyc5pye5pygXCIsNSxcIuacp+acqeacruacsOacsuacs+actuact+acuOacueacu+acvOacvuacv+adgeadhOadheadh+adiuadi+adjeadkuadlOadleadl1wiLDQsXCLmnZ3mnaLmnaPmnaTmnabmnafmnavmnazmna7mnbHmnbTmnbZcIl0sW1wiOTY4MFwiLFwi5p245p255p265p275p295p6A5p6C5p6D5p6F5p6G5p6I5p6K5p6M5p6N5p6O5p6P5p6R5p6S5p6T5p6U5p6W5p6Z5p6b5p6f5p6g5p6h5p6k5p6m5p6p5p6s5p6u5p6x5p6y5p605p65XCIsNyxcIuafguafhVwiLDksXCLmn5Xmn5bmn5fmn5vmn5/mn6Hmn6Pmn6Tmn6bmn6fmn6jmn6rmn6vmn63mn67mn7Lmn7VcIiw3LFwi5p++5qCB5qCC5qCD5qCE5qCG5qCN5qCQ5qCS5qCU5qCV5qCYXCIsNCxcIuagnuagn+agoOagolwiLDYsXCLmoKtcIiw2LFwi5qC05qC15qC25qC65qC75qC/5qGH5qGL5qGN5qGP5qGS5qGWXCIsNV0sW1wiOTc0MFwiLFwi5qGc5qGd5qGe5qGf5qGq5qGsXCIsNyxcIuahteahuFwiLDgsXCLmooLmooTmoodcIiw3LFwi5qKQ5qKR5qKS5qKU5qKV5qKW5qKYXCIsOSxcIuaio+aipOaipeaiqeaiquaiq+airOairuaiseaisuaitOaituait+aiuFwiXSxbXCI5NzgwXCIsXCLmorlcIiw2LFwi5qOB5qODXCIsNSxcIuajiuajjOajjuajj+ajkOajkeajk+ajlOajluajl+ajmeajm1wiLDQsXCLmo6Hmo6Lmo6RcIiw5LFwi5qOv5qOy5qOz5qO05qO25qO35qO45qO75qO95qO+5qO/5qSA5qSC5qSD5qSE5qSGXCIsNCxcIuakjOakj+akkeakk1wiLDExLFwi5qSh5qSi5qSj5qSlXCIsNyxcIuakruakr+akseaksuaks+akteaktuakt+akuOakuuaku+akvOakvualgOalgealg1wiLDE2LFwi5qWV5qWW5qWY5qWZ5qWb5qWc5qWfXCJdLFtcIjk4NDBcIixcIualoealoualpOalpealp+alqOalqealqualrOalrealr+alsOalslwiLDQsXCLmpbrmpbvmpb3mpb7mpb/mpoHmpoPmpoXmpormpovmpozmpo5cIiw1LFwi5qaW5qaX5qaZ5qaa5qadXCIsOSxcIuamqeamquamrOamruamr+amsOamsuams+amteamtuamuOamueamuuamvOamvVwiXSxbXCI5ODgwXCIsXCLmpr7mpr/mp4Dmp4JcIiw3LFwi5qeL5qeN5qeP5qeR5qeS5qeT5qeVXCIsNSxcIuannOanneannuanoVwiLDExLFwi5qeu5qev5qew5qex5qezXCIsOSxcIuanvuaogFwiLDksXCLmqItcIiwxMSxcIuaomVwiLDUsXCLmqKDmqKJcIiw1LFwi5qip5qir5qis5qit5qiu5qiw5qiy5qiz5qi05qi2XCIsNixcIuaov1wiLDQsXCLmqYXmqYbmqYhcIiw3LFwi5qmRXCIsNixcIuapmlwiXSxbXCI5OTQwXCIsXCLmqZxcIiw0LFwi5qmi5qmj5qmk5qmmXCIsMTAsXCLmqbJcIiw2LFwi5qm65qm75qm95qm+5qm/5qqB5qqC5qqD5qqFXCIsOCxcIuaqj+aqklwiLDQsXCLmqphcIiw3LFwi5qqhXCIsNV0sW1wiOTk4MFwiLFwi5qqn5qqo5qqq5qqtXCIsMTE0LFwi5qyl5qym5qyoXCIsNl0sW1wiOWE0MFwiLFwi5qyv5qyw5qyx5qyz5qy05qy15qy25qy45qy75qy85qy95qy/5q2A5q2B5q2C5q2E5q2F5q2I5q2K5q2L5q2NXCIsMTEsXCLmrZpcIiw3LFwi5q2o5q2p5q2rXCIsMTMsXCLmrbrmrb3mrb7mrb/mroDmroXmrohcIl0sW1wiOWE4MFwiLFwi5q6M5q6O5q6P5q6Q5q6R5q6U5q6V5q6X5q6Y5q6Z5q6cXCIsNCxcIuauolwiLDcsXCLmrqtcIiw3LFwi5q625q64XCIsNixcIuavgOavg+avhOavhlwiLDQsXCLmr4zmr47mr5Dmr5Hmr5jmr5rmr5xcIiw0LFwi5q+iXCIsNyxcIuavrOavreavruavsOavseavsuavtOavtuavt+avuOavuuavu+avvOavvlwiLDYsXCLmsIhcIiw0LFwi5rCO5rCS5rCX5rCc5rCd5rCe5rCg5rCj5rCl5rCr5rCs5rCt5rCx5rCz5rC25rC35rC55rC65rC75rC85rC+5rC/5rGD5rGE5rGF5rGI5rGLXCIsNCxcIuaxkeaxkuaxk+axluaxmFwiXSxbXCI5YjQwXCIsXCLmsZnmsZrmsaLmsaPmsaXmsabmsafmsatcIiw0LFwi5rGx5rGz5rG15rG35rG45rG65rG75rG85rG/5rKA5rKE5rKH5rKK5rKL5rKN5rKO5rKR5rKS5rKV5rKW5rKX5rKY5rKa5rKc5rKd5rKe5rKg5rKi5rKo5rKs5rKv5rKw5rK05rK15rK25rK35rK65rOA5rOB5rOC5rOD5rOG5rOH5rOI5rOL5rON5rOO5rOP5rOR5rOS5rOYXCJdLFtcIjliODBcIixcIuazmeazmuaznOazneazn+azpOazpuazp+azqeazrOazreazsuaztOazueazv+a0gOa0gua0g+a0hea0hua0iOa0iea0iua0jea0j+a0kOa0kea0k+a0lOa0lea0lua0mOa0nOa0nea0n1wiLDUsXCLmtKbmtKjmtKnmtKzmtK3mtK/mtLDmtLTmtLbmtLfmtLjmtLrmtL/mtYDmtYLmtYTmtYnmtYzmtZDmtZXmtZbmtZfmtZjmtZvmtZ3mtZ/mtaHmtaLmtaTmtaXmtafmtajmtavmtazmta3mtbDmtbHmtbLmtbPmtbXmtbbmtbnmtbrmtbvmtb1cIiw0LFwi5raD5raE5raG5raH5raK5raL5raN5raP5raQ5raS5raWXCIsNCxcIua2nOa2oua2pea2rOa2rea2sOa2sea2s+a2tOa2tua2t+a2uVwiLDUsXCLmt4Hmt4Lmt4Pmt4jmt4nmt4pcIl0sW1wiOWM0MFwiLFwi5reN5reO5reP5reQ5reS5reT5reU5reV5reX5rea5reb5rec5ref5rei5rej5rel5ren5reo5rep5req5ret5rev5rew5rey5re05re15re25re45re65re9XCIsNyxcIua4hua4h+a4iOa4iea4i+a4j+a4kua4k+a4lea4mOa4mea4m+a4nOa4nua4n+a4oua4pua4p+a4qOa4qua4rOa4rua4sOa4sea4s+a4tVwiXSxbXCI5YzgwXCIsXCLmuLbmuLfmuLnmuLtcIiw3LFwi5rmFXCIsNyxcIua5j+a5kOa5kea5kua5lea5l+a5mea5mua5nOa5nea5nua5oFwiLDEwLFwi5rms5rmt5rmvXCIsMTQsXCLmuoDmuoHmuoLmuoTmuofmuojmuopcIiw0LFwi5rqRXCIsNixcIua6mea6mua6m+a6nea6nua6oOa6oea6o+a6pOa6pua6qOa6qea6q+a6rOa6rea6rua6sOa6s+a6tea6uOa6uea6vOa6vua6v+a7gOa7g+a7hOa7hea7hua7iOa7iea7iua7jOa7jea7jua7kOa7kua7lua7mOa7mea7m+a7nOa7nea7o+a7p+a7qlwiLDVdLFtcIjlkNDBcIixcIua7sOa7sea7sua7s+a7tea7tua7t+a7uOa7ulwiLDcsXCLmvIPmvITmvIXmvIfmvIjmvIpcIiw0LFwi5ryQ5ryR5ryS5ryWXCIsOSxcIua8oea8oua8o+a8pea8pua8p+a8qOa8rOa8rua8sOa8sua8tOa8tea8t1wiLDYsXCLmvL/mvYDmvYHmvYJcIl0sW1wiOWQ4MFwiLFwi5r2D5r2E5r2F5r2I5r2J5r2K5r2M5r2OXCIsOSxcIua9mea9mua9m+a9nea9n+a9oOa9oea9o+a9pOa9pea9p1wiLDUsXCLmva/mvbDmvbHmvbPmvbXmvbbmvbfmvbnmvbvmvb1cIiw2LFwi5r6F5r6G5r6H5r6K5r6L5r6PXCIsMTIsXCLmvp3mvp7mvp/mvqDmvqJcIiw0LFwi5r6oXCIsMTAsXCLmvrTmvrXmvrfmvrjmvrpcIiw1LFwi5r+B5r+DXCIsNSxcIua/ilwiLDYsXCLmv5NcIiwxMCxcIua/n+a/oua/o+a/pOa/pVwiXSxbXCI5ZTQwXCIsXCLmv6ZcIiw3LFwi5r+wXCIsMzIsXCLngJJcIiw3LFwi54CcXCIsNixcIueApFwiLDZdLFtcIjllODBcIixcIueAq1wiLDksXCLngLbngLfngLjngLpcIiwxNyxcIueBjeeBjueBkFwiLDEzLFwi54GfXCIsMTEsXCLnga7ngbHngbLngbPngbTngbfngbnngbrngbvngb3ngoHngoLngoPngoTngobngofngojngovngozngo3ngo/ngpDngpHngpPngpfngpjngprngpvngp5cIiwxMixcIueCsOeCsueCtOeCteeCtueCuueCvueCv+eDhOeDheeDhueDh+eDieeDi1wiLDEyLFwi54OaXCJdLFtcIjlmNDBcIixcIueDnOeDneeDnueDoOeDoeeDoueDo+eDpeeDqueDrueDsFwiLDYsXCLng7jng7rng7vng7zng75cIiwxMCxcIueEi1wiLDQsXCLnhJHnhJLnhJTnhJfnhJtcIiwxMCxcIueEp1wiLDcsXCLnhLLnhLPnhLRcIl0sW1wiOWY4MFwiLFwi54S154S3XCIsMTMsXCLnhYbnhYfnhYjnhYnnhYvnhY3nhY9cIiwxMixcIueFneeFn1wiLDQsXCLnhaXnhalcIiw0LFwi54Wv54Ww54Wx54W054W154W254W354W554W754W854W+XCIsNSxcIueGhVwiLDQsXCLnhovnhoznho3nho7nhpDnhpHnhpLnhpPnhpXnhpbnhpfnhppcIiw0LFwi54ahXCIsNixcIueGqeeGqueGq+eGrVwiLDUsXCLnhrTnhrbnhrfnhrjnhrpcIiw4LFwi54eEXCIsOSxcIueHj1wiLDRdLFtcImEwNDBcIixcIueHllwiLDksXCLnh6Hnh6Lnh6Pnh6Tnh6bnh6hcIiw1LFwi54evXCIsOSxcIueHulwiLDExLFwi54iHXCIsMTldLFtcImEwODBcIixcIueIm+eInOeInlwiLDksXCLniKnniKvniK3niK7niK/niLLniLPniLTniLrniLzniL7niYBcIiw2LFwi54mJ54mK54mL54mO54mP54mQ54mR54mT54mU54mV54mX54mY54ma54mc54me54mg54mj54mk54ml54mo54mq54mr54ms54mt54mw54mx54mz54m054m254m354m454m754m854m954qC54qD54qFXCIsNCxcIueKjOeKjueKkOeKkeeKk1wiLDExLFwi54qgXCIsMTEsXCLniq7nirHnirLnirPnirXnirpcIiw2LFwi54uF54uG54uH54uJ54uK54uL54uM54uP54uR54uT54uU54uV54uW54uY54ua54ubXCJdLFtcImExYTFcIixcIuOAgOOAgeOAgsK3y4nLh8Ko44CD44CF4oCU772e4oCW4oCm4oCY4oCZ4oCc4oCd44CU44CV44CIXCIsNyxcIuOAluOAl+OAkOOAkcKxw5fDt+KItuKIp+KIqOKIkeKIj+KIquKIqeKIiOKIt+KImuKKpeKIpeKIoOKMkuKKmeKIq+KIruKJoeKJjOKJiOKIveKIneKJoOKJruKJr+KJpOKJpeKInuKIteKItOKZguKZgMKw4oCy4oCz4oSD77yEwqTvv6Dvv6HigLDCp+KEluKYhuKYheKXi+KXj+KXjuKXh+KXhuKWoeKWoOKWs+KWsuKAu+KGkuKGkOKGkeKGk+OAk1wiXSxbXCJhMmExXCIsXCLihbBcIiw5XSxbXCJhMmIxXCIsXCLikohcIiwxOSxcIuKRtFwiLDE5LFwi4pGgXCIsOV0sW1wiYTJlNVwiLFwi44igXCIsOV0sW1wiYTJmMVwiLFwi4oWgXCIsMTFdLFtcImEzYTFcIixcIu+8ge+8gu+8g++/pe+8hVwiLDg4LFwi77+jXCJdLFtcImE0YTFcIixcIuOBgVwiLDgyXSxbXCJhNWExXCIsXCLjgqFcIiw4NV0sW1wiYTZhMVwiLFwizpFcIiwxNixcIs6jXCIsNl0sW1wiYTZjMVwiLFwizrFcIiwxNixcIs+DXCIsNl0sW1wiYTZlMFwiLFwi77i177i277i577i677i/77mA77i977i+77mB77mC77mD77mEXCJdLFtcImE2ZWVcIixcIu+4u++4vO+4t++4uO+4sVwiXSxbXCJhNmY0XCIsXCLvuLPvuLRcIl0sW1wiYTdhMVwiLFwi0JBcIiw1LFwi0IHQllwiLDI1XSxbXCJhN2QxXCIsXCLQsFwiLDUsXCLRkdC2XCIsMjVdLFtcImE4NDBcIixcIsuKy4vLmeKAk+KAleKApeKAteKEheKEieKGluKGl+KGmOKGmeKIleKIn+KIo+KJkuKJpuKJp+KKv+KVkFwiLDM1LFwi4paBXCIsNl0sW1wiYTg4MFwiLFwi4paIXCIsNyxcIuKWk+KWlOKWleKWvOKWveKXouKXo+KXpOKXpeKYieKKleOAkuOAneOAnlwiXSxbXCJhOGExXCIsXCLEgcOhx47DoMSTw6nEm8OoxKvDrceQw6zFjcOzx5LDssWrw7rHlMO5x5bHmMeax5zDvMOqyZFcIl0sW1wiYThiZFwiLFwixYTFiFwiXSxbXCJhOGMwXCIsXCLJoVwiXSxbXCJhOGM1XCIsXCLjhIVcIiwzNl0sW1wiYTk0MFwiLFwi44ChXCIsOCxcIuOKo+OOjuOOj+OOnOOOneOOnuOOoeOPhOOPjuOPkeOPkuOPle+4sO+/ou+/pFwiXSxbXCJhOTU5XCIsXCLihKHjiLFcIl0sW1wiYTk1Y1wiLFwi4oCQXCJdLFtcImE5NjBcIixcIuODvOOCm+OCnOODveODvuOAhuOCneOCnu+5iVwiLDksXCLvuZTvuZXvuZbvuZfvuZlcIiw4XSxbXCJhOTgwXCIsXCLvuaJcIiw0LFwi77mo77mp77mq77mrXCJdLFtcImE5OTZcIixcIuOAh1wiXSxbXCJhOWE0XCIsXCLilIBcIiw3NV0sW1wiYWE0MFwiLFwi54uc54ud54uf54uiXCIsNSxcIueLqueLq+eLteeLtueLueeLveeLvueLv+eMgOeMgueMhFwiLDUsXCLnjIvnjIznjI3njI/njJDnjJHnjJLnjJTnjJjnjJnnjJrnjJ/njKDnjKPnjKTnjKbnjKfnjKjnjK3njK/njLDnjLLnjLPnjLXnjLbnjLrnjLvnjLznjL3njYBcIiw4XSxbXCJhYTgwXCIsXCLnjYnnjYrnjYvnjYznjY7njY/njZHnjZPnjZTnjZXnjZbnjZhcIiw3LFwi542hXCIsMTAsXCLnja7njbDnjbFcIl0sW1wiYWI0MFwiLFwi542yXCIsMTEsXCLnjb9cIiw0LFwi546F546G546I546K546M546N546P546Q546S546T546U546V546X546Y546Z546a546c546d546e546g546h546jXCIsNSxcIueOqueOrOeOreeOseeOtOeOteeOtueOuOeOueeOvOeOveeOvueOv+ePgeePg1wiLDRdLFtcImFiODBcIixcIuePi+ePjOePjuePklwiLDYsXCLnj5rnj5vnj5znj53nj5/nj6Hnj6Lnj6Pnj6Tnj6bnj6jnj6rnj6vnj6znj67nj6/nj7Dnj7Hnj7NcIiw0XSxbXCJhYzQwXCIsXCLnj7hcIiwxMCxcIueQhOeQh+eQiOeQi+eQjOeQjeeQjueQkVwiLDgsXCLnkJxcIiw1LFwi55Cj55Ck55Cn55Cp55Cr55Ct55Cv55Cx55Cy55C3XCIsNCxcIueQveeQvueQv+eRgOeRglwiLDExXSxbXCJhYzgwXCIsXCLnkY5cIiw2LFwi55GW55GY55Gd55GgXCIsMTIsXCLnka7nka/nkbFcIiw0LFwi55G455G555G6XCJdLFtcImFkNDBcIixcIueRu+eRvOeRveeRv+eSgueShOeSheeShueSiOeSieeSiueSjOeSjeeSj+eSkVwiLDEwLFwi55Kd55KfXCIsNyxcIueSqlwiLDE1LFwi55K7XCIsMTJdLFtcImFkODBcIixcIueTiFwiLDksXCLnk5NcIiw4LFwi55Od55Of55Oh55Ol55OnXCIsNixcIueTsOeTseeTslwiXSxbXCJhZTQwXCIsXCLnk7Pnk7Xnk7hcIiw2LFwi55SA55SB55SC55SD55SFXCIsNyxcIueUjueUkOeUkueUlOeUleeUlueUl+eUm+eUneeUnueUoFwiLDQsXCLnlKbnlKfnlKrnlK7nlLTnlLbnlLnnlLznlL3nlL/nlYHnlYLnlYPnlYTnlYbnlYfnlYnnlYrnlY3nlZDnlZHnlZLnlZPnlZXnlZbnlZfnlZhcIl0sW1wiYWU4MFwiLFwi55WdXCIsNyxcIueVp+eVqOeVqeeVq1wiLDYsXCLnlbPnlbXnlbbnlbfnlbpcIiw0LFwi55aA55aB55aC55aE55aF55aHXCJdLFtcImFmNDBcIixcIueWiOeWieeWiueWjOeWjeeWjueWkOeWk+eWleeWmOeWm+eWnOeWnueWoueWplwiLDQsXCLnlq3nlrbnlrfnlrrnlrvnlr/nl4Dnl4Hnl4bnl4vnl4znl47nl4/nl5Dnl5Hnl5Pnl5fnl5nnl5rnl5znl53nl5/nl6Dnl6Hnl6Xnl6nnl6znl63nl67nl6/nl7Lnl7Pnl7Xnl7bnl7fnl7jnl7rnl7vnl73nl77nmILnmITnmIbnmIdcIl0sW1wiYWY4MFwiLFwi55iI55iJ55iL55iN55iO55iP55iR55iS55iT55iU55iW55ia55ic55id55ie55ih55ij55in55io55is55iu55iv55ix55iy55i255i355i555i655i755i955mB55mC55mEXCJdLFtcImIwNDBcIixcIueZhVwiLDYsXCLnmY5cIiw1LFwi55mV55mXXCIsNCxcIueZneeZn+eZoOeZoeeZoueZpFwiLDYsXCLnmaznma3nma7nmbBcIiw3LFwi55m555m655m855m/55qA55qB55qD55qF55qJ55qK55qM55qN55qP55qQ55qS55qU55qV55qX55qY55qa55qbXCJdLFtcImIwODBcIixcIueanFwiLDcsXCLnmqVcIiw4LFwi55qv55qw55qz55q1XCIsOSxcIuebgOebgeebg+WViumYv+Wfg+aMqOWTjuWUieWTgOeakeeZjOiUvOefruiJvueijeeIsemamOmejeawqOWuieS/uuaMieaal+WyuOiDuuahiOiCruaYguebjuWHueaVlueGrOe/seiihOWCsuWlpeaHiua+s+iKreaNjOaJkuWPreWQp+eshuWFq+eWpOW3tOaLlOi3i+mdtuaKiuiAmeWdnemcuOe9oueIuOeZveafj+eZvuaRhuS9sOi0peaLnOeol+aWkeePreaQrOaJs+iIrOmigeadv+eJiOaJruaLjOS8tOeTo+WNiuWKnue7iumCpuW4ruaihuamnOiGgOe7keajkuejheiajOmVkeWCjeiwpOiLnuiDnuWMheikkuWJpVwiXSxbXCJiMTQwXCIsXCLnm4Tnm4fnm4nnm4vnm4znm5Pnm5Xnm5nnm5rnm5znm53nm57nm6BcIiw0LFwi55umXCIsNyxcIuebsOebs+ebteebtuebt+ebuuebu+ebveebv+ecgOecguecg+echeechueciuecjOecjlwiLDEwLFwi55yb55yc55yd55ye55yh55yj55yk55yl55yn55yq55yrXCJdLFtcImIxODBcIixcIuecrOecruecsFwiLDQsXCLnnLnnnLvnnL3nnL7nnL/nnYLnnYTnnYXnnYbnnYhcIiw3LFwi552SXCIsNyxcIuednOiWhOmbueS/neWgoemlseWuneaKseaKpeaatOixuemyjeeIhuadr+eikeaCsuWNkeWMl+i+iOiDjOi0nemSoeWAjeeLiOWkh+aDq+eEmeiiq+WllOiLr+acrOesqOW0qee7t+eUreaztei5pui/uOmAvOm8u+avlOmEmeeslOW9vOeip+iTluiUveavleavmeavluW4geW6h+eXuemXreaVneW8iuW/hei+n+WjgeiHgumBv+mZm+merei+uee8lui0rOaJgeS+v+WPmOWNnui+qOi+qei+q+mBjeagh+W9quiGmOihqOmzluaGi+WIq+eYquW9rOaWjOa/kua7qOWuvuaRiOWFteWGsOafhOS4meeniemlvOeCs1wiXSxbXCJiMjQwXCIsXCLnnZ3nnZ7nnZ/nnaDnnaTnnafnnannnarnna1cIiwxMSxcIueduuedu+edvOeegeeegueeg+eehlwiLDUsXCLnno/nnpDnnpNcIiwxMSxcIueeoeeeo+eepOeepueeqOeeq+eereeerueer+eeseeesueetOeetlwiLDRdLFtcImIyODBcIixcIueevOeevuefgFwiLDEyLFwi55+OXCIsOCxcIuefmOefmeefmuefnVwiLDQsXCLnn6Tnl4Xlubbnjrvoj6Dmkq3mi6jpkrXms6LljZrli4PmkI/pk4LnrpTkvK/luJvoiLbohJbohormuKTms4rpqbPmjZXljZzlk7rooaXln6DkuI3luIPmraXnsL/pg6jmgJbmk6bnjJzoo4HmnZDmiY3otKLnnazouKnph4flvanoj5zolKHppJDlj4LompXmrovmg63mg6jngb/oi43oiLHku5Pmsqfol4/mk43ns5nmp73mm7nojYnljpXnrZbkvqflhozmtYvlsYLoua3mj5Llj4nojKzojLbmn6XnorTmkL3lr5/lspTlt67or6fmi4bmn7TosbrmkIDmjrronYnppovosJfnvKDpk7LkuqfpmJDpoqTmmIznjJZcIl0sW1wiYjM0MFwiLFwi55+m55+o55+q55+v55+w55+x55+y55+055+155+355+555+655+755+856CDXCIsNSxcIuegiuegi+egjuegj+egkOegk+egleegmeegm+egnuegoOegoeegouegpOegqOegquegq+egruegr+egseegsuegs+egteegtuegveegv+ehgeehguehg+ehhOehhuehiOehieehiuehi+ehjeehj+ehkeehk+ehlOehmOehmeehmlwiXSxbXCJiMzgwXCIsXCLnoZvnoZznoZ5cIiwxMSxcIuehr1wiLDcsXCLnobjnobnnobrnobvnob1cIiw2LFwi5Zy65bCd5bi46ZW/5YG/6IKg5Y6C5pWe55WF5ZSx5YCh6LaF5oqE6ZKe5pyd5Ziy5r2u5bei5ZC154KS6L2m5omv5pKk5o6j5b275r6I6YO06Iej6L6w5bCY5pmo5b+x5rKJ6ZmI6LaB6KGs5pKR56ew5Z+O5qmZ5oiQ5ZGI5LmY56iL5oOp5r6E6K+a5om/6YCe6aqL56ek5ZCD55e05oyB5YyZ5rGg6L+f5byb6amw6IC76b2/5L6I5bC66LWk57+F5pal54K95YWF5Yay6Jmr5bSH5a6g5oq96YWs55W06LiM56ig5oSB56255LuH57u4556F5LiR6Iet5Yid5Ye65qmx5Y6o6LqH6ZSE6ZuP5ruB6Zmk5qWaXCJdLFtcImI0NDBcIixcIueihOeiheeihueiiOeiiueii+eij+eikOeikueilOeileeilueimeeineeinueioOeioueipOeipueiqFwiLDcsXCLnorXnorbnorfnorjnorrnorvnorznor3nor/no4Dno4Lno4Pno4Tno4bno4fno4jno4zno43no47no4/no5Hno5Lno5Pno5bno5fno5jno5pcIiw5XSxbXCJiNDgwXCIsXCLno6Tno6Xno6bno6fno6nno6rno6vno61cIiw0LFwi56Oz56O156O256O456O556O7XCIsNSxcIuekguekg+ekhOekhlwiLDYsXCLnoYDlgqjnn5fmkJDop6blpITmj6Plt53nqb/mpL3kvKDoiLnllpjkuLLnlq7nqpfluaLluorpl6/liJvlkLnngormjbbplKTlnoLmmKXmpL/phofllIfmt7Pnuq/ooKLmiLPnu7DnlrXojKjno4Hpm4zovp7mhYjnk7for43mraTliLrotZDmrKHogarokbHlm7HljIbku47kuJvlh5HnspfphovnsIfkv4Poub/nr6HnqpzmkafltJTlgqzohIbnmIHnsrnmt6znv6DmnZHlrZjlr7jno4vmkq7mkJPmjqrmjKvplJnmkK3ovr7nrZTnmKnmiZPlpKflkYbmrbnlgqPmiLTluKbmrobku6PotLfooovlvoXpgK5cIl0sW1wiYjU0MFwiLFwi56SNXCIsNSxcIueklFwiLDksXCLnpJ9cIiw0LFwi56SlXCIsMTQsXCLnpLVcIiw0LFwi56S956S/56WC56WD56WE56WF56WH56WKXCIsOCxcIuellOelleelmOelmeeloeelo1wiXSxbXCJiNTgwXCIsXCLnpaTnpabnpannparnpavnpaznpa7npbBcIiw2LFwi56W556W7XCIsNCxcIuemguemg+emhuemh+emiOemieemi+emjOemjeemjuemkOemkeemkuaAoOiAveaLheS4ueWNlemDuOaOuOiDhuaXpuawruS9huaDrua3oeivnuW8ueibi+W9k+aMoeWFmuiNoeaho+WIgOaNo+i5iOWAkuWym+elt+WvvOWIsOeou+aCvOmBk+ebl+W+t+W+l+eahOi5rOeBr+eZu+etieeequWHs+mCk+WgpOS9jua7tOi/quaVjOesm+eLhOa2pOe/n+WroeaKteW6leWcsOiSguesrOW4neW8n+mAkue8lOmioOaOgua7h+eimOeCueWFuOmdm+Weq+eUteS9g+eUuOW6l+aDpuWloOa3gOauv+eiieWPvOmbleWHi+WIgeaOieWQiumSk+iwg+i3jOeIueein+idtui/reiwjeWPoFwiXSxbXCJiNjQwXCIsXCLnppNcIiw2LFwi56abXCIsMTEsXCLnpqhcIiwxMCxcIuemtFwiLDQsXCLnprznpr/np4Lnp4Tnp4Xnp4fnp4jnp4rnp4znp47np4/np5Dnp5Pnp5Tnp5bnp5fnp5lcIiw1LFwi56eg56eh56ei56el56eo56eqXCJdLFtcImI2ODBcIixcIuenrOenruensVwiLDYsXCLnp7nnp7rnp7znp77np7/nqIHnqITnqIXnqIfnqIjnqInnqIrnqIznqI9cIiw0LFwi56iV56iW56iY56iZ56ib56ic5LiB55uv5Y+u6ZKJ6aG26byO6ZSt5a6a6K6i5Lii5Lic5Yas6JGj5oeC5Yqo5qCL5L6X5oGr5Ya75rSe5YWc5oqW5paX6Zmh6LGG6YCX55eY6YO9552j5q+S54qK54us6K+75aC155256LWM5p2c6ZWA6IKa5bqm5rih5aaS56uv55+t6ZS75q615pat57yO5aCG5YWR6Zif5a+55aKp5ZCo6Lmy5pWm6aG/5Zuk6ZKd55u+6YGB5o6H5ZOG5aSa5aS65Z6b6Lqy5py16Le66Ii15YmB5oOw5aCV6Ju+5bOo6bmF5L+E6aKd6K655ail5oG25Y6E5om86YGP6YSC6aW/5oGp6ICM5YS/6ICz5bCU6aW15rSx5LqMXCJdLFtcImI3NDBcIixcIueoneeon+eooeeooueopFwiLDE0LFwi56i056i156i256i456i656i+56mAXCIsNSxcIueph1wiLDksXCLnqZJcIiw0LFwi56mYXCIsMTZdLFtcImI3ODBcIixcIuepqVwiLDYsXCLnqbHnqbLnqbPnqbXnqbvnqbznqb3nqb7nqoLnqoXnqofnqonnqornqovnqoznqo7nqo/nqpDnqpPnqpTnqpnnqprnqpvnqp7nqqHnqqLotLDlj5HnvZrnrY/kvJDkuY/pmIDms5Xnj5Dol6nluIbnlarnv7vmqIrnn77pkpLnuYHlh6Hng6blj43ov5TojIPotKnniq/ppa3ms5vlnYroirPmlrnogqrmiL/pmLLlpqjku7/orr/nurrmlL7oj7LpnZ7llaHpo57ogqXljKror73lkKDogrrlup/msrjotLnoiqzphZrlkKnmsJvliIbnurflnZ/nhJrmsb7nsonlpYvku73lv7/mhKTnsqrkuLDlsIHmnqvonILls7DplIvpo47nlq/ng73pgKLlhq/nvJ3orr3lpYnlh6TkvZvlkKblpKvmlbfogqTlrbXmibbmi4LovpDluYXmsJ/nrKbkvI/kv5jmnI1cIl0sW1wiYjg0MFwiLFwi56qj56qk56qn56qp56qq56qr56quXCIsNCxcIueqtFwiLDEwLFwi56uAXCIsMTAsXCLnq4xcIiw5LFwi56uX56uY56ua56ub56uc56ud56uh56ui56uk56unXCIsNSxcIuerruersOerseersuers1wiXSxbXCJiODgwXCIsXCLnq7RcIiw0LFwi56u756u856u+56yA56yB56yC56yF56yH56yJ56yM56yN56yO56yQ56yS56yT56yW56yX56yY56ya56yc56yd56yf56yh56yi56yj56yn56yp56yt5rWu5raq56aP6KKx5byX55Sr5oqa6L6F5L+v6Yec5pan6ISv6IWR5bqc6IWQ6LW05Ymv6KaG6LWL5aSN5YKF5LuY6Zic54i26IW56LSf5a+M6K6j6ZmE5aaH57ya5ZKQ5Zm25ZiO6K+l5pS55qaC6ZKZ55uW5rqJ5bmy55SY5p2G5p+R56u/6IKd6LW25oSf56eG5pWi6LWj5YaI5Yia6ZKi57y46IKb57qy5bKX5riv5p2g56+Z55qL6auY6IaP576U57OV5pCe6ZWQ56i/5ZGK5ZOl5q2M5pCB5oiI6bi96IOz55aZ5Ymy6Z2p6JGb5qC86Juk6ZiB6ZqU6ZOs5Liq5ZCE57uZ5qC56Lef6ICV5pu05bqa5765XCJdLFtcImI5NDBcIixcIuesr+essOessuestOesteestuest+esueesu+esveesv1wiLDUsXCLnrYbnrYjnrYrnrY3nrY7nrZPnrZXnrZfnrZnnrZznrZ7nrZ/nraHnraNcIiwxMCxcIuetr+etsOets+ettOettuetuOetuuetvOetveetv+eugeeugueug+euhOeuhlwiLDYsXCLnro7nro9cIl0sW1wiYjk4MFwiLFwi566R566S566T566W566Y566Z566a566b566e566f566g566j566k566l566u566v566w566y566z5661566256635665XCIsNyxcIuevguevg+evhOWfguiAv+ail+W3peaUu+WKn+aBrem+muS+m+i6rOWFrOWuq+W8k+W3qeaxnuaLsei0oeWFsemSqeWLvuayn+iLn+eLl+WeouaehOi0reWkn+i+nOiPh+WSleeujeS8sOayveWtpOWnkem8k+WPpOibiumqqOiwt+iCoeaVhemhvuWbuumbh+WIrueTnOWJkOWvoeaMguikguS5luaLkOaAquajuuWFs+WumOWGoOingueuoemmhue9kOaDr+eBjOi0r+WFieW5v+mAm+eRsOinhOWcreehheW9kum+n+mXuui9qOmsvOivoeeZuOahguafnOi3qui0teWIvei+iua7muajjemUhemDreWbveaenOijuei/h+WTiFwiXSxbXCJiYTQwXCIsXCLnr4Xnr4jnr4nnr4rnr4vnr43nr47nr4/nr5Dnr5Lnr5RcIiw0LFwi56+b56+c56+e56+f56+g56+i56+j56+k56+n56+o56+p56+r56+s56+t56+v56+w56+yXCIsNCxcIuevuOevueevuuevu+evveevv1wiLDcsXCLnsIjnsInnsIrnsI3nsI7nsJBcIiw1LFwi57CX57CY57CZXCJdLFtcImJhODBcIixcIuewmlwiLDQsXCLnsKBcIiw1LFwi57Co57Cp57CrXCIsMTIsXCLnsLlcIiw1LFwi57GC6aq45a2p5rW35rCm5Lql5a6z6aqH6YWj5oao6YKv6Z+p5ZCr5ra15a+S5Ye95ZaK572V57+w5pK85o2N5pex5oa+5oKN54SK5rGX5rGJ5aSv5p2t6Iiq5aOV5ZqO6LGq5q+r6YOd5aW96ICX5Y+35rWp5ZG15Zad6I236I+P5qC456a+5ZKM5L2V5ZCI55uS6LKJ6ZiC5rKz5ra46LWr6KSQ6bmk6LS65Zi/6buR55eV5b6I54ug5oGo5ZO85Lqo5qiq6KGh5oGS6L2w5ZOE54OY6Jm56bi/5rSq5a6P5byY57qi5ZaJ5L6v54y05ZC85Y6a5YCZ5ZCO5ZG85LmO5b+955Ga5aO26JGr6IOh6J2054uQ57OK5rmWXCJdLFtcImJiNDBcIixcIuexg1wiLDksXCLnsY5cIiwzNixcIuextVwiLDUsXCLnsb5cIiw5XSxbXCJiYjgwXCIsXCLnsojnsopcIiw2LFwi57KT57KU57KW57KZ57Ka57Kb57Kg57Kh57Kj57Km57Kn57Ko57Kp57Kr57Ks57Kt57Kv57Kw57K0XCIsNCxcIueyuueyu+W8p+iZjuWUrOaKpOS6kuayquaIt+iKseWTl+WNjueMvua7keeUu+WIkuWMluivneankOW+iuaAgOa3ruWdj+asoueOr+ahk+i/mOe8k+aNouaCo+WUpOeXquixoueElea2o+WupuW5u+iNkuaFjOm7hOejuuidl+ewp+eah+WHsOaDtueFjOaZg+W5jOaBjeiwjueBsOaMpei+ieW+veaBouiblOWbnuavgeaClOaFp+WNieaDoOaZpui0v+enveS8mueDqeaxh+ius+ivsue7mOiNpOaYj+Wpmumtgua1kea3t+ixgea0u+S8meeBq+iOt+aIluaDkemcjei0p+eluOWHu+WcvuWfuuacuueVuOeoveenr+eulVwiXSxbXCJiYzQwXCIsXCLnsr/ns4Dns4Lns4Pns4Tns4bns4nns4vns45cIiw2LFwi57OY57Oa57Ob57Od57Oe57OhXCIsNixcIuezqVwiLDUsXCLns7BcIiw3LFwi57O557O657O8XCIsMTMsXCLntItcIiw1XSxbXCJiYzgwXCIsXCLntJFcIiwxNCxcIue0oee0o+e0pOe0pee0pue0qOe0qee0que0rOe0ree0rue0sFwiLDYsXCLogozppaXov7nmv4DorqXpuKHlp6znu6nnvInlkInmnoHmo5jovpHnsY3pm4blj4rmgKXnlr7msbLljbPlq4nnuqfmjKTlh6DohIrlt7Hok5/mioDlhoDlraPkvI7npa3liYLmgrjmtY7lr4Tlr4LorqHorrDml6Llv4zpmYXlppPnu6fnuqrlmInmnrflpLnkvbPlrrbliqDojZrpoorotL7nlLLpkr7lgYfnqLzku7fmnrbpqb7lq4Hmrbznm5HlnZrlsJbnrLrpl7TnhY7lhbzogqnoibDlpbjnvITojKfmo4Dmn6znorHnobfmi6PmjaHnroDkv63liarlh4/ojZDmp5vpibTot7XotLHop4HplK7nrq3ku7ZcIl0sW1wiYmQ0MFwiLFwi57S3XCIsNTQsXCLnta9cIiw3XSxbXCJiZDgwXCIsXCLntbhcIiwzMixcIuWBpeiIsOWJkemlr+a4kOa6hea2p+W7uuWDteWnnOWwhua1huaxn+eWhuiSi+ahqOWlluiusuWMoOmFsemZjeiVieakkuekgeeEpuiDtuS6pOmDiua1h+mqhOWoh+WavOaQhemTsOefq+S+peiEmueLoeinkumluue8tOe7nuWJv+aVmemFtei9v+i+g+WPq+eqluaPreaOpeeahuenuOihl+mYtuaIquWKq+iKguahlOadsOaNt+edq+errea0gee7k+ino+WnkOaIkuiXieiKpeeVjOWAn+S7i+eWpeivq+WxiuW3vueti+aWpOmHkeS7iua0peiln+e0p+mUpuS7heiwqOi/m+mds+aZi+emgei/keeDrOa1uFwiXSxbXCJiZTQwXCIsXCLntplcIiwxMixcIue2p1wiLDYsXCLntq9cIiw0Ml0sW1wiYmU4MFwiLFwi57eaXCIsMzIsXCLlsL3lirLojYblhaLojI7nnZvmmbbpsrjkuqzmg4rnsr7nsrPnu4/kupXorabmma/poojpnZnlooPmlazplZzlvoTnl4npnZbnq5/nq57lh4Dngq/nqpjmj6rnqbbnuqDnjpbpn63kuYXngbjkuZ3phZLljqnmlZHml6foh7zoiIXlko7lsLHnlprpnqDmi5jni5nnlr3lsYXpqbnoj4rlsYDlkoDnn6nkuL7msq7ogZrmi5Lmja7lt6jlhbfot53ouJ7plK/kv7Hlj6Xmg6fngqzliafmjZDpuYPlqJ/lgKbnnLfljbfnu6LmkoXmlKvmionmjpjlgJTniLXop4nlhrPor4Dnu53lnYfoj4zpkqflhpvlkJvls7tcIl0sW1wiYmY0MFwiLFwi57e7XCIsNjJdLFtcImJmODBcIixcIue4uue4vFwiLDQsXCLnuYJcIiw0LFwi57mIXCIsMjEsXCLkv4rnq6PmtZrpg6Hpqo/lloDlkpbljaHlkq/lvIDmj6nmpbflh6/mhajliIrloKrli5jlnY7noI3nnIvlurfmhbfns6DmiZvmipfkuqLngpXogIPmi7fng6TpnaDlnbfoi5vmn6/mo7Xno5Xpopfnp5Hlo7PlkrPlj6/muLTlhYvliLvlrqLor77ogq/llYPlnqbmgbPlnZHlkK3nqbrmgZDlrZTmjqfmiqDlj6PmiaPlr4fmnq/lk63nqp/oi6bphbflupPoo6TlpLjlnq7mjI7ot6jog6/lnZfnrbfkvqnlv6vlrr3mrL7ljKHnrZDni4LmoYbnn7/nnLbml7flhrXkuo/nm5Tlsr/nqqXokbXlpY7prYHlgoBcIl0sW1wiYzA0MFwiLFwi57meXCIsMzUsXCLnuoNcIiwyMyxcIue6nOe6nee6nlwiXSxbXCJjMDgwXCIsXCLnuq7nurTnurvnurznu5bnu6Tnu6znu7nnvIrnvJDnvJ7nvLfnvLnnvLtcIiw2LFwi572D572GXCIsOSxcIue9kue9k+mmiOaEp+a6g+WdpOaYhuaNhuWbsOaLrOaJqeW7k+mYlOWeg+aLieWWh+icoeiFiui+o+WVpuiOseadpei1luiTneWpquagj+aLpuevrumYkeWFsOa+nOiwsOaPveiniOaHkue8hueDgua7peeQheamlOeLvOW7iumDjuacl+a1quaNnuWKs+eJouiAgeS9rOWnpemFqueDmea2neWLkuS5kOmbt+mVreiVvuejiue0r+WEoeWekuaTguiCi+exu+azquajsealnuWGt+WOmOaiqOeKgem7juevseeLuOemu+a8k+eQhuadjumHjOmypOekvOiOieiNlOWQj+agl+S4veWOieWKseegvuWOhuWIqeWCiOS+i+S/kFwiXSxbXCJjMTQwXCIsXCLnvZbnvZnnvZvnvZznvZ3nvZ7nvaDnvaNcIiw0LFwi572r572s572t572v572w572z57215722572357245726572757285729572/576A576CXCIsNyxcIue+i+e+jee+j1wiLDQsXCLnvpVcIiw0LFwi576b576c576g576i576j576l576m576oXCIsNixcIue+sVwiXSxbXCJjMTgwXCIsXCLnvrNcIiw0LFwi57665767576+57+A57+C57+D57+E57+G57+H57+I57+J57+L57+N57+PXCIsNCxcIue/lue/l+e/mVwiLDUsXCLnv6Lnv6Pnl6Lnq4vnspLmsqXpmrblipvnkoPlk6nkv6nogZTojrLov57plbDlu4nmgJzmtp/luJjmlZvohLjpk77mgYvngrznu4Pnsq7lh4nmooHnsrHoia/kuKTovobph4/mmb7kuq7osIXmkqnogYrlg5rnlpfnh47lr6Xovr3mvabkuobmkoLplaPlu5bmlpnliJfoo4Lng4jliqPnjI7nkLPmnpfno7fpnJbkuLTpgrvps57mt4vlh5votYHlkJ3mi47njrLoj7Hpm7bpvoTpk4PkvLbnvprlh4zngbXpmbXlsq3pooblj6bku6TmupznkInmprTnoavppo/nlZnliJjnmKTmtYHmn7Plha3pvpnogYvlkpnnrLznqr9cIl0sW1wiYzI0MFwiLFwi57+k57+n57+o57+q57+r57+s57+t57+v57+y57+0XCIsNixcIue/vee/vue/v+iAguiAh+iAiOiAieiAiuiAjuiAj+iAkeiAk+iAmuiAm+iAneiAnuiAn+iAoeiAo+iApOiAq1wiLDUsXCLogLLogLTogLnogLrogLzogL7ogYDogYHogYTogYXogYfogYjogYnogY7ogY/ogZDogZHogZPogZXogZbogZdcIl0sW1wiYzI4MFwiLFwi6IGZ6IGbXCIsMTMsXCLogatcIiw1LFwi6IGyXCIsMTEsXCLpmoblnoTmi6LpmYfmpbzlqITmkILnr5PmvI/pmYvoiqbljaLpooXlupDngonmjrPljaTomY/psoHpupPnoozpnLLot6/otYLpub/mvZ7npoTlvZXpmYbmiK7pqbTlkJXpk53kvqPml4XlsaXlsaHnvJXomZHmsK/lvovnjofmu6Tnu7/ls6bmjJvlrarmu6bljbXkubHmjqDnlaXmiqHova7kvKbku5HmsqbnurborrrokJ3onrrnvZfpgLvplKPnrqnpqqHoo7jokL3mtJvpqobnu5zlpojpurvnjpvnoIHomoLpqazpqoLlmJvlkJfln4vkubDpuqbljZbov4johInnnpLpppLom67mu6HolJPmm7zmhaLmvKtcIl0sW1wiYzM0MFwiLFwi6IG+6IKB6IKC6IKF6IKI6IKK6IKNXCIsNSxcIuiClOiCleiCl+iCmeiCnuiCo+iCpuiCp+iCqOiCrOiCsOiCs+iCteiCtuiCuOiCueiCu+iDheiDh1wiLDQsXCLog49cIiw2LFwi6IOY6IOf6IOg6IOi6IOj6IOm6IOu6IO16IO36IO56IO76IO+6IO/6ISA6ISB6ISD6ISE6ISF6ISH6ISI6ISLXCJdLFtcImMzODBcIixcIuiEjOiEleiEl+iEmeiEm+iEnOiEneiEn1wiLDEyLFwi6ISt6ISu6ISw6ISz6IS06IS16IS36IS5XCIsNCxcIuiEv+iwqeiKkuiMq+ebsuawk+W/meiOveeMq+iMhemUmuavm+efm+mThuWNr+iMguWGkuW4veiyjOi0uOS5iOeOq+aemuaihemFtumcieeFpOayoeecieWqkumVgeavj+e+juaYp+WvkOWmueWqmumXqOmXt+S7rOiQjOiSmeaqrOebn+mUsOeMm+aipuWtn+ecr+mGmumdoeeznOi/t+iwnOW8peexs+enmOinheazjOicnOWvhuW5guajieecoOe7teWGleWFjeWLieWoqee8hemdouiLl+aPj+eehOiXkOenkua4uuW6meWmmeiUkeeBreawkeaKv+eav+aVj+aCr+mXveaYjuien+m4o+mTreWQjeWRveiwrOaRuFwiXSxbXCJjNDQwXCIsXCLohYBcIiw1LFwi6IWH6IWJ6IWN6IWO6IWP6IWS6IWW6IWX6IWY6IWbXCIsNCxcIuiFoeiFouiFo+iFpOiFpuiFqOiFquiFq+iFrOiFr+iFsuiFs+iFteiFtuiFt+iFuOiGgeiGg1wiLDQsXCLohonohovohozoho3oho7ohpDohpJcIiw1LFwi6IaZ6Iaa6IaeXCIsNCxcIuiGpOiGpVwiXSxbXCJjNDgwXCIsXCLohqfohqnohqtcIiw3LFwi6Ia0XCIsNSxcIuiGvOiGveiGvuiGv+iHhOiHheiHh+iHiOiHieiHi+iHjVwiLDYsXCLmkbnomJHmqKHohpzno6jmkanprZTmirnmnKvojqvloqjpu5jmsqvmvKDlr57pmYzosIvniZ/mn5Dmi4fniaHkuqnlp4bmr43lopPmmq7luZXli5/mhZXmnKjnm67nnabniafnqYbmi7/lk6rlkZDpkqDpgqPlqJznurPmsJbkuYPlpbbogJDlpYjljZfnlLfpmr7lm4rmjKDohJHmgbzpl7nmt5blkaLppoHlhoXlq6nog73lpq7pnJPlgKrms6XlsLzmi5/kvaDljL/ohbvpgIbmurrolKvmi4jlubTnor7mkrXmjbvlv7XlqJjphb/puJ/lsL/mjY/ogYLlrb3lla7plYrplY3mtoXmgqjmn6Dni57lh53lroFcIl0sW1wiYzU0MFwiLFwi6IeUXCIsMTQsXCLoh6Toh6Xoh6boh6joh6noh6voh65cIiw0LFwi6Ie1XCIsNSxcIuiHveiHv+iIg+iIh1wiLDQsXCLoiI7oiI/oiJHoiJPoiJVcIiw1LFwi6Iid6Iig6Iik6Iil6Iim6Iin6Iip6Iiu6Iiy6Ii66Ii86Ii96Ii/XCJdLFtcImM1ODBcIixcIuiJgOiJgeiJguiJg+iJheiJhuiJiOiJiuiJjOiJjeiJjuiJkFwiLDcsXCLoiZnoiZvoiZzoiZ3oiZ7oiaBcIiw3LFwi6Imp5oun5rOe54mb5omt6ZKu57q96IST5rWT5Yac5byE5aW05Yqq5oCS5aWz5pqW6JmQ55af5oyq5oem57Ov6K+65ZOm5qyn6bil5q606JeV5ZGV5YG25rKk5ZWq6La054is5biV5oCV55C25ouN5o6S54mM5b6Y5rmD5rS+5pSA5r2Y55uY56OQ55u855WU5Yik5Y+b5LmT5bqe5peB6ICq6IOW5oqb5ZKG5Yio54Ku6KKN6LeR5rOh5ZG46IOa5Z+56KO06LWU6Zmq6YWN5L2p5rKb5Za355uG56Cw5oqo54O55r6O5b2t6JOs5qOa56G856+36Iao5pyL6bmP5o2n56Kw5Z2v56CS6Zy55om55oqr5YqI55C15q+XXCJdLFtcImM2NDBcIixcIuiJquiJq+iJrOiJreiJseiJteiJtuiJt+iJuOiJu+iJvOiKgOiKgeiKg+iKheiKhuiKh+iKieiKjOiKkOiKk+iKlOiKleiKluiKmuiKm+iKnuiKoOiKouiKo+iKp+iKsuiKteiKtuiKuuiKu+iKvOiKv+iLgOiLguiLg+iLheiLhuiLieiLkOiLluiLmeiLmuiLneiLouiLp+iLqOiLqeiLquiLrOiLreiLruiLsOiLsuiLs+iLteiLtuiLuFwiXSxbXCJjNjgwXCIsXCLoi7roi7xcIiw0LFwi6IyK6IyL6IyN6IyQ6IyS6IyT6IyW6IyY6IyZ6IydXCIsOSxcIuiMqeiMquiMruiMsOiMsuiMt+iMu+iMveWVpOiEvueWsuearuWMueeXnuWDu+WxgeitrOevh+WBj+eJh+mql+mjmOa8gueTouelqOaSh+eepeaLvOmikei0q+WTgeiBmOS5kuWdquiLueiQjeW5s+WHreeTtuivhOWxj+WdoeazvOmih+WphuegtOmthOi/q+eyleWJluaJkemTuuS7huiOhuiRoeiPqeiSsuWflOactOWcg+aZrua1puiwseabneeAkeacn+asuuagluaImuWmu+S4g+WHhOa8huafkuayj+WFtuaji+Wlh+atp+eVpuW0juiEkOm9kOaXl+eliOelgemqkei1t+WyguS5nuS8geWQr+WlkeegjOWZqOawlOi/hOW8g+axveazo+iuq+aOkFwiXSxbXCJjNzQwXCIsXCLojL7ojL/ojYHojYLojYTojYXojYjojYpcIiw0LFwi6I2T6I2VXCIsNCxcIuiNneiNouiNsFwiLDYsXCLojbnojbrojb5cIiw2LFwi6I6H6I6I6I6K6I6L6I6M6I6N6I6P6I6Q6I6R6I6U6I6V6I6W6I6X6I6Z6I6a6I6d6I6f6I6hXCIsNixcIuiOrOiOreiOrlwiXSxbXCJjNzgwXCIsXCLojq/ojrXojrvojr7ojr/oj4Loj4Poj4Toj4boj4joj4noj4voj43oj47oj5Doj5Hoj5Loj5Poj5Xoj5foj5noj5roj5voj57oj6Loj6Poj6Toj6boj6foj6joj6voj6zoj63mgbDmtL3nibXmiabpko7pk4XljYPov4Hnrb7ku5/osKbkub7pu5TpkrHpkrPliY3mvZzpgaPmtYXosLTloJHltYzmrKDmrYnmnqrlkZvohZTnvozlopnolLflvLrmiqLmqYfplLnmlbLmgoTmoaXnnqfkuZTkvqjlt6fpnpjmkqznv5jls63kv4/nqo3liIfojITkuJTmgK/nqoPpkqbkvrXkurLnp6bnkLTli6Toirnmk5Lnpr3lr53msoHpnZLovbvmsKLlgL7ljb/muIXmk47mmbTmsLDmg4Xpobfor7fluobnkLznqbfnp4vkuJjpgrHnkIPmsYLlm5rphYvms4XotovljLrom4bmm7Louq/lsYjpqbHmuKBcIl0sW1wiYzg0MFwiLFwi6I+u6I+v6I+zXCIsNCxcIuiPuuiPu+iPvOiPvuiPv+iQgOiQguiQheiQh+iQiOiQieiQiuiQkOiQklwiLDUsXCLokJnokJrokJvokJ5cIiw1LFwi6JCpXCIsNyxcIuiQslwiLDUsXCLokLnokLrokLvokL5cIiw3LFwi6JGH6JGI6JGJXCJdLFtcImM4ODBcIixcIuiRilwiLDYsXCLokZJcIiw0LFwi6JGY6JGd6JGe6JGf6JGg6JGi6JGkXCIsNCxcIuiRquiRruiRr+iRsOiRsuiRtOiRt+iRueiRu+iRvOWPluWotum+i+i2o+WOu+WciOmip+adg+mGm+azieWFqOeXiuaLs+eKrOWIuOWKnee8uueClOeYuOWNtOm5iuamt+ehrumbgOijmee+pOeEtueHg+WGieafk+eTpOWjpOaUmOWat+iuqemltuaJsOe7leaDueeDreWjrOS7geS6uuW/jemfp+S7u+iupOWIg+Wmiue6q+aJlOS7jeaXpeaIjuiMuOiTieiNo+iejeeGlOa6tuWuuee7kuWGl+aPieaflOiCieiMueigleWEkuWtuuWmgui+seS5s+axneWFpeikpei9r+mYruiViueRnumUkOmXsOa2puiLpeW8seaSkua0kuiQqOiFrumzg+Whnui1m+S4ieWPgVwiXSxbXCJjOTQwXCIsXCLokb1cIiw0LFwi6JKD6JKE6JKF6JKG6JKK6JKN6JKPXCIsNyxcIuiSmOiSmuiSm+iSneiSnuiSn+iSoOiSolwiLDEyLFwi6JKw6JKx6JKz6JK16JK26JK36JK76JK86JK+6JOA6JOC6JOD6JOF6JOG6JOH6JOI6JOL6JOM6JOO6JOP6JOS6JOU6JOV6JOXXCJdLFtcImM5ODBcIixcIuiTmFwiLDQsXCLok57ok6Hok6Lok6Tok6dcIiw0LFwi6JOt6JOu6JOv6JOxXCIsMTAsXCLok73ok77olIDolIHolILkvJ7mlaPmoZHll5PkuKfmkJTpqprmiavlq4LnkZ/oibLmtqnmo67lg6fojo7noILmnYDliLnmspnnurHlgrvllaXnhZ7nrZvmmZLnj4roi6vmnYnlsbHliKDnhb3ooavpl6rpmZXmk4XotaHohrPlloTmsZXmiYfnvK7lopLkvKTllYbotY/mmYzkuIrlsJroo7PmoqLmjY7nqI3ng6foio3li7rpn7blsJHlk6jpgrXnu43lpaLotYrom4foiIzoiI3otabmkYTlsITmhZHmtonnpL7orr7noLfnlLPlkbvkvLjouqvmt7HlqKDnu4XnpZ7msojlrqHlqbbnlJrogr7mhY7muJflo7DnlJ/nlKXnibLljYfnu7NcIl0sW1wiY2E0MFwiLFwi6JSDXCIsOCxcIuiUjeiUjuiUj+iUkOiUkuiUlOiUleiUluiUmOiUmeiUm+iUnOiUneiUnuiUoOiUolwiLDgsXCLolK1cIiw5LFwi6JS+XCIsNCxcIuiVhOiVheiVhuiVh+iVi1wiLDEwXSxbXCJjYTgwXCIsXCLolZfolZjolZrolZvolZzolZ3olZ9cIiw0LFwi6JWl6JWm6JWn6JWpXCIsOCxcIuiVs+iVteiVtuiVt+iVuOiVvOiVveiVv+iWgOiWgeecgeebm+WJqeiDnOWco+W4iOWkseeLruaWvea5v+ivl+WwuOiZseWNgeefs+aLvuaXtuS7gOmjn+iagOWunuivhuWPsuefouS9v+WxjumptuWni+W8j+ekuuWjq+S4luafv+S6i+aLreiqk+mAneWKv+aYr+WXnOWZrOmAguS7leS+jemHiumlsOawj+W4guaBg+WupOinhuivleaUtuaJi+mmluWuiOWvv+aOiOWUruWPl+eYpuWFveiUrOaeouais+auiuaKkui+k+WPlOiIkua3keeWj+S5pui1juWtsOeGn+iWr+aakeabmee9suicgOm7jem8oOWxnuacr+i/sOagkeadn+aIjeerluWiheW6tuaVsOa8sVwiXSxbXCJjYjQwXCIsXCLoloLoloPolobolohcIiw2LFwi6JaQXCIsMTAsXCLolp1cIiw2LFwi6Jal6Jam6Jan6Jap6Jar6Jas6Jat6JaxXCIsNSxcIuiWuOiWulwiLDYsXCLol4JcIiw2LFwi6JeKXCIsNCxcIuiXkeiXklwiXSxbXCJjYjgwXCIsXCLol5Tol5ZcIiw1LFwi6JedXCIsNixcIuiXpeiXpuiXp+iXqOiXqlwiLDE0LFwi5oGV5Yi36ICN5pGU6KGw55Sp5biF5qCT5ou06Zyc5Y+M54i96LCB5rC0552h56iO5ZCu556s6aG66Iic6K+056GV5pyU54OB5pav5pKV5Zi25oCd56eB5Y+45Lid5q276IKG5a+65Zej5Zub5Ly65Ly86aWy5bez5p2+6IC45oCC6aKC6YCB5a6L6K686K+15pCc6ImY5pOe5Ze96IuP6YWl5L+X57Sg6YCf57Kf5YOz5aGR5rqv5a6/6K+J6IKD6YW46JKc566X6Jm96ZqL6ZqP57ul6auT56KO5bKB56mX6YGC6Zqn56Wf5a2Z5o2f56yL6JOR5qKt5ZSG57yp55CQ57Si6ZSB5omA5aGM5LuW5a6D5aW55aGUXCJdLFtcImNjNDBcIixcIuiXueiXuuiXvOiXveiXvuiYgFwiLDQsXCLomIZcIiwxMCxcIuiYkuiYk+iYlOiYleiYl1wiLDE1LFwi6Jio6JiqXCIsMTMsXCLomLnomLromLvomL3omL7omL/omYBcIl0sW1wiY2M4MFwiLFwi6JmBXCIsMTEsXCLomZLomZPomZVcIiw0LFwi6Jmb6Jmc6Jmd6Jmf6Jmg6Jmh6JmjXCIsNyxcIueNreaMnui5i+i4j+iDjuiLlOaKrOWPsOazsOmFnuWkquaAgeaxsOWdjeaRiui0queYq+a7qeWdm+aqgOeXsOa9reiwreiwiOWdpuavr+iikueis+aOouWPueeCreaxpOWhmOaQquWgguajoOiGm+WUkOezluWAmOi6uua3jOi2n+eDq+aOj+a2m+a7lOe7puiQhOahg+mAg+a3mOmZtuiuqOWll+eJueiXpOiFvueWvOiqiuair+WJlOi4oumUkeaPkOmimOi5hOWVvOS9k+abv+Waj+aDlea2leWJg+WxieWkqea3u+Whq+eUsOeUnOaBrOiIlOiFhuaMkeadoei/ouecuui3s+i0tOmTgeW4luWOheWQrOeDg1wiXSxbXCJjZDQwXCIsXCLoma3oma/ombDombJcIiw2LFwi6JqDXCIsNixcIuiajlwiLDQsXCLompTompZcIiw1LFwi6JqeXCIsNCxcIuiapeiapuiaq+iareiaruiasuias+iat+iauOiaueiau1wiLDQsXCLom4Hom4Lom4Pom4Xom4jom4zom43om5Lom5Pom5Xom5bom5fom5rom5xcIl0sW1wiY2Q4MFwiLFwi6Jud6Jug6Juh6Jui6Juj6Jul6Jum6Jun6Juo6Juq6Jur6Jus6Juv6Ju16Ju26Ju36Ju66Ju76Ju86Ju96Ju/6JyB6JyE6JyF6JyG6JyL6JyM6JyO6JyP6JyQ6JyR6JyU6JyW5rGA5bu35YGc5Lqt5bqt5oy66ImH6YCa5qGQ6YWu556z5ZCM6ZOc5b2k56ul5qG25o2F562S57uf55eb5YG35oqV5aS06YCP5Ye456eD56qB5Zu+5b6S6YCU5raC5bGg5Zyf5ZCQ5YWU5rmN5Zui5o6o6aKT6IW/6JyV6KSq6YCA5ZCe5bGv6IeA5ouW5omY6ISx6bi16ZmA6amu6am85qSt5aal5ouT5ZS+5oyW5ZOH6JuZ5rS85aiD55Om6KKc5q2q5aSW6LGM5byv5rm+546p6aG95Li454O35a6M56KX5oy95pma55qW5oOL5a6b5amJ5LiH6IWV5rGq546L5Lqh5p6J572R5b6A5pe65pyb5b+Y5aaE5aiBXCJdLFtcImNlNDBcIixcIuicmeicm+icneicn+icoOicpOicpuicp+icqOicquicq+icrOicreicr+icsOicsuics+icteictuicuOicueicuuicvOicveidgFwiLDYsXCLonYronYvonY3onY/onZDonZHonZLonZTonZXonZbonZjonZpcIiw1LFwi6J2h6J2i6J2mXCIsNyxcIuidr+idseidsuids+idtVwiXSxbXCJjZTgwXCIsXCLonbfonbjonbnonbronb/onoDonoHonoTonobonofonononoronozono5cIiw0LFwi6J6U6J6V6J6W6J6YXCIsNixcIuieoFwiLDQsXCLlt43lvq7ljbHpn6bov53moYXlm7TllK/mg5/kuLrmvY3nu7Toi4fokI7lp5TkvJ/kvKrlsL7nuqzmnKrolJrlkbPnlY/og4PlloLprY/kvY3muK3osJPlsInmhbDljavnmJ/muKnomormlofpl7vnurnlkLvnqLPntIrpl67ll6Hnv4Hnk67mjJ3onJfmtqHnqp3miJHmlqHljafmj6HmsoPlt6vlkZzpkqjkuYzmsaHor6zlsYvml6DoipzmoqflkL7lkLTmr4vmrabkupTmjYLljYjoiJ7kvI3kvq7lnZ7miIrpm77mmaTnianli7/liqHmgp/or6/mmJTnhpnmnpDopb/noZLnn73mmbDlmLvlkLjplKHnibpcIl0sW1wiY2Y0MFwiLFwi6J6l6J6m6J6n6J6p6J6q6J6u6J6w6J6x6J6y6J606J626J636J646J656J676J686J6+6J6/6J+BXCIsNCxcIuifh+ifiOifieifjFwiLDQsXCLon5RcIiw2LFwi6J+c6J+d6J+e6J+f6J+h6J+i6J+j6J+k6J+m6J+n6J+o6J+p6J+r6J+s6J+t6J+vXCIsOV0sW1wiY2Y4MFwiLFwi6J+66J+76J+86J+96J+/6KCA6KCB6KCC6KCEXCIsNSxcIuigi1wiLDcsXCLooJTooJfooJjooJnooJrooJxcIiw0LFwi6KCj56iA5oGv5biM5oKJ6Iad5aSV5oOc54aE54Ov5rqq5rGQ54qA5qqE6KKt5bit5Lmg5aqz5Zac6ZOj5rSX57O76ZqZ5oiP57uG556O6Jm+5Yyj6Zye6L6W5pqH5bOh5L6g54ut5LiL5Y6m5aSP5ZCT5o6A6ZSo5YWI5LuZ6bKc57qk5ZK46LSk6KGU6Ii36Zey5raO5bym5auM5pi+6Zmp546w54yu5Y6/6IW66aaF576h5a6q6Zm36ZmQ57q/55u45Y6i6ZW26aaZ566x6KWE5rmY5Lmh57+U56Wl6K+m5oOz5ZON5Lqr6aG55be35qmh5YOP5ZCR6LGh6JCn56Gd6ZyE5YmK5ZOu5Zqj6ZSA5raI5a615reG5pmTXCJdLFtcImQwNDBcIixcIuigpFwiLDEzLFwi6KCzXCIsNSxcIuiguuigu+igveigvuigv+ihgeihguihg+ihhlwiLDUsXCLooY5cIiw1LFwi6KGV6KGW6KGY6KGaXCIsNixcIuihpuihp+ihquihreihr+ihseihs+ihtOihteihtuihuOihueihulwiXSxbXCJkMDgwXCIsXCLoobvoobzoooDoooPooobooofooonooorooozooo7ooo/oopDoopHoopPoopToopXoopdcIiw0LFwi6KKdXCIsNCxcIuiio+iipVwiLDUsXCLlsI/lrZ3moKHogpbllbjnrJHmlYjmpZTkupvmrYfonY7pnovljY/mjJ/mkLrpgqrmlpzog4HosJDlhpnmorDljbjon7nmh4jms4Tms7vosKLlsZHolqroiq/plIzmrKPovpvmlrDlv7vlv4Pkv6HooYXmmJ/ohaXnjKnmg7rlhbTliJHlnovlvaLpgqLooYzphpLlubjmnY/mgKflp5PlhYTlh7bog7jljIjmsbnpm4TnhorkvJHkv67nvp7mnL3ll4XplIjnp4Doopbnu6Plop/miIzpnIDomZrlmJjpobvlvpDorrjok4TphZflj5nml63luo/nlZzmgaTnta7lqb/nu6rnu63ovanllqflrqPmgqzml4vnjoRcIl0sW1wiZDE0MFwiLFwi6KKs6KKu6KKv6KKw6KKyXCIsNCxcIuiiuOiiueiiuuiiu+iiveiivuiiv+ijgOijg+ijhOijh+ijiOijiuiji+ijjOijjeijj+ijkOijkeijk+ijluijl+ijmlwiLDQsXCLoo6Doo6Hoo6boo6foo6lcIiw2LFwi6KOy6KO16KO26KO36KO66KO76KO96KO/6KSA6KSB6KSDXCIsNV0sW1wiZDE4MFwiLFwi6KSJ6KSLXCIsNCxcIuikkeiklFwiLDQsXCLopJxcIiw0LFwi6KSi6KSj6KSk6KSm6KSn6KSo6KSp6KSs6KSt6KSu6KSv6KSx6KSy6KSz6KS16KS36YCJ55mj55yp57ua6Z206Jab5a2m56m06Zuq6KGA5YuL54aP5b6q5pes6K+i5a+76amv5beh5q6J5rGb6K6t6K6v6YCK6L+F5Y6L5oq86bim6bit5ZGA5Lir6Iq954mZ6Jqc5bSW6KGZ5rav6ZuF5ZOR5Lqa6K6254SJ5ZK96ZiJ54Of5re555uQ5Lil56CU6JyS5bKp5bu26KiA6aKc6ZiO54KO5rK/5aWE5o6p55y86KGN5ryU6Imz5aCw54eV5Y6M56Ca6ZuB5ZSB5b2m54Sw5a606LCa6aqM5q6D5aSu6biv56en5p2o5oms5L2v55ah576K5rSL6Ziz5rCn5Luw55eS5YW75qC35ry+6YKA6IWw5aaW55G2XCJdLFtcImQyNDBcIixcIuikuFwiLDgsXCLopYLopYPopYVcIiwyNCxcIuiloFwiLDUsXCLopadcIiwxOSxcIuilvFwiXSxbXCJkMjgwXCIsXCLopb3opb7opoDopoLopoTopoXopodcIiwyNixcIuaRh+Wwp+mBpeeqkeiwo+WnmuWSrOiIgOiNr+imgeiAgOaksOWZjuiAtueIt+mHjuWGtuS5n+mhteaOluS4muWPtuabs+iFi+WknOa2suS4gOWjueWMu+aPlumTseS+neS8iuiho+mikOWkt+mBl+enu+S7quiDsOeWkeayguWunOWnqOW9neakheiageWAmuW3suS5meefo+S7peiJuuaKkeaYk+mCkeWxueS6v+W9ueiHhumAuOiChOeWq+S6puijlOaEj+avheW/huS5ieebiua6ouivo+iuruiwiuivkeW8gue/vOe/jOe7juiMteiNq+WboOaut+mfs+mYtOWnu+WQn+mTtua3q+WvhemlruWwueW8lemakFwiXSxbXCJkMzQwXCIsXCLopqJcIiwzMCxcIuing+injeink+inlOinleinl+inmOinmeinm+inneinn+inoOinoeinouinpOinp+inqOinqeinquinrOinreinruinsOinseinsuintFwiLDZdLFtcImQzODBcIixcIuinu1wiLDQsXCLoqIFcIiw1LFwi6KiIXCIsMjEsXCLljbDoi7HmqLHlqbTpubDlupTnvKjojrnokKTokKXojafonYfov47otaLnm4jlvbHpopbnoazmmKDlk5/mi6XkvaPoh4Pnl4jlurjpm43ouIrom7nlko/ms7PmtozmsLjmgb/li4fnlKjlub3kvJjmgqDlv6flsKTnlLHpgq7pk4DnirnmsrnmuLjphYnmnInlj4vlj7PkvZHph4nor7Hlj4jlubzov4Lmt6Tkuo7nm4LmpobomZ7mhJroiIbkvZnkv57pgL7psbzmhInmuJ3muJTpmoXkuojlqLHpm6jkuI7lsb/nprnlrofor63nvr3njonln5/oiovpg4HlkIHpgYfllrvls6rlvqHmhIjmrLLni7HogrLoqolcIl0sW1wiZDQ0MFwiLFwi6KieXCIsMzEsXCLoqL9cIiw4LFwi6KmJXCIsMjFdLFtcImQ0ODBcIixcIuipn1wiLDI1LFwi6Km6XCIsNixcIua1tOWvk+ijlemihOixq+mprem4s+a4iuWGpOWFg+Weo+iigeWOn+aPtOi+leWbreWRmOWchueMv+a6kOe8mOi/nOiLkeaEv+aAqOmZouabsOe6pui2iui3g+mSpeWys+eypOaciOaCpumYheiAmOS6kemDp+WMgOmZqOWFgei/kOiVtOmFneaZlemfteWtleWMneeguOadguagveWTieeBvuWusOi9veWGjeWcqOWSseaUkuaagui1nui1g+iEj+iRrOmBreezn+WHv+iXu+aeo+aXqea+oeiapOi6geWZqumAoOeagueBtueHpei0o+aLqeWImeazvei0vOaAjuWinuaGjuabvui1oOaJjuWWs+a4o+acrei9p1wiXSxbXCJkNTQwXCIsXCLoqoFcIiw3LFwi6KqLXCIsNyxcIuiqlFwiLDQ2XSxbXCJkNTgwXCIsXCLoq4NcIiwzMixcIumToemXuOecqOagheamqOWSi+S5jeeCuOiviOaRmOaWi+WuheeqhOWAuuWvqOeeu+avoeipueeymOayvuebj+aWqei+l+W0reWxleiYuOagiOWNoOaImOermea5m+e7veaon+eroOW9sOa8s+W8oOaOjOa2qOadluS4iOW4kOi0puS7l+iDgOeYtOmanOaLm+aYreaJvuayvOi1teeFp+e9qeWFhuiCh+WPrOmBruaKmOWTsuibsOi+meiAhemUl+iUl+i/mea1meePjeaWn+ecn+eUhOegp+iHu+i0numSiOS+puaeleeWueiviumch+aMr+mVh+mYteiSuOaMo+edgeW+geeLsOS6ieaAlOaVtOaLr+ato+aUv1wiXSxbXCJkNjQwXCIsXCLoq6RcIiwzNCxcIuisiFwiLDI3XSxbXCJkNjgwXCIsXCLorKTorKXorKdcIiwzMCxcIuW4p+eXh+mDkeivgeiKneaeneaUr+WQseicmOefpeiCouiEguaxgeS5i+e7h+iBjOebtOakjeauluaJp+WAvOS+hOWdgOaMh+atoui2vuWPquaXqOe6uOW/l+aMmuaOt+iHs+iHtOe9ruW4nOWzmeWItuaZuuenqeeomui0qOeCmeeXlOa7nuayu+eqkuS4reebheW/oOmSn+iht+e7iOenjeiCv+mHjeS7suS8l+iIn+WRqOW3nua0suivjOeypei9tOiCmOW4muWSkueaseWumeaYvOmqpOePoOagquibm+acseeMquivuOivm+mAkOerueeDm+eFruaLhOeeqeWYseS4u+iRl+afseWKqeibgOi0rumTuOetkVwiXSxbXCJkNzQwXCIsXCLorYZcIiwzMSxcIuitp1wiLDQsXCLora1cIiwyNV0sW1wiZDc4MFwiLFwi6K6HXCIsMjQsXCLorqzorrHorrvor4for5Dor6rosInosJ7kvY/ms6jnpZ3pqbvmipPniKrmi73kuJPnoJbovazmkrDotZrnr4bmoanluoToo4Xlpobmkp7lo67nirbmpI7plKXov73otZjlnaDnvIDosIblh4bmjYnmi5nljZPmoYznkKLojIHphYzllYTnnYDngbzmtYrlhbnlkqjotYTlp7/mu4vmt4TlrZzntKvku5Tnsb3mu5PlrZDoh6rmuI3lrZfprIPmo5XouKrlrpfnu7zmgLvnurXpgrnotbDlpY/mj43np5/otrPljZLml4/npZbor4XpmLvnu4TpkrvnuoLlmLTphonmnIDnvarlsIrpgbXmmKjlt6bkvZDmn57lgZrkvZzlnZDluqdcIl0sW1wiZDg0MFwiLFwi6LC4XCIsOCxcIuixguixg+ixhOixheixiOixiuixi+ixjVwiLDcsXCLosZbosZfosZjosZnosZtcIiw1LFwi6LGjXCIsNixcIuixrFwiLDYsXCLosbTosbXosbbosbfosbtcIiw2LFwi6LKD6LKE6LKG6LKHXCJdLFtcImQ4ODBcIixcIuiyiOiyi+iyjVwiLDYsXCLospXospbospfosplcIiwyMCxcIuS6jeS4jOWFgOS4kOW7v+WNheS4leS6mOS4numssuWtrOWZqeS4qOemuuS4v+WMleS5h+WkreeIu+WNruawkOWbn+iDpOmml+avk+edvum8l+S4tuS6n+m8kOS5nOS5qeS6k+iKiOWtm+WVrOWYj+S7hOWOjeWOneWOo+WOpeWOrumdpei1neWMmuWPteWMpuWMruWMvui1nOWNpuWNo+WIguWIiOWIjuWIreWIs+WIv+WJgOWJjOWJnuWJoeWJnOiSr+WJveWKguWKgeWKkOWKk+WGgue9lOS6u+S7g+S7ieS7guS7qOS7oeS7q+S7nuS8m+S7s+S8ouS9pOS7teS8peS8p+S8ieS8q+S9nuS9p+aUuOS9muS9nVwiXSxbXCJkOTQwXCIsXCLosq5cIiw2Ml0sW1wiZDk4MFwiLFwi6LOtXCIsMzIsXCLkvZ/kvZfkvLLkvL3kvbbkvbTkvpHkvonkvoPkvo/kvb7kvbvkvqrkvbzkvqzkvpTkv6bkv6jkv6rkv4Xkv5rkv6Pkv5zkv5Hkv5/kv7jlgKnlgYzkv7PlgKzlgI/lgK7lgK3kv77lgJzlgIzlgKXlgKjlgb7lgYPlgZXlgYjlgY7lgazlgbvlgqXlgqflgqnlgrrlg5blhIblg63lg6zlg6blg67lhIflhIvku53msL3kvZjkvaXkv47pvqDmsYbnsbTlha7lt73pu4npppjlhoHlpJTli7nljI3oqIfljJDlh6vlpJnlhZXkuqDlhZbkurPooa7ooqTkurXohJToo5LnpoDlrLTooIPnvrjlhqvlhrHlhr3lhrxcIl0sW1wiZGE0MFwiLFwi6LSOXCIsMTQsXCLotKDotZHotZLotZfotZ/otaXotajotanotarotazota7ota/otbHotbLotbhcIiw4LFwi6LaC6LaD6LaG6LaH6LaI6LaJ6LaMXCIsNCxcIui2kui2k+i2lVwiLDksXCLotqDotqFcIl0sW1wiZGE4MFwiLFwi6Lai6LakXCIsMTIsXCLotrLotrbotrfotrnotrvotr3ot4Dot4Hot4Lot4Xot4fot4jot4not4rot43ot5Dot5Lot5Pot5Tlh4flhpblhqLlhqXorqDorqborqforqrorrTorrXorrfor4Lor4Por4vor4/or47or5Lor5Por5Tor5bor5jor5nor5zor5/or6Dor6Tor6jor6nor67or7Dor7Por7bor7nor7zor7/osIDosILosITosIfosIzosI/osJHosJLosJTosJXosJbosJnosJvosJjosJ3osJ/osKDosKHosKXosKfosKrosKvosK7osK/osLLosLPosLXosLbljanljbrpmJ3pmKLpmKHpmLHpmKrpmL3pmLzpmYLpmYnpmZTpmZ/pmafpmazpmbLpmbTpmojpmo3pmpfpmrDpgpfpgpvpgp3pgpnpgqzpgqHpgrTpgrPpgrbpgrpcIl0sW1wiZGI0MFwiLFwi6LeV6LeY6LeZ6Lec6Leg6Leh6Lei6Lel6Lem6Len6Lep6Let6Leu6Lew6Lex6Ley6Le06Le26Le86Le+XCIsNixcIui4hui4h+i4iOi4i+i4jei4jui4kOi4kei4kui4k+i4lVwiLDcsXCLouKDouKHouKRcIiw0LFwi6Lir6Lit6Liw6Liy6Liz6Li06Li26Li36Li46Li76Li86Li+XCJdLFtcImRiODBcIixcIui4v+i5g+i5hei5hui5jFwiLDQsXCLouZNcIiw1LFwi6LmaXCIsMTEsXCLouafouajouarouavoua7oubHpgrjpgrDpg4/pg4Xpgr7pg5Dpg4Tpg4fpg5Ppg6bpg6Lpg5zpg5fpg5vpg6vpg6/pg77phITphKLphJ7phKPphLHphK/phLnphYPphYbliI3lpYLliqLliqzliq3lir7lk7/li5Dli5bli7Dlj5/nh67nn43lu7Tlh7Xlh7zprK/ljrblvIHnlZrlt6/lnYzlnqnlnqHlob7lorzlo4Xlo5HlnKnlnKzlnKrlnLPlnLnlnK7lnK/lnZzlnLvlnYLlnanlnoXlnavlnoblnbzlnbvlnajlna3lnbblnbPlnq3lnqTlnozlnrLln4/lnqflnrTlnpPlnqDln5Xln5jln5rln5nln5Llnrjln7Tln6/ln7jln6Tln51cIl0sW1wiZGM0MFwiLFwi6Lmz6Lm16Lm3XCIsNCxcIui5vei5vui6gOi6gui6g+i6hOi6hui6iFwiLDYsXCLoupHoupLoupPoupVcIiw2LFwi6Lqd6LqfXCIsMTEsXCLouq3ouq7ourDourHourNcIiw2LFwi6Lq7XCIsN10sW1wiZGM4MFwiLFwi6LuDXCIsMTAsXCLou49cIiwyMSxcIuWgi+WgjeWfveWfreWggOWgnuWgmeWhhOWgoOWhpeWhrOWigeWiieWimuWigOmmqOm8meaHv+iJueiJveiJv+iKj+iKiuiKqOiKhOiKjuiKkeiKl+iKmeiKq+iKuOiKvuiKsOiLiOiLiuiLo+iKmOiKt+iKruiLi+iLjOiLgeiKqeiKtOiKoeiKquiKn+iLhOiLjuiKpOiLoeiMieiLt+iLpOiMj+iMh+iLnOiLtOiLkuiLmOiMjOiLu+iLk+iMkeiMmuiMhuiMlOiMleiLoOiLleiMnOiNkeiNm+iNnOiMiOiOkuiMvOiMtOiMseiOm+iNnuiMr+iNj+iNh+iNg+iNn+iNgOiMl+iNoOiMreiMuuiMs+iNpuiNpVwiXSxbXCJkZDQwXCIsXCLou6VcIiw2Ml0sW1wiZGQ4MFwiLFwi6LykXCIsMzIsXCLojajojJvojanojazojaroja3oja7ojrDojbjojrPojrTojqDojqrojpPojpzojoXojbzojrbojqnojb3ojrjojbvojpjojp7ojqjojrrojrzoj4HokIHoj6Xoj5jloIfokJjokIvoj53oj73oj5bokJzokLjokJHokIboj5Toj5/okI/okIPoj7joj7noj6roj4Xoj4DokKboj7Doj6HokZzokZHokZrokZnokbPokofokojokbrokonokbjokLzokYbokanokbbokozoko7okLHoka3ok4Hok43ok5Dok6bokr3ok5Pok4rokr/okrrok6DokqHokrnokrTokpfok6Xok6PolIznlI3olLjok7DolLnolJ/olLpcIl0sW1wiZGU0MFwiLFwi6L2FXCIsMzIsXCLovarovoDovozovpLovp3ovqDovqHovqLovqTovqXovqbovqfovqrovqzovq3ovq7ovq/ovrLovrPovrTovrXovrfovrjovrrovrvovrzovr/ov4Dov4Pov4ZcIl0sW1wiZGU4MFwiLFwi6L+JXCIsNCxcIui/j+i/kui/lui/l+i/mui/oOi/oei/o+i/p+i/rOi/r+i/sei/sui/tOi/tei/tui/uui/u+i/vOi/vui/v+mAh+mAiOmAjOmAjumAk+mAlemAmOiVluiUu+iTv+iTvOiVmeiViOiVqOiVpOiVnuiVuueeouiVg+iVsuiVu+iWpOiWqOiWh+iWj+iVueiWruiWnOiWheiWueiWt+iWsOiXk+iXgeiXnOiXv+iYp+iYheiYqeiYluiYvOW7vuW8iOWkvOWlgeiAt+WlleWlmuWlmOWMj+WwouWwpeWwrOWwtOaJjOaJquaKn+aKu+aLiuaLmuaLl+aLruaMouaLtuaMueaNi+aNg+aOreaPtuaNseaNuuaOjuaOtOaNreaOrOaOiuaNqeaOruaOvOaPsuaPuOaPoOaPv+aPhOaPnuaPjuaRkuaPhuaOvuaRheaRgeaQi+aQm+aQoOaQjOaQpuaQoeaRnuaShOaRreaSllwiXSxbXCJkZjQwXCIsXCLpgJnpgJzpgKPpgKTpgKXpgKdcIiw1LFwi6YCwXCIsNCxcIumAt+mAuemAuumAvemAv+mBgOmBg+mBhemBhumBiFwiLDQsXCLpgY7pgZTpgZXpgZbpgZnpgZrpgZxcIiw1LFwi6YGk6YGm6YGn6YGp6YGq6YGr6YGs6YGvXCIsNCxcIumBtlwiLDYsXCLpgb7pgoFcIl0sW1wiZGY4MFwiLFwi6YKE6YKF6YKG6YKH6YKJ6YKK6YKMXCIsNCxcIumCkumClOmClumCmOmCmumCnOmCnumCn+mCoOmCpOmCpemCp+mCqOmCqemCq+mCremCsumCt+mCvOmCvemCv+mDgOaRuuaSt+aSuOaSmeaSuuaTgOaTkOaTl+aTpOaTouaUieaUpeaUruW8i+W/kueUmeW8keWNn+WPseWPveWPqeWPqOWPu+WQkuWQluWQhuWRi+WRkuWRk+WRlOWRluWRg+WQoeWRl+WRmeWQo+WQsuWSguWSlOWRt+WRseWRpOWSmuWSm+WShOWRtuWRpuWSneWTkOWSreWTguWStOWTkuWSp+WSpuWTk+WTlOWRsuWSo+WTleWSu+WSv+WTjOWTmeWTmuWTnOWSqeWSquWSpOWTneWTj+WTnuWUm+WTp+WUoOWTveWUlOWTs+WUouWUo+WUj+WUkeWUp+WUquWVp+WWj+WWteWVieWVreWVgeWVleWUv+WVkOWUvFwiXSxbXCJlMDQwXCIsXCLpg4Lpg4Ppg4bpg4jpg4npg4vpg4zpg43pg5Lpg5Tpg5Xpg5bpg5jpg5npg5rpg57pg5/pg6Dpg6Ppg6Tpg6Xpg6npg6rpg6zpg67pg7Dpg7Hpg7Lpg7Ppg7Xpg7bpg7fpg7npg7rpg7vpg7zpg7/phIDphIHphIPphIVcIiwxOSxcIumEmumEm+mEnFwiXSxbXCJlMDgwXCIsXCLphJ3phJ/phKDphKHphKRcIiwxMCxcIumEsOmEslwiLDYsXCLphLpcIiw4LFwi6YWE5ZS35ZWW5ZW15ZW25ZW35ZSz5ZSw5ZWc5ZaL5ZeS5ZaD5Zax5Za55ZaI5ZaB5Zaf5ZW+5ZeW5ZaR5ZW75Zef5Za95Za+5ZaU5ZaZ5Zeq5Ze35ZeJ5Zif5ZeR5Zer5Zes5ZeU5Zem5Zed5ZeE5Zev5Zel5Zey5Zez5ZeM5ZeN5Zeo5Ze15Zek6L6U5Zie5ZiI5ZiM5ZiB5Zik5Zij5Ze+5ZiA5Zin5Zit5ZmY5Zi55ZmX5Zis5ZmN5Zmi5ZmZ5Zmc5ZmM5ZmU5ZqG5Zmk5Zmx5Zmr5Zm75Zm85ZqF5ZqT5Zqv5ZuU5ZuX5Zud5Zuh5Zu15Zur5Zu55Zu/5ZyE5ZyK5ZyJ5Zyc5biP5biZ5biU5biR5bix5bi75bi8XCJdLFtcImUxNDBcIixcIumFhemFh+mFiOmFkemFk+mFlOmFlemFlumFmOmFmemFm+mFnOmFn+mFoOmFpumFp+mFqOmFq+mFremFs+mFuumFu+mFvOmGgFwiLDQsXCLphobphojphorpho7pho/phpNcIiw2LFwi6YacXCIsNSxcIumGpFwiLDUsXCLphqvphqzphrDphrHphrLphrPphrbphrfphrjphrnphrtcIl0sW1wiZTE4MFwiLFwi6Ya8XCIsMTAsXCLph4jph4vph5Dph5JcIiw5LFwi6YedXCIsOCxcIuW4t+W5hOW5lOW5m+W5nuW5oeWyjOWxuuWyjeWykOWyluWyiOWymOWymeWykeWymuWynOWyteWyouWyveWyrOWyq+WyseWyo+WzgeWyt+WzhOWzkuWzpOWzi+WzpeW0guW0g+W0p+W0puW0ruW0pOW0nuW0huW0m+W1mOW0vuW0tOW0veW1rOW1m+W1r+W1neW1q+W1i+W1iuW1qeW1tOW2guW2meW2neixs+W2t+W3heW9s+W9t+W+guW+h+W+ieW+jOW+leW+meW+nOW+qOW+reW+teW+vOihouW9oeeKreeKsOeKtOeKt+eKuOeLg+eLgeeLjueLjeeLkueLqOeLr+eLqeeLsueLtOeLt+eMgeeLs+eMg+eLulwiXSxbXCJlMjQwXCIsXCLph6ZcIiw2Ml0sW1wiZTI4MFwiLFwi6YilXCIsMzIsXCLni7vnjJfnjJPnjKHnjIrnjJ7njJ3njJXnjKLnjLnnjKXnjKznjLjnjLHnjZDnjY3njZfnjaDnjaznja/njb7oiJvlpKXpo6flpKTlpILppaPppadcIiw1LFwi6aW06aW36aW96aaA6aaE6aaH6aaK6aaN6aaQ6aaR6aaT6aaU6aaV5bqA5bqR5bqL5bqW5bql5bqg5bq55bq15bq+5bqz6LWT5buS5buR5bub5buo5buq6Ia65b+E5b+J5b+W5b+P5oCD5b+u5oCE5b+h5b+k5b++5oCF5oCG5b+q5b+t5b+45oCZ5oC15oCm5oCb5oCP5oCN5oCp5oCr5oCK5oC/5oCh5oG45oG55oG75oG65oGCXCJdLFtcImUzNDBcIixcIumJhlwiLDQ1LFwi6Ym1XCIsMTZdLFtcImUzODBcIixcIumKhlwiLDcsXCLpio9cIiwyNCxcIuaBquaBveaCluaCmuaCreaCneaCg+aCkuaCjOaCm+aDrOaCu+aCseaDneaDmOaDhuaDmuaCtOaEoOaEpuaEleaEo+aDtOaEgOaEjuaEq+aFiuaFteaGrOaGlOaGp+aGt+aHlOaHteW/nemas+mXqemXq+mXsemXs+mXtemXtumXvOmXvumYg+mYhOmYhumYiOmYiumYi+mYjOmYjemYj+mYkumYlemYlumYl+mYmemYmuS4rOeIv+aIleawteaxlOaxnOaxiuayo+ayheaykOaylOayjOaxqOaxqeaxtOaxtuayhuayqeazkOazlOayreazt+azuOazseazl+aysuazoOazluazuuazq+azruayseazk+azr+azvlwiXSxbXCJlNDQwXCIsXCLpiqhcIiw1LFwi6YqvXCIsMjQsXCLpi4lcIiwzMV0sW1wiZTQ4MFwiLFwi6YupXCIsMzIsXCLmtLnmtKfmtIzmtYPmtYjmtIfmtITmtJnmtI7mtKvmtY3mtK7mtLXmtJrmtY/mtZLmtZTmtLPmtpHmta/mtp7mtqDmtZ7mtpPmtpTmtZzmtaDmtbzmtaPmuJrmt4fmt4Xmt57muI7mtr/mt6DmuJHmt6bmt53mt5nmuJbmtqvmuIzmtq7muKvmua7muY7muavmurLmuZ/muobmuZPmuZTmuLLmuKXmuYTmu5/murHmupjmu6DmvK3mu6LmuqXmuqfmur3murvmurfmu5fmurTmu4/muo/mu4Lmup/mvaLmvYbmvYfmvKTmvJXmu7nmvK/mvLbmvYvmvbTmvKrmvInmvKnmvonmvo3mvozmvbjmvbLmvbzmvbrmv5FcIl0sW1wiZTU0MFwiLFwi6YyKXCIsNTEsXCLpjL9cIiwxMF0sW1wiZTU4MFwiLFwi6Y2KXCIsMzEsXCLpjavmv4nmvqfmvrnmvrbmv4Lmv6Hmv67mv57mv6Dmv6/ngJrngKPngJvngLnngLXngY/ngZ7lroDlroTlrpXlrpPlrqXlrrjnlK/pqp7mkLTlr6Tlr67opLDlr7DouYforIfovrbov5Pov5Xov6Xov67ov6Tov6nov6bov7Pov6jpgIXpgITpgIvpgKbpgJHpgI3pgJbpgKHpgLXpgLbpgK3pgK/pgYTpgZHpgZLpgZDpgajpgZjpgaLpgZvmmrnpgbTpgb3pgoLpgojpgoPpgovlvZDlvZflvZblvZjlsLvlkqvlsZDlsZnlrbHlsaPlsabnvrzlvKrlvKnlvK3oibTlvLzprLvlsa7lpoHlpoPlpo3lpqnlpqrlpqNcIl0sW1wiZTY0MFwiLFwi6Y2sXCIsMzQsXCLpjpBcIiwyN10sW1wiZTY4MFwiLFwi6Y6sXCIsMjksXCLpj4vpj4zpj43lppflp4rlpqvlpp7lpqTlp5LlprLlpq/lp5flpr7lqIXlqIblp53lqIjlp6Plp5jlp7nlqIzlqInlqLLlqLTlqJHlqKPlqJPlqYDlqaflqYrlqZXlqLzlqaLlqbXog6zlqqrlqpvlqbflqbrlqr7lq6vlqrLlq5Llq5Tlqrjlq6Dlq6Plq7Hlq5blq6blq5jlq5zlrInlrJflrJblrLLlrLflrYDlsJXlsJzlrZrlraXlrbPlrZHlrZPlraLpqbXpqbfpqbjpqbrpqb/pqb3pqoDpqoHpqoXpqojpqorpqpDpqpLpqpPpqpbpqpjpqpvpqpzpqp3pqp/pqqDpqqLpqqPpqqXpqqfnup/nuqHnuqPnuqXnuqjnuqlcIl0sW1wiZTc0MFwiLFwi6Y+OXCIsNyxcIumPl1wiLDU0XSxbXCJlNzgwXCIsXCLpkI5cIiwzMixcIue6ree6sOe6vue7gOe7gee7gue7iee7i+e7jOe7kOe7lOe7l+e7m+e7oOe7oee7qOe7q+e7rue7r+e7see7sue8jee7tue7uue7u+e7vue8gee8gue8g+e8h+e8iOe8i+e8jOe8j+e8kee8kue8l+e8mee8nOe8m+e8n+e8oVwiLDYsXCLnvKrnvKvnvKznvK3nvK9cIiw0LFwi57y15bm655W/5beb55S+6YKV546O546R546u546i546f54+P54+C54+R5463546z54+A54+J54+I54+l54+Z6aG855CK54+p54+n54+e546654+y55CP55Cq55Gb55Cm55Cl55Co55Cw55Cu55CsXCJdLFtcImU4NDBcIixcIumQr1wiLDE0LFwi6ZC/XCIsNDMsXCLpkazpka3pka7pka9cIl0sW1wiZTg4MFwiLFwi6ZGwXCIsMjAsXCLpkpHpkpbpkpjpk4fpk4/pk5Ppk5Tpk5rpk6bpk7vplJzplKDnkJvnkJrnkYHnkZznkZfnkZXnkZnnkbfnka3nkb7nkpznko7nkoDnkoHnkofnkovnkp7nkqjnkqnnkpDnkqfnk5Lnkrrpn6rpn6vpn6zmnYzmnZPmnZ7mnYjmnanmnqXmnofmnarmnbPmnpjmnqfmnbXmnqjmnp7mnq3mnovmnbfmnbzmn7DmoInmn5jmoIrmn6nmnrDmoIzmn5nmnrXmn5rmnrPmn53moIDmn4Pmnrjmn6LmoI7mn4Hmn73moLLmoLPmoaDmoaHmoY7moaLmoYTmoaTmooPmoJ3moZXmoabmoYHmoafmoYDmoL7moYrmoYnmoKnmorXmoo/mobTmobfmopPmoavmo4Lmpa7mo7zmpJ/mpKDmo7lcIl0sW1wiZTk0MFwiLFwi6ZSn6ZSz6ZS96ZWD6ZWI6ZWL6ZWV6ZWa6ZWg6ZWu6ZW06ZW16ZW3XCIsNyxcIumWgFwiLDQyXSxbXCJlOTgwXCIsXCLplqtcIiwzMixcIuakpOajsOaki+akgeall+ajo+akkOalseakuealoOalgualneamhOalq+amgOammOaluOaktOanjOamh+amiOanjuamiealpualo+alueamm+amp+amu+amq+amreanlOamseangeaniuann+amleanoOamjeanv+aor+anreaol+aomOappeansuaphOaovuaqoOapkOapm+aoteaqjuapueaoveaoqOapmOapvOaqkeaqkOaqqeaql+aqq+eMt+eNkuaugeauguauh+auhOaukuauk+aujeaumuaum+auoeauqui9q+i9rei9sei9sui9s+i9tei9tui9uOi9t+i9uei9uui9vOi9vui+gei+gui+hOi+h+i+i1wiXSxbXCJlYTQwXCIsXCLpl4xcIiwyNyxcIumXrOmXv+mYh+mYk+mYmOmYm+mYnumYoOmYo1wiLDYsXCLpmKvpmKzpmK3pmK/pmLDpmLfpmLjpmLnpmLrpmL7pmYHpmYPpmYrpmY7pmY/pmZHpmZLpmZPpmZbpmZdcIl0sW1wiZWE4MFwiLFwi6ZmY6ZmZ6Zma6Zmc6Zmd6Zme6Zmg6Zmj6Zml6Zmm6Zmr6ZmtXCIsNCxcIumZs+mZuFwiLDEyLFwi6ZqH6ZqJ6ZqK6L6N6L6O6L6P6L6Y6L6a6LuO5oiL5oiX5oib5oif5oii5oih5oil5oik5ois6Ien55Ov55O055O/55SP55SR55ST5pS05peu5pev5pew5piK5piZ5p2y5piD5piV5piA54KF5pu35pid5pi05pix5pi25pi16ICG5pmf5pmU5pmB5pmP5pmW5pmh5pmX5pm35pqE5pqM5pqn5pqd5pq+5pub5puc5pum5pup6LSy6LSz6LS26LS76LS96LWA6LWF6LWG6LWI6LWJ6LWH6LWN6LWV6LWZ6KeH6KeK6KeL6KeM6KeO6KeP6KeQ6KeR54mu54qf54md54mm54mv54m+54m/54qE54qL54qN54qP54qS5oyI5oyy5o6wXCJdLFtcImViNDBcIixcIumajOmajumakemakumak+malemalumamumam+manVwiLDksXCLpmqhcIiw3LFwi6Zqx6Zqy6Zq06Zq16Zq36Zq46Zq66Zq76Zq/6ZuC6ZuD6ZuI6ZuK6ZuL6ZuQ6ZuR6ZuT6ZuU6ZuWXCIsOSxcIumboVwiLDYsXCLpm6tcIl0sW1wiZWI4MFwiLFwi6Zus6Zut6Zuu6Zuw6Zux6Zuy6Zu06Zu16Zu46Zu66Zu76Zu86Zu96Zu/6ZyC6ZyD6ZyF6ZyK6ZyL6ZyM6ZyQ6ZyR6ZyS6ZyU6ZyV6ZyXXCIsNCxcIumcnemcn+mcoOaQv+aTmOiAhOavquavs+avveavteavueawheawh+awhuawjeawleawmOawmeawmuawoeawqeawpOawquawsuaUteaVleaVq+eJjeeJkueJlueIsOiZouWIluiCn+iCnOiCk+iCvOaciuiCveiCseiCq+iCreiCtOiCt+iDp+iDqOiDqeiDquiDm+iDguiDhOiDmeiDjeiDl+ackOiDneiDq+iDseiDtOiDreiEjeiEjuiDsuiDvOacleiEkuixmuiEtuiEnuiErOiEmOiEsuiFiOiFjOiFk+iFtOiFmeiFmuiFseiFoOiFqeiFvOiFveiFreiFp+WhjeWqteiGiOiGguiGkea7leiGo+iGquiHjOacpuiHiuiGu1wiXSxbXCJlYzQwXCIsXCLpnKFcIiw4LFwi6Zyr6Zys6Zyu6Zyv6Zyx6ZyzXCIsNCxcIumcuumcu+mcvOmcvemcv1wiLDE4LFwi6Z2U6Z2V6Z2X6Z2Y6Z2a6Z2c6Z2d6Z2f6Z2j6Z2k6Z2m6Z2n6Z2o6Z2qXCIsN10sW1wiZWM4MFwiLFwi6Z2y6Z216Z23XCIsNCxcIumdvVwiLDcsXCLpnoZcIiw0LFwi6Z6M6Z6O6Z6P6Z6Q6Z6T6Z6V6Z6W6Z6X6Z6ZXCIsNCxcIuiHgeiGpuaspOast+asueatg+athuatmemjkemjkumjk+mjlemjmemjmuaus+W9gOavguins+aWkOm9keaWk+aWvOaXhuaXhOaXg+aXjOaXjuaXkuaXlueCgOeCnOeClueCneeCu+eDgOeCt+eCq+eCseeDqOeDiueEkOeEk+eElueEr+eEseeFs+eFnOeFqOeFheeFsueFiueFuOeFuueGmOeGs+eGteeGqOeGoOeHoOeHlOeHp+eHueeIneeIqOeBrOeEmOeFpueGueaIvuaIveaJg+aJiOaJieeku+elgOelhuelieelm+elnOelk+elmuelouell+eloOelr+elp+eluuemheemiuemmuemp+ems+W/keW/kFwiXSxbXCJlZDQwXCIsXCLpnp7pnp/pnqHpnqLpnqRcIiw2LFwi6Z6s6Z6u6Z6w6Z6x6Z6z6Z61XCIsNDZdLFtcImVkODBcIixcIumfpOmfpemfqOmfrlwiLDQsXCLpn7Tpn7dcIiwyMyxcIuaAvOaBneaBmuaBp+aBgeaBmeaBo+aCq+aEhuaEjeaFneaGqeaGneaHi+aHkeaIhuiCgOiBv+ayk+aztua3vOeftuefuOeggOegieegl+egmOegkeaWq+egreegnOegneegueeguuegu+egn+egvOegpeegrOego+egqeehjuehreehluehl+egpuehkOehh+ehjOehqueim+eik+eimueih+einOeioeeio+eisueiueeipeejlOejmeejieejrOejsuekheejtOekk+ekpOeknuektOm+m+m7uem7u+m7vOebseechOecjeebueech+eciOecmuecouecmeecreecpuecteecuOedkOedkeedh+edg+edmuedqFwiXSxbXCJlZTQwXCIsXCLpoI9cIiw2Ml0sW1wiZWU4MFwiLFwi6aGOXCIsMzIsXCLnnaLnnaXnnb/nno3nnb3nnoDnnoznnpHnnp/nnqDnnrDnnrXnnr3nlLrnlYDnlY7nlYvnlYjnlZvnlbLnlbnnloPnvZjnvaHnvZ/oqYjnvajnvbTnvbHnvbnnvoHnvb7nm43nm6XooLLpkoXpkobpkofpkovpkorpkozpko3pko/pkpDpkpTpkpfpkpXpkprpkpvpkpzpkqPpkqTpkqvpkqrpkq3pkqzpkq/pkrDpkrLpkrTpkrZcIiw0LFwi6ZK86ZK96ZK/6ZOE6ZOIXCIsNixcIumTkOmTkemTkumTlemTlumTl+mTmemTmOmTm+mTnumTn+mToOmToumTpOmTpemTp+mTqOmTqlwiXSxbXCJlZjQwXCIsXCLpoa9cIiw1LFwi6aKL6aKO6aKS6aKV6aKZ6aKj6aKoXCIsMzcsXCLpo4/po5Dpo5Tpo5bpo5fpo5vpo5zpo53po6BcIiw0XSxbXCJlZjgwXCIsXCLpo6Xpo6bpo6lcIiwzMCxcIumTqemTq+mTrumTr+mTs+mTtOmTtemTt+mTuemTvOmTvemTv+mUg+mUgumUhumUh+mUiemUiumUjemUjumUj+mUklwiLDQsXCLplJjplJvplJ3plJ7plJ/plKLplKrplKvplKnplKzplLHplLLplLTplLbplLfplLjplLzplL7plL/plYLplLXplYTplYXplYbplYnplYzplY7plY/plZLplZPplZTplZbplZfplZjplZnplZvplZ7plZ/plZ3plaHplaLplaRcIiw4LFwi6ZWv6ZWx6ZWy6ZWz6ZS655+n55+s6ZuJ56eV56et56ej56er56iG5bWH56iD56iC56ie56iUXCJdLFtcImYwNDBcIixcIumkiFwiLDQsXCLppI7ppI/ppJFcIiwyOCxcIumkr1wiLDI2XSxbXCJmMDgwXCIsXCLppYpcIiw5LFwi6aWWXCIsMTIsXCLppaTppabppbPppbjppbnppbvppb7ppoLppoPpponnqLnnqLfnqZHpu4/ppqXnqbDnmojnmo7nmpPnmpnnmqTnk57nk6DnlKzpuKDpuKLpuKhcIiw0LFwi6biy6bix6bi26bi46bi36bi56bi66bi+6bmB6bmC6bmE6bmG6bmH6bmI6bmJ6bmL6bmM6bmO6bmR6bmV6bmX6bma6bmb6bmc6bme6bmj6bmmXCIsNixcIum5sem5rem5s+eWkueWlOeWlueWoOeWneeWrOeWo+eWs+eWtOeWuOeXhOeWseeWsOeXg+eXgueXlueXjeeXo+eXqOeXpueXpOeXq+eXp+eYg+eXseeXvOeXv+eYkOeYgOeYheeYjOeYl+eYiueYpeeYmOeYleeYmVwiXSxbXCJmMTQwXCIsXCLppozppo7ppppcIiwxMCxcIummpummp+mmqVwiLDQ3XSxbXCJmMTgwXCIsXCLpp5lcIiwzMixcIueYm+eYvOeYoueYoOeZgOeYreeYsOeYv+eYteeZg+eYvueYs+eZjeeZnueZlOeZnOeZlueZq+eZr+e/iuerpuepuOepueeqgOeqhueqiOeqleeqpueqoOeqrOeqqOeqreeqs+ihpOihqeihsuihveihv+iiguiiouijhuiit+iivOijieijouijjuijo+ijpeijseikmuijvOijqOijvuijsOikoeikmeikk+ikm+ikiuiktOikq+iktuilgeilpuilu+eWi+iDpeeasueatOefnOiAkuiAlOiAluiAnOiAoOiAouiApeiApuiAp+iAqeiAqOiAseiAi+iAteiBg+iBhuiBjeiBkuiBqeiBseimg+mhuOmigOmig1wiXSxbXCJmMjQwXCIsXCLpp7pcIiw2Ml0sW1wiZjI4MFwiLFwi6ai5XCIsMzIsXCLpoonpoozpoo3poo/popTpoprpopvpop7pop/poqHpoqLpoqXpoqbomY3omZTomazoma7omb/ombrombzombvomqjomo3omovomqzomp3omqfomqPomqrompPomqnomrbom4TomrXom47omrDomrromrHomq/om4nom4/omrTom6nom7Hom7Lom63om7Pom5DonJPom57om7Tom5/om5jom5HonIPonIfom7jonIjonIronI3onInonKPonLvonJ7onKXonK7onJronL7onYjonLTonLHonKnonLfonL/onoLonKLonb3onb7onbvonaDonbDonYzona7onovonZPonaPonbzonaTonZnonaXonpPonq/onqjon5JcIl0sW1wiZjM0MFwiLFwi6amaXCIsMTcsXCLpqbLpqoPpqonpqo3pqo7pqpTpqpXpqpnpqqbpqqlcIiw2LFwi6aqy6aqz6aq06aq16aq56aq76aq96aq+6aq/6auD6auE6auGXCIsNCxcIumrjemrjumrj+mrkOmrkumrlOmrlemrlumrl+mrmemrmumrm+mrnFwiXSxbXCJmMzgwXCIsXCLpq53pq57pq6Dpq6Lpq6Ppq6Tpq6Xpq6fpq6jpq6npq6rpq6zpq67pq7BcIiw4LFwi6au66au8XCIsNixcIumshOmshemshuifhuieiOieheiereiel+ieg+ieq+ifpeierOieteies+ifi+ifk+ieveifkeifgOifiuifm+ifquifoOifruigluigk+ifvuigiuigm+igoeigueigvOe8tue9gue9hOe9heiIkOeruuerveesiOesg+eshOesleesiuesq+esj+eth+esuOesquesmeesruesseesoOespeespOess+esvuesnuetmOetmuetheetteetjOetneetoOetruetu+etouetsuetseeukOeupueup+euuOeurOeuneeuqOeuheeuqueunOeuoueuq+eutOevkeevgeevjOevneevmuevpeevpuevquewjOevvuevvOewj+ewluewi1wiXSxbXCJmNDQwXCIsXCLprIfprIlcIiw1LFwi6ayQ6ayR6ayS6ayUXCIsMTAsXCLprKDprKHprKLprKRcIiwxMCxcIumssOmssemss1wiLDcsXCLprL3prL7prL/prYDprYbprYrprYvprYzprY7prZDprZLprZPprZVcIiw1XSxbXCJmNDgwXCIsXCLprZtcIiwzMixcIuewn+ewquewpuewuOexgeexgOiHvuiIgeiIguiIhOiHrOihhOiIoeiIouiIo+iIreiIr+iIqOiIq+iIuOiIu+iIs+iItOiIvuiJhOiJieiJi+iJj+iJmuiJn+iJqOihvuiiheiiiOijmOijn+ilnue+nee+n+e+p+e+r+e+sOe+suexvOaVieeykeeyneeynOeynueyoueysueyvOeyveezgeezh+ezjOezjeeziOezheezl+ezqOiJruaaqOe+v+e/jue/lee/pee/oee/pue/qee/rue/s+ezuOe1t+e2pue2rue5h+e6m+m6uOm6tOi1s+i2hOi2lOi2kei2sei1p+i1reixh+ixiemFiumFkOmFjumFj+mFpFwiXSxbXCJmNTQwXCIsXCLprbxcIiw2Ml0sW1wiZjU4MFwiLFwi6a67XCIsMzIsXCLphaLphaHphbDphanpha/phb3phb7phbLphbTphbnphozphoXphpDpho3phpHphqLphqPphqrphq3phq7phq/phrXphrTphrrosZXpub7otrjot6vouIXouZnouanotrXotr/otrzotrrot4Tot5bot5fot5rot57ot47ot4/ot5vot4bot6zot7fot7jot6Pot7not7vot6TouInot73ouJTouJ3ouJ/ouKzouK7ouKPouK/ouLrouYDouLnouLXouL3ouLHouYnouYHouYLouZHouZLouYroubDoubboubzoua/oubTouoXouo/oupToupDoupzoup7osbjosoLosorosoXospjospTmlpvop5bop57op5rop5xcIl0sW1wiZjY0MFwiLFwi6a+cXCIsNjJdLFtcImY2ODBcIixcIumwm1wiLDMyLFwi6Kel6Ker6Kev6Ki+6Kym6Z2T6Zup6Zuz6Zuv6ZyG6ZyB6ZyI6ZyP6ZyO6Zyq6Zyt6Zyw6Zy+6b6A6b6D6b6FXCIsNSxcIum+jOm7vum8i+m8jemauemavOmavembjumbkueev+mboOmKjumKrumLiOmMvumNqumPiumOj+mQvumRq+mxv+mygumyhemyhumyh+myiOeoo+myi+myjumykOmykemykumylOmylemymumym+mynlwiLDUsXCLpsqVcIiw0LFwi6bKr6bKt6bKu6bKwXCIsNyxcIumyuumyu+myvOmyvemzhOmzhemzhumzh+mziumzi1wiXSxbXCJmNzQwXCIsXCLpsLxcIiw2Ml0sW1wiZjc4MFwiLFwi6bG76bG96bG+6bKA6bKD6bKE6bKJ6bKK6bKM6bKP6bKT6bKW6bKX6bKY6bKZ6bKd6bKq6bKs6bKv6bK56bK+XCIsNCxcIumziOmziemzkemzkumzmumzm+mzoOmzoemzjFwiLDQsXCLps5Pps5Tps5Xps5fps5jps5nps5zps53ps5/ps6LpnbzpnoXpnpHpnpLpnpTpnq/pnqvpnqPpnrLpnrTpqrHpqrDpqrfpuZjpqrbpqrrpqrzpq4Hpq4Dpq4Xpq4Lpq4vpq4zpq5HprYXprYPprYfprYnprYjprY3prZHpo6jppI3ppK7ppZXppZTpq5/pq6Hpq6bpq6/pq6vpq7vpq63pq7nprIjprI/prJPprJ/prKPpur3pur7nuLvpuoLpuofpuojpuovpupLpj5bpup3pup/pu5vpu5zpu53pu6Dpu5/pu6Lpu6npu6fpu6Xpu6rpu6/pvKLpvKzpvK/pvLnpvLfpvL3pvL7pvYRcIl0sW1wiZjg0MFwiLFwi6bOjXCIsNjJdLFtcImY4ODBcIixcIum0olwiLDMyXSxbXCJmOTQwXCIsXCLptYNcIiw2Ml0sW1wiZjk4MFwiLFwi6baCXCIsMzJdLFtcImZhNDBcIixcIum2o1wiLDYyXSxbXCJmYTgwXCIsXCLpt6JcIiwzMl0sW1wiZmI0MFwiLFwi6biDXCIsMjcsXCLpuKTpuKfpuK7puLDpuLTpuLvpuLzpuYDpuY3puZDpuZLpuZPpuZTpuZbpuZnpuZ3puZ/puaDpuaHpuaLpuaXpua7pua/pubLpubRcIiw5LFwi6bqAXCJdLFtcImZiODBcIixcIum6gem6g+m6hOm6hem6hum6iem6ium6jFwiLDUsXCLpupRcIiw4LFwi6bqe6bqgXCIsNSxcIum6p+m6qOm6qem6qlwiXSxbXCJmYzQwXCIsXCLpuqtcIiw4LFwi6bq16bq26bq36bq56bq66bq86bq/XCIsNCxcIum7hem7hum7h+m7iOm7ium7i+m7jOm7kOm7kum7k+m7lem7lum7l+m7mem7mum7num7oem7o+m7pOm7pum7qOm7q+m7rOm7rem7rum7sFwiLDgsXCLpu7rpu73pu79cIiw2XSxbXCJmYzgwXCIsXCLpvIZcIiw0LFwi6byM6byP6byR6byS6byU6byV6byW6byY6byaXCIsNSxcIum8oem8o1wiLDgsXCLpvK3pvK7pvLDpvLFcIl0sW1wiZmQ0MFwiLFwi6byyXCIsNCxcIum8uOm8uum8vOm8v1wiLDQsXCLpvYVcIiwxMCxcIum9klwiLDM4XSxbXCJmZDgwXCIsXCLpvblcIiw1LFwi6b6B6b6C6b6NXCIsMTEsXCLpvpzpvp3pvp7pvqFcIiw0LFwi76Ss76W576aV76en76exXCJdLFtcImZlNDBcIixcIu+ojO+oje+oju+oj++oke+ok++olO+omO+on++ooO+ooe+oo++opO+op++oqO+oqVwiXV1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9pY29udi1saXRlL2VuY29kaW5ncy90YWJsZXMvY3A5MzYuanNvblxuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiemxpYlwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInpsaWJcIlxuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnknKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKTtcbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGZvcm1hdHM6IGZvcm1hdHMsXG4gICAgcGFyc2U6IHBhcnNlLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcXMvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIG1ldGhvZHNcbiAqIENvcHlyaWdodChjKSAyMDEzLTIwMTQgVEogSG9sb3dheWNodWtcbiAqIENvcHlyaWdodChjKSAyMDE1LTIwMTYgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEN1cnJlbnROb2RlTWV0aG9kcygpIHx8IGdldEJhc2ljTm9kZU1ldGhvZHMoKTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgTm9kZS5qcyBtZXRob2RzLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Tm9kZU1ldGhvZHMoKSB7XG4gIHJldHVybiBodHRwLk1FVEhPRFMgJiYgaHR0cC5NRVRIT0RTLm1hcChmdW5jdGlvbiBsb3dlckNhc2VNZXRob2QobWV0aG9kKSB7XG4gICAgcmV0dXJuIG1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIFwiYmFzaWNcIiBOb2RlLmpzIG1ldGhvZHMsIGEgc25hcHNob3QgZnJvbSBOb2RlLmpzIDAuMTAuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGdldEJhc2ljTm9kZU1ldGhvZHMoKSB7XG4gIHJldHVybiBbXG4gICAgJ2dldCcsXG4gICAgJ3Bvc3QnLFxuICAgICdwdXQnLFxuICAgICdoZWFkJyxcbiAgICAnZGVsZXRlJyxcbiAgICAnb3B0aW9ucycsXG4gICAgJ3RyYWNlJyxcbiAgICAnY29weScsXG4gICAgJ2xvY2snLFxuICAgICdta2NvbCcsXG4gICAgJ21vdmUnLFxuICAgICdwdXJnZScsXG4gICAgJ3Byb3BmaW5kJyxcbiAgICAncHJvcHBhdGNoJyxcbiAgICAndW5sb2NrJyxcbiAgICAncmVwb3J0JyxcbiAgICAnbWthY3Rpdml0eScsXG4gICAgJ2NoZWNrb3V0JyxcbiAgICAnbWVyZ2UnLFxuICAgICdtLXNlYXJjaCcsXG4gICAgJ25vdGlmeScsXG4gICAgJ3N1YnNjcmliZScsXG4gICAgJ3Vuc3Vic2NyaWJlJyxcbiAgICAncGF0Y2gnLFxuICAgICdzZWFyY2gnLFxuICAgICdjb25uZWN0J1xuICBdO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0aG9kcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBzZW5kXG4gKiBDb3B5cmlnaHQoYykgMjAxMiBUSiBIb2xvd2F5Y2h1a1xuICogQ29weXJpZ2h0KGMpIDIwMTQtMjAxNiBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnaHR0cC1lcnJvcnMnKVxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc2VuZCcpXG52YXIgZGVwcmVjYXRlID0gcmVxdWlyZSgnZGVwZCcpKCdzZW5kJylcbnZhciBkZXN0cm95ID0gcmVxdWlyZSgnZGVzdHJveScpXG52YXIgZW5jb2RlVXJsID0gcmVxdWlyZSgnZW5jb2RldXJsJylcbnZhciBlc2NhcGVIdG1sID0gcmVxdWlyZSgnZXNjYXBlLWh0bWwnKVxudmFyIGV0YWcgPSByZXF1aXJlKCdldGFnJylcbnZhciBmcmVzaCA9IHJlcXVpcmUoJ2ZyZXNoJylcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcbnZhciBtaW1lID0gcmVxdWlyZSgnbWltZScpXG52YXIgbXMgPSByZXF1aXJlKCdtcycpXG52YXIgb25GaW5pc2hlZCA9IHJlcXVpcmUoJ29uLWZpbmlzaGVkJylcbnZhciBwYXJzZVJhbmdlID0gcmVxdWlyZSgncmFuZ2UtcGFyc2VyJylcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG52YXIgc3RhdHVzZXMgPSByZXF1aXJlKCdzdGF0dXNlcycpXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJylcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG5cbi8qKlxuICogUGF0aCBmdW5jdGlvbiByZWZlcmVuY2VzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgZXh0bmFtZSA9IHBhdGguZXh0bmFtZVxudmFyIGpvaW4gPSBwYXRoLmpvaW5cbnZhciBub3JtYWxpemUgPSBwYXRoLm5vcm1hbGl6ZVxudmFyIHJlc29sdmUgPSBwYXRoLnJlc29sdmVcbnZhciBzZXAgPSBwYXRoLnNlcFxuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgaWRlbnRpZnlpbmcgYSBieXRlcyBSYW5nZSBoZWFkZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBCWVRFU19SQU5HRV9SRUdFWFAgPSAvXiAqYnl0ZXM9L1xuXG4vKipcbiAqIE1heGltdW0gdmFsdWUgYWxsb3dlZCBmb3IgdGhlIG1heCBhZ2UuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBNQVhfTUFYQUdFID0gNjAgKiA2MCAqIDI0ICogMzY1ICogMTAwMCAvLyAxIHllYXJcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdG8gbWF0Y2ggYSBwYXRoIHdpdGggYSBkaXJlY3RvcnkgdXAgY29tcG9uZW50LlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgVVBfUEFUSF9SRUdFWFAgPSAvKD86XnxbXFxcXC9dKVxcLlxcLig/OltcXFxcL118JCkvXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBzZW5kXG5tb2R1bGUuZXhwb3J0cy5taW1lID0gbWltZVxuXG4vKipcbiAqIFJldHVybiBhIGBTZW5kU3RyZWFtYCBmb3IgYHJlcWAgYW5kIGBwYXRoYC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcmVxXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7U2VuZFN0cmVhbX1cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBzZW5kIChyZXEsIHBhdGgsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBTZW5kU3RyZWFtKHJlcSwgcGF0aCwgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIGEgYFNlbmRTdHJlYW1gIHdpdGggdGhlIGdpdmVuIGBwYXRoYC5cbiAqXG4gKiBAcGFyYW0ge1JlcXVlc3R9IHJlcVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gU2VuZFN0cmVhbSAocmVxLCBwYXRoLCBvcHRpb25zKSB7XG4gIFN0cmVhbS5jYWxsKHRoaXMpXG5cbiAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9XG5cbiAgdGhpcy5vcHRpb25zID0gb3B0c1xuICB0aGlzLnBhdGggPSBwYXRoXG4gIHRoaXMucmVxID0gcmVxXG5cbiAgdGhpcy5fYWNjZXB0UmFuZ2VzID0gb3B0cy5hY2NlcHRSYW5nZXMgIT09IHVuZGVmaW5lZFxuICAgID8gQm9vbGVhbihvcHRzLmFjY2VwdFJhbmdlcylcbiAgICA6IHRydWVcblxuICB0aGlzLl9jYWNoZUNvbnRyb2wgPSBvcHRzLmNhY2hlQ29udHJvbCAhPT0gdW5kZWZpbmVkXG4gICAgPyBCb29sZWFuKG9wdHMuY2FjaGVDb250cm9sKVxuICAgIDogdHJ1ZVxuXG4gIHRoaXMuX2V0YWcgPSBvcHRzLmV0YWcgIT09IHVuZGVmaW5lZFxuICAgID8gQm9vbGVhbihvcHRzLmV0YWcpXG4gICAgOiB0cnVlXG5cbiAgdGhpcy5fZG90ZmlsZXMgPSBvcHRzLmRvdGZpbGVzICE9PSB1bmRlZmluZWRcbiAgICA/IG9wdHMuZG90ZmlsZXNcbiAgICA6ICdpZ25vcmUnXG5cbiAgaWYgKHRoaXMuX2RvdGZpbGVzICE9PSAnaWdub3JlJyAmJiB0aGlzLl9kb3RmaWxlcyAhPT0gJ2FsbG93JyAmJiB0aGlzLl9kb3RmaWxlcyAhPT0gJ2RlbnknKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZG90ZmlsZXMgb3B0aW9uIG11c3QgYmUgXCJhbGxvd1wiLCBcImRlbnlcIiwgb3IgXCJpZ25vcmVcIicpXG4gIH1cblxuICB0aGlzLl9oaWRkZW4gPSBCb29sZWFuKG9wdHMuaGlkZGVuKVxuXG4gIGlmIChvcHRzLmhpZGRlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVwcmVjYXRlKCdoaWRkZW46IHVzZSBkb3RmaWxlczogXFwnJyArICh0aGlzLl9oaWRkZW4gPyAnYWxsb3cnIDogJ2lnbm9yZScpICsgJ1xcJyBpbnN0ZWFkJylcbiAgfVxuXG4gIC8vIGxlZ2FjeSBzdXBwb3J0XG4gIGlmIChvcHRzLmRvdGZpbGVzID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLl9kb3RmaWxlcyA9IHVuZGVmaW5lZFxuICB9XG5cbiAgdGhpcy5fZXh0ZW5zaW9ucyA9IG9wdHMuZXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkXG4gICAgPyBub3JtYWxpemVMaXN0KG9wdHMuZXh0ZW5zaW9ucywgJ2V4dGVuc2lvbnMgb3B0aW9uJylcbiAgICA6IFtdXG5cbiAgdGhpcy5faW1tdXRhYmxlID0gb3B0cy5pbW11dGFibGUgIT09IHVuZGVmaW5lZFxuICAgID8gQm9vbGVhbihvcHRzLmltbXV0YWJsZSlcbiAgICA6IGZhbHNlXG5cbiAgdGhpcy5faW5kZXggPSBvcHRzLmluZGV4ICE9PSB1bmRlZmluZWRcbiAgICA/IG5vcm1hbGl6ZUxpc3Qob3B0cy5pbmRleCwgJ2luZGV4IG9wdGlvbicpXG4gICAgOiBbJ2luZGV4Lmh0bWwnXVxuXG4gIHRoaXMuX2xhc3RNb2RpZmllZCA9IG9wdHMubGFzdE1vZGlmaWVkICE9PSB1bmRlZmluZWRcbiAgICA/IEJvb2xlYW4ob3B0cy5sYXN0TW9kaWZpZWQpXG4gICAgOiB0cnVlXG5cbiAgdGhpcy5fbWF4YWdlID0gb3B0cy5tYXhBZ2UgfHwgb3B0cy5tYXhhZ2VcbiAgdGhpcy5fbWF4YWdlID0gdHlwZW9mIHRoaXMuX21heGFnZSA9PT0gJ3N0cmluZydcbiAgICA/IG1zKHRoaXMuX21heGFnZSlcbiAgICA6IE51bWJlcih0aGlzLl9tYXhhZ2UpXG4gIHRoaXMuX21heGFnZSA9ICFpc05hTih0aGlzLl9tYXhhZ2UpXG4gICAgPyBNYXRoLm1pbihNYXRoLm1heCgwLCB0aGlzLl9tYXhhZ2UpLCBNQVhfTUFYQUdFKVxuICAgIDogMFxuXG4gIHRoaXMuX3Jvb3QgPSBvcHRzLnJvb3RcbiAgICA/IHJlc29sdmUob3B0cy5yb290KVxuICAgIDogbnVsbFxuXG4gIGlmICghdGhpcy5fcm9vdCAmJiBvcHRzLmZyb20pIHtcbiAgICB0aGlzLmZyb20ob3B0cy5mcm9tKVxuICB9XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBgU3RyZWFtYC5cbiAqL1xuXG51dGlsLmluaGVyaXRzKFNlbmRTdHJlYW0sIFN0cmVhbSlcblxuLyoqXG4gKiBFbmFibGUgb3IgZGlzYWJsZSBldGFnIGdlbmVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB2YWxcbiAqIEByZXR1cm4ge1NlbmRTdHJlYW19XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNlbmRTdHJlYW0ucHJvdG90eXBlLmV0YWcgPSBkZXByZWNhdGUuZnVuY3Rpb24oZnVuY3Rpb24gZXRhZyAodmFsKSB7XG4gIHRoaXMuX2V0YWcgPSBCb29sZWFuKHZhbClcbiAgZGVidWcoJ2V0YWcgJXMnLCB0aGlzLl9ldGFnKVxuICByZXR1cm4gdGhpc1xufSwgJ3NlbmQuZXRhZzogcGFzcyBldGFnIGFzIG9wdGlvbicpXG5cbi8qKlxuICogRW5hYmxlIG9yIGRpc2FibGUgXCJoaWRkZW5cIiAoZG90KSBmaWxlcy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHBhdGhcbiAqIEByZXR1cm4ge1NlbmRTdHJlYW19XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNlbmRTdHJlYW0ucHJvdG90eXBlLmhpZGRlbiA9IGRlcHJlY2F0ZS5mdW5jdGlvbihmdW5jdGlvbiBoaWRkZW4gKHZhbCkge1xuICB0aGlzLl9oaWRkZW4gPSBCb29sZWFuKHZhbClcbiAgdGhpcy5fZG90ZmlsZXMgPSB1bmRlZmluZWRcbiAgZGVidWcoJ2hpZGRlbiAlcycsIHRoaXMuX2hpZGRlbilcbiAgcmV0dXJuIHRoaXNcbn0sICdzZW5kLmhpZGRlbjogdXNlIGRvdGZpbGVzIG9wdGlvbicpXG5cbi8qKlxuICogU2V0IGluZGV4IGBwYXRoc2AsIHNldCB0byBhIGZhbHN5XG4gKiB2YWx1ZSB0byBkaXNhYmxlIGluZGV4IHN1cHBvcnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8Qm9vbGVhbnxBcnJheX0gcGF0aHNcbiAqIEByZXR1cm4ge1NlbmRTdHJlYW19XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNlbmRTdHJlYW0ucHJvdG90eXBlLmluZGV4ID0gZGVwcmVjYXRlLmZ1bmN0aW9uKGZ1bmN0aW9uIGluZGV4IChwYXRocykge1xuICB2YXIgaW5kZXggPSAhcGF0aHMgPyBbXSA6IG5vcm1hbGl6ZUxpc3QocGF0aHMsICdwYXRocyBhcmd1bWVudCcpXG4gIGRlYnVnKCdpbmRleCAlbycsIHBhdGhzKVxuICB0aGlzLl9pbmRleCA9IGluZGV4XG4gIHJldHVybiB0aGlzXG59LCAnc2VuZC5pbmRleDogcGFzcyBpbmRleCBhcyBvcHRpb24nKVxuXG4vKipcbiAqIFNldCByb290IGBwYXRoYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7U2VuZFN0cmVhbX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2VuZFN0cmVhbS5wcm90b3R5cGUucm9vdCA9IGZ1bmN0aW9uIHJvb3QgKHBhdGgpIHtcbiAgdGhpcy5fcm9vdCA9IHJlc29sdmUoU3RyaW5nKHBhdGgpKVxuICBkZWJ1Zygncm9vdCAlcycsIHRoaXMuX3Jvb3QpXG4gIHJldHVybiB0aGlzXG59XG5cblNlbmRTdHJlYW0ucHJvdG90eXBlLmZyb20gPSBkZXByZWNhdGUuZnVuY3Rpb24oU2VuZFN0cmVhbS5wcm90b3R5cGUucm9vdCxcbiAgJ3NlbmQuZnJvbTogcGFzcyByb290IGFzIG9wdGlvbicpXG5cblNlbmRTdHJlYW0ucHJvdG90eXBlLnJvb3QgPSBkZXByZWNhdGUuZnVuY3Rpb24oU2VuZFN0cmVhbS5wcm90b3R5cGUucm9vdCxcbiAgJ3NlbmQucm9vdDogcGFzcyByb290IGFzIG9wdGlvbicpXG5cbi8qKlxuICogU2V0IG1heC1hZ2UgdG8gYG1heEFnZWAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heEFnZVxuICogQHJldHVybiB7U2VuZFN0cmVhbX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2VuZFN0cmVhbS5wcm90b3R5cGUubWF4YWdlID0gZGVwcmVjYXRlLmZ1bmN0aW9uKGZ1bmN0aW9uIG1heGFnZSAobWF4QWdlKSB7XG4gIHRoaXMuX21heGFnZSA9IHR5cGVvZiBtYXhBZ2UgPT09ICdzdHJpbmcnXG4gICAgPyBtcyhtYXhBZ2UpXG4gICAgOiBOdW1iZXIobWF4QWdlKVxuICB0aGlzLl9tYXhhZ2UgPSAhaXNOYU4odGhpcy5fbWF4YWdlKVxuICAgID8gTWF0aC5taW4oTWF0aC5tYXgoMCwgdGhpcy5fbWF4YWdlKSwgTUFYX01BWEFHRSlcbiAgICA6IDBcbiAgZGVidWcoJ21heC1hZ2UgJWQnLCB0aGlzLl9tYXhhZ2UpXG4gIHJldHVybiB0aGlzXG59LCAnc2VuZC5tYXhhZ2U6IHBhc3MgbWF4QWdlIGFzIG9wdGlvbicpXG5cbi8qKlxuICogRW1pdCBlcnJvciB3aXRoIGBzdGF0dXNgLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXNcbiAqIEBwYXJhbSB7RXJyb3J9IFtlcnJdXG4gKiBAcHJpdmF0ZVxuICovXG5cblNlbmRTdHJlYW0ucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gZXJyb3IgKHN0YXR1cywgZXJyKSB7XG4gIC8vIGVtaXQgaWYgbGlzdGVuZXJzIGluc3RlYWQgb2YgcmVzcG9uZGluZ1xuICBpZiAoaGFzTGlzdGVuZXJzKHRoaXMsICdlcnJvcicpKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBjcmVhdGVFcnJvcihzdGF0dXMsIGVyciwge1xuICAgICAgZXhwb3NlOiBmYWxzZVxuICAgIH0pKVxuICB9XG5cbiAgdmFyIHJlcyA9IHRoaXMucmVzXG4gIHZhciBtc2cgPSBzdGF0dXNlc1tzdGF0dXNdIHx8IFN0cmluZyhzdGF0dXMpXG4gIHZhciBkb2MgPSBjcmVhdGVIdG1sRG9jdW1lbnQoJ0Vycm9yJywgZXNjYXBlSHRtbChtc2cpKVxuXG4gIC8vIGNsZWFyIGV4aXN0aW5nIGhlYWRlcnNcbiAgY2xlYXJIZWFkZXJzKHJlcylcblxuICAvLyBhZGQgZXJyb3IgaGVhZGVyc1xuICBpZiAoZXJyICYmIGVyci5oZWFkZXJzKSB7XG4gICAgc2V0SGVhZGVycyhyZXMsIGVyci5oZWFkZXJzKVxuICB9XG5cbiAgLy8gc2VuZCBiYXNpYyByZXNwb25zZVxuICByZXMuc3RhdHVzQ29kZSA9IHN0YXR1c1xuICByZXMuc2V0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAndGV4dC9odG1sOyBjaGFyc2V0PVVURi04JylcbiAgcmVzLnNldEhlYWRlcignQ29udGVudC1MZW5ndGgnLCBCdWZmZXIuYnl0ZUxlbmd0aChkb2MpKVxuICByZXMuc2V0SGVhZGVyKCdDb250ZW50LVNlY3VyaXR5LVBvbGljeScsIFwiZGVmYXVsdC1zcmMgJ3NlbGYnXCIpXG4gIHJlcy5zZXRIZWFkZXIoJ1gtQ29udGVudC1UeXBlLU9wdGlvbnMnLCAnbm9zbmlmZicpXG4gIHJlcy5lbmQoZG9jKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBwYXRobmFtZSBlbmRzIHdpdGggXCIvXCIuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cblxuU2VuZFN0cmVhbS5wcm90b3R5cGUuaGFzVHJhaWxpbmdTbGFzaCA9IGZ1bmN0aW9uIGhhc1RyYWlsaW5nU2xhc2ggKCkge1xuICByZXR1cm4gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXSA9PT0gJy8nXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBpcyBhIGNvbmRpdGlvbmFsIEdFVCByZXF1ZXN0LlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TZW5kU3RyZWFtLnByb3RvdHlwZS5pc0NvbmRpdGlvbmFsR0VUID0gZnVuY3Rpb24gaXNDb25kaXRpb25hbEdFVCAoKSB7XG4gIHJldHVybiB0aGlzLnJlcS5oZWFkZXJzWydpZi1tYXRjaCddIHx8XG4gICAgdGhpcy5yZXEuaGVhZGVyc1snaWYtdW5tb2RpZmllZC1zaW5jZSddIHx8XG4gICAgdGhpcy5yZXEuaGVhZGVyc1snaWYtbm9uZS1tYXRjaCddIHx8XG4gICAgdGhpcy5yZXEuaGVhZGVyc1snaWYtbW9kaWZpZWQtc2luY2UnXVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSByZXF1ZXN0IHByZWNvbmRpdGlvbnMgZmFpbGVkLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5cblNlbmRTdHJlYW0ucHJvdG90eXBlLmlzUHJlY29uZGl0aW9uRmFpbHVyZSA9IGZ1bmN0aW9uIGlzUHJlY29uZGl0aW9uRmFpbHVyZSAoKSB7XG4gIHZhciByZXEgPSB0aGlzLnJlcVxuICB2YXIgcmVzID0gdGhpcy5yZXNcblxuICAvLyBpZi1tYXRjaFxuICB2YXIgbWF0Y2ggPSByZXEuaGVhZGVyc1snaWYtbWF0Y2gnXVxuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgZXRhZyA9IHJlcy5nZXRIZWFkZXIoJ0VUYWcnKVxuICAgIHJldHVybiAhZXRhZyB8fCAobWF0Y2ggIT09ICcqJyAmJiBwYXJzZVRva2VuTGlzdChtYXRjaCkuZXZlcnkoZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWF0Y2ggIT09IGV0YWcgJiYgbWF0Y2ggIT09ICdXLycgKyBldGFnICYmICdXLycgKyBtYXRjaCAhPT0gZXRhZ1xuICAgIH0pKVxuICB9XG5cbiAgLy8gaWYtdW5tb2RpZmllZC1zaW5jZVxuICB2YXIgdW5tb2RpZmllZFNpbmNlID0gcGFyc2VIdHRwRGF0ZShyZXEuaGVhZGVyc1snaWYtdW5tb2RpZmllZC1zaW5jZSddKVxuICBpZiAoIWlzTmFOKHVubW9kaWZpZWRTaW5jZSkpIHtcbiAgICB2YXIgbGFzdE1vZGlmaWVkID0gcGFyc2VIdHRwRGF0ZShyZXMuZ2V0SGVhZGVyKCdMYXN0LU1vZGlmaWVkJykpXG4gICAgcmV0dXJuIGlzTmFOKGxhc3RNb2RpZmllZCkgfHwgbGFzdE1vZGlmaWVkID4gdW5tb2RpZmllZFNpbmNlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gKiBTdHJpcCBjb250ZW50LSogaGVhZGVyIGZpZWxkcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5cblNlbmRTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUNvbnRlbnRIZWFkZXJGaWVsZHMgPSBmdW5jdGlvbiByZW1vdmVDb250ZW50SGVhZGVyRmllbGRzICgpIHtcbiAgdmFyIHJlcyA9IHRoaXMucmVzXG4gIHZhciBoZWFkZXJzID0gZ2V0SGVhZGVyTmFtZXMocmVzKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBoZWFkZXIgPSBoZWFkZXJzW2ldXG4gICAgaWYgKGhlYWRlci5zdWJzdHIoMCwgOCkgPT09ICdjb250ZW50LScgJiYgaGVhZGVyICE9PSAnY29udGVudC1sb2NhdGlvbicpIHtcbiAgICAgIHJlcy5yZW1vdmVIZWFkZXIoaGVhZGVyKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlc3BvbmQgd2l0aCAzMDQgbm90IG1vZGlmaWVkLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNlbmRTdHJlYW0ucHJvdG90eXBlLm5vdE1vZGlmaWVkID0gZnVuY3Rpb24gbm90TW9kaWZpZWQgKCkge1xuICB2YXIgcmVzID0gdGhpcy5yZXNcbiAgZGVidWcoJ25vdCBtb2RpZmllZCcpXG4gIHRoaXMucmVtb3ZlQ29udGVudEhlYWRlckZpZWxkcygpXG4gIHJlcy5zdGF0dXNDb2RlID0gMzA0XG4gIHJlcy5lbmQoKVxufVxuXG4vKipcbiAqIFJhaXNlIGVycm9yIHRoYXQgaGVhZGVycyBhbHJlYWR5IHNlbnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2VuZFN0cmVhbS5wcm90b3R5cGUuaGVhZGVyc0FscmVhZHlTZW50ID0gZnVuY3Rpb24gaGVhZGVyc0FscmVhZHlTZW50ICgpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcignQ2FuXFwndCBzZXQgaGVhZGVycyBhZnRlciB0aGV5IGFyZSBzZW50LicpXG4gIGRlYnVnKCdoZWFkZXJzIGFscmVhZHkgc2VudCcpXG4gIHRoaXMuZXJyb3IoNTAwLCBlcnIpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHJlcXVlc3QgaXMgY2FjaGVhYmxlLCBha2FcbiAqIHJlc3BvbmRlZCB3aXRoIDJ4eCBvciAzMDQgKHNlZSBSRkMgMjYxNiBzZWN0aW9uIDE0LjJ7NSw2fSkuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNlbmRTdHJlYW0ucHJvdG90eXBlLmlzQ2FjaGFibGUgPSBmdW5jdGlvbiBpc0NhY2hhYmxlICgpIHtcbiAgdmFyIHN0YXR1c0NvZGUgPSB0aGlzLnJlcy5zdGF0dXNDb2RlXG4gIHJldHVybiAoc3RhdHVzQ29kZSA+PSAyMDAgJiYgc3RhdHVzQ29kZSA8IDMwMCkgfHxcbiAgICBzdGF0dXNDb2RlID09PSAzMDRcbn1cblxuLyoqXG4gKiBIYW5kbGUgc3RhdCgpIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5cblNlbmRTdHJlYW0ucHJvdG90eXBlLm9uU3RhdEVycm9yID0gZnVuY3Rpb24gb25TdGF0RXJyb3IgKGVycm9yKSB7XG4gIHN3aXRjaCAoZXJyb3IuY29kZSkge1xuICAgIGNhc2UgJ0VOQU1FVE9PTE9ORyc6XG4gICAgY2FzZSAnRU5PRU5UJzpcbiAgICBjYXNlICdFTk9URElSJzpcbiAgICAgIHRoaXMuZXJyb3IoNDA0LCBlcnJvcilcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMuZXJyb3IoNTAwLCBlcnJvcilcbiAgICAgIGJyZWFrXG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgY2FjaGUgaXMgZnJlc2guXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNlbmRTdHJlYW0ucHJvdG90eXBlLmlzRnJlc2ggPSBmdW5jdGlvbiBpc0ZyZXNoICgpIHtcbiAgcmV0dXJuIGZyZXNoKHRoaXMucmVxLmhlYWRlcnMsIHtcbiAgICAnZXRhZyc6IHRoaXMucmVzLmdldEhlYWRlcignRVRhZycpLFxuICAgICdsYXN0LW1vZGlmaWVkJzogdGhpcy5yZXMuZ2V0SGVhZGVyKCdMYXN0LU1vZGlmaWVkJylcbiAgfSlcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcmFuZ2UgaXMgZnJlc2guXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNlbmRTdHJlYW0ucHJvdG90eXBlLmlzUmFuZ2VGcmVzaCA9IGZ1bmN0aW9uIGlzUmFuZ2VGcmVzaCAoKSB7XG4gIHZhciBpZlJhbmdlID0gdGhpcy5yZXEuaGVhZGVyc1snaWYtcmFuZ2UnXVxuXG4gIGlmICghaWZSYW5nZSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBpZi1yYW5nZSBhcyBldGFnXG4gIGlmIChpZlJhbmdlLmluZGV4T2YoJ1wiJykgIT09IC0xKSB7XG4gICAgdmFyIGV0YWcgPSB0aGlzLnJlcy5nZXRIZWFkZXIoJ0VUYWcnKVxuICAgIHJldHVybiBCb29sZWFuKGV0YWcgJiYgaWZSYW5nZS5pbmRleE9mKGV0YWcpICE9PSAtMSlcbiAgfVxuXG4gIC8vIGlmLXJhbmdlIGFzIG1vZGlmaWVkIGRhdGVcbiAgdmFyIGxhc3RNb2RpZmllZCA9IHRoaXMucmVzLmdldEhlYWRlcignTGFzdC1Nb2RpZmllZCcpXG4gIHJldHVybiBwYXJzZUh0dHBEYXRlKGxhc3RNb2RpZmllZCkgPD0gcGFyc2VIdHRwRGF0ZShpZlJhbmdlKVxufVxuXG4vKipcbiAqIFJlZGlyZWN0IHRvIHBhdGguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEBwcml2YXRlXG4gKi9cblxuU2VuZFN0cmVhbS5wcm90b3R5cGUucmVkaXJlY3QgPSBmdW5jdGlvbiByZWRpcmVjdCAocGF0aCkge1xuICB2YXIgcmVzID0gdGhpcy5yZXNcblxuICBpZiAoaGFzTGlzdGVuZXJzKHRoaXMsICdkaXJlY3RvcnknKSkge1xuICAgIHRoaXMuZW1pdCgnZGlyZWN0b3J5JywgcmVzLCBwYXRoKVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHRoaXMuaGFzVHJhaWxpbmdTbGFzaCgpKSB7XG4gICAgdGhpcy5lcnJvcig0MDMpXG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgbG9jID0gZW5jb2RlVXJsKGNvbGxhcHNlTGVhZGluZ1NsYXNoZXModGhpcy5wYXRoICsgJy8nKSlcbiAgdmFyIGRvYyA9IGNyZWF0ZUh0bWxEb2N1bWVudCgnUmVkaXJlY3RpbmcnLCAnUmVkaXJlY3RpbmcgdG8gPGEgaHJlZj1cIicgKyBlc2NhcGVIdG1sKGxvYykgKyAnXCI+JyArXG4gICAgZXNjYXBlSHRtbChsb2MpICsgJzwvYT4nKVxuXG4gIC8vIHJlZGlyZWN0XG4gIHJlcy5zdGF0dXNDb2RlID0gMzAxXG4gIHJlcy5zZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICd0ZXh0L2h0bWw7IGNoYXJzZXQ9VVRGLTgnKVxuICByZXMuc2V0SGVhZGVyKCdDb250ZW50LUxlbmd0aCcsIEJ1ZmZlci5ieXRlTGVuZ3RoKGRvYykpXG4gIHJlcy5zZXRIZWFkZXIoJ0NvbnRlbnQtU2VjdXJpdHktUG9saWN5JywgXCJkZWZhdWx0LXNyYyAnc2VsZidcIilcbiAgcmVzLnNldEhlYWRlcignWC1Db250ZW50LVR5cGUtT3B0aW9ucycsICdub3NuaWZmJylcbiAgcmVzLnNldEhlYWRlcignTG9jYXRpb24nLCBsb2MpXG4gIHJlcy5lbmQoZG9jKVxufVxuXG4vKipcbiAqIFBpcGUgdG8gYHJlcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmVhbX0gcmVzXG4gKiBAcmV0dXJuIHtTdHJlYW19IHJlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TZW5kU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gcGlwZSAocmVzKSB7XG4gIC8vIHJvb3QgcGF0aFxuICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3RcblxuICAvLyByZWZlcmVuY2VzXG4gIHRoaXMucmVzID0gcmVzXG5cbiAgLy8gZGVjb2RlIHRoZSBwYXRoXG4gIHZhciBwYXRoID0gZGVjb2RlKHRoaXMucGF0aClcbiAgaWYgKHBhdGggPT09IC0xKSB7XG4gICAgdGhpcy5lcnJvcig0MDApXG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgLy8gbnVsbCBieXRlKHMpXG4gIGlmICh+cGF0aC5pbmRleE9mKCdcXDAnKSkge1xuICAgIHRoaXMuZXJyb3IoNDAwKVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIHZhciBwYXJ0c1xuICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgIC8vIG5vcm1hbGl6ZVxuICAgIGlmIChwYXRoKSB7XG4gICAgICBwYXRoID0gbm9ybWFsaXplKCcuJyArIHNlcCArIHBhdGgpXG4gICAgfVxuXG4gICAgLy8gbWFsaWNpb3VzIHBhdGhcbiAgICBpZiAoVVBfUEFUSF9SRUdFWFAudGVzdChwYXRoKSkge1xuICAgICAgZGVidWcoJ21hbGljaW91cyBwYXRoIFwiJXNcIicsIHBhdGgpXG4gICAgICB0aGlzLmVycm9yKDQwMylcbiAgICAgIHJldHVybiByZXNcbiAgICB9XG5cbiAgICAvLyBleHBsb2RlIHBhdGggcGFydHNcbiAgICBwYXJ0cyA9IHBhdGguc3BsaXQoc2VwKVxuXG4gICAgLy8gam9pbiAvIG5vcm1hbGl6ZSBmcm9tIG9wdGlvbmFsIHJvb3QgZGlyXG4gICAgcGF0aCA9IG5vcm1hbGl6ZShqb2luKHJvb3QsIHBhdGgpKVxuICAgIHJvb3QgPSBub3JtYWxpemUocm9vdCArIHNlcClcbiAgfSBlbHNlIHtcbiAgICAvLyBcIi4uXCIgaXMgbWFsaWNpb3VzIHdpdGhvdXQgXCJyb290XCJcbiAgICBpZiAoVVBfUEFUSF9SRUdFWFAudGVzdChwYXRoKSkge1xuICAgICAgZGVidWcoJ21hbGljaW91cyBwYXRoIFwiJXNcIicsIHBhdGgpXG4gICAgICB0aGlzLmVycm9yKDQwMylcbiAgICAgIHJldHVybiByZXNcbiAgICB9XG5cbiAgICAvLyBleHBsb2RlIHBhdGggcGFydHNcbiAgICBwYXJ0cyA9IG5vcm1hbGl6ZShwYXRoKS5zcGxpdChzZXApXG5cbiAgICAvLyByZXNvbHZlIHRoZSBwYXRoXG4gICAgcGF0aCA9IHJlc29sdmUocGF0aClcbiAgfVxuXG4gIC8vIGRvdGZpbGUgaGFuZGxpbmdcbiAgaWYgKGNvbnRhaW5zRG90RmlsZShwYXJ0cykpIHtcbiAgICB2YXIgYWNjZXNzID0gdGhpcy5fZG90ZmlsZXNcblxuICAgIC8vIGxlZ2FjeSBzdXBwb3J0XG4gICAgaWYgKGFjY2VzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhY2Nlc3MgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXVswXSA9PT0gJy4nXG4gICAgICAgID8gKHRoaXMuX2hpZGRlbiA/ICdhbGxvdycgOiAnaWdub3JlJylcbiAgICAgICAgOiAnYWxsb3cnXG4gICAgfVxuXG4gICAgZGVidWcoJyVzIGRvdGZpbGUgXCIlc1wiJywgYWNjZXNzLCBwYXRoKVxuICAgIHN3aXRjaCAoYWNjZXNzKSB7XG4gICAgICBjYXNlICdhbGxvdyc6XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdkZW55JzpcbiAgICAgICAgdGhpcy5lcnJvcig0MDMpXG4gICAgICAgIHJldHVybiByZXNcbiAgICAgIGNhc2UgJ2lnbm9yZSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmVycm9yKDQwNClcbiAgICAgICAgcmV0dXJuIHJlc1xuICAgIH1cbiAgfVxuXG4gIC8vIGluZGV4IGZpbGUgc3VwcG9ydFxuICBpZiAodGhpcy5faW5kZXgubGVuZ3RoICYmIHRoaXMuaGFzVHJhaWxpbmdTbGFzaCgpKSB7XG4gICAgdGhpcy5zZW5kSW5kZXgocGF0aClcbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICB0aGlzLnNlbmRGaWxlKHBhdGgpXG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBUcmFuc2ZlciBgcGF0aGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2VuZFN0cmVhbS5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIHNlbmQgKHBhdGgsIHN0YXQpIHtcbiAgdmFyIGxlbiA9IHN0YXQuc2l6ZVxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuICB2YXIgb3B0cyA9IHt9XG4gIHZhciByZXMgPSB0aGlzLnJlc1xuICB2YXIgcmVxID0gdGhpcy5yZXFcbiAgdmFyIHJhbmdlcyA9IHJlcS5oZWFkZXJzLnJhbmdlXG4gIHZhciBvZmZzZXQgPSBvcHRpb25zLnN0YXJ0IHx8IDBcblxuICBpZiAoaGVhZGVyc1NlbnQocmVzKSkge1xuICAgIC8vIGltcG9zc2libGUgdG8gc2VuZCBub3dcbiAgICB0aGlzLmhlYWRlcnNBbHJlYWR5U2VudCgpXG4gICAgcmV0dXJuXG4gIH1cblxuICBkZWJ1ZygncGlwZSBcIiVzXCInLCBwYXRoKVxuXG4gIC8vIHNldCBoZWFkZXIgZmllbGRzXG4gIHRoaXMuc2V0SGVhZGVyKHBhdGgsIHN0YXQpXG5cbiAgLy8gc2V0IGNvbnRlbnQtdHlwZVxuICB0aGlzLnR5cGUocGF0aClcblxuICAvLyBjb25kaXRpb25hbCBHRVQgc3VwcG9ydFxuICBpZiAodGhpcy5pc0NvbmRpdGlvbmFsR0VUKCkpIHtcbiAgICBpZiAodGhpcy5pc1ByZWNvbmRpdGlvbkZhaWx1cmUoKSkge1xuICAgICAgdGhpcy5lcnJvcig0MTIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0NhY2hhYmxlKCkgJiYgdGhpcy5pc0ZyZXNoKCkpIHtcbiAgICAgIHRoaXMubm90TW9kaWZpZWQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgLy8gYWRqdXN0IGxlbiB0byBzdGFydC9lbmQgb3B0aW9uc1xuICBsZW4gPSBNYXRoLm1heCgwLCBsZW4gLSBvZmZzZXQpXG4gIGlmIChvcHRpb25zLmVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGJ5dGVzID0gb3B0aW9ucy5lbmQgLSBvZmZzZXQgKyAxXG4gICAgaWYgKGxlbiA+IGJ5dGVzKSBsZW4gPSBieXRlc1xuICB9XG5cbiAgLy8gUmFuZ2Ugc3VwcG9ydFxuICBpZiAodGhpcy5fYWNjZXB0UmFuZ2VzICYmIEJZVEVTX1JBTkdFX1JFR0VYUC50ZXN0KHJhbmdlcykpIHtcbiAgICAvLyBwYXJzZVxuICAgIHJhbmdlcyA9IHBhcnNlUmFuZ2UobGVuLCByYW5nZXMsIHtcbiAgICAgIGNvbWJpbmU6IHRydWVcbiAgICB9KVxuXG4gICAgLy8gSWYtUmFuZ2Ugc3VwcG9ydFxuICAgIGlmICghdGhpcy5pc1JhbmdlRnJlc2goKSkge1xuICAgICAgZGVidWcoJ3JhbmdlIHN0YWxlJylcbiAgICAgIHJhbmdlcyA9IC0yXG4gICAgfVxuXG4gICAgLy8gdW5zYXRpc2ZpYWJsZVxuICAgIGlmIChyYW5nZXMgPT09IC0xKSB7XG4gICAgICBkZWJ1ZygncmFuZ2UgdW5zYXRpc2ZpYWJsZScpXG5cbiAgICAgIC8vIENvbnRlbnQtUmFuZ2VcbiAgICAgIHJlcy5zZXRIZWFkZXIoJ0NvbnRlbnQtUmFuZ2UnLCBjb250ZW50UmFuZ2UoJ2J5dGVzJywgbGVuKSlcblxuICAgICAgLy8gNDE2IFJlcXVlc3RlZCBSYW5nZSBOb3QgU2F0aXNmaWFibGVcbiAgICAgIHJldHVybiB0aGlzLmVycm9yKDQxNiwge1xuICAgICAgICBoZWFkZXJzOiB7J0NvbnRlbnQtUmFuZ2UnOiByZXMuZ2V0SGVhZGVyKCdDb250ZW50LVJhbmdlJyl9XG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIHZhbGlkIChzeW50YWN0aWNhbGx5IGludmFsaWQvbXVsdGlwbGUgcmFuZ2VzIGFyZSB0cmVhdGVkIGFzIGEgcmVndWxhciByZXNwb25zZSlcbiAgICBpZiAocmFuZ2VzICE9PSAtMiAmJiByYW5nZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICBkZWJ1ZygncmFuZ2UgJWonLCByYW5nZXMpXG5cbiAgICAgIC8vIENvbnRlbnQtUmFuZ2VcbiAgICAgIHJlcy5zdGF0dXNDb2RlID0gMjA2XG4gICAgICByZXMuc2V0SGVhZGVyKCdDb250ZW50LVJhbmdlJywgY29udGVudFJhbmdlKCdieXRlcycsIGxlbiwgcmFuZ2VzWzBdKSlcblxuICAgICAgLy8gYWRqdXN0IGZvciByZXF1ZXN0ZWQgcmFuZ2VcbiAgICAgIG9mZnNldCArPSByYW5nZXNbMF0uc3RhcnRcbiAgICAgIGxlbiA9IHJhbmdlc1swXS5lbmQgLSByYW5nZXNbMF0uc3RhcnQgKyAxXG4gICAgfVxuICB9XG5cbiAgLy8gY2xvbmUgb3B0aW9uc1xuICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnMpIHtcbiAgICBvcHRzW3Byb3BdID0gb3B0aW9uc1twcm9wXVxuICB9XG5cbiAgLy8gc2V0IHJlYWQgb3B0aW9uc1xuICBvcHRzLnN0YXJ0ID0gb2Zmc2V0XG4gIG9wdHMuZW5kID0gTWF0aC5tYXgob2Zmc2V0LCBvZmZzZXQgKyBsZW4gLSAxKVxuXG4gIC8vIGNvbnRlbnQtbGVuZ3RoXG4gIHJlcy5zZXRIZWFkZXIoJ0NvbnRlbnQtTGVuZ3RoJywgbGVuKVxuXG4gIC8vIEhFQUQgc3VwcG9ydFxuICBpZiAocmVxLm1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgcmVzLmVuZCgpXG4gICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLnN0cmVhbShwYXRoLCBvcHRzKVxufVxuXG4vKipcbiAqIFRyYW5zZmVyIGZpbGUgZm9yIGBwYXRoYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQGFwaSBwcml2YXRlXG4gKi9cblNlbmRTdHJlYW0ucHJvdG90eXBlLnNlbmRGaWxlID0gZnVuY3Rpb24gc2VuZEZpbGUgKHBhdGgpIHtcbiAgdmFyIGkgPSAwXG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGRlYnVnKCdzdGF0IFwiJXNcIicsIHBhdGgpXG4gIGZzLnN0YXQocGF0aCwgZnVuY3Rpb24gb25zdGF0IChlcnIsIHN0YXQpIHtcbiAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSAnRU5PRU5UJyAmJiAhZXh0bmFtZShwYXRoKSAmJiBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gIT09IHNlcCkge1xuICAgICAgLy8gbm90IGZvdW5kLCBjaGVjayBleHRlbnNpb25zXG4gICAgICByZXR1cm4gbmV4dChlcnIpXG4gICAgfVxuICAgIGlmIChlcnIpIHJldHVybiBzZWxmLm9uU3RhdEVycm9yKGVycilcbiAgICBpZiAoc3RhdC5pc0RpcmVjdG9yeSgpKSByZXR1cm4gc2VsZi5yZWRpcmVjdChwYXRoKVxuICAgIHNlbGYuZW1pdCgnZmlsZScsIHBhdGgsIHN0YXQpXG4gICAgc2VsZi5zZW5kKHBhdGgsIHN0YXQpXG4gIH0pXG5cbiAgZnVuY3Rpb24gbmV4dCAoZXJyKSB7XG4gICAgaWYgKHNlbGYuX2V4dGVuc2lvbnMubGVuZ3RoIDw9IGkpIHtcbiAgICAgIHJldHVybiBlcnJcbiAgICAgICAgPyBzZWxmLm9uU3RhdEVycm9yKGVycilcbiAgICAgICAgOiBzZWxmLmVycm9yKDQwNClcbiAgICB9XG5cbiAgICB2YXIgcCA9IHBhdGggKyAnLicgKyBzZWxmLl9leHRlbnNpb25zW2krK11cblxuICAgIGRlYnVnKCdzdGF0IFwiJXNcIicsIHApXG4gICAgZnMuc3RhdChwLCBmdW5jdGlvbiAoZXJyLCBzdGF0KSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gbmV4dChlcnIpXG4gICAgICBpZiAoc3RhdC5pc0RpcmVjdG9yeSgpKSByZXR1cm4gbmV4dCgpXG4gICAgICBzZWxmLmVtaXQoJ2ZpbGUnLCBwLCBzdGF0KVxuICAgICAgc2VsZi5zZW5kKHAsIHN0YXQpXG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIFRyYW5zZmVyIGluZGV4IGZvciBgcGF0aGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5TZW5kU3RyZWFtLnByb3RvdHlwZS5zZW5kSW5kZXggPSBmdW5jdGlvbiBzZW5kSW5kZXggKHBhdGgpIHtcbiAgdmFyIGkgPSAtMVxuICB2YXIgc2VsZiA9IHRoaXNcblxuICBmdW5jdGlvbiBuZXh0IChlcnIpIHtcbiAgICBpZiAoKytpID49IHNlbGYuX2luZGV4Lmxlbmd0aCkge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHNlbGYub25TdGF0RXJyb3IoZXJyKVxuICAgICAgcmV0dXJuIHNlbGYuZXJyb3IoNDA0KVxuICAgIH1cblxuICAgIHZhciBwID0gam9pbihwYXRoLCBzZWxmLl9pbmRleFtpXSlcblxuICAgIGRlYnVnKCdzdGF0IFwiJXNcIicsIHApXG4gICAgZnMuc3RhdChwLCBmdW5jdGlvbiAoZXJyLCBzdGF0KSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gbmV4dChlcnIpXG4gICAgICBpZiAoc3RhdC5pc0RpcmVjdG9yeSgpKSByZXR1cm4gbmV4dCgpXG4gICAgICBzZWxmLmVtaXQoJ2ZpbGUnLCBwLCBzdGF0KVxuICAgICAgc2VsZi5zZW5kKHAsIHN0YXQpXG4gICAgfSlcbiAgfVxuXG4gIG5leHQoKVxufVxuXG4vKipcbiAqIFN0cmVhbSBgcGF0aGAgdG8gdGhlIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2VuZFN0cmVhbS5wcm90b3R5cGUuc3RyZWFtID0gZnVuY3Rpb24gc3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gIC8vIFRPRE86IHRoaXMgaXMgYWxsIGxhbWUsIHJlZmFjdG9yIG1lZWVlXG4gIHZhciBmaW5pc2hlZCA9IGZhbHNlXG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgcmVzID0gdGhpcy5yZXNcblxuICAvLyBwaXBlXG4gIHZhciBzdHJlYW0gPSBmcy5jcmVhdGVSZWFkU3RyZWFtKHBhdGgsIG9wdGlvbnMpXG4gIHRoaXMuZW1pdCgnc3RyZWFtJywgc3RyZWFtKVxuICBzdHJlYW0ucGlwZShyZXMpXG5cbiAgLy8gcmVzcG9uc2UgZmluaXNoZWQsIGRvbmUgd2l0aCB0aGUgZmRcbiAgb25GaW5pc2hlZChyZXMsIGZ1bmN0aW9uIG9uZmluaXNoZWQgKCkge1xuICAgIGZpbmlzaGVkID0gdHJ1ZVxuICAgIGRlc3Ryb3koc3RyZWFtKVxuICB9KVxuXG4gIC8vIGVycm9yIGhhbmRsaW5nIGNvZGUtc21lbGxcbiAgc3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uIG9uZXJyb3IgKGVycikge1xuICAgIC8vIHJlcXVlc3QgYWxyZWFkeSBmaW5pc2hlZFxuICAgIGlmIChmaW5pc2hlZCkgcmV0dXJuXG5cbiAgICAvLyBjbGVhbiB1cCBzdHJlYW1cbiAgICBmaW5pc2hlZCA9IHRydWVcbiAgICBkZXN0cm95KHN0cmVhbSlcblxuICAgIC8vIGVycm9yXG4gICAgc2VsZi5vblN0YXRFcnJvcihlcnIpXG4gIH0pXG5cbiAgLy8gZW5kXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gb25lbmQgKCkge1xuICAgIHNlbGYuZW1pdCgnZW5kJylcbiAgfSlcbn1cblxuLyoqXG4gKiBTZXQgY29udGVudC10eXBlIGJhc2VkIG9uIGBwYXRoYFxuICogaWYgaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNlbmRTdHJlYW0ucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiB0eXBlIChwYXRoKSB7XG4gIHZhciByZXMgPSB0aGlzLnJlc1xuXG4gIGlmIChyZXMuZ2V0SGVhZGVyKCdDb250ZW50LVR5cGUnKSkgcmV0dXJuXG5cbiAgdmFyIHR5cGUgPSBtaW1lLmxvb2t1cChwYXRoKVxuXG4gIGlmICghdHlwZSkge1xuICAgIGRlYnVnKCdubyBjb250ZW50LXR5cGUnKVxuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNoYXJzZXQgPSBtaW1lLmNoYXJzZXRzLmxvb2t1cCh0eXBlKVxuXG4gIGRlYnVnKCdjb250ZW50LXR5cGUgJXMnLCB0eXBlKVxuICByZXMuc2V0SGVhZGVyKCdDb250ZW50LVR5cGUnLCB0eXBlICsgKGNoYXJzZXQgPyAnOyBjaGFyc2V0PScgKyBjaGFyc2V0IDogJycpKVxufVxuXG4vKipcbiAqIFNldCByZXNwb25zZSBoZWFkZXIgZmllbGRzLCBtb3N0XG4gKiBmaWVsZHMgbWF5IGJlIHByZS1kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2VuZFN0cmVhbS5wcm90b3R5cGUuc2V0SGVhZGVyID0gZnVuY3Rpb24gc2V0SGVhZGVyIChwYXRoLCBzdGF0KSB7XG4gIHZhciByZXMgPSB0aGlzLnJlc1xuXG4gIHRoaXMuZW1pdCgnaGVhZGVycycsIHJlcywgcGF0aCwgc3RhdClcblxuICBpZiAodGhpcy5fYWNjZXB0UmFuZ2VzICYmICFyZXMuZ2V0SGVhZGVyKCdBY2NlcHQtUmFuZ2VzJykpIHtcbiAgICBkZWJ1ZygnYWNjZXB0IHJhbmdlcycpXG4gICAgcmVzLnNldEhlYWRlcignQWNjZXB0LVJhbmdlcycsICdieXRlcycpXG4gIH1cblxuICBpZiAodGhpcy5fY2FjaGVDb250cm9sICYmICFyZXMuZ2V0SGVhZGVyKCdDYWNoZS1Db250cm9sJykpIHtcbiAgICB2YXIgY2FjaGVDb250cm9sID0gJ3B1YmxpYywgbWF4LWFnZT0nICsgTWF0aC5mbG9vcih0aGlzLl9tYXhhZ2UgLyAxMDAwKVxuXG4gICAgaWYgKHRoaXMuX2ltbXV0YWJsZSkge1xuICAgICAgY2FjaGVDb250cm9sICs9ICcsIGltbXV0YWJsZSdcbiAgICB9XG5cbiAgICBkZWJ1ZygnY2FjaGUtY29udHJvbCAlcycsIGNhY2hlQ29udHJvbClcbiAgICByZXMuc2V0SGVhZGVyKCdDYWNoZS1Db250cm9sJywgY2FjaGVDb250cm9sKVxuICB9XG5cbiAgaWYgKHRoaXMuX2xhc3RNb2RpZmllZCAmJiAhcmVzLmdldEhlYWRlcignTGFzdC1Nb2RpZmllZCcpKSB7XG4gICAgdmFyIG1vZGlmaWVkID0gc3RhdC5tdGltZS50b1VUQ1N0cmluZygpXG4gICAgZGVidWcoJ21vZGlmaWVkICVzJywgbW9kaWZpZWQpXG4gICAgcmVzLnNldEhlYWRlcignTGFzdC1Nb2RpZmllZCcsIG1vZGlmaWVkKVxuICB9XG5cbiAgaWYgKHRoaXMuX2V0YWcgJiYgIXJlcy5nZXRIZWFkZXIoJ0VUYWcnKSkge1xuICAgIHZhciB2YWwgPSBldGFnKHN0YXQpXG4gICAgZGVidWcoJ2V0YWcgJXMnLCB2YWwpXG4gICAgcmVzLnNldEhlYWRlcignRVRhZycsIHZhbClcbiAgfVxufVxuXG4vKipcbiAqIENsZWFyIGFsbCBoZWFkZXJzIGZyb20gYSByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNsZWFySGVhZGVycyAocmVzKSB7XG4gIHZhciBoZWFkZXJzID0gZ2V0SGVhZGVyTmFtZXMocmVzKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5yZW1vdmVIZWFkZXIoaGVhZGVyc1tpXSlcbiAgfVxufVxuXG4vKipcbiAqIENvbGxhcHNlIGFsbCBsZWFkaW5nIHNsYXNoZXMgaW50byBhIHNpbmdsZSBzbGFzaFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbGxhcHNlTGVhZGluZ1NsYXNoZXMgKHN0cikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHJbaV0gIT09ICcvJykge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaSA+IDFcbiAgICA/ICcvJyArIHN0ci5zdWJzdHIoaSlcbiAgICA6IHN0clxufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBwYXRoIHBhcnRzIGNvbnRhaW4gYSBkb3RmaWxlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbnRhaW5zRG90RmlsZSAocGFydHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwYXJ0ID0gcGFydHNbaV1cbiAgICBpZiAocGFydC5sZW5ndGggPiAxICYmIHBhcnRbMF0gPT09ICcuJykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBDb250ZW50LVJhbmdlIGhlYWRlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtudW1iZXJ9IHNpemVcbiAqIEBwYXJhbSB7YXJyYXl9IFtyYW5nZV1cbiAqL1xuXG5mdW5jdGlvbiBjb250ZW50UmFuZ2UgKHR5cGUsIHNpemUsIHJhbmdlKSB7XG4gIHJldHVybiB0eXBlICsgJyAnICsgKHJhbmdlID8gcmFuZ2Uuc3RhcnQgKyAnLScgKyByYW5nZS5lbmQgOiAnKicpICsgJy8nICsgc2l6ZVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIG1pbmltYWwgSFRNTCBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBib2R5XG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUh0bWxEb2N1bWVudCAodGl0bGUsIGJvZHkpIHtcbiAgcmV0dXJuICc8IURPQ1RZUEUgaHRtbD5cXG4nICtcbiAgICAnPGh0bWwgbGFuZz1cImVuXCI+XFxuJyArXG4gICAgJzxoZWFkPlxcbicgK1xuICAgICc8bWV0YSBjaGFyc2V0PVwidXRmLThcIj5cXG4nICtcbiAgICAnPHRpdGxlPicgKyB0aXRsZSArICc8L3RpdGxlPlxcbicgK1xuICAgICc8L2hlYWQ+XFxuJyArXG4gICAgJzxib2R5PlxcbicgK1xuICAgICc8cHJlPicgKyBib2R5ICsgJzwvcHJlPlxcbicgK1xuICAgICc8L2JvZHk+XFxuJyArXG4gICAgJzwvaHRtbD5cXG4nXG59XG5cbi8qKlxuICogZGVjb2RlVVJJQ29tcG9uZW50LlxuICpcbiAqIEFsbG93cyBWOCB0byBvbmx5IGRlb3B0aW1pemUgdGhpcyBmbiBpbnN0ZWFkIG9mIGFsbFxuICogb2Ygc2VuZCgpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBkZWNvZGUgKHBhdGgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHBhdGgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAtMVxuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBoZWFkZXIgbmFtZXMgb24gYSByZXNwbnNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNcbiAqIEByZXR1cm5zIHthcnJheVtzdHJpbmddfVxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRIZWFkZXJOYW1lcyAocmVzKSB7XG4gIHJldHVybiB0eXBlb2YgcmVzLmdldEhlYWRlck5hbWVzICE9PSAnZnVuY3Rpb24nXG4gICAgPyBPYmplY3Qua2V5cyhyZXMuX2hlYWRlcnMgfHwge30pXG4gICAgOiByZXMuZ2V0SGVhZGVyTmFtZXMoKVxufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBlbWl0dGVyIGhhcyBsaXN0ZW5lcnMgb2YgYSBnaXZlbiB0eXBlLlxuICpcbiAqIFRoZSB3YXkgdG8gZG8gdGhpcyBjaGVjayBpcyBkb25lIHRocmVlIGRpZmZlcmVudCB3YXlzIGluIE5vZGUuanMgPj0gMC44XG4gKiBzbyB0aGlzIGNvbnNvbGlkYXRlcyB0aGVtIGludG8gYSBtaW5pbWFsIHNldCB1c2luZyBpbnN0YW5jZSBtZXRob2RzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGhhc0xpc3RlbmVycyAoZW1pdHRlciwgdHlwZSkge1xuICB2YXIgY291bnQgPSB0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ICE9PSAnZnVuY3Rpb24nXG4gICAgPyBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGhcbiAgICA6IGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKVxuXG4gIHJldHVybiBjb3VudCA+IDBcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIHJlc3BvbnNlIGhlYWRlcnMgaGF2ZSBiZWVuIHNlbnQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHJlc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGhlYWRlcnNTZW50IChyZXMpIHtcbiAgcmV0dXJuIHR5cGVvZiByZXMuaGVhZGVyc1NlbnQgIT09ICdib29sZWFuJ1xuICAgID8gQm9vbGVhbihyZXMuX2hlYWRlcilcbiAgICA6IHJlcy5oZWFkZXJzU2VudFxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgaW5kZXggb3B0aW9uIGludG8gYW4gYXJyYXkuXG4gKlxuICogQHBhcmFtIHtib29sZWFufHN0cmluZ3xhcnJheX0gdmFsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVMaXN0ICh2YWwsIG5hbWUpIHtcbiAgdmFyIGxpc3QgPSBbXS5jb25jYXQodmFsIHx8IFtdKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0eXBlb2YgbGlzdFtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobmFtZSArICcgbXVzdCBiZSBhcnJheSBvZiBzdHJpbmdzIG9yIGZhbHNlJylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGlzdFxufVxuXG4vKipcbiAqIFBhcnNlIGFuIEhUVFAgRGF0ZSBpbnRvIGEgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlSHR0cERhdGUgKGRhdGUpIHtcbiAgdmFyIHRpbWVzdGFtcCA9IGRhdGUgJiYgRGF0ZS5wYXJzZShkYXRlKVxuXG4gIHJldHVybiB0eXBlb2YgdGltZXN0YW1wID09PSAnbnVtYmVyJ1xuICAgID8gdGltZXN0YW1wXG4gICAgOiBOYU5cbn1cblxuLyoqXG4gKiBQYXJzZSBhIEhUVFAgdG9rZW4gbGlzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlVG9rZW5MaXN0IChzdHIpIHtcbiAgdmFyIGVuZCA9IDBcbiAgdmFyIGxpc3QgPSBbXVxuICB2YXIgc3RhcnQgPSAwXG5cbiAgLy8gZ2F0aGVyIHRva2Vuc1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgc3dpdGNoIChzdHIuY2hhckNvZGVBdChpKSkge1xuICAgICAgY2FzZSAweDIwOiAvKiAgICovXG4gICAgICAgIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgICAgICAgc3RhcnQgPSBlbmQgPSBpICsgMVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDB4MmM6IC8qICwgKi9cbiAgICAgICAgbGlzdC5wdXNoKHN0ci5zdWJzdHJpbmcoc3RhcnQsIGVuZCkpXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gaSArIDFcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGVuZCA9IGkgKyAxXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gZmluYWwgdG9rZW5cbiAgbGlzdC5wdXNoKHN0ci5zdWJzdHJpbmcoc3RhcnQsIGVuZCkpXG5cbiAgcmV0dXJuIGxpc3Rcbn1cblxuLyoqXG4gKiBTZXQgYW4gb2JqZWN0IG9mIGhlYWRlcnMgb24gYSByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzXG4gKiBAcGFyYW0ge29iamVjdH0gaGVhZGVyc1xuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZXRIZWFkZXJzIChyZXMsIGhlYWRlcnMpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldXG4gICAgcmVzLnNldEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSlcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc2VuZC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZTp0cmFuc3BvcnQnKTtcblxuLyoqXG4gKiBFeHBvc2UgdGhlIGNvbnN0cnVjdG9yLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0O1xuXG4vKipcbiAqIE5vb3AgZnVuY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG4vKipcbiAqIFRyYW5zcG9ydCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXF1ZXN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFRyYW5zcG9ydCAocmVxKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgdGhpcy5kaXNjYXJkZWQgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIEV2ZW50RW1pdHRlci5cbiAqL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zcG9ydCwgRXZlbnRFbWl0dGVyKTtcblxuLyoqXG4gKiBGbGFncyB0aGUgdHJhbnNwb3J0IGFzIGRpc2NhcmRlZC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLmRpc2NhcmQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZGlzY2FyZGVkID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggYW4gaW5jb21pbmcgSFRUUCByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcXVlc3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25SZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcSkge1xuICBkZWJ1Zygnc2V0dGluZyByZXF1ZXN0Jyk7XG4gIHRoaXMucmVxID0gcmVxO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGZuKSB7XG4gIGlmICgnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSByZXR1cm47XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NpbmcnO1xuICB0aGlzLmRvQ2xvc2UoZm4gfHwgbm9vcCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGEgdHJhbnNwb3J0IGVycm9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIGVycm9yXG4gKiBAcGFyYW0ge09iamVjdH0gZXJyb3IgZGVzY3JpcHRpb25cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChtc2csIGRlc2MpIHtcbiAgaWYgKHRoaXMubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgICBlcnIudHlwZSA9ICdUcmFuc3BvcnRFcnJvcic7XG4gICAgZXJyLmRlc2NyaXB0aW9uID0gZGVzYztcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygnaWdub3JlZCB0cmFuc3BvcnQgZXJyb3IgJXMgKCVzKScsIG1zZywgZGVzYyk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggcGFyc2VkIG91dCBhIHBhY2tldHMgZnJvbSB0aGUgZGF0YSBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCB0aGUgZW5jb2RlZCBwYWNrZXQgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLm9uUGFja2V0KHBhcnNlci5kZWNvZGVQYWNrZXQoZGF0YSkpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy5lbWl0KCdjbG9zZScpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9saWIvdHJhbnNwb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiBnbG9iYWwgQmxvYiBGaWxlICovXG5cbi8qXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHdpdGhOYXRpdmVCbG9iID0gdHlwZW9mIEJsb2IgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiB0b1N0cmluZy5jYWxsKEJsb2IpID09PSAnW29iamVjdCBCbG9iQ29uc3RydWN0b3JdJztcbnZhciB3aXRoTmF0aXZlRmlsZSA9IHR5cGVvZiBGaWxlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdG9TdHJpbmcuY2FsbChGaWxlKSA9PT0gJ1tvYmplY3QgRmlsZUNvbnN0cnVjdG9yXSc7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cbi8qKlxuICogQ2hlY2tzIGZvciBiaW5hcnkgZGF0YS5cbiAqXG4gKiBTdXBwb3J0cyBCdWZmZXIsIEFycmF5QnVmZmVyLCBCbG9iIGFuZCBGaWxlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbnl0aGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBoYXNCaW5hcnkgKG9iaikge1xuICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChoYXNCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIEJ1ZmZlci5pc0J1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAodHlwZW9mIEFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fFxuICAgICh3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICh3aXRoTmF0aXZlRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvaGFzLWJpbmFyeS9wdWxsLzRcbiAgaWYgKG9iai50b0pTT04gJiYgdHlwZW9mIG9iai50b0pTT04gPT09ICdmdW5jdGlvbicgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBoYXNCaW5hcnkob2JqLnRvSlNPTigpLCB0cnVlKTtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSAmJiBoYXNCaW5hcnkob2JqW2tleV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9oYXMtYmluYXJ5Mi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgaGFzRmxhZyA9IHJlcXVpcmUoJ2hhcy1mbGFnJyk7XG5cbmNvbnN0IGVudiA9IHByb2Nlc3MuZW52O1xuXG5sZXQgZm9yY2VDb2xvcjtcbmlmIChoYXNGbGFnKCduby1jb2xvcicpIHx8XG5cdGhhc0ZsYWcoJ25vLWNvbG9ycycpIHx8XG5cdGhhc0ZsYWcoJ2NvbG9yPWZhbHNlJykpIHtcblx0Zm9yY2VDb2xvciA9IGZhbHNlO1xufSBlbHNlIGlmIChoYXNGbGFnKCdjb2xvcicpIHx8XG5cdGhhc0ZsYWcoJ2NvbG9ycycpIHx8XG5cdGhhc0ZsYWcoJ2NvbG9yPXRydWUnKSB8fFxuXHRoYXNGbGFnKCdjb2xvcj1hbHdheXMnKSkge1xuXHRmb3JjZUNvbG9yID0gdHJ1ZTtcbn1cbmlmICgnRk9SQ0VfQ09MT1InIGluIGVudikge1xuXHRmb3JjZUNvbG9yID0gZW52LkZPUkNFX0NPTE9SLmxlbmd0aCA9PT0gMCB8fCBwYXJzZUludChlbnYuRk9SQ0VfQ09MT1IsIDEwKSAhPT0gMDtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlTGV2ZWwobGV2ZWwpIHtcblx0aWYgKGxldmVsID09PSAwKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRsZXZlbCxcblx0XHRoYXNCYXNpYzogdHJ1ZSxcblx0XHRoYXMyNTY6IGxldmVsID49IDIsXG5cdFx0aGFzMTZtOiBsZXZlbCA+PSAzXG5cdH07XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzQ29sb3Ioc3RyZWFtKSB7XG5cdGlmIChmb3JjZUNvbG9yID09PSBmYWxzZSkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0aWYgKGhhc0ZsYWcoJ2NvbG9yPTE2bScpIHx8XG5cdFx0aGFzRmxhZygnY29sb3I9ZnVsbCcpIHx8XG5cdFx0aGFzRmxhZygnY29sb3I9dHJ1ZWNvbG9yJykpIHtcblx0XHRyZXR1cm4gMztcblx0fVxuXG5cdGlmIChoYXNGbGFnKCdjb2xvcj0yNTYnKSkge1xuXHRcdHJldHVybiAyO1xuXHR9XG5cblx0aWYgKHN0cmVhbSAmJiAhc3RyZWFtLmlzVFRZICYmIGZvcmNlQ29sb3IgIT09IHRydWUpIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGNvbnN0IG1pbiA9IGZvcmNlQ29sb3IgPyAxIDogMDtcblxuXHRpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuXHRcdC8vIE5vZGUuanMgNy41LjAgaXMgdGhlIGZpcnN0IHZlcnNpb24gb2YgTm9kZS5qcyB0byBpbmNsdWRlIGEgcGF0Y2ggdG9cblx0XHQvLyBsaWJ1diB0aGF0IGVuYWJsZXMgMjU2IGNvbG9yIG91dHB1dCBvbiBXaW5kb3dzLiBBbnl0aGluZyBlYXJsaWVyIGFuZCBpdFxuXHRcdC8vIHdvbid0IHdvcmsuIEhvd2V2ZXIsIGhlcmUgd2UgdGFyZ2V0IE5vZGUuanMgOCBhdCBtaW5pbXVtIGFzIGl0IGlzIGFuIExUU1xuXHRcdC8vIHJlbGVhc2UsIGFuZCBOb2RlLmpzIDcgaXMgbm90LiBXaW5kb3dzIDEwIGJ1aWxkIDEwNTg2IGlzIHRoZSBmaXJzdCBXaW5kb3dzXG5cdFx0Ly8gcmVsZWFzZSB0aGF0IHN1cHBvcnRzIDI1NiBjb2xvcnMuIFdpbmRvd3MgMTAgYnVpbGQgMTQ5MzEgaXMgdGhlIGZpcnN0IHJlbGVhc2Vcblx0XHQvLyB0aGF0IHN1cHBvcnRzIDE2bS9UcnVlQ29sb3IuXG5cdFx0Y29uc3Qgb3NSZWxlYXNlID0gb3MucmVsZWFzZSgpLnNwbGl0KCcuJyk7XG5cdFx0aWYgKFxuXHRcdFx0TnVtYmVyKHByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdCgnLicpWzBdKSA+PSA4ICYmXG5cdFx0XHROdW1iZXIob3NSZWxlYXNlWzBdKSA+PSAxMCAmJlxuXHRcdFx0TnVtYmVyKG9zUmVsZWFzZVsyXSkgPj0gMTA1ODZcblx0XHQpIHtcblx0XHRcdHJldHVybiBOdW1iZXIob3NSZWxlYXNlWzJdKSA+PSAxNDkzMSA/IDMgOiAyO1xuXHRcdH1cblxuXHRcdHJldHVybiAxO1xuXHR9XG5cblx0aWYgKCdDSScgaW4gZW52KSB7XG5cdFx0aWYgKFsnVFJBVklTJywgJ0NJUkNMRUNJJywgJ0FQUFZFWU9SJywgJ0dJVExBQl9DSSddLnNvbWUoc2lnbiA9PiBzaWduIGluIGVudikgfHwgZW52LkNJX05BTUUgPT09ICdjb2Rlc2hpcCcpIHtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblxuXHRcdHJldHVybiBtaW47XG5cdH1cblxuXHRpZiAoJ1RFQU1DSVRZX1ZFUlNJT04nIGluIGVudikge1xuXHRcdHJldHVybiAvXig5XFwuKDAqWzEtOV1cXGQqKVxcLnxcXGR7Mix9XFwuKS8udGVzdChlbnYuVEVBTUNJVFlfVkVSU0lPTikgPyAxIDogMDtcblx0fVxuXG5cdGlmIChlbnYuQ09MT1JURVJNID09PSAndHJ1ZWNvbG9yJykge1xuXHRcdHJldHVybiAzO1xuXHR9XG5cblx0aWYgKCdURVJNX1BST0dSQU0nIGluIGVudikge1xuXHRcdGNvbnN0IHZlcnNpb24gPSBwYXJzZUludCgoZW52LlRFUk1fUFJPR1JBTV9WRVJTSU9OIHx8ICcnKS5zcGxpdCgnLicpWzBdLCAxMCk7XG5cblx0XHRzd2l0Y2ggKGVudi5URVJNX1BST0dSQU0pIHtcblx0XHRcdGNhc2UgJ2lUZXJtLmFwcCc6XG5cdFx0XHRcdHJldHVybiB2ZXJzaW9uID49IDMgPyAzIDogMjtcblx0XHRcdGNhc2UgJ0FwcGxlX1Rlcm1pbmFsJzpcblx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHQvLyBObyBkZWZhdWx0XG5cdFx0fVxuXHR9XG5cblx0aWYgKC8tMjU2KGNvbG9yKT8kL2kudGVzdChlbnYuVEVSTSkpIHtcblx0XHRyZXR1cm4gMjtcblx0fVxuXG5cdGlmICgvXnNjcmVlbnxeeHRlcm18XnZ0MTAwfF52dDIyMHxecnh2dHxjb2xvcnxhbnNpfGN5Z3dpbnxsaW51eC9pLnRlc3QoZW52LlRFUk0pKSB7XG5cdFx0cmV0dXJuIDE7XG5cdH1cblxuXHRpZiAoJ0NPTE9SVEVSTScgaW4gZW52KSB7XG5cdFx0cmV0dXJuIDE7XG5cdH1cblxuXHRpZiAoZW52LlRFUk0gPT09ICdkdW1iJykge1xuXHRcdHJldHVybiBtaW47XG5cdH1cblxuXHRyZXR1cm4gbWluO1xufVxuXG5mdW5jdGlvbiBnZXRTdXBwb3J0TGV2ZWwoc3RyZWFtKSB7XG5cdGNvbnN0IGxldmVsID0gc3VwcG9ydHNDb2xvcihzdHJlYW0pO1xuXHRyZXR1cm4gdHJhbnNsYXRlTGV2ZWwobGV2ZWwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0c3VwcG9ydHNDb2xvcjogZ2V0U3VwcG9ydExldmVsLFxuXHRzdGRvdXQ6IGdldFN1cHBvcnRMZXZlbChwcm9jZXNzLnN0ZG91dCksXG5cdHN0ZGVycjogZ2V0U3VwcG9ydExldmVsKHByb2Nlc3Muc3RkZXJyKVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3N1cHBvcnRzLWNvbG9yL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTWVyZ2VzIGFuIGFycmF5IG9mIGJ1ZmZlcnMgaW50byBhIG5ldyBidWZmZXIuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJbXX0gbGlzdCBUaGUgYXJyYXkgb2YgYnVmZmVycyB0byBjb25jYXRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3RhbExlbmd0aCBUaGUgdG90YWwgbGVuZ3RoIG9mIGJ1ZmZlcnMgaW4gdGhlIGxpc3RcbiAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIHJlc3VsdGluZyBidWZmZXJcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gY29uY2F0KGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGNvbnN0IHRhcmdldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSh0b3RhbExlbmd0aCk7XG4gIHZhciBvZmZzZXQgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGJ1ZiA9IGxpc3RbaV07XG4gICAgYnVmLmNvcHkodGFyZ2V0LCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBidWYubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBNYXNrcyBhIGJ1ZmZlciB1c2luZyB0aGUgZ2l2ZW4gbWFzay5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc291cmNlIFRoZSBidWZmZXIgdG8gbWFza1xuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gb3V0cHV0IFRoZSBidWZmZXIgd2hlcmUgdG8gc3RvcmUgdGhlIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHdyaXRpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIG51bWJlciBvZiBieXRlcyB0byBtYXNrLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBfbWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IHNvdXJjZVtpXSBeIG1hc2tbaSAmIDNdO1xuICB9XG59XG5cbi8qKlxuICogVW5tYXNrcyBhIGJ1ZmZlciB1c2luZyB0aGUgZ2l2ZW4gbWFzay5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gdW5tYXNrXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWFzayBUaGUgbWFzayB0byB1c2VcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX3VubWFzayhidWZmZXIsIG1hc2spIHtcbiAgLy8gUmVxdWlyZWQgdW50aWwgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy85MDA2IGlzIHJlc29sdmVkLlxuICBjb25zdCBsZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgYnVmZmVyW2ldIF49IG1hc2tbaSAmIDNdO1xuICB9XG59XG5cbnRyeSB7XG4gIGNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCdidWZmZXJ1dGlsJyk7XG4gIGNvbnN0IGJ1ID0gYnVmZmVyVXRpbC5CdWZmZXJVdGlsIHx8IGJ1ZmZlclV0aWw7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgIGlmIChsZW5ndGggPCA0OCkgX21hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGVsc2UgYnUubWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIH0sXG4gICAgdW5tYXNrKGJ1ZmZlciwgbWFzaykge1xuICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPCAzMikgX3VubWFzayhidWZmZXIsIG1hc2spO1xuICAgICAgZWxzZSBidS51bm1hc2soYnVmZmVyLCBtYXNrKTtcbiAgICB9LFxuICAgIGNvbmNhdFxuICB9O1xufSBjYXRjaCAoZSkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgY29uY2F0LCBtYXNrOiBfbWFzaywgdW5tYXNrOiBfdW5tYXNrIH07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy93cy9saWIvYnVmZmVyLXV0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogZGVwZFxuICogQ29weXJpZ2h0KGMpIDIwMTQtMjAxNSBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHB1YmxpY1xuICovXG5cbmxhenlQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ2NhbGxTaXRlVG9TdHJpbmcnLCBmdW5jdGlvbiBjYWxsU2l0ZVRvU3RyaW5nICgpIHtcbiAgdmFyIGxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0XG4gIHZhciBvYmogPSB7fVxuICB2YXIgcHJlcCA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlXG5cbiAgZnVuY3Rpb24gcHJlcGFyZU9iamVjdFN0YWNrVHJhY2UgKG9iaiwgc3RhY2spIHtcbiAgICByZXR1cm4gc3RhY2tcbiAgfVxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJlcGFyZU9iamVjdFN0YWNrVHJhY2VcbiAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMlxuXG4gIC8vIGNhcHR1cmUgdGhlIHN0YWNrXG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKG9iailcblxuICAvLyBzbGljZSB0aGUgc3RhY2tcbiAgdmFyIHN0YWNrID0gb2JqLnN0YWNrLnNsaWNlKClcblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXBcbiAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gbGltaXRcblxuICByZXR1cm4gc3RhY2tbMF0udG9TdHJpbmcgPyB0b1N0cmluZyA6IHJlcXVpcmUoJy4vY2FsbHNpdGUtdG9zdHJpbmcnKVxufSlcblxubGF6eVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCAnZXZlbnRMaXN0ZW5lckNvdW50JywgZnVuY3Rpb24gZXZlbnRMaXN0ZW5lckNvdW50ICgpIHtcbiAgcmV0dXJuIEV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50IHx8IHJlcXVpcmUoJy4vZXZlbnQtbGlzdGVuZXItY291bnQnKVxufSlcblxuLyoqXG4gKiBEZWZpbmUgYSBsYXp5IHByb3BlcnR5LlxuICovXG5cbmZ1bmN0aW9uIGxhenlQcm9wZXJ0eSAob2JqLCBwcm9wLCBnZXR0ZXIpIHtcbiAgZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICB2YXIgdmFsID0gZ2V0dGVyKClcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdmFsXG4gICAgfSlcblxuICAgIHJldHVybiB2YWxcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGdldFxuICB9KVxufVxuXG4vKipcbiAqIENhbGwgdG9TdHJpbmcoKSBvbiB0aGUgb2JqXG4gKi9cblxuZnVuY3Rpb24gdG9TdHJpbmcgKG9iaikge1xuICByZXR1cm4gb2JqLnRvU3RyaW5nKClcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RlcGQvbGliL2NvbXBhdC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAqL1xuXG52YXIgcHJldlRpbWU7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgdmFyIGhhc2ggPSAwLCBpO1xuXG4gIGZvciAoaSBpbiBuYW1lc3BhY2UpIHtcbiAgICBoYXNoICA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXG4gIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgIC8vIGRpc2FibGVkP1xuICAgIGlmICghZGVidWcuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgdmFyIHNlbGYgPSBkZWJ1ZztcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gdHVybiB0aGUgYGFyZ3VtZW50c2AgaW50byBhIHByb3BlciBBcnJheVxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICAvLyBhcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuICAgIGV4cG9ydHMuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG4gICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cblxuICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIGRlYnVnLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgZGVidWcudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgfVxuXG4gIHJldHVybiBkZWJ1Zztcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICBleHBvcnRzLm5hbWVzID0gW107XG4gIGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9kZWJ1Zy5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFNvbWUgZW52aXJvbm1lbnRzIGRvbid0IGhhdmUgZ2xvYmFsIEJ1ZmZlciAoZS5nLiBSZWFjdCBOYXRpdmUpLlxuLy8gU29sdXRpb24gd291bGQgYmUgaW5zdGFsbGluZyBucG0gbW9kdWxlcyBcImJ1ZmZlclwiIGFuZCBcInN0cmVhbVwiIGV4cGxpY2l0bHkuXG52YXIgQnVmZmVyID0gcmVxdWlyZShcInNhZmVyLWJ1ZmZlclwiKS5CdWZmZXI7XG5cbnZhciBib21IYW5kbGluZyA9IHJlcXVpcmUoXCIuL2JvbS1oYW5kbGluZ1wiKSxcbiAgICBpY29udiA9IG1vZHVsZS5leHBvcnRzO1xuXG4vLyBBbGwgY29kZWNzIGFuZCBhbGlhc2VzIGFyZSBrZXB0IGhlcmUsIGtleWVkIGJ5IGVuY29kaW5nIG5hbWUvYWxpYXMuXG4vLyBUaGV5IGFyZSBsYXp5IGxvYWRlZCBpbiBgaWNvbnYuZ2V0Q29kZWNgIGZyb20gYGVuY29kaW5ncy9pbmRleC5qc2AuXG5pY29udi5lbmNvZGluZ3MgPSBudWxsO1xuXG4vLyBDaGFyYWN0ZXJzIGVtaXR0ZWQgaW4gY2FzZSBvZiBlcnJvci5cbmljb252LmRlZmF1bHRDaGFyVW5pY29kZSA9ICfvv70nO1xuaWNvbnYuZGVmYXVsdENoYXJTaW5nbGVCeXRlID0gJz8nO1xuXG4vLyBQdWJsaWMgQVBJLlxuaWNvbnYuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKHN0ciwgZW5jb2RpbmcsIG9wdGlvbnMpIHtcbiAgICBzdHIgPSBcIlwiICsgKHN0ciB8fCBcIlwiKTsgLy8gRW5zdXJlIHN0cmluZy5cblxuICAgIHZhciBlbmNvZGVyID0gaWNvbnYuZ2V0RW5jb2RlcihlbmNvZGluZywgb3B0aW9ucyk7XG5cbiAgICB2YXIgcmVzID0gZW5jb2Rlci53cml0ZShzdHIpO1xuICAgIHZhciB0cmFpbCA9IGVuY29kZXIuZW5kKCk7XG4gICAgXG4gICAgcmV0dXJuICh0cmFpbCAmJiB0cmFpbC5sZW5ndGggPiAwKSA/IEJ1ZmZlci5jb25jYXQoW3JlcywgdHJhaWxdKSA6IHJlcztcbn1cblxuaWNvbnYuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGJ1ZiwgZW5jb2RpbmcsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGJ1ZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCFpY29udi5za2lwRGVjb2RlV2FybmluZykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignSWNvbnYtbGl0ZSB3YXJuaW5nOiBkZWNvZGUoKS1pbmcgc3RyaW5ncyBpcyBkZXByZWNhdGVkLiBSZWZlciB0byBodHRwczovL2dpdGh1Yi5jb20vYXNodHVjaGtpbi9pY29udi1saXRlL3dpa2kvVXNlLUJ1ZmZlcnMtd2hlbi1kZWNvZGluZycpO1xuICAgICAgICAgICAgaWNvbnYuc2tpcERlY29kZVdhcm5pbmcgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVmID0gQnVmZmVyLmZyb20oXCJcIiArIChidWYgfHwgXCJcIiksIFwiYmluYXJ5XCIpOyAvLyBFbnN1cmUgYnVmZmVyLlxuICAgIH1cblxuICAgIHZhciBkZWNvZGVyID0gaWNvbnYuZ2V0RGVjb2RlcihlbmNvZGluZywgb3B0aW9ucyk7XG5cbiAgICB2YXIgcmVzID0gZGVjb2Rlci53cml0ZShidWYpO1xuICAgIHZhciB0cmFpbCA9IGRlY29kZXIuZW5kKCk7XG5cbiAgICByZXR1cm4gdHJhaWwgPyAocmVzICsgdHJhaWwpIDogcmVzO1xufVxuXG5pY29udi5lbmNvZGluZ0V4aXN0cyA9IGZ1bmN0aW9uIGVuY29kaW5nRXhpc3RzKGVuYykge1xuICAgIHRyeSB7XG4gICAgICAgIGljb252LmdldENvZGVjKGVuYyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLy8gTGVnYWN5IGFsaWFzZXMgdG8gY29udmVydCBmdW5jdGlvbnNcbmljb252LnRvRW5jb2RpbmcgPSBpY29udi5lbmNvZGU7XG5pY29udi5mcm9tRW5jb2RpbmcgPSBpY29udi5kZWNvZGU7XG5cbi8vIFNlYXJjaCBmb3IgYSBjb2RlYyBpbiBpY29udi5lbmNvZGluZ3MuIENhY2hlIGNvZGVjIGRhdGEgaW4gaWNvbnYuX2NvZGVjRGF0YUNhY2hlLlxuaWNvbnYuX2NvZGVjRGF0YUNhY2hlID0ge307XG5pY29udi5nZXRDb2RlYyA9IGZ1bmN0aW9uIGdldENvZGVjKGVuY29kaW5nKSB7XG4gICAgaWYgKCFpY29udi5lbmNvZGluZ3MpXG4gICAgICAgIGljb252LmVuY29kaW5ncyA9IHJlcXVpcmUoXCIuLi9lbmNvZGluZ3NcIik7IC8vIExhenkgbG9hZCBhbGwgZW5jb2RpbmcgZGVmaW5pdGlvbnMuXG4gICAgXG4gICAgLy8gQ2Fub25pY2FsaXplIGVuY29kaW5nIG5hbWU6IHN0cmlwIGFsbCBub24tYWxwaGFudW1lcmljIGNoYXJzIGFuZCBhcHBlbmRlZCB5ZWFyLlxuICAgIHZhciBlbmMgPSBpY29udi5fY2Fub25pY2FsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuXG4gICAgLy8gVHJhdmVyc2UgaWNvbnYuZW5jb2RpbmdzIHRvIGZpbmQgYWN0dWFsIGNvZGVjLlxuICAgIHZhciBjb2RlY09wdGlvbnMgPSB7fTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgY29kZWMgPSBpY29udi5fY29kZWNEYXRhQ2FjaGVbZW5jXTtcbiAgICAgICAgaWYgKGNvZGVjKVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVjO1xuXG4gICAgICAgIHZhciBjb2RlY0RlZiA9IGljb252LmVuY29kaW5nc1tlbmNdO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIGNvZGVjRGVmKSB7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6IC8vIERpcmVjdCBhbGlhcyB0byBvdGhlciBlbmNvZGluZy5cbiAgICAgICAgICAgICAgICBlbmMgPSBjb2RlY0RlZjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOiAvLyBBbGlhcyB3aXRoIG9wdGlvbnMuIENhbiBiZSBsYXllcmVkLlxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBjb2RlY0RlZilcbiAgICAgICAgICAgICAgICAgICAgY29kZWNPcHRpb25zW2tleV0gPSBjb2RlY0RlZltrZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjb2RlY09wdGlvbnMuZW5jb2RpbmdOYW1lKVxuICAgICAgICAgICAgICAgICAgICBjb2RlY09wdGlvbnMuZW5jb2RpbmdOYW1lID0gZW5jO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGVuYyA9IGNvZGVjRGVmLnR5cGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOiAvLyBDb2RlYyBpdHNlbGYuXG4gICAgICAgICAgICAgICAgaWYgKCFjb2RlY09wdGlvbnMuZW5jb2RpbmdOYW1lKVxuICAgICAgICAgICAgICAgICAgICBjb2RlY09wdGlvbnMuZW5jb2RpbmdOYW1lID0gZW5jO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvZGVjIGZ1bmN0aW9uIG11c3QgbG9hZCBhbGwgdGFibGVzIGFuZCByZXR1cm4gb2JqZWN0IHdpdGggLmVuY29kZXIgYW5kIC5kZWNvZGVyIG1ldGhvZHMuXG4gICAgICAgICAgICAgICAgLy8gSXQnbGwgYmUgY2FsbGVkIG9ubHkgb25jZSAoZm9yIGVhY2ggZGlmZmVyZW50IG9wdGlvbnMgb2JqZWN0KS5cbiAgICAgICAgICAgICAgICBjb2RlYyA9IG5ldyBjb2RlY0RlZihjb2RlY09wdGlvbnMsIGljb252KTtcblxuICAgICAgICAgICAgICAgIGljb252Ll9jb2RlY0RhdGFDYWNoZVtjb2RlY09wdGlvbnMuZW5jb2RpbmdOYW1lXSA9IGNvZGVjOyAvLyBTYXZlIGl0IHRvIGJlIHJldXNlZCBsYXRlci5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZWM7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jb2Rpbmcgbm90IHJlY29nbml6ZWQ6ICdcIiArIGVuY29kaW5nICsgXCInIChzZWFyY2hlZCBhczogJ1wiK2VuYytcIicpXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5pY29udi5fY2Fub25pY2FsaXplRW5jb2RpbmcgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICAgIC8vIENhbm9uaWNhbGl6ZSBlbmNvZGluZyBuYW1lOiBzdHJpcCBhbGwgbm9uLWFscGhhbnVtZXJpYyBjaGFycyBhbmQgYXBwZW5kZWQgeWVhci5cbiAgICByZXR1cm4gKCcnK2VuY29kaW5nKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLzpcXGR7NH0kfFteMC05YS16XS9nLCBcIlwiKTtcbn1cblxuaWNvbnYuZ2V0RW5jb2RlciA9IGZ1bmN0aW9uIGdldEVuY29kZXIoZW5jb2RpbmcsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29kZWMgPSBpY29udi5nZXRDb2RlYyhlbmNvZGluZyksXG4gICAgICAgIGVuY29kZXIgPSBuZXcgY29kZWMuZW5jb2RlcihvcHRpb25zLCBjb2RlYyk7XG5cbiAgICBpZiAoY29kZWMuYm9tQXdhcmUgJiYgb3B0aW9ucyAmJiBvcHRpb25zLmFkZEJPTSlcbiAgICAgICAgZW5jb2RlciA9IG5ldyBib21IYW5kbGluZy5QcmVwZW5kQk9NKGVuY29kZXIsIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIGVuY29kZXI7XG59XG5cbmljb252LmdldERlY29kZXIgPSBmdW5jdGlvbiBnZXREZWNvZGVyKGVuY29kaW5nLCBvcHRpb25zKSB7XG4gICAgdmFyIGNvZGVjID0gaWNvbnYuZ2V0Q29kZWMoZW5jb2RpbmcpLFxuICAgICAgICBkZWNvZGVyID0gbmV3IGNvZGVjLmRlY29kZXIob3B0aW9ucywgY29kZWMpO1xuXG4gICAgaWYgKGNvZGVjLmJvbUF3YXJlICYmICEob3B0aW9ucyAmJiBvcHRpb25zLnN0cmlwQk9NID09PSBmYWxzZSkpXG4gICAgICAgIGRlY29kZXIgPSBuZXcgYm9tSGFuZGxpbmcuU3RyaXBCT00oZGVjb2Rlciwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gZGVjb2Rlcjtcbn1cblxuXG4vLyBMb2FkIGV4dGVuc2lvbnMgaW4gTm9kZS4gQWxsIG9mIHRoZW0gYXJlIG9taXR0ZWQgaW4gQnJvd3NlcmlmeSBidWlsZCB2aWEgJ2Jyb3dzZXInIGZpZWxkIGluIHBhY2thZ2UuanNvbi5cbnZhciBub2RlVmVyID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlO1xuaWYgKG5vZGVWZXIpIHtcblxuICAgIC8vIExvYWQgc3RyZWFtaW5nIHN1cHBvcnQgaW4gTm9kZSB2MC4xMCtcbiAgICB2YXIgbm9kZVZlckFyciA9IG5vZGVWZXIuc3BsaXQoXCIuXCIpLm1hcChOdW1iZXIpO1xuICAgIGlmIChub2RlVmVyQXJyWzBdID4gMCB8fCBub2RlVmVyQXJyWzFdID49IDEwKSB7XG4gICAgICAgIHJlcXVpcmUoXCIuL3N0cmVhbXNcIikoaWNvbnYpO1xuICAgIH1cblxuICAgIC8vIExvYWQgTm9kZSBwcmltaXRpdmUgZXh0ZW5zaW9ucy5cbiAgICByZXF1aXJlKFwiLi9leHRlbmQtbm9kZVwiKShpY29udik7XG59XG5cbmlmIChcIsSAXCIgIT0gXCJcXHUwMTAwXCIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiaWNvbnYtbGl0ZSB3YXJuaW5nOiBqYXZhc2NyaXB0IGZpbGVzIHVzZSBlbmNvZGluZyBkaWZmZXJlbnQgZnJvbSB1dGYtOC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hc2h0dWNoa2luL2ljb252LWxpdGUvd2lraS9KYXZhc2NyaXB0LXNvdXJjZS1maWxlLWVuY29kaW5ncyBmb3IgbW9yZSBpbmZvLlwiKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFtbXCJhMTQwXCIsXCLuk4ZcIiw2Ml0sW1wiYTE4MFwiLFwi7pSFXCIsMzJdLFtcImEyNDBcIixcIu6UplwiLDYyXSxbXCJhMjgwXCIsXCLulaVcIiwzMl0sW1wiYTJhYlwiLFwi7p2mXCIsNV0sW1wiYTJlM1wiLFwi4oKs7p2tXCJdLFtcImEyZWZcIixcIu6dru6dr1wiXSxbXCJhMmZkXCIsXCLunbDunbFcIl0sW1wiYTM0MFwiLFwi7paGXCIsNjJdLFtcImEzODBcIixcIu6XhVwiLDMxLFwi44CAXCJdLFtcImE0NDBcIixcIu6XplwiLDYyXSxbXCJhNDgwXCIsXCLumKVcIiwzMl0sW1wiYTRmNFwiLFwi7p2yXCIsMTBdLFtcImE1NDBcIixcIu6ZhlwiLDYyXSxbXCJhNTgwXCIsXCLumoVcIiwzMl0sW1wiYTVmN1wiLFwi7p29XCIsN10sW1wiYTY0MFwiLFwi7pqmXCIsNjJdLFtcImE2ODBcIixcIu6bpVwiLDMyXSxbXCJhNmI5XCIsXCLunoVcIiw3XSxbXCJhNmQ5XCIsXCLuno1cIiw2XSxbXCJhNmVjXCIsXCLunpTunpVcIl0sW1wiYTZmM1wiLFwi7p6WXCJdLFtcImE2ZjZcIixcIu6el1wiLDhdLFtcImE3NDBcIixcIu6chlwiLDYyXSxbXCJhNzgwXCIsXCLunYVcIiwzMl0sW1wiYTdjMlwiLFwi7p6gXCIsMTRdLFtcImE3ZjJcIixcIu6er1wiLDEyXSxbXCJhODk2XCIsXCLunrxcIiwxMF0sW1wiYThiY1wiLFwi7p+HXCJdLFtcImE4YmZcIixcIse5XCJdLFtcImE4YzFcIixcIu6fie6fiu6fi+6fjFwiXSxbXCJhOGVhXCIsXCLun41cIiwyMF0sW1wiYTk1OFwiLFwi7p+iXCJdLFtcImE5NWJcIixcIu6fo1wiXSxbXCJhOTVkXCIsXCLun6Tun6Xun6ZcIl0sW1wiYTk4OVwiLFwi44C+4r+wXCIsMTFdLFtcImE5OTdcIixcIu6ftFwiLDEyXSxbXCJhOWYwXCIsXCLuoIFcIiwxNF0sW1wiYWFhMVwiLFwi7oCAXCIsOTNdLFtcImFiYTFcIixcIu6BnlwiLDkzXSxbXCJhY2ExXCIsXCLugrxcIiw5M10sW1wiYWRhMVwiLFwi7oSaXCIsOTNdLFtcImFlYTFcIixcIu6FuFwiLDkzXSxbXCJhZmExXCIsXCLuh5ZcIiw5M10sW1wiZDdmYVwiLFwi7qCQXCIsNF0sW1wiZjhhMVwiLFwi7oi0XCIsOTNdLFtcImY5YTFcIixcIu6KklwiLDkzXSxbXCJmYWExXCIsXCLui7BcIiw5M10sW1wiZmJhMVwiLFwi7o2OXCIsOTNdLFtcImZjYTFcIixcIu6OrFwiLDkzXSxbXCJmZGExXCIsXCLukIpcIiw5M10sW1wiZmU1MFwiLFwi4rqB7qCW7qCX7qCY4rqE45Gz45GH4rqI4rqL7qCe45ae45ia45iO4rqM4rqX46Wu46SY7qCm46eP46ef46mz46eQ7qCr7qCs462O47Gu47Og4rqn7qCx7qCy4rqq5IGW5IWf4rqu5Iy34rqz4rq24rq37qC75I6x5I6s4rq75I+d5JOW5Jmh5JmM7qGDXCJdLFtcImZlODBcIixcIuSco+ScqeSdvOSejeK7iuSlh+SluuSlveSmguSmg+SmheSmhuSmn+Smm+Smt+Smtu6hlO6hleSyo+Syn+SyoOSyoeSxt+SyouS0k1wiLDYsXCLktq7uoaTukahcIiw5M11dXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaWNvbnYtbGl0ZS9lbmNvZGluZ3MvdGFibGVzL2diay1hZGRlZC5qc29uXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFtbXCIwXCIsXCJcXHUwMDAwXCIsMTI3XSxbXCJhMTQwXCIsXCLjgIDvvIzjgIHjgILvvI7igKfvvJvvvJrvvJ/vvIHvuLDigKbigKXvuZDvuZHvuZLCt++5lO+5le+5lu+5l++9nOKAk++4seKAlO+4s+KVtO+4tO+5j++8iO+8ie+4te+4tu+9m++9ne+4t++4uOOAlOOAle+4ue+4uuOAkOOAke+4u++4vOOAiuOAi++4ve+4vuOAiOOAie+4v++5gOOAjOOAje+5ge+5guOAjuOAj++5g++5hO+5me+5mlwiXSxbXCJhMWExXCIsXCLvuZvvuZzvuZ3vuZ7igJjigJnigJzigJ3jgJ3jgJ7igLXigLLvvIPvvIbvvIrigLvCp+OAg+KXi+KXj+KWs+KWsuKXjuKYhuKYheKXh+KXhuKWoeKWoOKWveKWvOOKo+KEhcKv77+j77y/y43vuYnvuYrvuY3vuY7vuYvvuYzvuZ/vuaDvuaHvvIvvvI3Dl8O3wrHiiJrvvJzvvJ7vvJ3iiabiiafiiaDiiJ7iiZLiiaHvuaJcIiw0LFwi772e4oip4oiq4oql4oig4oif4oq/44+S44+R4oir4oiu4oi14oi04pmA4pmC4oqV4oqZ4oaR4oaT4oaQ4oaS4oaW4oaX4oaZ4oaY4oil4oij77yPXCJdLFtcImEyNDBcIixcIu+8vOKIle+5qO+8hO+/peOAku+/oO+/oe+8he+8oOKEg+KEie+5qe+5qu+5q+OPleOOnOOOneOOnuOPjuOOoeOOjuOOj+OPhMKw5YWZ5YWb5YWe5YWd5YWh5YWj5Zen55Op57OO4paBXCIsNyxcIuKWj+KWjuKWjeKWjOKWi+KWiuKWieKUvOKUtOKUrOKUpOKUnOKWlOKUgOKUguKWleKUjOKUkOKUlOKUmOKVrVwiXSxbXCJhMmExXCIsXCLila7ilbDila/ilZDilZ7ilarilaHil6Lil6Pil6Xil6TilbHilbLilbPvvJBcIiw5LFwi4oWgXCIsOSxcIuOAoVwiLDgsXCLljYHljYTljYXvvKFcIiwyNSxcIu+9gVwiLDIxXSxbXCJhMzQwXCIsXCLvvZfvvZjvvZnvvZrOkVwiLDE2LFwizqNcIiw2LFwizrFcIiwxNixcIs+DXCIsNixcIuOEhVwiLDEwXSxbXCJhM2ExXCIsXCLjhJBcIiwyNSxcIsuZy4nLisuHy4tcIl0sW1wiYTNlMVwiLFwi4oKsXCJdLFtcImE0NDBcIixcIuS4gOS5meS4geS4g+S5g+S5neS6huS6jOS6uuWEv+WFpeWFq+WHoOWIgOWIgeWKm+WMleWNgeWNnOWPiOS4ieS4i+S4iOS4iuS4q+S4uOWHoeS5heS5iOS5n+S5nuS6juS6oeWFgOWIg+WLuuWNg+WPieWPo+Wcn+Wjq+WkleWkp+Wls+WtkOWtkeWtk+WvuOWwj+WwouWwuOWxseW3neW3peW3seW3suW3s+W3vuW5suW7vuW8i+W8k+aJjVwiXSxbXCJhNGExXCIsXCLkuJHkuJDkuI3kuK3kuLDkuLnkuYvlsLnkuojkupHkupXkupLkupTkuqLku4Hku4Dku4Pku4bku4fku43ku4rku4vku4TlhYPlhYHlhaflha3lha7lhazlhpflh7bliIbliIfliIjli7vli77li7/ljJbljLnljYjljYfljYXljZ7ljoTlj4vlj4rlj43lo6zlpKnlpKvlpKrlpK3lrZTlsJHlsKTlsLrlsa/lt7Tlubvlu7/lvJTlvJXlv4PmiIjmiLbmiYvmiY7mlK/mlofmlpfmlqTmlrnml6Xmm7DmnIjmnKjmrKDmraLmrbnmr4vmr5Tmr5vmsI/msLTngavniKrniLbniLvniYfniZnniZvniqznjovkuJlcIl0sW1wiYTU0MFwiLFwi5LiW5LiV5LiU5LiY5Li75LmN5LmP5LmO5Lul5LuY5LuU5LuV5LuW5LuX5Luj5Luk5LuZ5Lue5YWF5YWE5YaJ5YaK5Yas5Ye55Ye65Ye45YiK5Yqg5Yqf5YyF5YyG5YyX5Yyd5Luf5Y2K5Y2J5Y2h5Y2g5Y2v5Y2u5Y675Y+v5Y+k5Y+z5Y+s5Y+u5Y+p5Y+o5Y+85Y+45Y+15Y+r5Y+m5Y+q5Y+y5Y+x5Y+w5Y+l5Y+t5Y+75Zub5Zua5aSWXCJdLFtcImE1YTFcIixcIuWkruWkseWltOWltuWtleWug+WwvOW3qOW3p+W3puW4guW4g+W5s+W5vOW8geW8mOW8l+W/heaIiuaJk+aJlOaJkuaJkeaWpeaXpuacruacrOacquacq+acreato+avjeawkeawkOawuOaxgeaxgOawvueKr+eOhOeOieeTnOeTpueUmOeUn+eUqOeUqeeUsOeUseeUsueUs+eWi+eZveearueav+ebruefm+efouefs+ekuuemvueptOeri+S4nuS4n+S5kuS5k+S5qeS6meS6pOS6puS6peS7v+S8ieS8meS8iuS8leS8jeS8kOS8keS8j+S7suS7tuS7u+S7sOS7s+S7veS8geS8i+WFieWFh+WFhuWFiOWFqFwiXSxbXCJhNjQwXCIsXCLlhbHlho3lhrDliJfliJHliJLliI7liJbliqPljIjljKHljKDljbDljbHlkInlkI/lkIzlkIrlkJDlkIHlkIvlkITlkJHlkI3lkIjlkIPlkI7lkIblkJLlm6Dlm57lm53lnLPlnLDlnKjlnK3lnKzlnK/lnKnlpJnlpJrlpLflpLjlpoTlpbjlpoPlpb3lpbnlpoLlpoHlrZflrZjlroflrojlroXlronlr7rlsJblsbnlt57luIblubblubRcIl0sW1wiYTZhMVwiLFwi5byP5byb5b+Z5b+W5oiO5oiM5oiN5oiQ5omj5omb5omY5pS25pep5peo5pes5pet5puy5puz5pyJ5py95py05pyx5py15qyh5q2k5q275rCW5rGd5rGX5rGZ5rGf5rGg5rGQ5rGV5rGh5rGb5rGN5rGO54Gw54mf54md55m+56u557Gz57O457y2576K57696ICB6ICD6ICM6ICS6ICz6IG/6IKJ6IKL6IKM6Iej6Ieq6Iez6Ie86IiM6Iib6Iif6Imu6Imy6Im+6Jmr6KGA6KGM6KGj6KW/6Zih5Liy5Lqo5L2N5L2P5L2H5L2X5L2e5Ly05L2b5L2V5Lyw5L2Q5L2R5Ly95Ly65Ly45L2D5L2U5Ly85L2G5L2jXCJdLFtcImE3NDBcIixcIuS9nOS9oOS8r+S9juS8tuS9meS9neS9iOS9muWFjOWFi+WFjeWFteWGtuWGt+WIpeWIpOWIqeWIquWIqOWKq+WKqeWKquWKrOWMo+WNs+WNteWQneWQreWQnuWQvuWQpuWRjuWQp+WRhuWRg+WQs+WRiOWRguWQm+WQqeWRiuWQueWQu+WQuOWQruWQteWQtuWQoOWQvOWRgOWQseWQq+WQn+WQrOWbquWbsOWbpOWbq+WdiuWdkeWdgOWdjVwiXSxbXCJhN2ExXCIsXCLlnYflnY7lnL7lnZDlnY/lnLvlo6/lpL7lpp3lppLlpqjlpp7lpqPlppnlppblpo3lpqTlppPlporlpqXlrZ3lrZzlrZrlrZvlrozlrovlro/lsKzlsYDlsYHlsL/lsL7lspDlspHlspTlsozlt6vluIzluo/luofluorlu7flvITlvJ/lvaTlvaLlvbflvbnlv5jlv4zlv5flv43lv7Hlv6vlv7jlv6rmiJLmiJHmioTmipfmipbmioDmibbmionmia3miormibzmib7mibnmibPmipLmia/mipjmia7mipXmipPmipHmiobmlLnmlLvmlLjml7Hmm7TmnZ/mnY7mnY/mnZDmnZHmnZzmnZbmnZ7mnYnmnYbmnaBcIl0sW1wiYTg0MFwiLFwi5p2T5p2X5q2l5q+P5rGC5rGe5rKZ5rKB5rKI5rKJ5rKF5rKb5rGq5rG65rKQ5rGw5rKM5rGo5rKW5rKS5rG95rKD5rGy5rG+5rG05rKG5rG25rKN5rKU5rKY5rKC54G254G854G954G454mi54mh54mg54uE54uC546W55Ss55Sr55S355S455qC55uv55+j56eB56eA56a/56m257O7572V6IKW6IKT6IKd6IKY6IKb6IKa6IKy6Imv6IqSXCJdLFtcImE4YTFcIixcIuiKi+iKjeimi+inkuiogOiwt+ixhuixleiynei1pOi1sOi2s+i6q+i7iui+m+i+sOi/gui/hui/hei/hOW3oemCkemCoumCqumCpumCo+mFiemHhumHjOmYsumYrumYsemYqumYrOS4puS5luS5s+S6i+S6m+S6nuS6q+S6rOS9r+S+neS+jeS9s+S9v+S9rOS+m+S+i+S+huS+g+S9sOS9teS+iOS9qeS9u+S+luS9vuS+j+S+keS9uuWFlOWFkuWFleWFqeWFt+WFtuWFuOWGveWHveWIu+WIuOWIt+WIuuWIsOWIruWItuWJgeWKvuWKu+WNkuWNlOWNk+WNkeWNpuWNt+WNuOWNueWPluWPlOWPl+WRs+WRtVwiXSxbXCJhOTQwXCIsXCLlkpblkbjlkpXlkoDlkbvlkbflkoTlkpLlkoblkbzlkpDlkbHlkbblkozlkprlkaLlkajlkovlkb3lko7lm7rlnoPlnbflnarlnanlnaHlnablnaTlnbzlpJzlpYnlpYflpYjlpYTlpZTlpr7lprvlp5Tlprnlpq7lp5Hlp4blp5Dlp43lp4vlp5Plp4rlpq/lprPlp5Llp4XlrZ/lraTlraPlrpflrprlrpjlrpzlrpnlrpvlsJrlsYjlsYVcIl0sW1wiYTlhMVwiLFwi5bGG5bK35bKh5bK45bKp5bKr5bKx5bKz5biY5bia5biW5biV5bib5biR5bm45bqa5bqX5bqc5bqV5bqW5bu25bym5byn5byp5b6A5b6B5b2/5b285b+d5b+g5b+95b+15b+/5oCP5oCU5oCv5oC15oCW5oCq5oCV5oCh5oCn5oCp5oCr5oCb5oiW5oiV5oi/5oi+5omA5om/5ouJ5ouM5ouE5oq/5ouC5oq55ouS5oub5oqr5ouT5ouU5ouL5ouI5oqo5oq95oq85ouQ5ouZ5ouH5ouN5oq15oua5oqx5ouY5ouW5ouX5ouG5oqs5ouO5pS+5pan5pa85pe65piU5piT5piM5piG5piC5piO5piA5piP5piV5piKXCJdLFtcImFhNDBcIixcIuaYh+acjeaci+adreaei+aeleadseaenOads+adt+aeh+aeneael+adr+adsOadv+aeieadvuaekOadteaemuaek+advOadquadsuaso+atpuatp+atv+awk+awm+azo+azqOazs+ayseazjOazpeays+ayveayvuayvOazouayq+azleazk+ayuOazhOayueazgeayruazl+azheazseayv+ayu+azoeazm+aziuayrOazr+aznOazluazoFwiXSxbXCJhYWExXCIsXCLngpXngo7ngpLngorngpnniKzniK3niLjniYjniafnianni4Dni47ni5nni5fni5Dnjqnnjqjnjp/njqvnjqXnlL3nlp3nlpnnlprnmoTnm4Lnm7Lnm7Tnn6Xnn73npL7npYDnpYHnp4nnp4jnqbrnqbnnq7rns77nvZTnvoznvovogIXogrrogqXogqLogrHogqHogqvogqnogrTogqrogq/oh6Xoh77oiI3oirPoip3oipnoiq3oir3oip/oirnoirHoiqzoiqXoiq/oirjoiqPoirDoir7oirfomY7ombHliJ3ooajou4vov47ov5Tov5HpgrXpgrjpgrHpgrbph4fph5HplbfploDpmJzpmYDpmL/pmLvpmYRcIl0sW1wiYWI0MFwiLFwi6ZmC6Zq56Zuo6Z2S6Z2e5Lqf5Lqt5Lqu5L+h5L615L6v5L6/5L+g5L+R5L+P5L+d5L+D5L625L+Y5L+f5L+K5L+X5L6u5L+Q5L+E5L+C5L+a5L+O5L+e5L635YWX5YaS5YaR5Yag5YmO5YmD5YmK5YmN5YmM5YmL5YmH5YuH5YuJ5YuD5YuB5YyN5Y2X5Y275Y6a5Y+b5ZKs5ZOA5ZKo5ZOO5ZOJ5ZK45ZKm5ZKz5ZOH5ZOC5ZK95ZKq5ZOBXCJdLFtcImFiYTFcIixcIuWThOWTiOWSr+WSq+WSseWSu+WSqeWSp+WSv+Wbv+WeguWei+WeoOWeo+WeouWfjuWeruWek+WlleWlkeWlj+WljuWlkOWnnOWnmOWnv+Wno+WnqOWog+WnpeWnquWnmuWnpuWogeWnu+WtqeWuo+WupuWupOWuouWupeWwgeWxjuWxj+WxjeWxi+WzmeWzkuW3t+W4neW4peW4n+W5veW6oOW6puW7uuW8iOW8reW9peW+iOW+heW+iuW+i+W+h+W+jOW+ieaAkuaAneaAoOaApeaAjuaAqOaBjeaBsOaBqOaBouaBhuaBg+aBrOaBq+aBquaBpOaJgeaLnOaMluaMieaLvOaLreaMgeaLruaLveaMh+aLseaLt1wiXSxbXCJhYzQwXCIsXCLmi6/mi6zmi77mi7TmjJHmjILmlL/mlYXmlqvmlr3ml6LmmKXmmK3mmKDmmKfmmK/mmJ/mmKjmmLHmmKTmm7fmn7/mn5Pmn7Hmn5Tmn5Dmn6zmnrbmnq/mn7Xmn6nmn6/mn4Tmn5HmnrTmn5rmn6Xmnrjmn4/mn57mn7PmnrDmn5nmn6Lmn53mn5LmrarmroPmrobmrrXmr5Lmr5fmsJ/ms4nmtIvmtLLmtKrmtYHmtKXmtIzmtLHmtJ7mtJdcIl0sW1wiYWNhMVwiLFwi5rS75rS95rS+5rS25rSb5rO15rS55rSn5rS45rSp5rSu5rS15rSO5rSr54Kr54K654Kz54Ks54Kv54Kt54K454Ku54Kk54iw54my54mv54m054up54ug54uh546354+K5467546y54+N54+A546z55Sa55St55WP55WM55WO55WL55ar55ak55al55ai55aj55m455qG55qH55qI55uI55uG55uD55uF55yB55u555u455yJ55yL55u+55u855yH55+c56CC56CU56CM56CN56WG56WJ56WI56WH56a556a656eR56eS56eL56m/56qB56u/56u957G957SC57SF57SA57SJ57SH57SE57SG57y4576O576/6ICEXCJdLFtcImFkNDBcIixcIuiAkOiAjeiAkeiAtuiDluiDpeiDmuiDg+iDhOiDjOiDoeiDm+iDjuiDnuiDpOiDneiHtOiIouiLp+iMg+iMheiLo+iLm+iLpuiMhOiLpeiMguiMieiLkuiLl+iLseiMgeiLnOiLlOiLkeiLnuiLk+iLn+iLr+iMhuiZkOiZueiZu+iZuuihjeihq+imgeinlOioiOioguiog+iynuiyoOi1tOi1s+i2tOi7jei7jOi/sOi/pui/oui/qui/pVwiXSxbXCJhZGExXCIsXCLov63ov6vov6Tov6jpg4rpg47pg4Hpg4PphYvphYrph43ploLpmZDpmYvpmYzpmY3pnaLpnanpn4vpn63pn7PpoIHpoqjpo5vpo5/pppbpppnkuZjkurPlgIzlgI3lgKPkv6/lgKblgKXkv7jlgKnlgJblgIblgLzlgJ/lgJrlgJLlgJHkv7rlgIDlgJTlgKjkv7HlgKHlgIvlgJnlgJjkv7Pkv67lgK3lgKrkv77lgKvlgInlhbzlhqTlhqXlhqLlh43lh4zlh4blh4vliZbliZzliZTliZvliZ3ljKrljb/ljp/ljp3lj5/lk6jllJDllIHllLflk7zlk6Xlk7LllIblk7rllJTlk6nlk63lk6HllInlk67lk6pcIl0sW1wiYWU0MFwiLFwi5ZOm5ZSn5ZSH5ZO95ZSP5ZyD5ZyE5Z+C5Z+U5Z+L5Z+D5aCJ5aSP5aWX5aWY5aWa5aiR5aiY5aic5aif5aib5aiT5aes5aig5aij5aip5ail5aiM5aiJ5a2r5bGY5a6w5a6z5a625a605a6u5a615a655a645bCE5bGR5bGV5bGQ5bOt5bO95bO75bOq5bOo5bOw5bO25bSB5bO05beu5bit5bir5bqr5bqt5bqn5byx5b6S5b6R5b6Q5oGZXCJdLFtcImFlYTFcIixcIuaBo+aBpeaBkOaBleaBreaBqeaBr+aChOaCn+aCmuaCjeaClOaCjOaCheaCluaJh+aLs+aMiOaLv+aNjuaMvuaMr+aNleaNguaNhuaNj+aNieaMuuaNkOaMveaMquaMq+aMqOaNjeaNjOaViOaVieaWmeaXgeaXheaZguaZieaZj+aZg+aZkuaZjOaZheaZgeabuOaclOacleacl+agoeaguOahiOahhuahk+agueahguahlOagqeais+agl+ahjOahkeagveaftOahkOahgOagvOahg+agquahheagk+agmOahgeauiuauieaut+awo+awp+awqOawpuawpOazsOa1qua2lea2iOa2h+a1pua1uOa1t+a1mea2k1wiXSxbXCJhZjQwXCIsXCLmtazmtonmta7mtZrmtbTmtanmtozmtormtbnmtoXmtaXmtpTng4rng5jng6Tng5nng4jng4/niLnnibnni7zni7nni73ni7jni7fnjobnj63nkInnj67nj6Dnj6rnj57nlZTnlZ3nlZznlZrnlZnnlr7nl4Xnl4fnlrLnlrPnlr3nlrznlrnnl4LnlrjnmovnmrDnm4rnm43nm47nnKnnnJ/nnKDnnKjnn6nnoLDnoKfnoLjnoJ3noLTnoLdcIl0sW1wiYWZhMVwiLFwi56Cl56Ct56Cg56Cf56Cy56WV56WQ56Wg56Wf56WW56We56Wd56WX56Wa56ek56ej56en56ef56em56ep56eY56qE56qI56uZ56yG56yR57KJ57Sh57SX57SL57SK57Sg57Si57SU57SQ57SV57Sa57Sc57SN57SZ57Sb57y6572f576U57+F57+B6ICG6ICY6ICV6ICZ6ICX6IC96IC/6IOx6ISC6IOw6ISF6IOt6IO06ISG6IO46IOz6ISI6IO96ISK6IO86IOv6Iet6Ies6IiA6IiQ6Iiq6Iir6Iio6Iis6Iq76Iyr6I2S6I2U6I2K6Iy46I2Q6I2J6Iy16Iy06I2P6Iyy6Iy56Iy26IyX6I2A6Iyx6Iyo6I2DXCJdLFtcImIwNDBcIixcIuiZlOiaiuiaquiak+iapOiaqeiajOiao+ianOihsOiht+iigeiiguihveihueiomOiokOiojuiojOioleioiuiol+iok+ioluioj+iokeixiOixuuixueiyoeiyoui1t+i6rOi7kui7lOi7j+i+semAgemAhui/t+mAgOi/uui/tOmAg+i/vemAhei/uOmClemDoemDnemDoumFkumFjemFjOmHmOmHnemHl+mHnOmHmemWg+mZoumZo+mZoVwiXSxbXCJiMGExXCIsXCLpmZvpmZ3pmaTpmZjpmZ7pmrvpo6Lppqzpqqjpq5jprKXprLLprLzkub7lgbrlgb3lgZzlgYflgYPlgYzlgZrlgYnlgaXlgbblgY7lgZXlgbXlgbTlgbflgY/lgI/lga/lga3lhZzlhpXlh7Dliarlia/li5Lli5nli5jli5XljJDljI/ljJnljL/ljYDljL7lj4Pmm7zllYbllarllabllYTllZ7llaHllYPllYrllLHllZbllY/llZXllK/llaTllLjllK7llZzllKzllaPllLPllYHllZflnIjlnIvlnInln5/loIXloIrloIbln6Dln6Tln7rloILloLXln7fln7nlpKDlpaLlqLblqYHlqYnlqablqarlqYBcIl0sW1wiYjE0MFwiLFwi5ai85ami5ama5amG5amK5a2w5a+H5a+F5a+E5a+C5a6/5a+G5bCJ5bCI5bCH5bGg5bGc5bGd5bSH5bSG5bSO5bSb5bSW5bSi5bSR5bSp5bSU5bSZ5bSk5bSn5bSX5bei5bi45bi25biz5bi35bq35bq45bq25bq15bq+5by15by35b2X5b2s5b2p5b2r5b6X5b6Z5b6e5b6Y5b6h5b6g5b6c5oG/5oKj5oKJ5oKg5oKo5oOL5oK05oOm5oK9XCJdLFtcImIxYTFcIixcIuaDheaCu+aCteaDnOaCvOaDmOaDleaDhuaDn+aCuOaDmuaDh+aImuaIm+aJiOaOoOaOp+aNsuaOluaOouaOpeaNt+aNp+aOmOaOquaNseaOqeaOieaOg+aOm+aNq+aOqOaOhOaOiOaOmeaOoeaOrOaOkuaOj+aOgOaNu+aNqeaNqOaNuuaVneaVluaVkeaVmeaVl+WVn+aVj+aVmOaVleaVlOaWnOaWm+aWrOaXj+aXi+aXjOaXjuaZneaZmuaZpOaZqOaZpuaZnuabueWLl+acm+aigeair+aiouaik+aiteahv+ahtuaiseaip+ail+aisOaig+ajhOaireaihuaiheailOaineaiqOain+aioeaiguassuauulwiXSxbXCJiMjQwXCIsXCLmr6vmr6zmsKvmto7mtrzmt7Pmt5nmtrLmt6Hmt4zmt6Tmt7vmt7rmuIXmt4fmt4vmtq/mt5Hmtq7mt57mt7nmtrjmt7fmt7Xmt4Xmt5LmuJrmtrXmt5rmt6vmt5jmt6rmt7Hmt67mt6jmt4bmt4Tmtqrmt6zmtr/mt6bng7nnhInnhIrng73ng6/niL3nib3nioHnjJznjJvnjJbnjJPnjJnnjofnkIXnkIrnkIPnkIbnj77nkI3nk6Dnk7ZcIl0sW1wiYjJhMVwiLFwi55O355Sc55Si55Wl55Wm55Wi55Ww55aP55eU55eV55a155eK55eN55qO55uU55uS55ub55y355y+55y855y255y455y656Gr56GD56GO56Wl56Wo56Wt56e756qS56qV56yg56yo56yb56ys56ym56yZ56ye56yu57KS57KX57KV57WG57WD57Wx57Su57S557S857WA57Sw57Sz57WE57Sv57WC57Sy57Sx57y9576e576a57+M57+O57+S6ICc6IGK6IGG6ISv6ISW6ISj6ISr6ISp6ISw6ISk6IiC6Ii16Ii36Ii26Ii56I6O6I6e6I6Y6I246I6i6I6W6I696I6r6I6S6I6K6I6T6I6J6I6g6I236I276I28XCJdLFtcImIzNDBcIixcIuiOhuiOp+iZleW9quibh+ibgOiatuibhOiateibhuibi+iaseiar+ibieihk+iinuiiiOiiq+iikuiiluiijeiii+imk+imj+ioquioneioo+iopeioseioreion+iom+ioouixieixmuiyqeiyrOiyq+iyqOiyquiyp+i1p+i1pui2vui2uui7m+i7n+mAmemAjemAmumAl+mAo+mAn+mAnemAkOmAlemAnumAoOmAj+mAoumAlumAm+mAlFwiXSxbXCJiM2ExXCIsXCLpg6jpg63pg73phZfph47ph7Xph6bph6Pph6fph63ph6nplonpmarpmbXpmbPpmbjpmbDpmbTpmbbpmbfpmazpm4Dpm6rpm6nnq6Dnq5/poILpoIPprZrps6XpubXpub/puqXpurvlgqLlgo3lgoXlgpnlgpHlgoDlgpblgpjlgprmnIDlh7HlibLlibTlibXlianli57li53li5vljZrljqXllbvlloDllqfllbzllorllp3llpjlloLllpzllqrllpTllofllovlloPllrPllq7llp/llL7llrLllprllrvllqzllrHllb7llonllqvllpnlnI3loK/loKrloLTloKTloLDloLHloKHloJ3loKDlo7nlo7rlpaBcIl0sW1wiYjQ0MFwiLFwi5am35aqa5am/5aqS5aqb5aqn5a2z5a2x5a+S5a+M5a+T5a+Q5bCK5bCL5bCx5bWM5bWQ5bS05bWH5be95bmF5bi95bmA5bmD5bm+5buK5buB5buC5buE5by85b2t5b6p5b6q5b6o5oOR5oOh5oKy5oK25oOg5oSc5oSj5oO65oSV5oOw5oO75oO05oWo5oOx5oSO5oO25oSJ5oSA5oSS5oif5omJ5o6j5o6M5o+P5o+A5o+p5o+J5o+G5o+NXCJdLFtcImI0YTFcIixcIuaPkuaPo+aPkOaPoeaPluaPreaPruaNtuaPtOaPquaPm+aRkuaPmuaPueaVnuaVpuaVouaVo+aWkeaWkOaWr+aZruaZsOaZtOaZtuaZr+aakeaZuuaZvuaZt+abvuabv+acn+acneajuuajleajoOajmOajl+akheajn+ajteajruajp+ajueajkuajsuajo+aji+ajjeakjeakkuakjuajieajmualruaju+asvuasuuasveaumOauluauvOavr+awruawr+awrOa4r+a4uOa5lOa4oea4sua5p+a5iua4oOa4pea4o+a4m+a5m+a5mOa4pOa5lua5rua4rea4pua5r+a4tOa5jea4uua4rOa5g+a4nea4vua7i1wiXSxbXCJiNTQwXCIsXCLmuonmuJnmuY7muaPmuYTmubLmuanmuZ/nhJnnhJrnhKbnhLDnhKHnhLbnha7nhJzniYznioTnioDnjLbnjKXnjLTnjKnnkLrnkKrnkLPnkKLnkKXnkLXnkLbnkLTnkK/nkJvnkKbnkKjnlKXnlKbnlavnlarnl6Lnl5vnl6Pnl5nnl5jnl57nl6DnmbvnmbznmpbnmpPnmrTnm5znnY/nn63noZ3noaznoa/nqI3nqIjnqIvnqIXnqIDnqphcIl0sW1wiYjVhMVwiLFwi56qX56qW56ul56uj562J562W562G562Q562S562U562N562L562P562R57Kf57Kl57We57WQ57Wo57WV57Sr57Wu57Wy57Wh57Wm57Wi57Ww57Wz5ZaE57+U57+V6ICL6IGS6IKF6IWV6IWU6IWL6IWR6IWO6IS56IWG6IS+6IWM6IWT6IW06IiS6Iic6I+p6JCD6I+46JCN6I+g6I+F6JCL6I+B6I+v6I+x6I+06JGX6JCK6I+w6JCM6I+M6I+96I+y6I+K6JC46JCO6JCE6I+c6JCH6I+U6I+f6Jmb6Juf6JuZ6Jut6JuU6Jub6Juk6JuQ6Jue6KGX6KOB6KOC6KKx6KaD6KaW6Ki76Kmg6KmV6Kme6Ki86KmBXCJdLFtcImI2NDBcIixcIuiplOipm+ipkOiphuiotOiouuiotuipluixoeiyguiyr+iyvOiys+iyveizgeiyu+izgOiytOiyt+iytuiyv+iyuOi2iui2hei2gei3jui3nei3i+i3mui3kei3jOi3m+i3hui7u+i7uOi7vOi+nOmArumAtemAsemAuOmAsumAtumEgumDtemEiemDvumFo+mFpemHj+mIlOmIlemIo+mIiemInumIjemIkOmIh+mIkemWlOmWj+mWi+mWkVwiXSxbXCJiNmExXCIsXCLplpPplpLplo7pmorpmo7pmovpmb3pmoXpmobpmo3pmbLpmoTpm4Hpm4Xpm4Tpm4bpm4fpm6/pm7Lpn4zpoIXpoIbpoIjpo6fpo6rpo6/po6npo7Lpo63ppq7ppq3pu4Ppu43pu5HkuoLlgq3lgrXlgrLlgrPlg4Xlgr7lgqzlgrflgrvlgq/lg4flib/libflib3li5/li6bli6Tli6Lli6PljK/ll5/ll6jll5Pll6bll47ll5zll4fll5Hll6Pll6Tll6/ll5rll6Hll4Xll4bll6Xll4nlnJLlnJPloZ7loZHloZjloZfloZrloZTloavloYzloa3loYrloaLloZLloYvlpaflq4Hlq4nlq4zlqr7lqr3lqrxcIl0sW1wiYjc0MFwiLFwi5aqz5auC5aqy5bWp5bWv5bmM5bm55buJ5buI5byS5b2Z5b6s5b6u5oSa5oSP5oWI5oSf5oOz5oSb5oO55oSB5oSI5oWO5oWM5oWE5oWN5oS+5oS05oSn5oSN5oSG5oS35oih5oii5pCT5pC+5pCe5pCq5pCt5pC95pCs5pCP5pCc5pCU5pCN5pC25pCW5pCX5pCG5pWs5paf5paw5pqX5pqJ5pqH5pqI5pqW5pqE5pqY5pqN5pyD5qaU5qWtXCJdLFtcImI3YTFcIixcIualmualt+aloOallOalteaksOamgualiualqOalq+alnualk+alueamhualnealo+alm+ath+atsuavgOauv+avk+avvea6oua6r+a7k+a6tua7gua6kOa6nea7h+a7hea6pea6mOa6vOa6uua6q+a7kea6lua6nOa7hOa7lOa6qua6p+a6tOeFjueFmeeFqeeFpOeFieeFp+eFnOeFrOeFpueFjOeFpeeFnueFhueFqOeFlueIuueJkueMt+eNheeMv+eMvueRr+eRmueRleeRn+eRnueRgeeQv+eRmeeRm+eRnOeVtueVuOeYgOeXsOeYgeeXsueXseeXuueXv+eXtOeXs+ebnuebn+edm+edq+edpuednuedo1wiXSxbXCJiODQwXCIsXCLnnbnnnarnnaznnZznnaXnnajnnaLnn67noo7norDnopfnopjnooznoonnobznopHnopPnob/npbrnpb/npoHokKznpr3nqJznqJrnqKDnqJTnqJ/nqJ7nqp/nqqDnrbfnr4DnraDnra7nrafnsrHnsrPnsrXntpPntbnntpHntoHnto/ntZvnva7nvannvarnvbLnvqnnvqjnvqTogZbogZjogobogoTohbHohbDohbjohaXoha7ohbPohatcIl0sW1wiYjhhMVwiLFwi6IW56IW66IWm6IiF6ImH6JKC6JG36JC96JCx6JG16JGm6JGr6JGJ6JGs6JGb6JC86JC16JGh6JGj6JGp6JGt6JGG6Jme6Jmc6Jmf6Ju56JyT6JyI6JyH6JyA6Ju+6Ju76JyC6JyD6JyG6JyK6KGZ6KOf6KOU6KOZ6KOc6KOY6KOd6KOh6KOK6KOV6KOS6Kac6Kej6Kmr6Kmy6Kmz6Kmm6Kmp6Kmw6KqH6Km86Kmj6Kqg6Kmx6KqF6Kmt6Kmi6Kmu6Kms6Km56Km76Ki+6Kmo6LGi6LKK6LKJ6LOK6LOH6LOI6LOE6LKy6LOD6LOC6LOF6Leh6Lef6Leo6Lev6Lez6Le66Leq6Lek6Lem6Lqy6LyD6LyJ6Lu+6LyKXCJdLFtcImI5NDBcIixcIui+n+i+sumBi+mBiumBk+mBgumBlOmAvOmBlemBkOmBh+mBj+mBjumBjemBkemAvumBgemEkumEl+mFrOmFqumFqemHiemIt+mJl+mIuOmIvemJgOmIvumJm+mJi+mJpOmJkemItOmJiemJjemJhemIuemIv+mJmumWmOmamOmalOmalembjembi+mbiembiumbt+mbu+mbuembtumdlumdtOmdtumgkOmgkemgk+mgiumgkumgjOmjvOmjtFwiXSxbXCJiOWExXCIsXCLpo73po77pprPpprHpprTpq6Hps6npuoLpvI7pvJPpvKDlg6flg67lg6Xlg5blg63lg5rlg5Xlg4/lg5Hlg7Hlg47lg6nlhaLlh7PlioPlioLljLHljq3ll77lmIDlmJvlmJfll73lmJTlmIblmInlmI3lmI7ll7flmJblmJ/lmIjlmJDll7blnJjlnJblobXlob7looPlopPloorlobnlooXlob3lo73lpKXlpKLlpKTlparlpanlq6Hlq6blq6nlq5flq5blq5jlq6PlrbXlr57lr6flr6Hlr6Xlr6blr6jlr6Llr6Tlr5/lsI3lsaLltoTltofluZvluaPluZXluZfluZTlu5Plu5blvIrlvYblvbDlvrnmhYdcIl0sW1wiYmE0MFwiLFwi5oS/5oWL5oW35oWi5oWj5oWf5oWa5oWY5oW15oiq5pKH5pGY5pGU5pKk5pG45pGf5pG65pGR5pGn5pC05pGt5pG75pWy5pah5peX5peW5pqi5pqo5pqd5qac5qao5qaV5qeB5qau5qeT5qeL5qab5qa35qa75qar5qa05qeQ5qeN5qat5qeM5qam5qeD5qaj5q2J5q2M5rCz5ryz5ryU5ru+5ryT5ru05ryp5ry+5ryg5rys5ryP5ryC5ryiXCJdLFtcImJhYTFcIixcIua7v+a7r+a8hua8sea8uOa8sua8o+a8lea8q+a8r+a+iOa8qua7rOa8gea7sua7jOa7t+eGlOeGmeeFveeGiueGhOeGkueIvueKkueKlueNhOeNkOeRpOeRo+eRqueRsOeRreeUhOeWkeeYp+eYjeeYi+eYieeYk+eboeebo+eehOedveedv+edoeejgeein+eip+eis+eiqeeio+emjuemj+emjeeorueoseeqqueqqeerreerr+euoeeuleeui+etteeul+euneeulOeuj+euuOeuh+euhOeyueeyveeyvue2u+e2sOe2nOe2vee2vue2oOe3iue2tOe2sue2see2uue2oue2v+e2tee2uOe2ree3kue3h+e2rFwiXSxbXCJiYjQwXCIsXCLnvbDnv6Dnv6Hnv5/ogZ7ogZrogofohZDohoDoho/ohojohorohb/ohoLoh6foh7roiIfoiJToiJ7oiYvok4nokr/ok4bok4Tokpnokp7okrLokpzok4vokrjok4Dok5PokpDokrzok5Hok4ronL/onJzonLvonKLonKXonLTonJjonZXonLfonKnoo7PopILoo7Too7noo7joo73oo6jopJroo6/oqqboqozoqp7oqqPoqo3oqqHoqpPoqqRcIl0sW1wiYmJhMVwiLFwi6Kqq6Kql6Kqo6KqY6KqR6Kqa6Kqn6LGq6LKN6LKM6LOT6LOR6LOS6LWr6LaZ6LaV6Le86LyU6LyS6LyV6LyT6L6j6YGg6YGY6YGc6YGj6YGZ6YGe6YGi6YGd6YGb6YSZ6YSY6YSe6YW16YW46YW36YW06Ym46YqA6YqF6YqY6YqW6Ym76YqT6Yqc6Yqo6Ym86YqR6Zah6Zao6Zap6Zaj6Zal6Zak6ZqZ6Zqc6Zqb6ZuM6ZuS6ZyA6Z286Z6F6Z+26aCX6aCY6aKv6aKx6aSD6aSF6aSM6aSJ6aeB6aqv6aqw6aum6a2B6a2C6bO06bO26bOz6bq86by76b2K5YSE5YSA5YO75YO15YO55YSC5YSI5YSJ5YSF5YecXCJdLFtcImJjNDBcIixcIuWKh+WKiOWKieWKjeWKiuWLsOWOsuWYruWYu+WYueWYsuWYv+WYtOWYqeWZk+WZjuWZl+WZtOWYtuWYr+WYsOWigOWin+WinuWis+WinOWiruWiqeWipuWlreWsieWru+Wsi+WrteWsjOWsiOWvruWvrOWvqeWvq+WxpOWxpeW2neW2lOW5ouW5n+W5oeW7ouW7muW7n+W7neW7o+W7oOW9iOW9seW+t+W+teaFtuaFp+aFruaFneaFleaGglwiXSxbXCJiY2ExXCIsXCLmhbzmhbDmhavmhb7mhqfmhpDmhqvmho7mhqzmhprmhqTmhpTmhq7miK7mkanmka/mkbnmkp7mkrLmkojmkpDmkrDmkqXmkpPmkpXmkqnmkpLmkq7mkq3mkqvmkprmkqzmkpnmkqLmkrPmlbXmlbfmlbjmmq7mmqvmmrTmmrHmqKPmqJ/mp6jmqIHmqJ7mqJnmp73mqKHmqJPmqIrmp7PmqILmqIXmp63mqJHmrZDmrY7mrqTmr4Xmr4bmvL/mvbzmvoTmvZHmvabmvZTmvobmva3mvZvmvbjmva7mvo7mvbrmvbDmvaTmvpfmvZjmu5Xmva/mvaDmvZ/nhp/nhqznhrHnhqjniZbnipvnjY7njZfnkannkovnkoNcIl0sW1wiYmQ0MFwiLFwi55G+55KA55W/55ig55ip55if55ik55im55ih55ii55qa55q655uk556O556H556M556R556L56OL56OF56K656OK56K+56OV56K856OQ56i/56i856mA56i956i356i756qv56qu566t566x56+E566056+G56+H56+B566g56+M57OK57eg57e057ev57e757eY57es57ed57eo57ej57ea57ee57ep57ae57eZ57ey57e557215723576vXCJdLFtcImJkYTFcIixcIue/qeiApuiGm+iGnOiGneiGoOiGmuiGmOiUl+iUveiUmuiTruiUrOiUreiUk+iUkeiUo+iUoeiUlOiTrOiUpeiTv+iUhuieguidtOidtuidoOidpuiduOidqOidmeidl+idjOidk+ihm+ihneikkOikh+ikkuikk+ikleikiuiqvOirkuirh+irhOiqleiri+iruOiqsuirieirguiqv+iqsOirluirjeiqtuiqueirm+ixjOixjuixrOizoOiznuizpuizpOizrOizreizouizo+iznOizquizoei1rei2n+i2o+i4q+i4kOi4nei4oui4j+i4qei4n+i4oei4nui6uui8nei8m+i8n+i8qei8pui8qui8nOi8nlwiXSxbXCJiZTQwXCIsXCLovKXpganpga7pgajpga3pgbfphLDphK3phKfphLHphofphonphovphoPpi4Xpirvpirfpi6rpiqzpi6Tpi4HpirPpirzpi5Lpi4fpi7DpirLplq3plrHpnITpnIbpnIfpnInpnaDpno3pnovpno/poKHpoKvpoJzporPppIrppJPppJLppJjpp53pp5Dpp5/pp5vpp5Hpp5Xpp5Lpp5npqrfpq67pq6/prKfprYXprYTprbfpra/ptIbptIlcIl0sW1wiYmVhMVwiLFwi6bSD6bqp6bq+6buO5aKo6b2S5YSS5YSY5YSU5YSQ5YSV5YaA5Yaq5Yed5YqR5YqT5Yuz5ZmZ5Zmr5Zm55Zmp5Zmk5Zm45Zmq5Zmo5Zml5Zmx5Zmv5Zms5Zmi5Zm25aOB5aK+5aOH5aOF5aWu5ayd5ay05a245a+w5bCO5b2K5oay5oaR5oap5oaK5oeN5oa25oa+5oeK5oeI5oiw5pOF5pOB5pOL5pK75pK85pOa5pOE5pOH5pOC5pON5pK/5pOS5pOU5pK+5pW05puG5puJ5pq55puE5puH5pq45qi95qi45qi65qmZ5qmr5qmY5qi55qmE5qmi5qmh5qmL5qmH5qi15qmf5qmI5q2Z5q235rCF5r+C5r6x5r6hXCJdLFtcImJmNDBcIixcIua/g+a+pOa/gea+p+a+s+a/gOa+uea+tua+pua+oOa+tOeGvueHieeHkOeHkueHiOeHleeGueeHjueHmeeHnOeHg+eHhOeNqOeSnOeSo+eSmOeSn+eSnueToueUjOeUjeeYtOeYuOeYuuebp+ebpeeeoOeenueen+eepeejqOejmuejrOejp+empuepjeepjuephuepjOepi+equuevmeewkeevieevpOevm+evoeevqeevpuezleezlue4ilwiXSxbXCJiZmExXCIsXCLnuJHnuIjnuJvnuKPnuJ7nuJ3nuInnuJDnvbnnvrLnv7Dnv7Hnv67ogKjohrPohqnohqjoh7voiIjoiZjoiZnolYrolZnolYjolajolanolYPolYnola3olarolZ7onoPonp/onp7onqLono3ooaHopKropLLopKXopKvopKHopqropqboq6boq7roq6voq7HorIDoq5zoq6foq67oq77orIHorILoq7foq63oq7Poq7boq7zosavosa3ospPos7TouYTouLHouLTouYLouLnouLXovLvovK/ovLjovLPovqjovqbpgbXpgbTpgbjpgbLpgbzpgbrphLTphpLpjKDpjLbpi7jpjLPpjK/pjKLpi7zpjKvpjITpjJpcIl0sW1wiYzA0MFwiLFwi6YyQ6Yym6Yyh6YyV6Yyu6YyZ6Za76Zqn6Zqo6Zqq6ZuV6ZyO6ZyR6ZyW6ZyN6ZyT6ZyP6Z2b6Z2c6Z2m6Z6Y6aCw6aC46aC76aC36aCt6aC56aCk6aSQ6aSo6aSe6aSb6aSh6aSa6aet6aei6aex6aq46aq86au76aut6ayo6a6R6bSV6bSj6bSm6bSo6bSS6bSb6buY6buU6b6N6b6c5YSq5YSf5YSh5YSy5Yu15ZqO5ZqA5ZqQ5ZqF5ZqHXCJdLFtcImMwYTFcIixcIuWaj+WjleWjk+WjkeWjjuWssOWsquWspOWtuuWwt+WxqOW2vOW2uuW2veW2uOW5q+W9jOW+veaHieaHguaHh+aHpuaHi+aIsuaItOaTjuaTiuaTmOaToOaTsOaTpuaTrOaTseaTouaTreaWguaWg+abmeabluaqgOaqlOaqhOaqouaqnOarm+aqo+apvuaql+aqkOaqoOatnOauruavmuawiOa/mOa/sea/n+a/oOa/m+a/pOa/q+a/r+a+gOa/rOa/oea/qea/lea/rua/sOeHp+eHn+eHrueHpueHpeeHreeHrOeHtOeHoOeIteeJhueNsOeNsueSqeeSsOeSpueSqOeZhueZgueZjOebquees+eequeesOeerFwiXSxbXCJjMTQwXCIsXCLnnqfnnq3nn6/no7fno7rno7Tno6/npIHnpqfnpqrnqZfnqr/nsIfnsI3nr77nr7fnsIznr6Dns6Dns5zns57ns6Lns5/ns5nns53nuK7nuL7nuYbnuLfnuLLnuYPnuKvnuL3nuLHnuYXnuYHnuLTnuLnnuYjnuLXnuL/nuK/nvYTnv7Pnv7zogbHogbLogbDoga/ogbPoh4boh4Pohrroh4Loh4Dohr/ohr3oh4nohr7oh6joiInoibHolqpcIl0sW1wiYzFhMVwiLFwi6JaE6JW+6Jac6JaR6JaU6Jav6Jab6JaH6Jao6JaK6Jmn6J+A6J+R6J6z6J+S6J+G6J6r6J676J666J+I6J+L6KS76KS26KWE6KS46KS96Kas6KyO6KyX6KyZ6Kyb6KyK6Kyg6Kyd6KyE6KyQ6LGB6LC/6LGz6LO66LO96LO86LO46LO76Lao6LmJ6LmL6LmI6LmK6L2E6Ly+6L2C6L2F6Ly/6YG/6YG96YKE6YKB6YKC6YKA6YS56Yaj6Yae6Yac6Y2N6Y6C6Yyo6Y216Y2K6Y2l6Y2L6YyY6Y2+6Y2s6Y2b6Y2w6Y2a6Y2U6ZeK6ZeL6ZeM6ZeI6ZeG6Zqx6Zq46ZuW6Zyc6Zye6Z6g6Z+T6aGG6aK26aS16aiBXCJdLFtcImMyNDBcIixcIumnv+murumuq+muqumurem0u+m0v+m6i+m7j+m7num7nOm7nem7m+m8vum9i+WPouWaleWaruWjmeWjmOWsuOW9neaHo+aIs+aTtOaTsuaTvuaUhuaTuuaTu+aTt+aWt+abnOacpuaqs+aqrOarg+aqu+aquOarguaqruaqr+atn+atuOaur+eAieeAi+a/vueAhua/uueAkeeAj+eHu+eHvOeHvueHuOeNt+eNteeSp+eSv+eUleeZlueZmFwiXSxbXCJjMmExXCIsXCLnmZLnnr3nnr/nnrvnnrznpI7npq7nqaHnqaLnqaDnq4Tnq4XnsKvnsKfnsKrnsJ7nsKPnsKHns6fnuZTnuZXnuZ7nuZrnuaHnuZLnuZnnvYjnv7nnv7vogbfogbboh43oh4/oiIrol4/olqnol43ol5Dol4nolrDolrrolrnolqbon6/on6zon7Lon6DopoboprLop7TorKjorLnorKzorKvosZDotIXouZnouaPouabouaTouZ/ouZXou4DovYnovY3pgofpgoPpgojphqvphqzph5DpjpTpjorpjpbpjqLpjrPpjq7pjqzpjrDpjpjpjprpjpfpl5Tpl5bpl5Dpl5Xpm6Lpm5zpm5npm5vpm57pnKTpnqPpnqZcIl0sW1wiYzM0MFwiLFwi6Z6t6Z+56aGN6aGP6aGM6aGO6aGT6aK66aS+6aS/6aS96aSu6aal6aiO6auB6ayD6ayG6a2P6a2O6a2N6a+K6a+J6a+96a+I6a+A6bWR6bWd6bWg6bug6byV6bys5YSz5Zql5aOe5aOf5aOi5a+16b6Q5bus5oey5oe35oe25oe15pSA5pSP5pug5pud5qul5qud5qua5quT54Cb54Cf54Co54Ca54Cd54CV54CY54iG54iN54mY54qi5424XCJdLFtcImMzYTFcIixcIueNuueSveeTiueTo+eWh+eWhueZn+eZoeefh+ekmeemseepq+epqeewvuewv+ewuOewveewt+exgOe5q+e5ree5uee5qee5que+hee5s+e+tue+uee+uOiHmOiXqeiXneiXquiXleiXpOiXpeiXt+ifu+igheigjeifueifvuiloOiln+illuilnuitgeitnOitmOitieitmuitjuitj+ithuitmei0iOi0iui5vOi5sui6h+i5tui5rOi5uui5tOi9lOi9jui+remCiumCi+mGsemGrumPoemPkemPn+mPg+mPiOmPnOmPnemPlumPoumPjemPmOmPpOmPl+mPqOmXnOmatOmbo+mcqumcp+mdoemfnOmfu+mhnlwiXSxbXCJjNDQwXCIsXCLpoZjpoZvporzppYXppYnpqJbpqJnprI3pr6jpr6fpr5bpr5vptonptaHptbLptarptazpupLpupfpupPpurTli7jlmqjlmrflmrblmrTlmrzlo6TlrYDlrYPlrb3lr7blt4nmh7jmh7rmlJjmlJTmlJnmm6bmnKfmq6zngL7ngLDngLLniJDnjbvnk4/nmaLnmaXnpKbnpKrnpKznpKvnq4fnq7bnsYznsYPnsY3ns6/ns7Dovq7nub3nubxcIl0sW1wiYzRhMVwiLFwi57qC572M6ICA6Iea6Imm6Je76Je56JiR6Je66JiG6JiL6JiH6JiK6KCU6KCV6KWk6Ka66Ke46K2w6K2s6K2m6K2v6K2f6K2r6LSP6LSN6LqJ6LqB6LqF6LqC6Ya06YeL6ZCY6ZCD6Y+96Zeh6Zyw6aOE6aWS6aWR6aao6air6aiw6ai36ai16bCT6bCN6bm56bq16buo6byv6b2f6b2j6b2h5YS35YS45ZuB5ZuA5ZuC5aSU5bGs5beN5oe85oe+5pSd5pSc5paV5pup5qu75qyE5qu65q6y54GM54ib54qn55OW55OU55mp55+T57GQ57qP57qM57686JiX6Jit6Jia6KCj6KCi6KCh6KCf6KWq6KWs6Ka96K20XCJdLFtcImM1NDBcIixcIuitt+itvei0k+i6iui6jei6i+i9n+i+r+mGuumQrumQs+mQtemQuumQuOmQsumQq+mXoumcuOmcuemcsumfv+mhp+mhpemll+mphempg+mpgOmovumrj+mtlOmtkemwremwpem2r+m2tOm3gum2uOm6nem7r+m8mem9nOm9pum9p+WEvOWEu+WbiOWbiuWbieWtv+W3lOW3kuW9juaHv+aUpOasiuatoeeBkeeBmOeOgOeTpOeWiueZrueZrFwiXSxbXCJjNWExXCIsXCLnprPnsaDnsZ/ogb7ogb3oh5/opbLopa/op7zoroDotJbotJfoupHoupPovaHphYjpkYTpkZHpkZLpnL3pnL7pn4Ppn4HpoavppZXpqZXpqY3pq5LprJrpsYnpsLHpsL7psLvpt5Ppt5fpvLTpvazpvarpvpTlm4zlt5bmiIDmlKPmlKvmlKrmm6zmrJDnk5rnq4rnsaTnsaPnsaXnupPnupbnupToh6LomLjomL/ooLHororpgpDpgo/pkaPpkaDpkaTpnajpoa/ppZzpqZrpqZvpqZfpq5Ppq5Tpq5HpsZTpsZfpsZbpt6Xpup/pu7Tlm5Hlo6nmlKzngZ7nmbHnmbLnn5fnvZDnvojooLbooLnooaLorpPorpJcIl0sW1wiYzY0MFwiLFwi6K6W6Im36LSb6YeA6ZGq6Z2C6Z2I6Z2E6Z+G6aGw6amf6ayi6a2Y6bGf6be56be66bm86bm96byH6b236b2y5buz5qyW54Gj57Gs57Gu6KC76KeA6Lqh6YeB6ZGy6ZGw6aGx6aWe6auW6ayj6buM54Gk55+a6K6a6ZG36Z+J6ami6aml57qc6K6c6Lqq6YeF6ZG96ZG+6ZG86bG36bG46bu36LGU6ZG/6bia54io6amq6ayx6bib6bie57GyXCJdLFtcImM5NDBcIixcIuS5guS5nOWHteWMmuWOguS4h+S4jOS5h+S6jeWbl++ojOWxruW9s+S4j+WGh+S4juS4ruS6k+S7guS7ieS7iOWGmOWLvOWNrOWOueWcoOWkg+WkrOWwkOW3v+aXoeaus+avjOawlOeIv+S4seS4vOS7qOS7nOS7qeS7oeS7neS7muWIjOWMnOWNjOWcouWco+Wkl+Wkr+WugeWuhOWwkuWwu+WxtOWxs+W4hOW6gOW6guW/ieaIieaJkOawlVwiXSxbXCJjOWExXCIsXCLmsLbmsYPmsL/msLvniq7nirDnjornprjogorpmJ7kvI7kvJjkvKzku7XkvJTku7HkvIDku7fkvIjkvJ3kvILkvIXkvKLkvJPkvITku7TkvJLlhrHliJPliInliJDliqbljKLljJ/ljY3ljorlkIflm6Hlm5/lnK7lnKrlnLTlpLzlpoDlpbzlpoXlpbvlpb7lpbflpb/lrZblsJXlsKXlsbzlsbrlsbvlsb7lt5/lubXluoTlvILlvJrlvbTlv5Xlv5Tlv4/miZzmiZ7miaTmiaHmiabmiaLmiZnmiaDmiZrmiaXml6/ml67mnL7mnLnmnLjmnLvmnLrmnL/mnLzmnLPmsJjmsYbmsZLmsZzmsY/msYrmsZTmsYtcIl0sW1wiY2E0MFwiLFwi5rGM54Gx54me54q054q1546O55Sq55m/56m1572R6Im46Im86IqA6Im96Im/6JmN6KW+6YKZ6YKX6YKY6YKb6YKU6Zii6Zik6Zig6Zij5L2W5Ly75L2i5L2J5L2T5L2k5Ly+5L2n5L2S5L2f5L2B5L2Y5Lyt5Lyz5Ly/5L2h5YaP5Ya55Yic5Yie5Yih5Yqt5Yqu5YyJ5Y2j5Y2y5Y6O5Y6P5ZCw5ZC35ZCq5ZGU5ZGF5ZCZ5ZCc5ZCl5ZCYXCJdLFtcImNhYTFcIixcIuWQveWRj+WRgeWQqOWQpOWRh+WbruWbp+WbpeWdgeWdheWdjOWdieWdi+WdkuWkhuWlgOWmpuWmmOWmoOWml+WmjuWmouWmkOWmj+Wmp+WmoeWujuWukuWwqOWwquWyjeWyj+WyiOWyi+WyieWykuWyiuWyhuWyk+WyleW3oOW4iuW4juW6i+W6ieW6jOW6iOW6jeW8heW8neW9uOW9tuW/kuW/keW/kOW/reW/qOW/ruW/s+W/oeW/pOW/o+W/uuW/r+W/t+W/u+aAgOW/tOaIuuaKg+aKjOaKjuaKj+aKlOaKh+aJseaJu+aJuuaJsOaKgeaKiOaJt+aJveaJsuaJtOaUt+aXsOaXtOaXs+aXsuaXteadheadh1wiXSxbXCJjYjQwXCIsXCLmnZnmnZXmnYzmnYjmnZ3mnY3mnZrmnYvmr5DmsJnmsJrmsbjmsafmsavmsoTmsovmso/msbHmsa/msanmsprmsa3msofmspXmspzmsabmsbPmsaXmsbvmso7ngbTngbrniaPnir/nir3ni4Pni4bni4Hnirrni4XnjpXnjpfnjpPnjpTnjpLnlLrnlLnnlpTnlpXnmoHnpL3ogLTogpXogpnogpDogpLogpzoipDoio/oioXoio7oipHoipNcIl0sW1wiY2JhMVwiLFwi6IqK6IqD6IqE6LG46L+J6L6/6YKf6YKh6YKl6YKe6YKn6YKg6Ziw6Zio6Ziv6Zit5Liz5L6Y5L285L6F5L295L6A5L6H5L225L205L6J5L6E5L235L2M5L6X5L2q5L6a5L255L6B5L245L6Q5L6c5L6U5L6e5L6S5L6C5L6V5L2r5L2u5Yae5Ya85Ya+5Yi15Yiy5Yiz5YmG5Yix5Yq85YyK5YyL5Yy85Y6S5Y6U5ZKH5ZG/5ZKB5ZKR5ZKC5ZKI5ZGr5ZG65ZG+5ZGl5ZGs5ZG05ZGm5ZKN5ZGv5ZGh5ZGg5ZKY5ZGj5ZGn5ZGk5Zu35Zu55Z2v5Z2y5Z2t5Z2r5Z2x5Z2w5Z225Z6A5Z215Z275Z2z5Z205Z2iXCJdLFtcImNjNDBcIixcIuWdqOWdveWkjOWlheWmteWmuuWnj+WnjuWmsuWnjOWngeWmtuWmvOWng+WnluWmseWmveWngOWniOWmtOWnh+WtouWtpeWuk+WuleWxhOWxh+WyruWypOWyoOWyteWyr+WyqOWyrOWyn+Wyo+WyreWyouWyquWyp+WyneWypeWytuWysOWypuW4l+W4lOW4meW8qOW8ouW8o+W8pOW9lOW+guW9vuW9veW/nuW/peaAreaApuaAmeaAsuaAi1wiXSxbXCJjY2ExXCIsXCLmgLTmgIrmgJfmgLPmgJrmgJ7mgKzmgKLmgI3mgJDmgK7mgJPmgJHmgIzmgInmgJzmiJTmiL3miq3mirTmi5Hmir7miqrmirbmi4rmiq7mirPmiq/mirvmiqnmirDmirjmlL3mlqjmlrvmmInml7zmmITmmJLmmIjml7vmmIPmmIvmmI3mmIXml73mmJHmmJDmm7bmnIrmnoXmnazmno7mnpLmnbbmnbvmnpjmnobmnoTmnbTmno3mnozmnbrmnp/mnpHmnpnmnoPmnb3mnoHmnbjmnbnmnpTmrKXmroDmrb7mr57msJ3mspPms6zms6vms67ms5nmsrbms5Tmsq3ms6fmsrfms5Dms4Lmsrrms4Pms4bms63ms7JcIl0sW1wiY2Q0MFwiLFwi5rOS5rOd5rK05rKK5rKd5rKA5rOe5rOA5rSw5rON5rOH5rKw5rO55rOP5rOp5rOR54KU54KY54KF54KT54KG54KE54KR54KW54KC54Ka54KD54mq54uW54uL54uY54uJ54uc54uS54uU54ua54uM54uR546k546h546t546m546i546g546s546d55Od55Oo55S/55WA55S+55aM55aY55qv55uz55ux55uw55u155+455+855+555+755+6XCJdLFtcImNkYTFcIixcIueft+elguekv+enheepuOepu+eru+exteezveiAteiCj+iCruiCo+iCuOiCteiCreiIoOiKoOiLgOiKq+iKmuiKmOiKm+iKteiKp+iKruiKvOiKnuiKuuiKtOiKqOiKoeiKqeiLguiKpOiLg+iKtuiKouiZsOiZr+iZreiZruixlui/kui/i+i/k+i/jei/lui/lei/l+mCsumCtOmCr+mCs+mCsOmYuemYvemYvOmYuumZg+S/jeS/heS/k+S+suS/ieS/i+S/geS/lOS/nOS/meS+u+S+s+S/m+S/h+S/luS+uuS/gOS+ueS/rOWJhOWJieWLgOWLguWMveWNvOWOl+WOluWOmeWOmOWSuuWSoeWSreWSpeWTj1wiXSxbXCJjZTQwXCIsXCLlk4PojI3lkrflkq7lk5blkrblk4Xlk4blkqDlkbDlkrzlkqLlkr7lkbLlk57lkrDlnrXlnp7lnp/lnqTlnozlnpflnp3lnpvlnpTlnpjlno/lnpnlnqXlnprlnpXlo7TlpI3lpZPlp6Hlp57lp67lqIDlp7Hlp53lp7rlp73lp7zlp7blp6Tlp7Llp7flp5vlp6nlp7Plp7Xlp6Dlp77lp7Tlp63lrqjlsYzls5Dls5jls4zls5fls4vls5tcIl0sW1wiY2VhMVwiLFwi5bOe5bOa5bOJ5bOH5bOK5bOW5bOT5bOU5bOP5bOI5bOG5bOO5bOf5bO45be55bih5bii5bij5big5bik5bqw5bqk5bqi5bqb5bqj5bql5byH5byu5b2W5b6G5oC35oC55oGU5oGy5oGe5oGF5oGT5oGH5oGJ5oGb5oGM5oGA5oGC5oGf5oCk5oGE5oGY5oGm5oGu5omC5omD5ouP5oyN5oyL5ou15oyO5oyD5our5ou55oyP5oyM5ou45ou25oyA5oyT5oyU5ou65oyV5ou75ouw5pWB5pWD5paq5pa/5pi25pih5piy5pi15pic5pim5pii5piz5pir5pi65pid5pi05pi55piu5pyP5pyQ5p+B5p+y5p+I5p66XCJdLFtcImNmNDBcIixcIuafnOaeu+afuOafmOafgOaet+afheafq+afpOafn+aeteafjeaes+aft+aftuafruafo+afguaeueafjuafp+afsOaesuafvOafhuafreafjOaeruafpuafm+afuuafieafiuafg+afquafi+asqOauguauhOautuavluavmOavoOawoOawoea0qOa0tOa0rea0n+a0vOa0v+a0kua0iuazmua0s+a0hOa0mea0uua0mua0kea0gOa0nea1glwiXSxbXCJjZmExXCIsXCLmtIHmtJjmtLfmtIPmtI/mtYDmtIfmtKDmtKzmtIjmtKLmtInmtJDngrfngp/ngr7ngrHngrDngqHngrTngrXngqnniYHniYnniYrniaznibDnibPnia7ni4rni6Tni6jni6vni5/ni6rni6bni6PnjoXnj4znj4Lnj4jnj4XnjrnnjrbnjrXnjrTnj6vnjr/nj4fnjr7nj4Pnj4bnjrjnj4vnk6znk67nlK7nlYfnlYjnlqfnlqrnmbnnm4TnnIjnnIPnnITnnIXnnIrnm7fnm7vnm7rnn6fnn6jnoIbnoJHnoJLnoIXnoJDnoI/noI7noInnoIPnoJPnpYrnpYznpYvnpYXnpYTnp5Xnp43np4/np5bnp47nqoBcIl0sW1wiZDA0MFwiLFwi56m+56uR56yA56yB57G657G457G557G/57KA57KB57SD57SI57SB572Y576R576N576+6ICH6ICO6ICP6ICU6IC36IOY6IOH6IOg6IOR6IOI6IOC6IOQ6IOF6IOj6IOZ6IOc6IOK6IOV6IOJ6IOP6IOX6IOm6ION6Ie/6Iih6IqU6IuZ6Iu+6Iu56IyH6Iuo6IyA6IuV6Iy66Iur6IuW6Iu06Ius6Iuh6Iuy6Iu16IyM6Iu76Iu26Iuw6IuqXCJdLFtcImQwYTFcIixcIuiLpOiLoOiLuuiLs+iLreiZt+iZtOiZvOiZs+ihgeihjuihp+ihquihqeink+iohOioh+i1sui/o+i/oei/rui/oOmDsemCvemCv+mDlemDhemCvumDh+mDi+mDiOmHlOmHk+mZlOmZj+mZkemZk+mZiumZjuWAnuWAheWAh+WAk+WAouWAsOWAm+S/teS/tOWAs+WAt+WArOS/tuS/t+WAl+WAnOWAoOWAp+WAteWAr+WAseWAjuWFmuWGlOWGk+WHiuWHhOWHheWHiOWHjuWJoeWJmuWJkuWJnuWJn+WJleWJouWLjeWMjuWOnuWUpuWTouWUl+WUkuWTp+WTs+WTpOWUmuWTv+WUhOWUiOWTq+WUkeWUheWTsVwiXSxbXCJkMTQwXCIsXCLllIrlk7vlk7flk7jlk6DllI7llIPllIvlnIHlnILln4zloLLln5Xln5Llnrrln4blnr3lnrzlnrjlnrblnr/ln4fln5Dlnrnln4HlpI7lpYrlqJnlqJblqK3lqK7lqJXlqI/lqJflqIrlqJ7lqLPlrazlrqflrq3lrqzlsIPlsZblsZTls6zls7/ls67ls7Hls7fltIDls7nluKnluKjluqjluq7luqrluqzlvLPlvLDlvafmgZ3mgZrmgadcIl0sW1wiZDFhMVwiLFwi5oGB5oKi5oKI5oKA5oKS5oKB5oKd5oKD5oKV5oKb5oKX5oKH5oKc5oKO5oiZ5omG5ouy5oyQ5o2W5oys5o2E5o2F5oy25o2D5o+k5oy55o2L5o2K5oy85oyp5o2B5oy05o2Y5o2U5o2Z5oyt5o2H5oyz5o2a5o2R5oy45o2X5o2A5o2I5pWK5pWG5peG5peD5peE5peC5pmK5pmf5pmH5pmR5pyS5pyT5qCf5qCa5qGJ5qCy5qCz5qC75qGL5qGP5qCW5qCx5qCc5qC15qCr5qCt5qCv5qGO5qGE5qC05qCd5qCS5qCU5qCm5qCo5qCu5qGN5qC65qCl5qCg5qys5qyv5qyt5qyx5qy05q2t6IKC5q6I5q+m5q+kXCJdLFtcImQyNDBcIixcIuavqOavo+avouavp+awpea1uua1o+a1pOa1tua0jea1oea2kua1mOa1oua1rea1r+a2kea2jea3r+a1v+a2hua1nua1p+a1oOa2l+a1sOa1vOa1n+a2gua2mOa0r+a1qOa2i+a1vua2gOa2hOa0lua2g+a1u+a1vea1tea2kOeDnOeDk+eDkeeDneeDi+e8ueeDoueDl+eDkueDnueDoOeDlOeDjeeDheeDhueDh+eDmueDjueDoeeJgueJuFwiXSxbXCJkMmExXCIsXCLnibfnibbnjIDni7rni7Tni77ni7bni7Pni7vnjIHnj5Pnj5nnj6Xnj5bnjrznj6fnj6Pnj6nnj5znj5Lnj5vnj5Tnj53nj5rnj5fnj5jnj6jnk57nk5/nk7Tnk7XnlKHnlZvnlZ/nlrDnl4Hnlrvnl4Tnl4Dnlr/nlrbnlrrnmornm4nnnJ3nnJvnnJDnnJPnnJLnnKPnnJHnnJXnnJnnnJrnnKLnnKfnoKPnoKznoKLnoLXnoK/noKjnoK7noKvnoKHnoKnnoLPnoKrnoLHnpZTnpZvnpY/npZznpZPnpZLnpZHnp6vnp6znp6Dnp67np63np6rnp5znp57np53nqobnqonnqoXnqovnqoznqornqofnq5jnrJBcIl0sW1wiZDM0MFwiLFwi56yE56yT56yF56yP56yI56yK56yO56yJ56yS57KE57KR57KK57KM57KI57KN57KF57Se57Sd57SR57SO57SY57SW57ST57Sf57SS57SP57SM572c572h572e572g572d572b576W576S57+D57+C57+A6ICW6IC+6IC56IO66IOy6IO56IO16ISB6IO76ISA6IiB6Iiv6Iil6Iyz6Iyt6I2E6IyZ6I2R6Iyl6I2W6Iy/6I2B6Iym6Iyc6IyiXCJdLFtcImQzYTFcIixcIuiNguiNjuiMm+iMquiMiOiMvOiNjeiMluiMpOiMoOiMt+iMr+iMqeiNh+iNheiNjOiNk+iMnuiMrOiNi+iMp+iNiOiZk+iZkuiaouiaqOialuiajeiakeianuiah+ial+iahuiai+iamuiaheiapeiameiaoeiap+ialeiamOiajuianeiakOialOihg+ihhOihreihteihtuihsuiigOihseihv+ihr+iig+ihvuihtOihvOiokuixh+ixl+ixu+iypOiyo+i1tui1uOi2tei2t+i2tui7kei7k+i/vui/temAgui/v+i/u+mAhOi/vOi/tumDlumDoOmDmemDmumDo+mDn+mDpemDmOmDm+mDl+mDnOmDpOmFkFwiXSxbXCJkNDQwXCIsXCLphY7phY/ph5Xph6Lph5rpmZzpmZ/pmrzpo6Ppq5/prK/kub/lgbDlgarlgaHlgZ7lgaDlgZPlgYvlgZ3lgbLlgYjlgY3lgYHlgZvlgYrlgaLlgJXlgYXlgZ/lganlgavlgaPlgaTlgYblgYDlga7lgbPlgZflgZHlh5Dliavlia3liazlia7li5bli5PljK3ljpzllbXllbbllLzllY3llZDllLTllKrllZHllaLllLbllLXllLDllZLllYVcIl0sW1wiZDRhMVwiLFwi5ZSM5ZSy5ZWl5ZWO5ZS55ZWI5ZSt5ZS75ZWA5ZWL5ZyK5ZyH5Z+75aCU5Z+i5Z+25Z+c5Z+05aCA5Z+t5Z+95aCI5Z+45aCL5Z+z5Z+P5aCH5Z+u5Z+j5Z+y5Z+l5Z+s5Z+h5aCO5Z+85aCQ5Z+n5aCB5aCM5Z+x5Z+p5Z+w5aCN5aCE5aWc5amg5amY5amV5amn5ame5ai45ai15amt5amQ5amf5aml5ams5amT5amk5amX5amD5amd5amS5amE5amb5amI5aqO5ai+5amN5ai55amM5amw5amp5amH5amR5amW5amC5amc5a2y5a2u5a+B5a+A5bGZ5bSe5bSL5bSd5bSa5bSg5bSM5bSo5bSN5bSm5bSl5bSPXCJdLFtcImQ1NDBcIixcIuW0sOW0kuW0o+W0n+W0ruW4vuW4tOW6seW6tOW6ueW6suW6s+W8tuW8uOW+m+W+luW+n+aCiuaCkOaChuaCvuaCsOaCuuaDk+aDlOaDj+aDpOaDmeaDneaDiOaCseaDm+aCt+aDiuaCv+aDg+aDjeaDgOaMsuaNpeaOiuaOguaNveaOveaOnuaOreaOneaOl+aOq+aOjuaNr+aOh+aOkOaNruaOr+aNteaOnOaNreaOruaNvOaOpOaMu+aOn1wiXSxbXCJkNWExXCIsXCLmjbjmjoXmjoHmjpHmjo3mjbDmlZPml43mmaXmmaHmmZvmmZnmmZzmmaLmnJjmobnmoofmopDmopzmoa3moa7moq7moqvmpZbmoa/moqPmoqzmoqnmobXmobTmorLmoo/mobfmopLmobzmoavmobLmoqrmooDmobHmob7mopvmopbmoovmoqDmoonmoqTmobjmobvmopHmoozmoormob3mrLbmrLPmrLfmrLjmrpHmro/mro3mro7mrozmsKrmt4DmtqvmtrTmtrPmubTmtqzmt6nmt6Lmtrfmt7bmt5TmuIDmt4jmt6Dmt5/mt5bmtr7mt6Xmt5zmt53mt5vmt7Tmt4rmtr3mt63mt7Dmtrrmt5Xmt4Lmt4/mt4lcIl0sW1wiZDY0MFwiLFwi5reQ5rey5reT5re95reX5reN5rej5ra754O654SN54O354SX54O054SM54Ow54SE54Oz54SQ54O854O/54SG54ST54SA54O454O254SL54SC54SO54m+54m754m854m/54yd54yX54yH54yR54yY54yK54yI54u/54yP54ye546I54+254+454+155CE55CB54+955CH55CA54+654+854+/55CM55CL54+055CI55Wk55Wj55eO55eS55ePXCJdLFtcImQ2YTFcIixcIueXi+eXjOeXkeeXkOeaj+eaieebk+ecueecr+ecreecseecsuectOecs+ecveecpeecu+ecteehiOehkuehieehjeehiuehjOegpuehheehkOelpOelp+elqeelquelo+elq+eloeemu+enuuenuOentuent+eqj+eqlOeqkOesteeth+estOespeessOesouespOess+esmOesquesneesseesq+esreesr+essuesuOesmueso+eylOeymOeylueyo+e0tee0vee0uOe0tue0uue1hee0rOe0qee1gee1h+e0vue0v+e1iue0u+e0qOe9o+e+lee+nOe+nee+m+e/iue/i+e/jee/kOe/kee/h+e/j+e/ieiAn1wiXSxbXCJkNzQwXCIsXCLogJ7ogJvogYfogYPogYjohJjohKXohJnohJvohK3ohJ/ohKzohJ7ohKHohJXohKfohJ3ohKLoiJHoiLjoiLPoiLroiLToiLLoibTojpDojqPojqjojo3ojbrojbPojqTojbTojo/ojoHojpXojpnojbXojpTojqnojb3ojoPojozojp3ojpvojqrojovojb7ojqXojq/ojojojpfojrDojb/ojqbojofojq7ojbbojpromZnomZbomr/omrdcIl0sW1wiZDdhMVwiLFwi6JuC6JuB6JuF6Jq66Jqw6JuI6Jq56Jqz6Jq46JuM6Jq06Jq76Jq86JuD6Jq96Jq+6KGS6KKJ6KKV6KKo6KKi6KKq6KKa6KKR6KKh6KKf6KKY6KKn6KKZ6KKb6KKX6KKk6KKs6KKM6KKT6KKO6KaC6KeW6KeZ6KeV6Kiw6Kin6Kis6Kie6LC56LC76LGc6LGd6LG96LKl6LW96LW76LW56La86LeC6La56La/6LeB6LuY6Lue6Lud6Luc6LuX6Lug6Luh6YCk6YCL6YCR6YCc6YCM6YCh6YOv6YOq6YOw6YO06YOy6YOz6YOU6YOr6YOs6YOp6YWW6YWY6YWa6YWT6YWV6Yes6Ye06Yex6Yez6Ye46Yek6Ye56YeqXCJdLFtcImQ4NDBcIixcIumHq+mHt+mHqOmHrumVuumWhumWiOmZvOmZremZq+mZsemZr+mav+mdqumghOmjpemml+WCm+WCleWClOWCnuWCi+WCo+WCg+WCjOWCjuWCneWBqOWCnOWCkuWCguWCh+WFn+WHlOWMkuWMkeWOpOWOp+WWkeWWqOWWpeWWreWVt+WZheWWouWWk+WWiOWWj+WWteWWgeWWo+WWkuWWpOWVveWWjOWWpuWVv+WWleWWoeWWjuWcjOWgqeWgt1wiXSxbXCJkOGExXCIsXCLloJnloJ7loKfloKPloKjln7XloYjloKXloJzloJvloLPloL/loLbloK7loLnloLjloK3loKzloLvlpaHlqq/lqpTlqp/lqbrlqqLlqp7lqbjlqqblqbzlqqXlqqzlqpXlqq7lqLflqoTlqorlqpflqoPlqovlqqnlqbvlqb3lqozlqpzlqo/lqpPlqp3lr6rlr43lr4vlr5Tlr5Hlr4rlr47lsIzlsLDltLfltYPltavltYHltYvltL/ltLXltZHltY7ltZXltLPltLrltZLltL3ltLHltZnltYLltLnltYnltLjltLzltLLltLbltYDltYXluYTluYHlvZjlvqblvqXlvqvmg4nmgrnmg4zmg6Lmg47mg4TmhJRcIl0sW1wiZDk0MFwiLFwi5oOy5oSK5oSW5oSF5oO15oST5oO45oO85oO+5oOB5oSD5oSY5oSd5oSQ5oO/5oSE5oSL5omK5o6U5o6x5o6w5o+O5o+l5o+o5o+v5o+D5pKd5o+z5o+K5o+g5o+25o+V5o+y5o+15pGh5o+f5o6+5o+d5o+c5o+E5o+Y5o+T5o+C5o+H5o+M5o+L5o+I5o+w5o+X5o+Z5pSy5pWn5pWq5pWk5pWc5pWo5pWl5paM5pad5pae5pau5peQ5peSXCJdLFtcImQ5YTFcIixcIuaZvOaZrOaZu+aagOaZseaZueaZquaZsuacgeakjOajk+akhOajnOakquajrOajquajseakj+ajluajt+ajq+ajpOajtuakk+akkOajs+ajoeakh+ajjOakiOalsOaitOakkeajr+ajhuaklOajuOajkOajveajvOajqOaki+akiuakl+ajjuajiOajneajnuajpuajtOajkeakhuajlOajqeakleakpeajh+asueasu+asv+asvOaulOaul+aumeauleauveavsOavsuavs+awsOa3vOa5hua5h+a4n+a5iea6iOa4vOa4vea5hea5oua4q+a4v+a5gea5nea5s+a4nOa4s+a5i+a5gOa5kea4u+a4g+a4rua5nlwiXSxbXCJkYTQwXCIsXCLmuajmuZzmuaHmuLHmuKjmuaDmubHmuavmuLnmuKLmuLDmuZPmuaXmuKfmubjmuaTmubfmuZXmubnmuZLmuabmuLXmuLbmuZrnhKDnhJ7nhK/ng7vnhK7nhLHnhKPnhKXnhKLnhLLnhJ/nhKjnhLrnhJvniYvniZrniojnionniobnioXniovnjJLnjIvnjLDnjKLnjLHnjLPnjKfnjLLnjK3njKbnjKPnjLXnjIznkK7nkKznkLDnkKvnkJZcIl0sW1wiZGFhMVwiLFwi55Ca55Ch55Ct55Cx55Ck55Cj55Cd55Cp55Cg55Cy55O755Sv55Wv55Ws55en55ea55eh55em55ed55ef55ek55eX55qV55qS55ua552G552H552E552N552F552K552O552L552M55+e55+s56Gg56Gk56Gl56Gc56Gt56Gx56Gq56Gu56Gw56Gp56Go56Ge56Gi56W056Wz56Wy56Ww56iC56iK56iD56iM56iE56qZ56um56uk562K56y7562E562I562M562O562A562Y562F57Ki57Ke57Ko57Kh57WY57Wv57Wj57WT57WW57Wn57Wq57WP57Wt57Wc57Wr57WS57WU57Wp57WR57Wf57WO57y+57y/572lXCJdLFtcImRiNDBcIixcIue9pue+oue+oOe+oee/l+iBkeiBj+iBkOiDvuiDlOiFg+iFiuiFkuiFj+iFh+iEveiFjeiEuuiHpuiHruiHt+iHuOiHueiIhOiIvOiIveiIv+iJteiMu+iPj+iPueiQo+iPgOiPqOiQkuiPp+iPpOiPvOiPtuiQkOiPhuiPiOiPq+iPo+iOv+iQgeiPneiPpeiPmOiPv+iPoeiPi+iPjuiPluiPteiPieiQieiQj+iPnuiQkeiQhuiPguiPs1wiXSxbXCJkYmExXCIsXCLoj5Xoj7roj4foj5Hoj6rokJPoj4Poj6zoj67oj4Toj7voj5foj6LokJvoj5voj77om5jom6Lom6bom5Pom6Pom5rom6rom53om6vom5zom6zom6nom5fom6jom5HooYjooZbooZXoorroo5foornoorjoo4Door7oorboorzoorfoor3oorLopIHoo4noppXoppjoppfop53op5rop5voqY7oqY3oqLnoqZnoqYDoqZfoqZjoqYToqYXoqZLoqYjoqZHoqYroqYzoqY/osZ/osoHosoDosrrosr7osrDosrnosrXotoTotoDotonot5jot5Pot43ot4fot5bot5zot4/ot5Xot5not4jot5fot4Xou6/ou7fou7pcIl0sW1wiZGM0MFwiLFwi6Lu56Lum6Luu6Lul6Lu16Lun6Luo6Lu26Lur6Lux6Lus6Lu06Lup6YCt6YC06YCv6YSG6YSs6YSE6YO/6YO86YSI6YO56YO76YSB6YSA6YSH6YSF6YSD6YWh6YWk6YWf6YWi6YWg6YiB6YiK6Yil6YiD6Yia6Yim6YiP6YiM6YiA6YiS6Ye/6Ye96YiG6YiE6Yin6YiC6Yic6Yik6YiZ6YiX6YiF6YiW6ZW76ZaN6ZaM6ZaQ6ZqH6Zm+6ZqIXCJdLFtcImRjYTFcIixcIumaiemag+magOmbgumbiOmbg+mbsembsOmdrOmdsOmdrumgh+miqemjq+mzpum7ueS6g+S6hOS6tuWCveWCv+WDhuWCruWDhOWDiuWCtOWDiOWDguWCsOWDgeWCuuWCseWDi+WDieWCtuWCuOWHl+WJuuWJuOWJu+WJvOWXg+WXm+WXjOWXkOWXi+WXiuWXneWXgOWXlOWXhOWXqeWWv+WXkuWWjeWXj+WXleWXouWXluWXiOWXsuWXjeWXmeWXguWclOWhk+WhqOWhpOWhj+WhjeWhieWhr+WhleWhjuWhneWhmeWhpeWhm+WgveWho+WhseWjvOWrh+WrhOWri+WquuWquOWqseWqteWqsOWqv+WriOWqu+WrhlwiXSxbXCJkZDQwXCIsXCLlqrflq4Dlq4rlqrTlqrblq43lqrnlqpDlr5blr5jlr5nlsJ/lsLPltbHltaPltYrltaXltbLltazltZ7ltajltafltaLlt7DluY/luY7luYrluY3luYvlu4Xlu4zlu4blu4vlu4flvYDlvq/lvq3mg7fmhYnmhYrmhKvmhYXmhLbmhLLmhK7mhYbmhK/mhY/mhKnmhYDmiKDphajmiKPmiKXmiKTmj4Xmj7Hmj6vmkJDmkJLmkInmkKDmkKRcIl0sW1wiZGRhMVwiLFwi5pCz5pGD5pCf5pCV5pCY5pC55pC35pCi5pCj5pCM5pCm5pCw5pCo5pGB5pC15pCv5pCK5pCa5pGA5pCl5pCn5pCL5o+n5pCb5pCu5pCh5pCO5pWv5paS5peT5pqG5pqM5pqV5pqQ5pqL5pqK5pqZ5pqU5pm45pyg5qWm5qWf5qS45qWO5qWi5qWx5qS/5qWF5qWq5qS55qWC5qWX5qWZ5qW65qWI5qWJ5qS15qWs5qSz5qS95qWl5qOw5qW45qS05qWp5qWA5qWv5qWE5qW25qWY5qWB5qW05qWM5qS75qWL5qS35qWc5qWP5qWR5qSy5qWS5qSv5qW75qS85q2G5q2F5q2D5q2C5q2I5q2B5q6b76iN5q+75q+8XCJdLFtcImRlNDBcIixcIuavueavt+avuOa6m+a7lua7iOa6j+a7gOa6n+a6k+a6lOa6oOa6sea6uea7hua7kua6vea7gea6nua7iea6t+a6sOa7jea6pua7j+a6sua6vua7g+a7nOa7mOa6mea6kua6jua6jea6pOa6oea6v+a6s+a7kOa7iua6l+a6rua6o+eFh+eFlOeFkueFo+eFoOeFgeeFneeFoueFsueFuOeFqueFoeeFgueFmOeFg+eFi+eFsOeFn+eFkOeFk1wiXSxbXCJkZWExXCIsXCLnhYTnhY3nhZrniY/nio3nioznipHnipDnio7njLznjYLnjLvnjLrnjYDnjYrnjYnnkYTnkYrnkYvnkZLnkZHnkZfnkYDnkY/nkZDnkY7nkYLnkYbnkY3nkZTnk6Hnk7/nk77nk73nlJ3nlbnnlbfmpoPnl6/nmI/nmIPnl7fnl77nl7znl7nnl7jnmJDnl7vnl7bnl63nl7Xnl73nmpnnmrXnm53nnZXnnZ/nnaDnnZLnnZbnnZrnnannnafnnZTnnZnnna3nn6DnoofnoprnopTnoo/nooTnopXnooXnoobnoqHnooPnobnnopnnooDnopbnobvnpbznpoLnpb3npbnnqJHnqJjnqJnnqJLnqJfnqJXnqKLnqJNcIl0sW1wiZGY0MFwiLFwi56ib56iQ56qj56qi56qe56ur562m562k562t5620562p562y562l562z562x562w562h56245622562j57Ky57K057Kv57aI57aG57aA57aN57W/57aF57W657aO57W757aD57W857aM57aU57aE57W957aS572t572r572n572o572s576m576l576n57+b57+c6ICh6IWk6IWg6IW36IWc6IWp6IWb6IWi6IWy5pyh6IWe6IW26IWn6IWvXCJdLFtcImRmYTFcIixcIuiFhOiFoeiIneiJieiJhOiJgOiJguiJheiTseiQv+iRluiRtuiRueiSj+iSjeiRpeiRkeiRgOiShuiRp+iQsOiRjeiRveiRmuiRmeiRtOiRs+iRneiUh+iRnuiQt+iQuuiQtOiRuuiRg+iRuOiQsuiRheiQqeiPmeiRi+iQr+iRguiQreiRn+iRsOiQueiRjuiRjOiRkuiRr+iTheiSjuiQu+iRh+iQtuiQs+iRqOiRvuiRhOiQq+iRoOiRlOiRruiRkOici+ichOibt+icjOibuuibluibteidjeibuOicjuicieicgeibtuicjeicheijluiji+ijjeijjuijnuijm+ijmuijjOijkOimheimm+inn+inpeinpFwiXSxbXCJlMDQwXCIsXCLop6Hop6Dop6Lop5zop6boqbboqoboqb/oqaHoqL/oqbfoqoLoqoToqbXoqoPoqoHoqbToqbrosLzosYvosYrosaXosaTosabosobosoTosoXos4zotajotanotpHotozoto7oto/oto3otpPotpTotpDotpLot7Dot6Dot6zot7Hot67ot5Dot6not6Pot6Lot6fot7Lot6vot7TovIbou7/ovIHovIDovIXovIfovIjovILovIvpgZLpgL9cIl0sW1wiZTBhMVwiLFwi6YGE6YGJ6YC96YSQ6YSN6YSP6YSR6YSW6YSU6YSL6YSO6YWu6YWv6YmI6YmS6Yiw6Yi66Ymm6Yiz6Yml6Yme6YqD6Yiu6YmK6YmG6Ymt6Yms6YmP6Ymg6Ymn6Ymv6Yi26Ymh6Ymw6Yix6YmU6Ymj6YmQ6Ymy6YmO6YmT6YmM6YmW6Yiy6Zaf6Zac6Zae6Zab6ZqS6ZqT6ZqR6ZqX6ZuO6Zu66Zu96Zu46Zu16Z2z6Z236Z246Z2y6aCP6aCN6aCO6aKs6aO26aO56aav6aay6aaw6aa16aqt6aqr6a2b6bOq6bOt6bOn6bqA6bu95YOm5YOU5YOX5YOo5YOz5YOb5YOq5YOd5YOk5YOT5YOs5YOw5YOv5YOj5YOgXCJdLFtcImUxNDBcIixcIuWHmOWKgOWKgeWLqeWLq+WMsOWOrOWYp+WYleWYjOWYkuWXvOWYj+WYnOWYgeWYk+WYguWXuuWYneWYhOWXv+WXueWiieWhvOWikOWimOWihuWigeWhv+WhtOWii+WhuuWih+WikeWijuWhtuWiguWiiOWhu+WilOWij+WjvuWlq+WrnOWrruWrpeWrleWrquWrmuWrreWrq+Wrs+WrouWroOWrm+WrrOWrnuWrneWrmeWrqOWrn+Wtt+WvoFwiXSxbXCJlMWExXCIsXCLlr6PlsaPltoLltoDltb3ltobltbrltoHltbfltorltonltojltb7ltbzlto3ltbnltb/luZjluZnluZPlu5jlu5Hlu5flu47lu5zlu5Xlu5nlu5Llu5TlvYTlvYPlva/lvrbmhKzmhKjmhYHmhZ7mhbHmhbPmhZLmhZPmhbLmhazmhoDmhbTmhZTmhbrmhZvmhaXmhLvmharmhaHmhZbmiKnmiKfmiKvmkKvmkY3mkZvmkZ3mkbTmkbbmkbLmkbPmkb3mkbXmkabmkqbmkY7mkoLmkZ7mkZzmkYvmkZPmkaDmkZDmkb/mkL/mkazmkavmkZnmkaXmkbfmlbPmlqDmmqHmmqDmmp/mnIXmnITmnKLmprHmprbmp4lcIl0sW1wiZTI0MFwiLFwi5qag5qeO5qaW5qaw5qas5qa85qaR5qaZ5qaO5qan5qaN5qap5qa+5qav5qa/5qeE5qa95qak5qeU5qa55qeK5qaa5qeP5qaz5qaT5qaq5qah5qae5qeZ5qaX5qaQ5qeC5qa15qal5qeG5q2K5q2N5q2L5q6e5q6f5q6g5q+D5q+E5q++5ruO5ru15rux5ryD5ryl5ru45ry35ru75ryu5ryJ5r2O5ryZ5rya5ryn5ryY5ry75ryS5rut5ryKXCJdLFtcImUyYTFcIixcIua8tua9s+a7uea7rua8rea9gOa8sOa8vOa8tea7q+a8h+a8jua9g+a8hea7vea7tua8uea8nOa7vOa8uua8n+a8jea8nua8iOa8oeeGh+eGkOeGieeGgOeGheeGgueGj+eFu+eGhueGgeeGl+eJhOeJk+eKl+eKleeKk+eNg+eNjeeNkeeNjOeRoueRs+eRseeRteeRsueRp+eRrueUgOeUgueUg+eVveeWkOeYlueYiOeYjOeYleeYkeeYiueYlOeauOeegeedvOeeheeeguedrueegOedr+edvueeg+eisueiqueitOeireeiqOehvueiq+einueipeeioOeirOeioueipOemmOemiuemi+emluemleemlOemk1wiXSxbXCJlMzQwXCIsXCLnppfnpojnppLnppDnqKvnqYrnqLDnqK/nqKjnqKbnqqjnqqvnqqznq67nrojnrpznrornrpHnrpDnrpbnro3nroznrpvnro7nroXnrpjlioTnrpnnrqTnroLnsrvnsr/nsrznsrrntqfntrfnt4LntqPntqrnt4Hnt4Dnt4Xntp3nt47nt4Tnt4bnt4vnt4zntq/ntrnntpbntrzntp/ntqbntq7ntqnntqHnt4nnvbPnv6Lnv6Pnv6Xnv55cIl0sW1wiZTNhMVwiLFwi6ICk6IGd6IGc6IaJ6IaG6IaD6IaH6IaN6IaM6IaL6IiV6JKX6JKk6JKh6JKf6JK66JOO6JOC6JKs6JKu6JKr6JK56JK06JOB6JON6JKq6JKa6JKx6JOQ6JKd6JKn6JK76JKi6JKU6JOH6JOM6JKb6JKp6JKv6JKo6JOW6JKY6JK26JOP6JKg6JOX6JOU6JOS6JOb6JKw6JKR6Jmh6Jyz6Jyj6Jyo6J2r6J2A6Jyu6Jye6Jyh6JyZ6Jyb6J2D6Jys6J2B6Jy+6J2G6Jyg6Jyy6Jyq6Jyt6Jy86JyS6Jy66Jyx6Jy16J2C6Jym6Jyn6Jy46Jyk6Jya6Jyw6JyR6KO36KOn6KOx6KOy6KO66KO+6KOu6KO86KO26KO7XCJdLFtcImU0NDBcIixcIuijsOijrOijq+imneimoeimn+imnuinqeinq+inqOiqq+iqmeiqi+iqkuiqj+iqluiwveixqOixqeizleizj+izl+i2lui4iei4gui3v+i4jei3vei4iui4g+i4h+i4hui4hei3vui4gOi4hOi8kOi8kei8jui8jemEo+mEnOmEoOmEoumEn+mEnemEmumEpOmEoemEm+mFuumFsumFuemFs+mKpemKpOmJtumKm+mJuumKoOmKlOmKqumKjVwiXSxbXCJlNGExXCIsXCLpiqbpiprpiqvpibnpipfpib/piqPpi67pio7pioLpipXpiqLpib3piojpiqHpiorpiobpiozpipnpiqfpib7piofpiqnpip3piovpiK3pmp7pmqHpm7/pnZjpnb3pnbrpnb7pnoPpnoDpnoLpnbvpnoTpnoHpnb/pn47pn43poJbpoq3poq7ppILppIDppIfppp3pppzpp4Ppprnpprvpprrpp4Lppr3pp4fpqrHpq6Ppq6fprL7prL/praDpraHprZ/ps7Hps7Lps7Xpuqflg7/lhIPlhLDlg7jlhIblhIflg7blg77lhIvlhIzlg73lhIrliovliozli7Hli6/lmYjlmYLlmYzlmLXlmYHlmYrlmYnlmYblmZhcIl0sW1wiZTU0MFwiLFwi5Zma5ZmA5Ziz5Zi95Zis5Zi+5Zi45Ziq5Zi65Zya5aKr5aKd5aKx5aKg5aKj5aKv5aKs5aKl5aKh5aO/5au/5au05au95au35au25ayD5au45ayC5au55ayB5ayH5ayF5ayP5bGn5baZ5baX5baf5baS5bai5baT5baV5bag5bac5bah5baa5bae5bmp5bmd5bmg5bmc57ez5bub5bue5buh5b2J5b6y5oaL5oaD5oW55oax5oaw5oai5oaJXCJdLFtcImU1YTFcIixcIuaGm+aGk+aGr+aGreaGn+aGkuaGquaGoeaGjeaFpuaGs+aIreaRruaRsOaSluaSoOaSheaSl+aSnOaSj+aSi+aSiuaSjOaSo+aSn+aRqOaSseaSmOaVtuaVuuaVueaVu+aWsuaWs+aateaasOaaqeaasuaat+aaquaar+aogOaohuaol+anpeanuOaoleanseanpOaooOanv+anrOanouaom+aoneanvuaop+ansuanruaolOant+anp+apgOaoiOanpuanu+aojeanvOanq+aoieaohOaomOaopeaoj+antuaopuaoh+antOaoluatkeaupeauo+auouaupuawgeawgOavv+awgua9gea8pua9vua+h+a/hua+klwiXSxbXCJlNjQwXCIsXCLmvo3mvonmvozmvaLmvY/mvoXmvZrmvpbmvbbmvazmvoLmvZXmvbLmvZLmvZDmvZfmvpTmvpPmvZ3mvIDmvaHmvavmvb3mvafmvpDmvZPmvovmvanmvb/mvpXmvaPmvbfmvarmvbvnhrLnhq/nhpvnhrDnhqDnhprnhqnnhrXnhp3nhqXnhp7nhqTnhqHnhqrnhpznhqfnhrPnipjniprnjZjnjZLnjZ7njZ/njaDnjZ3njZvnjaHnjZrnjZlcIl0sW1wiZTZhMVwiLFwi542i55KH55KJ55KK55KG55KB55G955KF55KI55G855G555SI55SH55W+55il55ie55iZ55id55ic55ij55ia55io55ib55qc55qd55qe55qb556N556P556J556I56ON56K756OP56OM56OR56OO56OU56OI56OD56OE56OJ56aa56ah56ag56ac56ai56ab5q2256i556qy56q056qz566356+L566+566s56+O566v566556+K566157OF57OI57OM57OL57e357eb57eq57en57eX57eh57iD57e657em57e257ex57ew57eu57ef5722576s576w576t57+t57+r57+q57+s57+m57+o6IGk6IGn6Iaj6IafXCJdLFtcImU3NDBcIixcIuiGnuiGleiGouiGmeiGl+iIluiJj+iJk+iJkuiJkOiJjuiJkeiUpOiUu+iUj+iUgOiUqeiUjuiUieiUjeiUn+iUiuiUp+iUnOiTu+iUq+iTuuiUiOiUjOiTtOiUquiTsuiUleiTt+iTq+iTs+iTvOiUkuiTquiTqeiUluiTvuiUqOiUneiUruiUguiTveiUnuiTtuiUseiUpuiTp+iTqOiTsOiTr+iTueiUmOiUoOiUsOiUi+iUmeiUr+iZolwiXSxbXCJlN2ExXCIsXCLonZbonaPonaTonbfon6HonbPonZjonZTonZvonZLonaHonZronZHonZ7ona3onaronZDonY7onZ/onZ3ona/onazonbrona7onZzonaXonY/onbvonbXonaLonafonanooZropIXopIzopJTopIvopJfopJjopJnopIbopJbopJHopI7opInopqLopqTopqPop63op7Dop6zoq4/oq4boqrjoq5Poq5Hoq5Toq5Xoqrvoq5foqr7oq4Doq4Xoq5joq4Poqrroqr3oq5nosL7osY3oso/os6Xos5/os5nos6jos5ros53os6fotqDotpzotqHotpvouKDouKPouKXouKTouK7ouJXouJvouJbouJHouJnouKbouKdcIl0sW1wiZTg0MFwiLFwi6LiU6LiS6LiY6LiT6Lic6LiX6Lia6Lys6Lyk6LyY6Lya6Lyg6Lyj6LyW6LyX6YGz6YGw6YGv6YGn6YGr6YSv6YSr6YSp6YSq6YSy6YSm6YSu6YaF6YaG6YaK6YaB6YaC6YaE6YaA6YuQ6YuD6YuE6YuA6YuZ6Yq26YuP6Yux6Yuf6YuY6Yup6YuX6Yud6YuM6Yuv6YuC6Yuo6YuK6YuI6YuO6Yum6YuN6YuV6YuJ6Yug6Yue6Yun6YuR6YuTXCJdLFtcImU4YTFcIixcIumKtemLoemLhumKtOmVvOmWrOmWq+mWrumWsOmapOmaoumbk+mchemciOmcgumdmumeiumejumeiOmfkOmfj+mgnumgnemgpumgqemgqOmgoOmgm+mgp+misumkiOmjuumkkemklOmklumkl+mklemnnOmnjemnj+mnk+mnlOmnjumniemnlumnmOmni+mnl+mnjOmqs+mrrOmrq+mrs+mrsumrsemthumtg+mtp+mttOmtsemtpumttumttemtsOmtqOmtpOmtrOmzvOmzuumzvemzv+mzt+m0h+m0gOmzuemzu+m0iOm0hem0hOm6g+m7k+m8j+m8kOWEnOWEk+WEl+WEmuWEkeWHnuWMtOWPoeWZsOWZoOWZrlwiXSxbXCJlOTQwXCIsXCLlmbPlmablmaPlma3lmbLlmZ7lmbflnJzlnJvlo4jlor3lo4nlor/lorrlo4Llorzlo4blrJflrJnlrJvlrKHlrJTlrJPlrJDlrJblrKjlrJrlrKDlrJ7lr6/ltqzltrHltqnltqfltrXltrDltq7ltqrltqjltrLltq3ltq/ltrTluafluajluablua/lu6nlu6flu6blu6jlu6XlvYvlvrzmhp3mhqjmhpbmh4XmhrTmh4bmh4Hmh4zmhrpcIl0sW1wiZTlhMVwiLFwi5oa/5oa45oaM5pOX5pOW5pOQ5pOP5pOJ5pK95pKJ5pOD5pOb5pOz5pOZ5pSz5pW/5pW85pai5puI5pq+5puA5puK5puL5puP5pq95pq75pq65puM5pyj5qi05qmm5qmJ5qmn5qiy5qmo5qi+5qmd5qmt5qm25qmb5qmR5qio5qma5qi75qi/5qmB5qmq5qmk5qmQ5qmP5qmU5qmv5qmp5qmg5qi85qme5qmW5qmV5qmN5qmO5qmG5q2V5q2U5q2W5q6n5q6q5q6r5q+I5q+H5rCE5rCD5rCG5r6t5r+L5r6j5r+H5r685r+O5r+I5r2e5r+E5r695r6e5r+K5r6o54CE5r6l5r6u5r665r6s5r6q5r+P5r6/5r64XCJdLFtcImVhNDBcIixcIua+oua/iea+q+a/jea+r+a+sua+sOeHheeHgueGv+eGuOeHlueHgOeHgeeHi+eHlOeHiueHh+eHj+eGveeHmOeGvOeHhueHmueHm+eKneeKnueNqeeNpueNp+eNrOeNpeeNq+eNqueRv+eSmueSoOeSlOeSkueSleeSoeeUi+eWgOeYr+eYreeYseeYveeYs+eYvOeYteeYsueYsOeau+ebpueemueeneeeoeeenOeem+eeoueeo+eeleeemVwiXSxbXCJlYWExXCIsXCLnnpfno53no6nno6Xno6rno57no6Pno5vno6Hno6Lno63no5/no6DnpqTnqYTnqYjnqYfnqrbnqrjnqrXnqrHnqrfnr57nr6Pnr6fnr53nr5Xnr6Xnr5rnr6jnr7nnr5Tnr6rnr6Lnr5znr6vnr5jnr5/ns5Lns5Tns5fns5Dns5HnuJLnuKHnuJfnuIznuJ/nuKDnuJPnuI7nuJznuJXnuJrnuKLnuIvnuI/nuJbnuI3nuJTnuKXnuKTnvYPnvbvnvbznvbrnvrHnv6/ogKrogKnogazohrHohqbohq7ohrnohrXohqvohrDohqzohrTohrLohrfohqfoh7LoiZXoiZboiZfolZbolYXolavolY3olZPolaHolZhcIl0sW1wiZWI0MFwiLFwi6JWA6JWG6JWk6JWB6JWi6JWE6JWR6JWH6JWj6JS+6JWb6JWx6JWO6JWu6JW16JWV6JWn6JWg6JaM6JWm6JWd6JWU6JWl6JWs6Jmj6Jml6Jmk6J6b6J6P6J6X6J6T6J6S6J6I6J6B6J6W6J6Y6J256J6H6J6j6J6F6J6Q6J6R6J6d6J6E6J6U6J6c6J6a6J6J6KSe6KSm6KSw6KSt6KSu6KSn6KSx6KSi6KSp6KSj6KSv6KSs6KSf6Kex6KugXCJdLFtcImViYTFcIixcIuirouirsuirtOirteirneislOirpOirn+irsOiriOirnuiroeirqOirv+irr+iru+iykeiykuiykOizteizruizseizsOizs+i1rOi1rui2pei2p+i4s+i4vui4uOi5gOi5hei4tui4vOi4vei5gei4sOi4v+i6vei8tui8rui8tei8sui8uei8t+i8tOmBtumBuemBu+mChumDuumEs+mEtemEtumGk+mGkOmGkemGjemGj+mMp+mMnumMiOmMn+mMhumMj+mNuumMuOmMvOmMm+mMo+mMkumMgemNhumMremMjumMjemLi+mMnemLuumMpemMk+mLuemLt+mMtOmMgumMpOmLv+mMqemMuemMtemMqumMlOmMjFwiXSxbXCJlYzQwXCIsXCLpjIvpi77pjInpjIDpi7vpjJbplrzpl43plr7plrnplrrplrbplr/plrXplr3pmqnpm5TpnIvpnJLpnJDpnpnpnpfpnpTpn7Dpn7jpoLXpoK/poLLppKTppJ/ppKfppKnppp7pp67pp6zpp6Xpp6Tpp7Dpp6Ppp6rpp6npp6fpqrnpqr/pqrTpqrvpq7bpq7rpq7npq7fprLPproDproXprofprbzprb7prbvproLprpPprpLprpDprbrprpVcIl0sW1wiZWNhMVwiLFwi6a296a6I6bSl6bSX6bSg6bSe6bSU6bSp6bSd6bSY6bSi6bSQ6bSZ6bSf6bqI6bqG6bqH6bqu6bqt6buV6buW6bu66byS6by95YSm5YSl5YSi5YSk5YSg5YSp5Yu05ZqT5ZqM5ZqN5ZqG5ZqE5ZqD5Zm+5ZqC5Zm/5ZqB5aOW5aOU5aOP5aOS5ayt5ayl5ayy5ayj5ays5ayn5aym5ayv5ayu5a275a+x5a+y5ba35bms5bmq5b6+5b675oeD5oa15oa85oen5oeg5oel5oek5oeo5oee5pOv5pOp5pOj5pOr5pOk5pOo5paB5paA5pa25pea5puS5qqN5qqW5qqB5qql5qqJ5qqf5qqb5qqh5qqe5qqH5qqT5qqOXCJdLFtcImVkNDBcIixcIuaqleaqg+aqqOaqpOaqkeapv+aqpuaqmuaqheaqjOaqkuatm+aureawiea/jOa+qea/tOa/lOa/o+a/nOa/rea/p+a/pua/nua/sua/nea/oua/qOeHoeeHseeHqOeHsueHpOeHsOeHoueNs+eNrueNr+eSl+eSsueSq+eSkOeSqueSreeSseeSpeeSr+eUkOeUkeeUkueUj+eWhOeZg+eZiOeZieeZh+eapOebqeeeteeeq+eesueet+eetlwiXSxbXCJlZGExXCIsXCLnnrTnnrHnnqjnn7Dno7Pno73npILno7vno7zno7LnpIXno7nno77npITnpqvnpqjnqZznqZvnqZbnqZjnqZTnqZrnqr7nq4Dnq4HnsIXnsI/nr7LnsIDnr7/nr7vnsI7nr7TnsIvnr7PnsILnsInnsIPnsIHnr7jnr73nsIbnr7Dnr7HnsJDnsIrns6jnuK3nuLznuYLnuLPpoYjnuLjnuKrnuYnnuYDnuYfnuKnnuYznuLDnuLvnuLbnuYTnuLrnvYXnvb/nvb7nvb3nv7Tnv7LogKzohrvoh4Toh4zoh4roh4Xoh4fohrzoh6noiZvoiZroiZzoloPoloDolo/olqfolpXolqDolovolqPolbvolqTolprolp5cIl0sW1wiZWU0MFwiLFwi6JW36JW86JaJ6Jah6JW66JW46JWX6JaO6JaW6JaG6JaN6JaZ6Jad6JaB6Jai6JaC6JaI6JaF6JW56JW26JaY6JaQ6Jaf6Jmo6J6+6J6q6J6t6J+F6J6w6J6s6J656J616J686J6u6J+J6J+D6J+C6J+M6J636J6v6J+E6J+K6J606J626J6/6J646J696J+e6J6y6KS16KSz6KS86KS+6KWB6KWS6KS36KWC6Kat6Kav6Kau6Key6Kez6KyeXCJdLFtcImVlYTFcIixcIuismOisluiskeisheisi+isouisj+iskuisleish+isjeisiOishuisnOisk+ismuixj+ixsOixsuixseixr+iyleiylOizuei1r+i5jui5jei5k+i5kOi5jOi5h+i9g+i9gOmChemBvumEuOmGmumGoumGm+mGmemGn+mGoemGnemGoOmOoemOg+mOr+mNpOmNlumNh+mNvOmNmOmNnOmNtumNiemNkOmNkemNoOmNremOj+mNjOmNqumNuemNl+mNlemNkumNj+mNsemNt+mNu+mNoemNnumNo+mNp+mOgOmNjumNmemXh+mXgOmXiemXg+mXhemWt+marumasOmarOmcoOmcn+mcmOmcnemcmememumeoemenFwiXSxbXCJlZjQwXCIsXCLpnp7pnp3pn5Xpn5Tpn7HpoYHpoYTpoYrpoYnpoYXpoYPppKXppKvppKzppKrppLPppLLppK/ppK3ppLHppLDpppjppqPppqHpqILpp7rpp7Tpp7fpp7npp7jpp7bpp7vpp73pp77pp7zpqIPpqr7pq77pq73prIHpq7zprYjprprprqjprp7prpvprqbprqHprqXprqTprobprqLprqDprq/ptLPptYHptafptLbptK7ptK/ptLHptLjptLBcIl0sW1wiZWZhMVwiLFwi6bWF6bWC6bWD6bS+6bS36bWA6bS957+16bSt6bqK6bqJ6bqN6bqw6buI6bua6bu76bu/6byk6byj6byi6b2U6b6g5YSx5YSt5YSu5ZqY5Zqc5ZqX5Zqa5Zqd5ZqZ5aWw5ay85bGp5bGq5beA5bmt5bmu5oeY5oef5oet5oeu5oex5oeq5oew5oer5oeW5oep5pO/5pSE5pO95pO45pSB5pSD5pO85paU5peb5pua5pub5puY5quF5qq55qq95quh5quG5qq65qq25qq35quH5qq05qqt5q2e5q+J5rCL54CH54CM54CN54CB54CF54CU54CO5r+/54CA5r+754Cm5r+85r+354CK54iB54e/54e554iD54e95422XCJdLFtcImYwNDBcIixcIueSuOeTgOeSteeTgeeSvueStueSu+eTgueUlOeUk+eZnOeZpOeZmeeZkOeZk+eZl+eZmueapueaveebrOefgueeuuejv+ekjOekk+eklOekieekkOekkuekkeemreemrOepn+ewnOewqeewmeewoOewn+ewreewneewpuewqOewouewpeewsOe5nOe5kOe5lue5o+e5mOe5oue5n+e5kee5oOe5l+e5k+e+tee+s+e/t+e/uOiBteiHkeiHklwiXSxbXCJmMGExXCIsXCLoh5DoiZ/oiZ7olrTol4bol4Dol4Pol4LolrPolrXolr3ol4fol4Tolr/ol4vol47ol4jol4XolrHolrbol5LomKTolrjolrfolr7omanon6fon6bon6Lon5von6von6ron6Xon5/on7Pon6Ton5Ton5zon5Pon63on5jon6PonqTon5fon5nooIHon7Ton6jon53opZPopYvopY/opYzopYbopZDopZHopYnorKrorKforKPorLPorLDorLXorYforK/orLzorL7orLHorKXorLforKborLborK7orKTorLvorL3orLrosYLosbXospnospjospfos77otITotILotIDouZzouaLouaDouZfouZbouZ7ouaXouadcIl0sW1wiZjE0MFwiLFwi6Lmb6Lma6Lmh6Lmd6Lmp6LmU6L2G6L2H6L2I6L2L6YSo6YS66YS76YS+6Yao6Yal6Yan6Yav6Yaq6Y616Y6M6Y6S6Y636Y6b6Y6d6Y6J6Y6n6Y6O6Y6q6Y6e6Y6m6Y6V6Y6I6Y6Z6Y6f6Y6N6Y6x6Y6R6Y6y6Y6k6Y6o6Y606Y6j6Y6l6ZeS6ZeT6ZeR6Zqz6ZuX6Zua5beC6Zuf6ZuY6Zud6Zyj6Zyi6Zyl6Z6s6Z6u6Z6o6Z6r6Z6k6Z6qXCJdLFtcImYxYTFcIixcIumeoumepemfl+mfmemflumfmOmfuumhkOmhkemhkumiuOmlgemkvOmkuumoj+moi+moiemojemohOmokemoiumohemoh+mohumrgOmrnOmsiOmshOmshemsqemstemtiumtjOmti+mvh+mvhumvg+muv+mvgemutemuuOmvk+mutumvhOmuuemuvem1nOm1k+m1j+m1ium1m+m1i+m1mem1lum1jOm1l+m1kum1lOm1n+m1mOm1mum6jum6jOm7n+m8gem8gOm8lum8pem8q+m8qum8qem8qOm9jOm9leWEtOWEteWKluWLt+WOtOWaq+WareWapuWap+WaquWarOWjmuWjneWjm+WkkuWsveWsvuWsv+W3g+W5sFwiXSxbXCJmMjQwXCIsXCLlvr/mh7vmlIfmlJDmlI3mlInmlIzmlI7mloTml57ml53mm57mq6fmq6Dmq4zmq5Hmq5nmq4vmq5/mq5zmq5Dmq6vmq4/mq43mq57mraDmrrDmsIzngJnngKfngKDngJbngKvngKHngKLngKPngKnngJfngKTngJzngKrniIzniIrniIfniILniIXniqXniqbniqTniqPniqHnk4vnk4Xnkrfnk4PnlJbnmaDnn4nnn4rnn4Tnn7HnpJ3npJtcIl0sW1wiZjJhMVwiLFwi56Sh56Sc56SX56Se56aw56mn56mo57Cz57C857C557Cs57C757Os57Oq57m257m157m457mw57m357mv57m657my57m057mo572L572K576D576G576357+957++6IG46IeX6IeV6Imk6Imh6Imj6Jer6Jex6Jet6JeZ6Jeh6Jeo6Jea6JeX6Jes6Jey6Je46JeY6Jef6Jej6Jec6JeR6Jew6Jem6Jev6Jee6Jei6KCA6J+66KCD6J+26J+36KCJ6KCM6KCL6KCG6J+86KCI6J+/6KCK6KCC6KWi6KWa6KWb6KWX6KWh6KWc6KWY6KWd6KWZ6KaI6Ka36Ka26Ke26K2Q6K2I6K2K6K2A6K2T6K2W6K2U6K2L6K2VXCJdLFtcImYzNDBcIixcIuitkeitguitkuitl+ixg+ixt+ixtuiymui0hui0h+i0iei2rOi2qui2rei2q+i5rei5uOi5s+i5qui5r+i5u+i7gui9kui9kei9j+i9kOi9k+i+tOmFgOmEv+mGsOmGremPnumPh+mPj+mPgumPmumPkOmPuemPrOmPjOmPmemOqemPpumPiumPlOmPrumPo+mPlemPhOmPjumPgOmPkumPp+mVvemXmumXm+mboemcqemcq+mcrOmcqOmcplwiXSxbXCJmM2ExXCIsXCLpnrPpnrfpnrbpn53pn57pn5/poZzpoZnpoZ3poZfpor/por3porvpor7ppYjppYfppYPppqbppqfpqJrpqJXpqKXpqJ3pqKTpqJvpqKLpqKDpqKfpqKPpqJ7pqJzpqJTpq4LprIvprIrprI7prIzprLfpr6rpr6vpr6Dpr57pr6Tpr6bpr6Lpr7Dpr5Tpr5fpr6zpr5zpr5npr6Xpr5Xpr6Hpr5rptbfptoHptorptoTptojptbHptoDptbjptobptovptozptb3ptavptbTptbXptbDptanptoXptbPptbvptoLpta/ptbnptb/ptofptajpupTpupHpu4Dpu7zpvK3pvYDpvYHpvY3pvZbpvZfpvZjljLflmrJcIl0sW1wiZjQ0MFwiLFwi5Zq15Zqz5aOj5a2F5beG5beH5buu5buv5b+A5b+B5oe55pSX5pSW5pSV5pST5pef5puo5puj5puk5quz5quw5quq5quo5qu55qux5quu5quv54C854C154Cv54C354C054Cx54GC54C454C/54C654C554GA54C754Cz54GB54iT54iU54qo5429542855K655qr55qq55q+55ut55+M55+O55+P55+N55+y56Sl56Sj56Sn56So56Sk56SpXCJdLFtcImY0YTFcIixcIuemsueprueprOepreert+exieexiOexiuexh+exheezrue5u+e5vue6gee6gOe+uue/v+iBueiHm+iHmeiIi+iJqOiJqeiYouiXv+iYgeiXvuiYm+iYgOiXtuiYhOiYieiYheiYjOiXveigmeigkOigkeigl+igk+igluilo+ilpuimueint+itoOitquitneitqOito+itpeitp+itrei2rui6hui6iOi6hOi9mei9lui9l+i9lei9mOi9mumCjemFg+mFgemGt+mGtemGsumGs+mQi+mQk+mPu+mQoOmQj+mQlOmPvumQlemQkOmQqOmQmemQjemPtemQgOmPt+mQh+mQjumQlumQkumPuumQiemPuOmQiumPv1wiXSxbXCJmNTQwXCIsXCLpj7zpkIzpj7bpkJHpkIbpl57pl6Dpl5/pnK7pnK/pnrnpnrvpn73pn77poaDpoaLpoaPpoZ/po4Hpo4LppZDppY7ppZnppYzppYvppZPpqLLpqLTpqLHpqKzpqKrpqLbpqKnpqK7pqLjpqK3pq4fpq4rpq4bprJDprJLprJHpsIvpsIjpr7fpsIXpsJLpr7jpsYDpsIfpsI7psIbpsJfpsJTpsInptp/ptpnptqTptp3ptpLptpjptpDptptcIl0sW1wiZjVhMVwiLFwi6bag6baU6bac6baq6baX6bah6baa6bai6bao6bae6baj6ba/6bap6baW6bam6ban6bqZ6bqb6bqa6bul6buk6bun6bum6byw6byu6b2b6b2g6b2e6b2d6b2Z6b6R5YS65YS55YqY5YqX5ZuD5Zq95Zq+5a2I5a2H5beL5beP5bux5oe95pSb5qyC5qu85qyD5qu45qyA54GD54GE54GK54GI54GJ54GF54GG54id54ia54iZ542+55SX55mq55+Q56St56Sx56Sv57GU57GT57Oy57qK57qH57qI57qL57qG57qN572N57676ICw6Ied6JiY6Jiq6Jim6Jif6Jij6Jic6JiZ6Jin6Jiu6Jih6Jig6Jip6Jie6JilXCJdLFtcImY2NDBcIixcIuigqeigneigm+igoOigpOignOigq+ihiuilreilqeilruilq+inuuitueituOitheituuitu+i0kOi0lOi2r+i6jui6jOi9nui9m+i9nemFhumFhOmFhemGuemQv+mQu+mQtumQqemQvemQvOmQsOmQuemQqumQt+mQrOmRgOmQsemXpemXpOmXo+mctemcuumev+mfoemhpOmjiemjhumjgOmlmOmllumouemovemphumphOmpgumpgemoulwiXSxbXCJmNmExXCIsXCLpqL/pq43prJXprJfprJjprJbprLrprZLpsKvpsJ3psJzpsKzpsKPpsKjpsKnpsKTpsKHptrfptrbptrzpt4Hpt4fpt4rpt4/ptr7pt4Xpt4PptrvptrXpt47ptrnptrrptqzpt4jptrHptq3pt4zptrPpt43ptrLpubrpupzpu6vpu67pu63pvJvpvJjpvJrpvLHpvY7pvaXpvaTpvpLkurnlm4blm4Xlm4vlpbHlrYvlrYzlt5Xlt5Hlu7LmlKHmlKDmlKbmlKLmrIvmrIjmrInmsI3ngZXngZbngZfngZLniJ7niJ/niqnnjb/nk5jnk5Xnk5nnk5fnma3nmq3npLXnprTnqbDnqbHnsZfnsZznsZnnsZvnsZpcIl0sW1wiZjc0MFwiLFwi57O057Ox57qR572P576H6Iee6Imr6Ji06Ji16Jiz6Jis6Jiy6Ji26KCs6KCo6KCm6KCq6KCl6KWx6Ka/6Ka+6Ke76K2+6K6E6K6C6K6G6K6F6K2/6LSV6LqV6LqU6Lqa6LqS6LqQ6LqW6LqX6L2g6L2i6YWH6ZGM6ZGQ6ZGK6ZGL6ZGP6ZGH6ZGF6ZGI6ZGJ6ZGG6Zy/6Z+j6aGq6aGp6aOL6aWU6aWb6amO6amT6amU6amM6amP6amI6amKXCJdLFtcImY3YTFcIixcIumpiempkumpkOmrkOmsmemsq+msu+mtlumtlemxhumxiOmwv+mxhOmwuemws+mxgemwvOmwt+mwtOmwsumwvemwtum3m+m3kum3num3mum3i+m3kOm3nOm3kem3n+m3qem3mem3mOm3lum3tem3lem3nem6tum7sOm8tem8s+m8sum9gum9q+m+lem+ouWEveWKmeWjqOWjp+WlsuWtjeW3mOigr+W9j+aIgeaIg+aIhOaUqeaUpeaWluabq+askeaskuasj+aviueBm+eBmueIoueOgueOgeeOg+eZsOeflOexp+expue6leiJrOiYuuiZgOiYueiYvOiYseiYu+iYvuigsOigsuigruigs+iltuiltOils+invlwiXSxbXCJmODQwXCIsXCLorozoro7orovorojosYXotJnoupjovaTovaPphrzpkaLpkZXpkZ3pkZfpkZ7pn4Tpn4XpoIDpqZbpqZnprJ7prJ/prKDpsZLpsZjpsZDpsYrpsY3psYvpsZXpsZnpsYzpsY7pt7vpt7fpt6/pt6Ppt6vpt7jpt6Tpt7bpt6Hpt67pt6bpt7Lpt7Dpt6Lpt6zpt7Tpt7Ppt6jpt63pu4Lpu5Dpu7Lpu7PpvIbpvJzpvLjpvLfpvLbpvYPpvY9cIl0sW1wiZjhhMVwiLFwi6b2x6b2w6b2u6b2v5ZuT5ZuN5a2O5bGt5pSt5put5puu5qyT54Gf54Gh54Gd54Gg54ij55Ob55Ol55+V56S456a356a257Gq57qX576J6Imt6JmD6KC46KC36KC16KGL6K6U6K6V6Lqe6Lqf6Lqg6Lqd6Ya+6Ya96YeC6ZGr6ZGo6ZGp6Zul6Z2G6Z2D6Z2H6Z+H6Z+l6ame6auV6a2Z6bGj6bGn6bGm6bGi6bGe6bGg6biC6be+6biH6biD6biG6biF6biA6biB6biJ6be/6be96biE6bqg6bye6b2G6b206b216b225ZuU5pSu5pa45qyY5qyZ5qyX5qya54Gi54im54qq55+Y55+Z56S557Gp57Gr57O257qaXCJdLFtcImY5NDBcIixcIue6mOe6m+e6meiHoOiHoeiZhuiZh+iZiOilueiluuilvOilu+inv+iumOiumei6pei6pOi6o+mRrumRremRr+mRsemRs+mdiemhsumln+mxqOmxrumxrem4i+m4jem4kOm4j+m4kum4kem6oem7tem8iem9h+m9uOm9u+m9uum9ueWcnueBpuexr+igvOi2sui6pumHg+mRtOmRuOmRtumRtempoOmxtOmxs+mxsemxtem4lOm4k+m7tum8ilwiXSxbXCJmOWExXCIsXCLpvqTngajngaXns7fomarooL7ooL3ooL/orp7ospzouqnou4npnYvpobPpobTpo4zppaHppqvpqaTpqabpqafprKTpuJXpuJfpvYjmiIfmrJ7niKfomYzouqjpkoLpkoDpkoHpqanpqajprK7puJnniKnomYvorp/pkoPpsbnpurfnmbXpqavpsbrpuJ3nganngarpuqTpvb7pvYnpvpjnooHpirnoo4/lorvmgZLnsqflq7rilZTilabilZfilaDilazilaPilZrilanilZ3ilZLilaTilZXilZ7ilarilaHilZjilafilZvilZPilaXilZbilZ/ilavilaLilZnilajilZzilZHilZDila3ila7ilbDila/ilpNcIl1dXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaWNvbnYtbGl0ZS9lbmNvZGluZ3MvdGFibGVzL2NwOTUwLmpzb25cbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogdW5waXBlXG4gKiBDb3B5cmlnaHQoYykgMjAxNSBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB1bnBpcGVcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlcmUgYXJlIE5vZGUuanMgcGlwZS1saWtlIGRhdGEgbGlzdGVuZXJzLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBoYXNQaXBlRGF0YUxpc3RlbmVycyhzdHJlYW0pIHtcbiAgdmFyIGxpc3RlbmVycyA9IHN0cmVhbS5saXN0ZW5lcnMoJ2RhdGEnKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxpc3RlbmVyc1tpXS5uYW1lID09PSAnb25kYXRhJykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gKiBVbnBpcGUgYSBzdHJlYW0gZnJvbSBhbGwgZGVzdGluYXRpb25zLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdHJlYW1cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiB1bnBpcGUoc3RyZWFtKSB7XG4gIGlmICghc3RyZWFtKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc3RyZWFtIGlzIHJlcXVpcmVkJylcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc3RyZWFtLnVucGlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIG5ldy1zdHlsZVxuICAgIHN0cmVhbS51bnBpcGUoKVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gTm9kZS5qcyAwLjggaGFja1xuICBpZiAoIWhhc1BpcGVEYXRhTGlzdGVuZXJzKHN0cmVhbSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBsaXN0ZW5lclxuICB2YXIgbGlzdGVuZXJzID0gc3RyZWFtLmxpc3RlbmVycygnY2xvc2UnKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV1cblxuICAgIGlmIChsaXN0ZW5lci5uYW1lICE9PSAnY2xlYW51cCcgJiYgbGlzdGVuZXIubmFtZSAhPT0gJ29uY2xvc2UnKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIC8vIGludm9rZSB0aGUgbGlzdGVuZXJcbiAgICBsaXN0ZW5lci5jYWxsKHN0cmVhbSlcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdW5waXBlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIG1pbWUtdHlwZXNcbiAqIENvcHlyaWdodChjKSAyMDE0IEpvbmF0aGFuIE9uZ1xuICogQ29weXJpZ2h0KGMpIDIwMTUgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBkYiA9IHJlcXVpcmUoJ21pbWUtZGInKVxudmFyIGV4dG5hbWUgPSByZXF1aXJlKCdwYXRoJykuZXh0bmFtZVxuXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBFWFRSQUNUX1RZUEVfUkVHRVhQID0gL15cXHMqKFteO1xcc10qKSg/Ojt8XFxzfCQpL1xudmFyIFRFWFRfVFlQRV9SRUdFWFAgPSAvXnRleHRcXC8vaVxuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydHMuY2hhcnNldCA9IGNoYXJzZXRcbmV4cG9ydHMuY2hhcnNldHMgPSB7IGxvb2t1cDogY2hhcnNldCB9XG5leHBvcnRzLmNvbnRlbnRUeXBlID0gY29udGVudFR5cGVcbmV4cG9ydHMuZXh0ZW5zaW9uID0gZXh0ZW5zaW9uXG5leHBvcnRzLmV4dGVuc2lvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5leHBvcnRzLmxvb2t1cCA9IGxvb2t1cFxuZXhwb3J0cy50eXBlcyA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuLy8gUG9wdWxhdGUgdGhlIGV4dGVuc2lvbnMvdHlwZXMgbWFwc1xucG9wdWxhdGVNYXBzKGV4cG9ydHMuZXh0ZW5zaW9ucywgZXhwb3J0cy50eXBlcylcblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgY2hhcnNldCBmb3IgYSBNSU1FIHR5cGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW58c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGNoYXJzZXQgKHR5cGUpIHtcbiAgaWYgKCF0eXBlIHx8IHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gVE9ETzogdXNlIG1lZGlhLXR5cGVyXG4gIHZhciBtYXRjaCA9IEVYVFJBQ1RfVFlQRV9SRUdFWFAuZXhlYyh0eXBlKVxuICB2YXIgbWltZSA9IG1hdGNoICYmIGRiW21hdGNoWzFdLnRvTG93ZXJDYXNlKCldXG5cbiAgaWYgKG1pbWUgJiYgbWltZS5jaGFyc2V0KSB7XG4gICAgcmV0dXJuIG1pbWUuY2hhcnNldFxuICB9XG5cbiAgLy8gZGVmYXVsdCB0ZXh0LyogdG8gdXRmLThcbiAgaWYgKG1hdGNoICYmIFRFWFRfVFlQRV9SRUdFWFAudGVzdChtYXRjaFsxXSkpIHtcbiAgICByZXR1cm4gJ1VURi04J1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZnVsbCBDb250ZW50LVR5cGUgaGVhZGVyIGdpdmVuIGEgTUlNRSB0eXBlIG9yIGV4dGVuc2lvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtib29sZWFufHN0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBjb250ZW50VHlwZSAoc3RyKSB7XG4gIC8vIFRPRE86IHNob3VsZCB0aGlzIGV2ZW4gYmUgaW4gdGhpcyBtb2R1bGU/XG4gIGlmICghc3RyIHx8IHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB2YXIgbWltZSA9IHN0ci5pbmRleE9mKCcvJykgPT09IC0xXG4gICAgPyBleHBvcnRzLmxvb2t1cChzdHIpXG4gICAgOiBzdHJcblxuICBpZiAoIW1pbWUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIFRPRE86IHVzZSBjb250ZW50LXR5cGUgb3Igb3RoZXIgbW9kdWxlXG4gIGlmIChtaW1lLmluZGV4T2YoJ2NoYXJzZXQnKSA9PT0gLTEpIHtcbiAgICB2YXIgY2hhcnNldCA9IGV4cG9ydHMuY2hhcnNldChtaW1lKVxuICAgIGlmIChjaGFyc2V0KSBtaW1lICs9ICc7IGNoYXJzZXQ9JyArIGNoYXJzZXQudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgcmV0dXJuIG1pbWVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgZXh0ZW5zaW9uIGZvciBhIE1JTUUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHJldHVybiB7Ym9vbGVhbnxzdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZXh0ZW5zaW9uICh0eXBlKSB7XG4gIGlmICghdHlwZSB8fCB0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIFRPRE86IHVzZSBtZWRpYS10eXBlclxuICB2YXIgbWF0Y2ggPSBFWFRSQUNUX1RZUEVfUkVHRVhQLmV4ZWModHlwZSlcblxuICAvLyBnZXQgZXh0ZW5zaW9uc1xuICB2YXIgZXh0cyA9IG1hdGNoICYmIGV4cG9ydHMuZXh0ZW5zaW9uc1ttYXRjaFsxXS50b0xvd2VyQ2FzZSgpXVxuXG4gIGlmICghZXh0cyB8fCAhZXh0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBleHRzWzBdXG59XG5cbi8qKlxuICogTG9va3VwIHRoZSBNSU1FIHR5cGUgZm9yIGEgZmlsZSBwYXRoL2V4dGVuc2lvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQHJldHVybiB7Ym9vbGVhbnxzdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gbG9va3VwIChwYXRoKSB7XG4gIGlmICghcGF0aCB8fCB0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIGdldCB0aGUgZXh0ZW5zaW9uIChcImV4dFwiIG9yIFwiLmV4dFwiIG9yIGZ1bGwgcGF0aClcbiAgdmFyIGV4dGVuc2lvbiA9IGV4dG5hbWUoJ3guJyArIHBhdGgpXG4gICAgLnRvTG93ZXJDYXNlKClcbiAgICAuc3Vic3RyKDEpXG5cbiAgaWYgKCFleHRlbnNpb24pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLnR5cGVzW2V4dGVuc2lvbl0gfHwgZmFsc2Vcbn1cblxuLyoqXG4gKiBQb3B1bGF0ZSB0aGUgZXh0ZW5zaW9ucyBhbmQgdHlwZXMgbWFwcy5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcG9wdWxhdGVNYXBzIChleHRlbnNpb25zLCB0eXBlcykge1xuICAvLyBzb3VyY2UgcHJlZmVyZW5jZSAobGVhc3QgLT4gbW9zdClcbiAgdmFyIHByZWZlcmVuY2UgPSBbJ25naW54JywgJ2FwYWNoZScsIHVuZGVmaW5lZCwgJ2lhbmEnXVxuXG4gIE9iamVjdC5rZXlzKGRiKS5mb3JFYWNoKGZ1bmN0aW9uIGZvckVhY2hNaW1lVHlwZSAodHlwZSkge1xuICAgIHZhciBtaW1lID0gZGJbdHlwZV1cbiAgICB2YXIgZXh0cyA9IG1pbWUuZXh0ZW5zaW9uc1xuXG4gICAgaWYgKCFleHRzIHx8ICFleHRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gbWltZSAtPiBleHRlbnNpb25zXG4gICAgZXh0ZW5zaW9uc1t0eXBlXSA9IGV4dHNcblxuICAgIC8vIGV4dGVuc2lvbiAtPiBtaW1lXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZXh0ZW5zaW9uID0gZXh0c1tpXVxuXG4gICAgICBpZiAodHlwZXNbZXh0ZW5zaW9uXSkge1xuICAgICAgICB2YXIgZnJvbSA9IHByZWZlcmVuY2UuaW5kZXhPZihkYlt0eXBlc1tleHRlbnNpb25dXS5zb3VyY2UpXG4gICAgICAgIHZhciB0byA9IHByZWZlcmVuY2UuaW5kZXhPZihtaW1lLnNvdXJjZSlcblxuICAgICAgICBpZiAodHlwZXNbZXh0ZW5zaW9uXSAhPT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScgJiZcbiAgICAgICAgICAoZnJvbSA+IHRvIHx8IChmcm9tID09PSB0byAmJiB0eXBlc1tleHRlbnNpb25dLnN1YnN0cigwLCAxMikgPT09ICdhcHBsaWNhdGlvbi8nKSkpIHtcbiAgICAgICAgICAvLyBza2lwIHRoZSByZW1hcHBpbmdcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCB0aGUgZXh0ZW5zaW9uIC0+IG1pbWVcbiAgICAgIHR5cGVzW2V4dGVuc2lvbl0gPSB0eXBlXG4gICAgfVxuICB9KVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWltZS10eXBlcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGhleFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gICAgICAgIGFycmF5LnB1c2goJyUnICsgKChpIDwgMTYgPyAnMCcgOiAnJykgKyBpLnRvU3RyaW5nKDE2KSkudG9VcHBlckNhc2UoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xufSgpKTtcblxudmFyIGNvbXBhY3RRdWV1ZSA9IGZ1bmN0aW9uIGNvbXBhY3RRdWV1ZShxdWV1ZSkge1xuICAgIHZhciBvYmo7XG5cbiAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBpdGVtID0gcXVldWUucG9wKCk7XG4gICAgICAgIG9iaiA9IGl0ZW0ub2JqW2l0ZW0ucHJvcF07XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgdmFyIGNvbXBhY3RlZCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9iai5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW2pdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wYWN0ZWQucHVzaChvYmpbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbS5vYmpbaXRlbS5wcm9wXSA9IGNvbXBhY3RlZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG52YXIgYXJyYXlUb09iamVjdCA9IGZ1bmN0aW9uIGFycmF5VG9PYmplY3Qoc291cmNlLCBvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBvYmpbaV0gPSBzb3VyY2VbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxudmFyIG1lcmdlID0gZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaChzb3VyY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wbGFpbk9iamVjdHMgfHwgb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMgfHwgIWhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbc291cmNlXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3RhcmdldCwgc291cmNlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBbdGFyZ2V0XS5jb25jYXQoc291cmNlKTtcbiAgICB9XG5cbiAgICB2YXIgbWVyZ2VUYXJnZXQgPSB0YXJnZXQ7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiAhQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIG1lcmdlVGFyZ2V0ID0gYXJyYXlUb09iamVjdCh0YXJnZXQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgICAgICBpZiAoaGFzLmNhbGwodGFyZ2V0LCBpKSkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRbaV0gJiYgdHlwZW9mIHRhcmdldFtpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2ldID0gbWVyZ2UodGFyZ2V0W2ldLCBpdGVtLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhzb3VyY2UpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW2tleV07XG5cbiAgICAgICAgaWYgKGhhcy5jYWxsKGFjYywga2V5KSkge1xuICAgICAgICAgICAgYWNjW2tleV0gPSBtZXJnZShhY2Nba2V5XSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIG1lcmdlVGFyZ2V0KTtcbn07XG5cbnZhciBhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ25TaW5nbGVTb3VyY2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc291cmNlKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgIGFjY1trZXldID0gc291cmNlW2tleV07XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgdGFyZ2V0KTtcbn07XG5cbnZhciBkZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIucmVwbGFjZSgvXFwrL2csICcgJykpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG59O1xuXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKHN0cikge1xuICAgIC8vIFRoaXMgY29kZSB3YXMgb3JpZ2luYWxseSB3cml0dGVuIGJ5IEJyaWFuIFdoaXRlIChtc2NkZXgpIGZvciB0aGUgaW8uanMgY29yZSBxdWVyeXN0cmluZyBsaWJyYXJ5LlxuICAgIC8vIEl0IGhhcyBiZWVuIGFkYXB0ZWQgaGVyZSBmb3Igc3RyaWN0ZXIgYWRoZXJlbmNlIHRvIFJGQyAzOTg2XG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICB2YXIgc3RyaW5nID0gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBzdHIgOiBTdHJpbmcoc3RyKTtcblxuICAgIHZhciBvdXQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGMgPT09IDB4MkQgLy8gLVxuICAgICAgICAgICAgfHwgYyA9PT0gMHgyRSAvLyAuXG4gICAgICAgICAgICB8fCBjID09PSAweDVGIC8vIF9cbiAgICAgICAgICAgIHx8IGMgPT09IDB4N0UgLy8gflxuICAgICAgICAgICAgfHwgKGMgPj0gMHgzMCAmJiBjIDw9IDB4MzkpIC8vIDAtOVxuICAgICAgICAgICAgfHwgKGMgPj0gMHg0MSAmJiBjIDw9IDB4NUEpIC8vIGEtelxuICAgICAgICAgICAgfHwgKGMgPj0gMHg2MSAmJiBjIDw9IDB4N0EpIC8vIEEtWlxuICAgICAgICApIHtcbiAgICAgICAgICAgIG91dCArPSBzdHJpbmcuY2hhckF0KGkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIG91dCA9IG91dCArIGhleFRhYmxlW2NdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICBvdXQgPSBvdXQgKyAoaGV4VGFibGVbMHhDMCB8IChjID4+IDYpXSArIGhleFRhYmxlWzB4ODAgfCAoYyAmIDB4M0YpXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjIDwgMHhEODAwIHx8IGMgPj0gMHhFMDAwKSB7XG4gICAgICAgICAgICBvdXQgPSBvdXQgKyAoaGV4VGFibGVbMHhFMCB8IChjID4+IDEyKV0gKyBoZXhUYWJsZVsweDgwIHwgKChjID4+IDYpICYgMHgzRildICsgaGV4VGFibGVbMHg4MCB8IChjICYgMHgzRildKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgICBjID0gMHgxMDAwMCArICgoKGMgJiAweDNGRikgPDwgMTApIHwgKHN0cmluZy5jaGFyQ29kZUF0KGkpICYgMHgzRkYpKTtcbiAgICAgICAgb3V0ICs9IGhleFRhYmxlWzB4RjAgfCAoYyA+PiAxOCldXG4gICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoKGMgPj4gMTIpICYgMHgzRildXG4gICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoKGMgPj4gNikgJiAweDNGKV1cbiAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8IChjICYgMHgzRildO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG52YXIgY29tcGFjdCA9IGZ1bmN0aW9uIGNvbXBhY3QodmFsdWUpIHtcbiAgICB2YXIgcXVldWUgPSBbeyBvYmo6IHsgbzogdmFsdWUgfSwgcHJvcDogJ28nIH1dO1xuICAgIHZhciByZWZzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBpdGVtID0gcXVldWVbaV07XG4gICAgICAgIHZhciBvYmogPSBpdGVtLm9ialtpdGVtLnByb3BdO1xuXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tqXTtcbiAgICAgICAgICAgIHZhciB2YWwgPSBvYmpba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwgJiYgcmVmcy5pbmRleE9mKHZhbCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaCh7IG9iajogb2JqLCBwcm9wOiBrZXkgfSk7XG4gICAgICAgICAgICAgICAgcmVmcy5wdXNoKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29tcGFjdFF1ZXVlKHF1ZXVlKTtcbn07XG5cbnZhciBpc1JlZ0V4cCA9IGZ1bmN0aW9uIGlzUmVnRXhwKG9iaikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59O1xuXG52YXIgaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlcihvYmopIHtcbiAgICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gISEob2JqLmNvbnN0cnVjdG9yICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBhcnJheVRvT2JqZWN0OiBhcnJheVRvT2JqZWN0LFxuICAgIGFzc2lnbjogYXNzaWduLFxuICAgIGNvbXBhY3Q6IGNvbXBhY3QsXG4gICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICAgIGlzUmVnRXhwOiBpc1JlZ0V4cCxcbiAgICBtZXJnZTogbWVyZ2Vcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9xcy9saWIvdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XG52YXIgcGVyY2VudFR3ZW50aWVzID0gLyUyMC9nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnZGVmYXVsdCc6ICdSRkMzOTg2JyxcbiAgICBmb3JtYXR0ZXJzOiB7XG4gICAgICAgIFJGQzE3Mzg6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2UuY2FsbCh2YWx1ZSwgcGVyY2VudFR3ZW50aWVzLCAnKycpO1xuICAgICAgICB9LFxuICAgICAgICBSRkMzOTg2OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgUkZDMTczODogJ1JGQzE3MzgnLFxuICAgIFJGQzM5ODY6ICdSRkMzOTg2J1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3FzL2xpYi9mb3JtYXRzLmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGV4cHJlc3NcbiAqIENvcHlyaWdodChjKSAyMDA5LTIwMTMgVEogSG9sb3dheWNodWtcbiAqIENvcHlyaWdodChjKSAyMDEzIFJvbWFuIFNodHlsbWFuXG4gKiBDb3B5cmlnaHQoYykgMjAxNC0yMDE1IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIFJvdXRlID0gcmVxdWlyZSgnLi9yb3V0ZScpO1xudmFyIExheWVyID0gcmVxdWlyZSgnLi9sYXllcicpO1xudmFyIG1ldGhvZHMgPSByZXF1aXJlKCdtZXRob2RzJyk7XG52YXIgbWl4aW4gPSByZXF1aXJlKCd1dGlscy1tZXJnZScpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZXhwcmVzczpyb3V0ZXInKTtcbnZhciBkZXByZWNhdGUgPSByZXF1aXJlKCdkZXBkJykoJ2V4cHJlc3MnKTtcbnZhciBmbGF0dGVuID0gcmVxdWlyZSgnYXJyYXktZmxhdHRlbicpO1xudmFyIHBhcnNlVXJsID0gcmVxdWlyZSgncGFyc2V1cmwnKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ3NldHByb3RvdHlwZW9mJylcblxuLyoqXG4gKiBNb2R1bGUgdmFyaWFibGVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgb2JqZWN0UmVnRXhwID0gL15cXFtvYmplY3QgKFxcUyspXFxdJC87XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJvdXRlcmAgd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge1JvdXRlcn0gd2hpY2ggaXMgYW4gY2FsbGFibGUgZnVuY3Rpb25cbiAqIEBwdWJsaWNcbiAqL1xuXG52YXIgcHJvdG8gPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGZ1bmN0aW9uIHJvdXRlcihyZXEsIHJlcywgbmV4dCkge1xuICAgIHJvdXRlci5oYW5kbGUocmVxLCByZXMsIG5leHQpO1xuICB9XG5cbiAgLy8gbWl4aW4gUm91dGVyIGNsYXNzIGZ1bmN0aW9uc1xuICBzZXRQcm90b3R5cGVPZihyb3V0ZXIsIHByb3RvKVxuXG4gIHJvdXRlci5wYXJhbXMgPSB7fTtcbiAgcm91dGVyLl9wYXJhbXMgPSBbXTtcbiAgcm91dGVyLmNhc2VTZW5zaXRpdmUgPSBvcHRzLmNhc2VTZW5zaXRpdmU7XG4gIHJvdXRlci5tZXJnZVBhcmFtcyA9IG9wdHMubWVyZ2VQYXJhbXM7XG4gIHJvdXRlci5zdHJpY3QgPSBvcHRzLnN0cmljdDtcbiAgcm91dGVyLnN0YWNrID0gW107XG5cbiAgcmV0dXJuIHJvdXRlcjtcbn07XG5cbi8qKlxuICogTWFwIHRoZSBnaXZlbiBwYXJhbSBwbGFjZWhvbGRlciBgbmFtZWAocykgdG8gdGhlIGdpdmVuIGNhbGxiYWNrLlxuICpcbiAqIFBhcmFtZXRlciBtYXBwaW5nIGlzIHVzZWQgdG8gcHJvdmlkZSBwcmUtY29uZGl0aW9ucyB0byByb3V0ZXNcbiAqIHdoaWNoIHVzZSBub3JtYWxpemVkIHBsYWNlaG9sZGVycy4gRm9yIGV4YW1wbGUgYSBfOnVzZXJfaWRfIHBhcmFtZXRlclxuICogY291bGQgYXV0b21hdGljYWxseSBsb2FkIGEgdXNlcidzIGluZm9ybWF0aW9uIGZyb20gdGhlIGRhdGFiYXNlIHdpdGhvdXRcbiAqIGFueSBhZGRpdGlvbmFsIGNvZGUsXG4gKlxuICogVGhlIGNhbGxiYWNrIHVzZXMgdGhlIHNhbWUgc2lnbmF0dXJlIGFzIG1pZGRsZXdhcmUsIHRoZSBvbmx5IGRpZmZlcmVuY2VcbiAqIGJlaW5nIHRoYXQgdGhlIHZhbHVlIG9mIHRoZSBwbGFjZWhvbGRlciBpcyBwYXNzZWQsIGluIHRoaXMgY2FzZSB0aGUgX2lkX1xuICogb2YgdGhlIHVzZXIuIE9uY2UgdGhlIGBuZXh0KClgIGZ1bmN0aW9uIGlzIGludm9rZWQsIGp1c3QgbGlrZSBtaWRkbGV3YXJlXG4gKiBpdCB3aWxsIGNvbnRpbnVlIG9uIHRvIGV4ZWN1dGUgdGhlIHJvdXRlLCBvciBzdWJzZXF1ZW50IHBhcmFtZXRlciBmdW5jdGlvbnMuXG4gKlxuICogSnVzdCBsaWtlIGluIG1pZGRsZXdhcmUsIHlvdSBtdXN0IGVpdGhlciByZXNwb25kIHRvIHRoZSByZXF1ZXN0IG9yIGNhbGwgbmV4dFxuICogdG8gYXZvaWQgc3RhbGxpbmcgdGhlIHJlcXVlc3QuXG4gKlxuICogIGFwcC5wYXJhbSgndXNlcl9pZCcsIGZ1bmN0aW9uKHJlcSwgcmVzLCBuZXh0LCBpZCl7XG4gKiAgICBVc2VyLmZpbmQoaWQsIGZ1bmN0aW9uKGVyciwgdXNlcil7XG4gKiAgICAgIGlmIChlcnIpIHtcbiAqICAgICAgICByZXR1cm4gbmV4dChlcnIpO1xuICogICAgICB9IGVsc2UgaWYgKCF1c2VyKSB7XG4gKiAgICAgICAgcmV0dXJuIG5leHQobmV3IEVycm9yKCdmYWlsZWQgdG8gbG9hZCB1c2VyJykpO1xuICogICAgICB9XG4gKiAgICAgIHJlcS51c2VyID0gdXNlcjtcbiAqICAgICAgbmV4dCgpO1xuICogICAgfSk7XG4gKiAgfSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHthcHB9IGZvciBjaGFpbmluZ1xuICogQHB1YmxpY1xuICovXG5cbnByb3RvLnBhcmFtID0gZnVuY3Rpb24gcGFyYW0obmFtZSwgZm4pIHtcbiAgLy8gcGFyYW0gbG9naWNcbiAgaWYgKHR5cGVvZiBuYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZGVwcmVjYXRlKCdyb3V0ZXIucGFyYW0oZm4pOiBSZWZhY3RvciB0byB1c2UgcGF0aCBwYXJhbXMnKTtcbiAgICB0aGlzLl9wYXJhbXMucHVzaChuYW1lKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBhcHBseSBwYXJhbSBmdW5jdGlvbnNcbiAgdmFyIHBhcmFtcyA9IHRoaXMuX3BhcmFtcztcbiAgdmFyIGxlbiA9IHBhcmFtcy5sZW5ndGg7XG4gIHZhciByZXQ7XG5cbiAgaWYgKG5hbWVbMF0gPT09ICc6Jykge1xuICAgIGRlcHJlY2F0ZSgncm91dGVyLnBhcmFtKCcgKyBKU09OLnN0cmluZ2lmeShuYW1lKSArICcsIGZuKTogVXNlIHJvdXRlci5wYXJhbSgnICsgSlNPTi5zdHJpbmdpZnkobmFtZS5zdWJzdHIoMSkpICsgJywgZm4pIGluc3RlYWQnKTtcbiAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHJldCA9IHBhcmFtc1tpXShuYW1lLCBmbikpIHtcbiAgICAgIGZuID0gcmV0O1xuICAgIH1cbiAgfVxuXG4gIC8vIGVuc3VyZSB3ZSBlbmQgdXAgd2l0aCBhXG4gIC8vIG1pZGRsZXdhcmUgZnVuY3Rpb25cbiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBmbikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwYXJhbSgpIGNhbGwgZm9yICcgKyBuYW1lICsgJywgZ290ICcgKyBmbik7XG4gIH1cblxuICAodGhpcy5wYXJhbXNbbmFtZV0gPSB0aGlzLnBhcmFtc1tuYW1lXSB8fCBbXSkucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcSwgcmVzIGludG8gdGhlIHJvdXRlci5cbiAqIEBwcml2YXRlXG4gKi9cblxucHJvdG8uaGFuZGxlID0gZnVuY3Rpb24gaGFuZGxlKHJlcSwgcmVzLCBvdXQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGRlYnVnKCdkaXNwYXRjaGluZyAlcyAlcycsIHJlcS5tZXRob2QsIHJlcS51cmwpO1xuXG4gIHZhciBpZHggPSAwO1xuICB2YXIgcHJvdG9ob3N0ID0gZ2V0UHJvdG9ob3N0KHJlcS51cmwpIHx8ICcnXG4gIHZhciByZW1vdmVkID0gJyc7XG4gIHZhciBzbGFzaEFkZGVkID0gZmFsc2U7XG4gIHZhciBwYXJhbWNhbGxlZCA9IHt9O1xuXG4gIC8vIHN0b3JlIG9wdGlvbnMgZm9yIE9QVElPTlMgcmVxdWVzdFxuICAvLyBvbmx5IHVzZWQgaWYgT1BUSU9OUyByZXF1ZXN0XG4gIHZhciBvcHRpb25zID0gW107XG5cbiAgLy8gbWlkZGxld2FyZSBhbmQgcm91dGVzXG4gIHZhciBzdGFjayA9IHNlbGYuc3RhY2s7XG5cbiAgLy8gbWFuYWdlIGludGVyLXJvdXRlciB2YXJpYWJsZXNcbiAgdmFyIHBhcmVudFBhcmFtcyA9IHJlcS5wYXJhbXM7XG4gIHZhciBwYXJlbnRVcmwgPSByZXEuYmFzZVVybCB8fCAnJztcbiAgdmFyIGRvbmUgPSByZXN0b3JlKG91dCwgcmVxLCAnYmFzZVVybCcsICduZXh0JywgJ3BhcmFtcycpO1xuXG4gIC8vIHNldHVwIG5leHQgbGF5ZXJcbiAgcmVxLm5leHQgPSBuZXh0O1xuXG4gIC8vIGZvciBvcHRpb25zIHJlcXVlc3RzLCByZXNwb25kIHdpdGggYSBkZWZhdWx0IGlmIG5vdGhpbmcgZWxzZSByZXNwb25kc1xuICBpZiAocmVxLm1ldGhvZCA9PT0gJ09QVElPTlMnKSB7XG4gICAgZG9uZSA9IHdyYXAoZG9uZSwgZnVuY3Rpb24ob2xkLCBlcnIpIHtcbiAgICAgIGlmIChlcnIgfHwgb3B0aW9ucy5sZW5ndGggPT09IDApIHJldHVybiBvbGQoZXJyKTtcbiAgICAgIHNlbmRPcHRpb25zUmVzcG9uc2UocmVzLCBvcHRpb25zLCBvbGQpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc2V0dXAgYmFzaWMgcmVxIHZhbHVlc1xuICByZXEuYmFzZVVybCA9IHBhcmVudFVybDtcbiAgcmVxLm9yaWdpbmFsVXJsID0gcmVxLm9yaWdpbmFsVXJsIHx8IHJlcS51cmw7XG5cbiAgbmV4dCgpO1xuXG4gIGZ1bmN0aW9uIG5leHQoZXJyKSB7XG4gICAgdmFyIGxheWVyRXJyb3IgPSBlcnIgPT09ICdyb3V0ZSdcbiAgICAgID8gbnVsbFxuICAgICAgOiBlcnI7XG5cbiAgICAvLyByZW1vdmUgYWRkZWQgc2xhc2hcbiAgICBpZiAoc2xhc2hBZGRlZCkge1xuICAgICAgcmVxLnVybCA9IHJlcS51cmwuc3Vic3RyKDEpO1xuICAgICAgc2xhc2hBZGRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIHJlc3RvcmUgYWx0ZXJlZCByZXEudXJsXG4gICAgaWYgKHJlbW92ZWQubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXEuYmFzZVVybCA9IHBhcmVudFVybDtcbiAgICAgIHJlcS51cmwgPSBwcm90b2hvc3QgKyByZW1vdmVkICsgcmVxLnVybC5zdWJzdHIocHJvdG9ob3N0Lmxlbmd0aCk7XG4gICAgICByZW1vdmVkID0gJyc7XG4gICAgfVxuXG4gICAgLy8gc2lnbmFsIHRvIGV4aXQgcm91dGVyXG4gICAgaWYgKGxheWVyRXJyb3IgPT09ICdyb3V0ZXInKSB7XG4gICAgICBzZXRJbW1lZGlhdGUoZG9uZSwgbnVsbClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIG5vIG1vcmUgbWF0Y2hpbmcgbGF5ZXJzXG4gICAgaWYgKGlkeCA+PSBzdGFjay5sZW5ndGgpIHtcbiAgICAgIHNldEltbWVkaWF0ZShkb25lLCBsYXllckVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBnZXQgcGF0aG5hbWUgb2YgcmVxdWVzdFxuICAgIHZhciBwYXRoID0gZ2V0UGF0aG5hbWUocmVxKTtcblxuICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgIHJldHVybiBkb25lKGxheWVyRXJyb3IpO1xuICAgIH1cblxuICAgIC8vIGZpbmQgbmV4dCBtYXRjaGluZyBsYXllclxuICAgIHZhciBsYXllcjtcbiAgICB2YXIgbWF0Y2g7XG4gICAgdmFyIHJvdXRlO1xuXG4gICAgd2hpbGUgKG1hdGNoICE9PSB0cnVlICYmIGlkeCA8IHN0YWNrLmxlbmd0aCkge1xuICAgICAgbGF5ZXIgPSBzdGFja1tpZHgrK107XG4gICAgICBtYXRjaCA9IG1hdGNoTGF5ZXIobGF5ZXIsIHBhdGgpO1xuICAgICAgcm91dGUgPSBsYXllci5yb3V0ZTtcblxuICAgICAgaWYgKHR5cGVvZiBtYXRjaCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIC8vIGhvbGQgb24gdG8gbGF5ZXJFcnJvclxuICAgICAgICBsYXllckVycm9yID0gbGF5ZXJFcnJvciB8fCBtYXRjaDtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoICE9PSB0cnVlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJvdXRlKSB7XG4gICAgICAgIC8vIHByb2Nlc3Mgbm9uLXJvdXRlIGhhbmRsZXJzIG5vcm1hbGx5XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobGF5ZXJFcnJvcikge1xuICAgICAgICAvLyByb3V0ZXMgZG8gbm90IG1hdGNoIHdpdGggYSBwZW5kaW5nIGVycm9yXG4gICAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWV0aG9kID0gcmVxLm1ldGhvZDtcbiAgICAgIHZhciBoYXNfbWV0aG9kID0gcm91dGUuX2hhbmRsZXNfbWV0aG9kKG1ldGhvZCk7XG5cbiAgICAgIC8vIGJ1aWxkIHVwIGF1dG9tYXRpYyBvcHRpb25zIHJlc3BvbnNlXG4gICAgICBpZiAoIWhhc19tZXRob2QgJiYgbWV0aG9kID09PSAnT1BUSU9OUycpIHtcbiAgICAgICAgYXBwZW5kTWV0aG9kcyhvcHRpb25zLCByb3V0ZS5fb3B0aW9ucygpKTtcbiAgICAgIH1cblxuICAgICAgLy8gZG9uJ3QgZXZlbiBib3RoZXIgbWF0Y2hpbmcgcm91dGVcbiAgICAgIGlmICghaGFzX21ldGhvZCAmJiBtZXRob2QgIT09ICdIRUFEJykge1xuICAgICAgICBtYXRjaCA9IGZhbHNlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBubyBtYXRjaFxuICAgIGlmIChtYXRjaCAhPT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGRvbmUobGF5ZXJFcnJvcik7XG4gICAgfVxuXG4gICAgLy8gc3RvcmUgcm91dGUgZm9yIGRpc3BhdGNoIG9uIGNoYW5nZVxuICAgIGlmIChyb3V0ZSkge1xuICAgICAgcmVxLnJvdXRlID0gcm91dGU7XG4gICAgfVxuXG4gICAgLy8gQ2FwdHVyZSBvbmUtdGltZSBsYXllciB2YWx1ZXNcbiAgICByZXEucGFyYW1zID0gc2VsZi5tZXJnZVBhcmFtc1xuICAgICAgPyBtZXJnZVBhcmFtcyhsYXllci5wYXJhbXMsIHBhcmVudFBhcmFtcylcbiAgICAgIDogbGF5ZXIucGFyYW1zO1xuICAgIHZhciBsYXllclBhdGggPSBsYXllci5wYXRoO1xuXG4gICAgLy8gdGhpcyBzaG91bGQgYmUgZG9uZSBmb3IgdGhlIGxheWVyXG4gICAgc2VsZi5wcm9jZXNzX3BhcmFtcyhsYXllciwgcGFyYW1jYWxsZWQsIHJlcSwgcmVzLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBuZXh0KGxheWVyRXJyb3IgfHwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJvdXRlKSB7XG4gICAgICAgIHJldHVybiBsYXllci5oYW5kbGVfcmVxdWVzdChyZXEsIHJlcywgbmV4dCk7XG4gICAgICB9XG5cbiAgICAgIHRyaW1fcHJlZml4KGxheWVyLCBsYXllckVycm9yLCBsYXllclBhdGgsIHBhdGgpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJpbV9wcmVmaXgobGF5ZXIsIGxheWVyRXJyb3IsIGxheWVyUGF0aCwgcGF0aCkge1xuICAgIGlmIChsYXllclBhdGgubGVuZ3RoICE9PSAwKSB7XG4gICAgICAvLyBWYWxpZGF0ZSBwYXRoIGJyZWFrcyBvbiBhIHBhdGggc2VwYXJhdG9yXG4gICAgICB2YXIgYyA9IHBhdGhbbGF5ZXJQYXRoLmxlbmd0aF1cbiAgICAgIGlmIChjICYmIGMgIT09ICcvJyAmJiBjICE9PSAnLicpIHJldHVybiBuZXh0KGxheWVyRXJyb3IpXG5cbiAgICAgIC8vIFRyaW0gb2ZmIHRoZSBwYXJ0IG9mIHRoZSB1cmwgdGhhdCBtYXRjaGVzIHRoZSByb3V0ZVxuICAgICAgLy8gbWlkZGxld2FyZSAoLnVzZSBzdHVmZikgbmVlZHMgdG8gaGF2ZSB0aGUgcGF0aCBzdHJpcHBlZFxuICAgICAgZGVidWcoJ3RyaW0gcHJlZml4ICglcykgZnJvbSB1cmwgJXMnLCBsYXllclBhdGgsIHJlcS51cmwpO1xuICAgICAgcmVtb3ZlZCA9IGxheWVyUGF0aDtcbiAgICAgIHJlcS51cmwgPSBwcm90b2hvc3QgKyByZXEudXJsLnN1YnN0cihwcm90b2hvc3QubGVuZ3RoICsgcmVtb3ZlZC5sZW5ndGgpO1xuXG4gICAgICAvLyBFbnN1cmUgbGVhZGluZyBzbGFzaFxuICAgICAgaWYgKCFwcm90b2hvc3QgJiYgcmVxLnVybFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlcS51cmwgPSAnLycgKyByZXEudXJsO1xuICAgICAgICBzbGFzaEFkZGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0dXAgYmFzZSBVUkwgKG5vIHRyYWlsaW5nIHNsYXNoKVxuICAgICAgcmVxLmJhc2VVcmwgPSBwYXJlbnRVcmwgKyAocmVtb3ZlZFtyZW1vdmVkLmxlbmd0aCAtIDFdID09PSAnLydcbiAgICAgICAgPyByZW1vdmVkLnN1YnN0cmluZygwLCByZW1vdmVkLmxlbmd0aCAtIDEpXG4gICAgICAgIDogcmVtb3ZlZCk7XG4gICAgfVxuXG4gICAgZGVidWcoJyVzICVzIDogJXMnLCBsYXllci5uYW1lLCBsYXllclBhdGgsIHJlcS5vcmlnaW5hbFVybCk7XG5cbiAgICBpZiAobGF5ZXJFcnJvcikge1xuICAgICAgbGF5ZXIuaGFuZGxlX2Vycm9yKGxheWVyRXJyb3IsIHJlcSwgcmVzLCBuZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5ZXIuaGFuZGxlX3JlcXVlc3QocmVxLCByZXMsIG5leHQpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBQcm9jZXNzIGFueSBwYXJhbWV0ZXJzIGZvciB0aGUgbGF5ZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnByb3RvLnByb2Nlc3NfcGFyYW1zID0gZnVuY3Rpb24gcHJvY2Vzc19wYXJhbXMobGF5ZXIsIGNhbGxlZCwgcmVxLCByZXMsIGRvbmUpIHtcbiAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuXG4gIC8vIGNhcHR1cmVkIHBhcmFtZXRlcnMgZnJvbSB0aGUgbGF5ZXIsIGtleXMgYW5kIHZhbHVlc1xuICB2YXIga2V5cyA9IGxheWVyLmtleXM7XG5cbiAgLy8gZmFzdCB0cmFja1xuICBpZiAoIWtleXMgfHwga2V5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZG9uZSgpO1xuICB9XG5cbiAgdmFyIGkgPSAwO1xuICB2YXIgbmFtZTtcbiAgdmFyIHBhcmFtSW5kZXggPSAwO1xuICB2YXIga2V5O1xuICB2YXIgcGFyYW1WYWw7XG4gIHZhciBwYXJhbUNhbGxiYWNrcztcbiAgdmFyIHBhcmFtQ2FsbGVkO1xuXG4gIC8vIHByb2Nlc3MgcGFyYW1zIGluIG9yZGVyXG4gIC8vIHBhcmFtIGNhbGxiYWNrcyBjYW4gYmUgYXN5bmNcbiAgZnVuY3Rpb24gcGFyYW0oZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICB9XG5cbiAgICBpZiAoaSA+PSBrZXlzLmxlbmd0aCApIHtcbiAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuXG4gICAgcGFyYW1JbmRleCA9IDA7XG4gICAga2V5ID0ga2V5c1tpKytdO1xuICAgIG5hbWUgPSBrZXkubmFtZTtcbiAgICBwYXJhbVZhbCA9IHJlcS5wYXJhbXNbbmFtZV07XG4gICAgcGFyYW1DYWxsYmFja3MgPSBwYXJhbXNbbmFtZV07XG4gICAgcGFyYW1DYWxsZWQgPSBjYWxsZWRbbmFtZV07XG5cbiAgICBpZiAocGFyYW1WYWwgPT09IHVuZGVmaW5lZCB8fCAhcGFyYW1DYWxsYmFja3MpIHtcbiAgICAgIHJldHVybiBwYXJhbSgpO1xuICAgIH1cblxuICAgIC8vIHBhcmFtIHByZXZpb3VzbHkgY2FsbGVkIHdpdGggc2FtZSB2YWx1ZSBvciBlcnJvciBvY2N1cnJlZFxuICAgIGlmIChwYXJhbUNhbGxlZCAmJiAocGFyYW1DYWxsZWQubWF0Y2ggPT09IHBhcmFtVmFsXG4gICAgICB8fCAocGFyYW1DYWxsZWQuZXJyb3IgJiYgcGFyYW1DYWxsZWQuZXJyb3IgIT09ICdyb3V0ZScpKSkge1xuICAgICAgLy8gcmVzdG9yZSB2YWx1ZVxuICAgICAgcmVxLnBhcmFtc1tuYW1lXSA9IHBhcmFtQ2FsbGVkLnZhbHVlO1xuXG4gICAgICAvLyBuZXh0IHBhcmFtXG4gICAgICByZXR1cm4gcGFyYW0ocGFyYW1DYWxsZWQuZXJyb3IpO1xuICAgIH1cblxuICAgIGNhbGxlZFtuYW1lXSA9IHBhcmFtQ2FsbGVkID0ge1xuICAgICAgZXJyb3I6IG51bGwsXG4gICAgICBtYXRjaDogcGFyYW1WYWwsXG4gICAgICB2YWx1ZTogcGFyYW1WYWxcbiAgICB9O1xuXG4gICAgcGFyYW1DYWxsYmFjaygpO1xuICB9XG5cbiAgLy8gc2luZ2xlIHBhcmFtIGNhbGxiYWNrc1xuICBmdW5jdGlvbiBwYXJhbUNhbGxiYWNrKGVycikge1xuICAgIHZhciBmbiA9IHBhcmFtQ2FsbGJhY2tzW3BhcmFtSW5kZXgrK107XG5cbiAgICAvLyBzdG9yZSB1cGRhdGVkIHZhbHVlXG4gICAgcGFyYW1DYWxsZWQudmFsdWUgPSByZXEucGFyYW1zW2tleS5uYW1lXTtcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIC8vIHN0b3JlIGVycm9yXG4gICAgICBwYXJhbUNhbGxlZC5lcnJvciA9IGVycjtcbiAgICAgIHBhcmFtKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFmbikgcmV0dXJuIHBhcmFtKCk7XG5cbiAgICB0cnkge1xuICAgICAgZm4ocmVxLCByZXMsIHBhcmFtQ2FsbGJhY2ssIHBhcmFtVmFsLCBrZXkubmFtZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcGFyYW1DYWxsYmFjayhlKTtcbiAgICB9XG4gIH1cblxuICBwYXJhbSgpO1xufTtcblxuLyoqXG4gKiBVc2UgdGhlIGdpdmVuIG1pZGRsZXdhcmUgZnVuY3Rpb24sIHdpdGggb3B0aW9uYWwgcGF0aCwgZGVmYXVsdGluZyB0byBcIi9cIi5cbiAqXG4gKiBVc2UgKGxpa2UgYC5hbGxgKSB3aWxsIHJ1biBmb3IgYW55IGh0dHAgTUVUSE9ELCBidXQgaXQgd2lsbCBub3QgYWRkXG4gKiBoYW5kbGVycyBmb3IgdGhvc2UgbWV0aG9kcyBzbyBPUFRJT05TIHJlcXVlc3RzIHdpbGwgbm90IGNvbnNpZGVyIGAudXNlYFxuICogZnVuY3Rpb25zIGV2ZW4gaWYgdGhleSBjb3VsZCByZXNwb25kLlxuICpcbiAqIFRoZSBvdGhlciBkaWZmZXJlbmNlIGlzIHRoYXQgX3JvdXRlXyBwYXRoIGlzIHN0cmlwcGVkIGFuZCBub3QgdmlzaWJsZVxuICogdG8gdGhlIGhhbmRsZXIgZnVuY3Rpb24uIFRoZSBtYWluIGVmZmVjdCBvZiB0aGlzIGZlYXR1cmUgaXMgdGhhdCBtb3VudGVkXG4gKiBoYW5kbGVycyBjYW4gb3BlcmF0ZSB3aXRob3V0IGFueSBjb2RlIGNoYW5nZXMgcmVnYXJkbGVzcyBvZiB0aGUgXCJwcmVmaXhcIlxuICogcGF0aG5hbWUuXG4gKlxuICogQHB1YmxpY1xuICovXG5cbnByb3RvLnVzZSA9IGZ1bmN0aW9uIHVzZShmbikge1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdmFyIHBhdGggPSAnLyc7XG5cbiAgLy8gZGVmYXVsdCBwYXRoIHRvICcvJ1xuICAvLyBkaXNhbWJpZ3VhdGUgcm91dGVyLnVzZShbZm5dKVxuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGFyZyA9IGZuO1xuXG4gICAgd2hpbGUgKEFycmF5LmlzQXJyYXkoYXJnKSAmJiBhcmcubGVuZ3RoICE9PSAwKSB7XG4gICAgICBhcmcgPSBhcmdbMF07XG4gICAgfVxuXG4gICAgLy8gZmlyc3QgYXJnIGlzIHRoZSBwYXRoXG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9mZnNldCA9IDE7XG4gICAgICBwYXRoID0gZm47XG4gICAgfVxuICB9XG5cbiAgdmFyIGNhbGxiYWNrcyA9IGZsYXR0ZW4oc2xpY2UuY2FsbChhcmd1bWVudHMsIG9mZnNldCkpO1xuXG4gIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUm91dGVyLnVzZSgpIHJlcXVpcmVzIGEgbWlkZGxld2FyZSBmdW5jdGlvbicpXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmbiA9IGNhbGxiYWNrc1tpXTtcblxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JvdXRlci51c2UoKSByZXF1aXJlcyBhIG1pZGRsZXdhcmUgZnVuY3Rpb24gYnV0IGdvdCBhICcgKyBnZXR0eXBlKGZuKSlcbiAgICB9XG5cbiAgICAvLyBhZGQgdGhlIG1pZGRsZXdhcmVcbiAgICBkZWJ1ZygndXNlICVvICVzJywgcGF0aCwgZm4ubmFtZSB8fCAnPGFub255bW91cz4nKVxuXG4gICAgdmFyIGxheWVyID0gbmV3IExheWVyKHBhdGgsIHtcbiAgICAgIHNlbnNpdGl2ZTogdGhpcy5jYXNlU2Vuc2l0aXZlLFxuICAgICAgc3RyaWN0OiBmYWxzZSxcbiAgICAgIGVuZDogZmFsc2VcbiAgICB9LCBmbik7XG5cbiAgICBsYXllci5yb3V0ZSA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuc3RhY2sucHVzaChsYXllcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IFJvdXRlIGZvciB0aGUgZ2l2ZW4gcGF0aC5cbiAqXG4gKiBFYWNoIHJvdXRlIGNvbnRhaW5zIGEgc2VwYXJhdGUgbWlkZGxld2FyZSBzdGFjayBhbmQgVkVSQiBoYW5kbGVycy5cbiAqXG4gKiBTZWUgdGhlIFJvdXRlIGFwaSBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzIG9uIGFkZGluZyBoYW5kbGVyc1xuICogYW5kIG1pZGRsZXdhcmUgdG8gcm91dGVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtSb3V0ZX1cbiAqIEBwdWJsaWNcbiAqL1xuXG5wcm90by5yb3V0ZSA9IGZ1bmN0aW9uIHJvdXRlKHBhdGgpIHtcbiAgdmFyIHJvdXRlID0gbmV3IFJvdXRlKHBhdGgpO1xuXG4gIHZhciBsYXllciA9IG5ldyBMYXllcihwYXRoLCB7XG4gICAgc2Vuc2l0aXZlOiB0aGlzLmNhc2VTZW5zaXRpdmUsXG4gICAgc3RyaWN0OiB0aGlzLnN0cmljdCxcbiAgICBlbmQ6IHRydWVcbiAgfSwgcm91dGUuZGlzcGF0Y2guYmluZChyb3V0ZSkpO1xuXG4gIGxheWVyLnJvdXRlID0gcm91dGU7XG5cbiAgdGhpcy5zdGFjay5wdXNoKGxheWVyKTtcbiAgcmV0dXJuIHJvdXRlO1xufTtcblxuLy8gY3JlYXRlIFJvdXRlciNWRVJCIGZ1bmN0aW9uc1xubWV0aG9kcy5jb25jYXQoJ2FsbCcpLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKXtcbiAgcHJvdG9bbWV0aG9kXSA9IGZ1bmN0aW9uKHBhdGgpe1xuICAgIHZhciByb3V0ZSA9IHRoaXMucm91dGUocGF0aClcbiAgICByb3V0ZVttZXRob2RdLmFwcGx5KHJvdXRlLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xufSk7XG5cbi8vIGFwcGVuZCBtZXRob2RzIHRvIGEgbGlzdCBvZiBtZXRob2RzXG5mdW5jdGlvbiBhcHBlbmRNZXRob2RzKGxpc3QsIGFkZGl0aW9uKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWRkaXRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWV0aG9kID0gYWRkaXRpb25baV07XG4gICAgaWYgKGxpc3QuaW5kZXhPZihtZXRob2QpID09PSAtMSkge1xuICAgICAgbGlzdC5wdXNoKG1ldGhvZCk7XG4gICAgfVxuICB9XG59XG5cbi8vIGdldCBwYXRobmFtZSBvZiByZXF1ZXN0XG5mdW5jdGlvbiBnZXRQYXRobmFtZShyZXEpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcGFyc2VVcmwocmVxKS5wYXRobmFtZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vLyBHZXQgZ2V0IHByb3RvY29sICsgaG9zdCBmb3IgYSBVUkxcbmZ1bmN0aW9uIGdldFByb3RvaG9zdCh1cmwpIHtcbiAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnIHx8IHVybC5sZW5ndGggPT09IDAgfHwgdXJsWzBdID09PSAnLycpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICB2YXIgc2VhcmNoSW5kZXggPSB1cmwuaW5kZXhPZignPycpXG4gIHZhciBwYXRoTGVuZ3RoID0gc2VhcmNoSW5kZXggIT09IC0xXG4gICAgPyBzZWFyY2hJbmRleFxuICAgIDogdXJsLmxlbmd0aFxuICB2YXIgZnFkbkluZGV4ID0gdXJsLnN1YnN0cigwLCBwYXRoTGVuZ3RoKS5pbmRleE9mKCc6Ly8nKVxuXG4gIHJldHVybiBmcWRuSW5kZXggIT09IC0xXG4gICAgPyB1cmwuc3Vic3RyKDAsIHVybC5pbmRleE9mKCcvJywgMyArIGZxZG5JbmRleCkpXG4gICAgOiB1bmRlZmluZWRcbn1cblxuLy8gZ2V0IHR5cGUgZm9yIGVycm9yIG1lc3NhZ2VcbmZ1bmN0aW9uIGdldHR5cGUob2JqKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIG9iajtcblxuICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIC8vIGluc3BlY3QgW1tDbGFzc11dIGZvciBvYmplY3RzXG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iailcbiAgICAucmVwbGFjZShvYmplY3RSZWdFeHAsICckMScpO1xufVxuXG4vKipcbiAqIE1hdGNoIHBhdGggdG8gYSBsYXllci5cbiAqXG4gKiBAcGFyYW0ge0xheWVyfSBsYXllclxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWF0Y2hMYXllcihsYXllciwgcGF0aCkge1xuICB0cnkge1xuICAgIHJldHVybiBsYXllci5tYXRjaChwYXRoKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxufVxuXG4vLyBtZXJnZSBwYXJhbXMgd2l0aCBwYXJlbnQgcGFyYW1zXG5mdW5jdGlvbiBtZXJnZVBhcmFtcyhwYXJhbXMsIHBhcmVudCkge1xuICBpZiAodHlwZW9mIHBhcmVudCAhPT0gJ29iamVjdCcgfHwgIXBhcmVudCkge1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvLyBtYWtlIGNvcHkgb2YgcGFyZW50IGZvciBiYXNlXG4gIHZhciBvYmogPSBtaXhpbih7fSwgcGFyZW50KTtcblxuICAvLyBzaW1wbGUgbm9uLW51bWVyaWMgbWVyZ2luZ1xuICBpZiAoISgwIGluIHBhcmFtcykgfHwgISgwIGluIHBhcmVudCkpIHtcbiAgICByZXR1cm4gbWl4aW4ob2JqLCBwYXJhbXMpO1xuICB9XG5cbiAgdmFyIGkgPSAwO1xuICB2YXIgbyA9IDA7XG5cbiAgLy8gZGV0ZXJtaW5lIG51bWVyaWMgZ2Fwc1xuICB3aGlsZSAoaSBpbiBwYXJhbXMpIHtcbiAgICBpKys7XG4gIH1cblxuICB3aGlsZSAobyBpbiBwYXJlbnQpIHtcbiAgICBvKys7XG4gIH1cblxuICAvLyBvZmZzZXQgbnVtZXJpYyBpbmRpY2VzIGluIHBhcmFtcyBiZWZvcmUgbWVyZ2VcbiAgZm9yIChpLS07IGkgPj0gMDsgaS0tKSB7XG4gICAgcGFyYW1zW2kgKyBvXSA9IHBhcmFtc1tpXTtcblxuICAgIC8vIGNyZWF0ZSBob2xlcyBmb3IgdGhlIG1lcmdlIHdoZW4gbmVjZXNzYXJ5XG4gICAgaWYgKGkgPCBvKSB7XG4gICAgICBkZWxldGUgcGFyYW1zW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtaXhpbihvYmosIHBhcmFtcyk7XG59XG5cbi8vIHJlc3RvcmUgb2JqIHByb3BzIGFmdGVyIGZ1bmN0aW9uXG5mdW5jdGlvbiByZXN0b3JlKGZuLCBvYmopIHtcbiAgdmFyIHByb3BzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAyKTtcbiAgdmFyIHZhbHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDIpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBwcm9wc1tpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgdmFsc1tpXSA9IG9ialtwcm9wc1tpXV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIC8vIHJlc3RvcmUgdmFsc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9ialtwcm9wc1tpXV0gPSB2YWxzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vLyBzZW5kIGFuIE9QVElPTlMgcmVzcG9uc2VcbmZ1bmN0aW9uIHNlbmRPcHRpb25zUmVzcG9uc2UocmVzLCBvcHRpb25zLCBuZXh0KSB7XG4gIHRyeSB7XG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmpvaW4oJywnKTtcbiAgICByZXMuc2V0KCdBbGxvdycsIGJvZHkpO1xuICAgIHJlcy5zZW5kKGJvZHkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBuZXh0KGVycik7XG4gIH1cbn1cblxuLy8gd3JhcCBhIGZ1bmN0aW9uXG5mdW5jdGlvbiB3cmFwKG9sZCwgZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByb3h5KCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggKyAxKTtcblxuICAgIGFyZ3NbMF0gPSBvbGQ7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpICsgMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgZm4uYXBwbHkodGhpcywgYXJncyk7XG4gIH07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9leHByZXNzL2xpYi9yb3V0ZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogZXhwcmVzc1xuICogQ29weXJpZ2h0KGMpIDIwMDktMjAxMyBUSiBIb2xvd2F5Y2h1a1xuICogQ29weXJpZ2h0KGMpIDIwMTMgUm9tYW4gU2h0eWxtYW5cbiAqIENvcHlyaWdodChjKSAyMDE0LTIwMTUgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdleHByZXNzOnJvdXRlcjpyb3V0ZScpO1xudmFyIGZsYXR0ZW4gPSByZXF1aXJlKCdhcnJheS1mbGF0dGVuJyk7XG52YXIgTGF5ZXIgPSByZXF1aXJlKCcuL2xheWVyJyk7XG52YXIgbWV0aG9kcyA9IHJlcXVpcmUoJ21ldGhvZHMnKTtcblxuLyoqXG4gKiBNb2R1bGUgdmFyaWFibGVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUm91dGU7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBgUm91dGVgIHdpdGggdGhlIGdpdmVuIGBwYXRoYCxcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJvdXRlKHBhdGgpIHtcbiAgdGhpcy5wYXRoID0gcGF0aDtcbiAgdGhpcy5zdGFjayA9IFtdO1xuXG4gIGRlYnVnKCduZXcgJW8nLCBwYXRoKVxuXG4gIC8vIHJvdXRlIGhhbmRsZXJzIGZvciB2YXJpb3VzIGh0dHAgbWV0aG9kc1xuICB0aGlzLm1ldGhvZHMgPSB7fTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIHJvdXRlIGhhbmRsZXMgYSBnaXZlbiBtZXRob2QuXG4gKiBAcHJpdmF0ZVxuICovXG5cblJvdXRlLnByb3RvdHlwZS5faGFuZGxlc19tZXRob2QgPSBmdW5jdGlvbiBfaGFuZGxlc19tZXRob2QobWV0aG9kKSB7XG4gIGlmICh0aGlzLm1ldGhvZHMuX2FsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIG5hbWUgPSBtZXRob2QudG9Mb3dlckNhc2UoKTtcblxuICBpZiAobmFtZSA9PT0gJ2hlYWQnICYmICF0aGlzLm1ldGhvZHNbJ2hlYWQnXSkge1xuICAgIG5hbWUgPSAnZ2V0JztcbiAgfVxuXG4gIHJldHVybiBCb29sZWFuKHRoaXMubWV0aG9kc1tuYW1lXSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge0FycmF5fSBzdXBwb3J0ZWQgSFRUUCBtZXRob2RzXG4gKiBAcHJpdmF0ZVxuICovXG5cblJvdXRlLnByb3RvdHlwZS5fb3B0aW9ucyA9IGZ1bmN0aW9uIF9vcHRpb25zKCkge1xuICB2YXIgbWV0aG9kcyA9IE9iamVjdC5rZXlzKHRoaXMubWV0aG9kcyk7XG5cbiAgLy8gYXBwZW5kIGF1dG9tYXRpYyBoZWFkXG4gIGlmICh0aGlzLm1ldGhvZHMuZ2V0ICYmICF0aGlzLm1ldGhvZHMuaGVhZCkge1xuICAgIG1ldGhvZHMucHVzaCgnaGVhZCcpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gbWFrZSB1cHBlciBjYXNlXG4gICAgbWV0aG9kc1tpXSA9IG1ldGhvZHNbaV0udG9VcHBlckNhc2UoKTtcbiAgfVxuXG4gIHJldHVybiBtZXRob2RzO1xufTtcblxuLyoqXG4gKiBkaXNwYXRjaCByZXEsIHJlcyBpbnRvIHRoaXMgcm91dGVcbiAqIEBwcml2YXRlXG4gKi9cblxuUm91dGUucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gZGlzcGF0Y2gocmVxLCByZXMsIGRvbmUpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBzdGFjayA9IHRoaXMuc3RhY2s7XG4gIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZG9uZSgpO1xuICB9XG5cbiAgdmFyIG1ldGhvZCA9IHJlcS5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgaWYgKG1ldGhvZCA9PT0gJ2hlYWQnICYmICF0aGlzLm1ldGhvZHNbJ2hlYWQnXSkge1xuICAgIG1ldGhvZCA9ICdnZXQnO1xuICB9XG5cbiAgcmVxLnJvdXRlID0gdGhpcztcblxuICBuZXh0KCk7XG5cbiAgZnVuY3Rpb24gbmV4dChlcnIpIHtcbiAgICAvLyBzaWduYWwgdG8gZXhpdCByb3V0ZVxuICAgIGlmIChlcnIgJiYgZXJyID09PSAncm91dGUnKSB7XG4gICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cblxuICAgIC8vIHNpZ25hbCB0byBleGl0IHJvdXRlclxuICAgIGlmIChlcnIgJiYgZXJyID09PSAncm91dGVyJykge1xuICAgICAgcmV0dXJuIGRvbmUoZXJyKVxuICAgIH1cblxuICAgIHZhciBsYXllciA9IHN0YWNrW2lkeCsrXTtcbiAgICBpZiAoIWxheWVyKSB7XG4gICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgIH1cblxuICAgIGlmIChsYXllci5tZXRob2QgJiYgbGF5ZXIubWV0aG9kICE9PSBtZXRob2QpIHtcbiAgICAgIHJldHVybiBuZXh0KGVycik7XG4gICAgfVxuXG4gICAgaWYgKGVycikge1xuICAgICAgbGF5ZXIuaGFuZGxlX2Vycm9yKGVyciwgcmVxLCByZXMsIG5leHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXllci5oYW5kbGVfcmVxdWVzdChyZXEsIHJlcywgbmV4dCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEFkZCBhIGhhbmRsZXIgZm9yIGFsbCBIVFRQIHZlcmJzIHRvIHRoaXMgcm91dGUuXG4gKlxuICogQmVoYXZlcyBqdXN0IGxpa2UgbWlkZGxld2FyZSBhbmQgY2FuIHJlc3BvbmQgb3IgY2FsbCBgbmV4dGBcbiAqIHRvIGNvbnRpbnVlIHByb2Nlc3NpbmcuXG4gKlxuICogWW91IGNhbiB1c2UgbXVsdGlwbGUgYC5hbGxgIGNhbGwgdG8gYWRkIG11bHRpcGxlIGhhbmRsZXJzLlxuICpcbiAqICAgZnVuY3Rpb24gY2hlY2tfc29tZXRoaW5nKHJlcSwgcmVzLCBuZXh0KXtcbiAqICAgICBuZXh0KCk7XG4gKiAgIH07XG4gKlxuICogICBmdW5jdGlvbiB2YWxpZGF0ZV91c2VyKHJlcSwgcmVzLCBuZXh0KXtcbiAqICAgICBuZXh0KCk7XG4gKiAgIH07XG4gKlxuICogICByb3V0ZVxuICogICAuYWxsKHZhbGlkYXRlX3VzZXIpXG4gKiAgIC5hbGwoY2hlY2tfc29tZXRoaW5nKVxuICogICAuZ2V0KGZ1bmN0aW9uKHJlcSwgcmVzLCBuZXh0KXtcbiAqICAgICByZXMuc2VuZCgnaGVsbG8gd29ybGQnKTtcbiAqICAgfSk7XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlclxuICogQHJldHVybiB7Um91dGV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Sb3V0ZS5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gYWxsKCkge1xuICB2YXIgaGFuZGxlcyA9IGZsYXR0ZW4oc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaGFuZGxlID0gaGFuZGxlc1tpXTtcblxuICAgIGlmICh0eXBlb2YgaGFuZGxlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdHlwZSA9IHRvU3RyaW5nLmNhbGwoaGFuZGxlKTtcbiAgICAgIHZhciBtc2cgPSAnUm91dGUuYWxsKCkgcmVxdWlyZXMgYSBjYWxsYmFjayBmdW5jdGlvbiBidXQgZ290IGEgJyArIHR5cGVcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobXNnKTtcbiAgICB9XG5cbiAgICB2YXIgbGF5ZXIgPSBMYXllcignLycsIHt9LCBoYW5kbGUpO1xuICAgIGxheWVyLm1ldGhvZCA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMubWV0aG9kcy5fYWxsID0gdHJ1ZTtcbiAgICB0aGlzLnN0YWNrLnB1c2gobGF5ZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5tZXRob2RzLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKXtcbiAgUm91dGUucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbigpe1xuICAgIHZhciBoYW5kbGVzID0gZmxhdHRlbihzbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGFuZGxlID0gaGFuZGxlc1tpXTtcblxuICAgICAgaWYgKHR5cGVvZiBoYW5kbGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0b1N0cmluZy5jYWxsKGhhbmRsZSk7XG4gICAgICAgIHZhciBtc2cgPSAnUm91dGUuJyArIG1ldGhvZCArICcoKSByZXF1aXJlcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIGJ1dCBnb3QgYSAnICsgdHlwZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH1cblxuICAgICAgZGVidWcoJyVzICVvJywgbWV0aG9kLCB0aGlzLnBhdGgpXG5cbiAgICAgIHZhciBsYXllciA9IExheWVyKCcvJywge30sIGhhbmRsZSk7XG4gICAgICBsYXllci5tZXRob2QgPSBtZXRob2Q7XG5cbiAgICAgIHRoaXMubWV0aG9kc1ttZXRob2RdID0gdHJ1ZTtcbiAgICAgIHRoaXMuc3RhY2sucHVzaChsYXllcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2V4cHJlc3MvbGliL3JvdXRlci9yb3V0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBleHByZXNzXG4gKiBDb3B5cmlnaHQoYykgMjAwOS0yMDEzIFRKIEhvbG93YXljaHVrXG4gKiBDb3B5cmlnaHQoYykgMjAxMyBSb21hbiBTaHR5bG1hblxuICogQ29weXJpZ2h0KGMpIDIwMTQtMjAxNSBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBwYXRoUmVnZXhwID0gcmVxdWlyZSgncGF0aC10by1yZWdleHAnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2V4cHJlc3M6cm91dGVyOmxheWVyJyk7XG5cbi8qKlxuICogTW9kdWxlIHZhcmlhYmxlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IExheWVyO1xuXG5mdW5jdGlvbiBMYXllcihwYXRoLCBvcHRpb25zLCBmbikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTGF5ZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBMYXllcihwYXRoLCBvcHRpb25zLCBmbik7XG4gIH1cblxuICBkZWJ1ZygnbmV3ICVvJywgcGF0aClcbiAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRoaXMuaGFuZGxlID0gZm47XG4gIHRoaXMubmFtZSA9IGZuLm5hbWUgfHwgJzxhbm9ueW1vdXM+JztcbiAgdGhpcy5wYXJhbXMgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGF0aCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5yZWdleHAgPSBwYXRoUmVnZXhwKHBhdGgsIHRoaXMua2V5cyA9IFtdLCBvcHRzKTtcblxuICAvLyBzZXQgZmFzdCBwYXRoIGZsYWdzXG4gIHRoaXMucmVnZXhwLmZhc3Rfc3RhciA9IHBhdGggPT09ICcqJ1xuICB0aGlzLnJlZ2V4cC5mYXN0X3NsYXNoID0gcGF0aCA9PT0gJy8nICYmIG9wdHMuZW5kID09PSBmYWxzZVxufVxuXG4vKipcbiAqIEhhbmRsZSB0aGUgZXJyb3IgZm9yIHRoZSBsYXllci5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvclxuICogQHBhcmFtIHtSZXF1ZXN0fSByZXFcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gbmV4dFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTGF5ZXIucHJvdG90eXBlLmhhbmRsZV9lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZV9lcnJvcihlcnJvciwgcmVxLCByZXMsIG5leHQpIHtcbiAgdmFyIGZuID0gdGhpcy5oYW5kbGU7XG5cbiAgaWYgKGZuLmxlbmd0aCAhPT0gNCkge1xuICAgIC8vIG5vdCBhIHN0YW5kYXJkIGVycm9yIGhhbmRsZXJcbiAgICByZXR1cm4gbmV4dChlcnJvcik7XG4gIH1cblxuICB0cnkge1xuICAgIGZuKGVycm9yLCByZXEsIHJlcywgbmV4dCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIG5leHQoZXJyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGUgdGhlIHJlcXVlc3QgZm9yIHRoZSBsYXllci5cbiAqXG4gKiBAcGFyYW0ge1JlcXVlc3R9IHJlcVxuICogQHBhcmFtIHtSZXNwb25zZX0gcmVzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBuZXh0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5MYXllci5wcm90b3R5cGUuaGFuZGxlX3JlcXVlc3QgPSBmdW5jdGlvbiBoYW5kbGUocmVxLCByZXMsIG5leHQpIHtcbiAgdmFyIGZuID0gdGhpcy5oYW5kbGU7XG5cbiAgaWYgKGZuLmxlbmd0aCA+IDMpIHtcbiAgICAvLyBub3QgYSBzdGFuZGFyZCByZXF1ZXN0IGhhbmRsZXJcbiAgICByZXR1cm4gbmV4dCgpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBmbihyZXEsIHJlcywgbmV4dCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIG5leHQoZXJyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIHJvdXRlIG1hdGNoZXMgYHBhdGhgLCBpZiBzb1xuICogcG9wdWxhdGUgYC5wYXJhbXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTGF5ZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gbWF0Y2gocGF0aCkge1xuICB2YXIgbWF0Y2hcblxuICBpZiAocGF0aCAhPSBudWxsKSB7XG4gICAgLy8gZmFzdCBwYXRoIG5vbi1lbmRpbmcgbWF0Y2ggZm9yIC8gKGFueSBwYXRoIG1hdGNoZXMpXG4gICAgaWYgKHRoaXMucmVnZXhwLmZhc3Rfc2xhc2gpIHtcbiAgICAgIHRoaXMucGFyYW1zID0ge31cbiAgICAgIHRoaXMucGF0aCA9ICcnXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIGZhc3QgcGF0aCBmb3IgKiAoZXZlcnl0aGluZyBtYXRjaGVkIGluIGEgcGFyYW0pXG4gICAgaWYgKHRoaXMucmVnZXhwLmZhc3Rfc3Rhcikge1xuICAgICAgdGhpcy5wYXJhbXMgPSB7JzAnOiBkZWNvZGVfcGFyYW0ocGF0aCl9XG4gICAgICB0aGlzLnBhdGggPSBwYXRoXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIG1hdGNoIHRoZSBwYXRoXG4gICAgbWF0Y2ggPSB0aGlzLnJlZ2V4cC5leGVjKHBhdGgpXG4gIH1cblxuICBpZiAoIW1hdGNoKSB7XG4gICAgdGhpcy5wYXJhbXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYXRoID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIHN0b3JlIHZhbHVlc1xuICB0aGlzLnBhcmFtcyA9IHt9O1xuICB0aGlzLnBhdGggPSBtYXRjaFswXVxuXG4gIHZhciBrZXlzID0gdGhpcy5rZXlzO1xuICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBtYXRjaC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2kgLSAxXTtcbiAgICB2YXIgcHJvcCA9IGtleS5uYW1lO1xuICAgIHZhciB2YWwgPSBkZWNvZGVfcGFyYW0obWF0Y2hbaV0pXG5cbiAgICBpZiAodmFsICE9PSB1bmRlZmluZWQgfHwgIShoYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtcywgcHJvcCkpKSB7XG4gICAgICBwYXJhbXNbcHJvcF0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIERlY29kZSBwYXJhbSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlY29kZV9wYXJhbSh2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdzdHJpbmcnIHx8IHZhbC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHZhbCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBVUklFcnJvcikge1xuICAgICAgZXJyLm1lc3NhZ2UgPSAnRmFpbGVkIHRvIGRlY29kZSBwYXJhbSBcXCcnICsgdmFsICsgJ1xcJyc7XG4gICAgICBlcnIuc3RhdHVzID0gZXJyLnN0YXR1c0NvZGUgPSA0MDA7XG4gICAgfVxuXG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9leHByZXNzL2xpYi9yb3V0ZXIvbGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogZXhwcmVzc1xuICogQ29weXJpZ2h0KGMpIDIwMDktMjAxMyBUSiBIb2xvd2F5Y2h1a1xuICogQ29weXJpZ2h0KGMpIDIwMTMgUm9tYW4gU2h0eWxtYW5cbiAqIENvcHlyaWdodChjKSAyMDE0LTIwMTUgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBtZXJnZSA9IHJlcXVpcmUoJ3V0aWxzLW1lcmdlJylcbnZhciBwYXJzZVVybCA9IHJlcXVpcmUoJ3BhcnNldXJsJyk7XG52YXIgcXMgPSByZXF1aXJlKCdxcycpO1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBxdWVyeShvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gbWVyZ2Uoe30sIG9wdGlvbnMpXG4gIHZhciBxdWVyeXBhcnNlID0gcXMucGFyc2U7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcXVlcnlwYXJzZSA9IG9wdGlvbnM7XG4gICAgb3B0cyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgb3B0cy5hbGxvd1Byb3RvdHlwZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGJhY2stY29tcGF0IGZvciBxcyBtb2R1bGVcbiAgICBvcHRzLmFsbG93UHJvdG90eXBlcyA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcXVlcnkocmVxLCByZXMsIG5leHQpe1xuICAgIGlmICghcmVxLnF1ZXJ5KSB7XG4gICAgICB2YXIgdmFsID0gcGFyc2VVcmwocmVxKS5xdWVyeTtcbiAgICAgIHJlcS5xdWVyeSA9IHF1ZXJ5cGFyc2UodmFsLCBvcHRzKTtcbiAgICB9XG5cbiAgICBuZXh0KCk7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZXhwcmVzcy9saWIvbWlkZGxld2FyZS9xdWVyeS5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGNvbnRlbnQtZGlzcG9zaXRpb25cbiAqIENvcHlyaWdodChjKSAyMDE0IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnREaXNwb3NpdGlvblxubW9kdWxlLmV4cG9ydHMucGFyc2UgPSBwYXJzZVxuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGJhc2VuYW1lID0gcmVxdWlyZSgncGF0aCcpLmJhc2VuYW1lXG5cbi8qKlxuICogUmVnRXhwIHRvIG1hdGNoIG5vbiBhdHRyLWNoYXIsICphZnRlciogZW5jb2RlVVJJQ29tcG9uZW50IChpLmUuIG5vdCBpbmNsdWRpbmcgXCIlXCIpXG4gKi9cblxudmFyIEVOQ09ERV9VUkxfQVRUUl9DSEFSX1JFR0VYUCA9IC9bXFx4MDAtXFx4MjBcIicoKSosLzo7PD0+P0BbXFxcXFxcXXt9XFx4N2ZdL2cgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250cm9sLXJlZ2V4XG5cbi8qKlxuICogUmVnRXhwIHRvIG1hdGNoIHBlcmNlbnQgZW5jb2RpbmcgZXNjYXBlLlxuICovXG5cbnZhciBIRVhfRVNDQVBFX1JFR0VYUCA9IC8lWzAtOUEtRmEtZl17Mn0vXG52YXIgSEVYX0VTQ0FQRV9SRVBMQUNFX1JFR0VYUCA9IC8lKFswLTlBLUZhLWZdezJ9KS9nXG5cbi8qKlxuICogUmVnRXhwIHRvIG1hdGNoIG5vbi1sYXRpbjEgY2hhcmFjdGVycy5cbiAqL1xuXG52YXIgTk9OX0xBVElOMV9SRUdFWFAgPSAvW15cXHgyMC1cXHg3ZVxceGEwLVxceGZmXS9nXG5cbi8qKlxuICogUmVnRXhwIHRvIG1hdGNoIHF1b3RlZC1wYWlyIGluIFJGQyAyNjE2XG4gKlxuICogcXVvdGVkLXBhaXIgPSBcIlxcXCIgQ0hBUlxuICogQ0hBUiAgICAgICAgPSA8YW55IFVTLUFTQ0lJIGNoYXJhY3RlciAob2N0ZXRzIDAgLSAxMjcpPlxuICovXG5cbnZhciBRRVNDX1JFR0VYUCA9IC9cXFxcKFtcXHUwMDAwLVxcdTAwN2ZdKS9nXG5cbi8qKlxuICogUmVnRXhwIHRvIG1hdGNoIGNoYXJzIHRoYXQgbXVzdCBiZSBxdW90ZWQtcGFpciBpbiBSRkMgMjYxNlxuICovXG5cbnZhciBRVU9URV9SRUdFWFAgPSAvKFtcXFxcXCJdKS9nXG5cbi8qKlxuICogUmVnRXhwIGZvciB2YXJpb3VzIFJGQyAyNjE2IGdyYW1tYXJcbiAqXG4gKiBwYXJhbWV0ZXIgICAgID0gdG9rZW4gXCI9XCIgKCB0b2tlbiB8IHF1b3RlZC1zdHJpbmcgKVxuICogdG9rZW4gICAgICAgICA9IDEqPGFueSBDSEFSIGV4Y2VwdCBDVExzIG9yIHNlcGFyYXRvcnM+XG4gKiBzZXBhcmF0b3JzICAgID0gXCIoXCIgfCBcIilcIiB8IFwiPFwiIHwgXCI+XCIgfCBcIkBcIlxuICogICAgICAgICAgICAgICB8IFwiLFwiIHwgXCI7XCIgfCBcIjpcIiB8IFwiXFxcIiB8IDxcIj5cbiAqICAgICAgICAgICAgICAgfCBcIi9cIiB8IFwiW1wiIHwgXCJdXCIgfCBcIj9cIiB8IFwiPVwiXG4gKiAgICAgICAgICAgICAgIHwgXCJ7XCIgfCBcIn1cIiB8IFNQIHwgSFRcbiAqIHF1b3RlZC1zdHJpbmcgPSAoIDxcIj4gKihxZHRleHQgfCBxdW90ZWQtcGFpciApIDxcIj4gKVxuICogcWR0ZXh0ICAgICAgICA9IDxhbnkgVEVYVCBleGNlcHQgPFwiPj5cbiAqIHF1b3RlZC1wYWlyICAgPSBcIlxcXCIgQ0hBUlxuICogQ0hBUiAgICAgICAgICA9IDxhbnkgVVMtQVNDSUkgY2hhcmFjdGVyIChvY3RldHMgMCAtIDEyNyk+XG4gKiBURVhUICAgICAgICAgID0gPGFueSBPQ1RFVCBleGNlcHQgQ1RMcywgYnV0IGluY2x1ZGluZyBMV1M+XG4gKiBMV1MgICAgICAgICAgID0gW0NSTEZdIDEqKCBTUCB8IEhUIClcbiAqIENSTEYgICAgICAgICAgPSBDUiBMRlxuICogQ1IgICAgICAgICAgICA9IDxVUy1BU0NJSSBDUiwgY2FycmlhZ2UgcmV0dXJuICgxMyk+XG4gKiBMRiAgICAgICAgICAgID0gPFVTLUFTQ0lJIExGLCBsaW5lZmVlZCAoMTApPlxuICogU1AgICAgICAgICAgICA9IDxVUy1BU0NJSSBTUCwgc3BhY2UgKDMyKT5cbiAqIEhUICAgICAgICAgICAgPSA8VVMtQVNDSUkgSFQsIGhvcml6b250YWwtdGFiICg5KT5cbiAqIENUTCAgICAgICAgICAgPSA8YW55IFVTLUFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVyIChvY3RldHMgMCAtIDMxKSBhbmQgREVMICgxMjcpPlxuICogT0NURVQgICAgICAgICA9IDxhbnkgOC1iaXQgc2VxdWVuY2Ugb2YgZGF0YT5cbiAqL1xuXG52YXIgUEFSQU1fUkVHRVhQID0gLztbXFx4MDlcXHgyMF0qKFshIyQlJicqKy4wLTlBLVpeX2BhLXp8fi1dKylbXFx4MDlcXHgyMF0qPVtcXHgwOVxceDIwXSooXCIoPzpbXFx4MjAhXFx4MjMtXFx4NWJcXHg1ZC1cXHg3ZVxceDgwLVxceGZmXXxcXFxcW1xceDIwLVxceDdlXSkqXCJ8WyEjJCUmJyorLjAtOUEtWl5fYGEtenx+LV0rKVtcXHgwOVxceDIwXSovZyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbnZhciBURVhUX1JFR0VYUCA9IC9eW1xceDIwLVxceDdlXFx4ODAtXFx4ZmZdKyQvXG52YXIgVE9LRU5fUkVHRVhQID0gL15bISMkJSYnKisuMC05QS1aXl9gYS16fH4tXSskL1xuXG4vKipcbiAqIFJlZ0V4cCBmb3IgdmFyaW91cyBSRkMgNTk4NyBncmFtbWFyXG4gKlxuICogZXh0LXZhbHVlICAgICA9IGNoYXJzZXQgIFwiJ1wiIFsgbGFuZ3VhZ2UgXSBcIidcIiB2YWx1ZS1jaGFyc1xuICogY2hhcnNldCAgICAgICA9IFwiVVRGLThcIiAvIFwiSVNPLTg4NTktMVwiIC8gbWltZS1jaGFyc2V0XG4gKiBtaW1lLWNoYXJzZXQgID0gMSptaW1lLWNoYXJzZXRjXG4gKiBtaW1lLWNoYXJzZXRjID0gQUxQSEEgLyBESUdJVFxuICogICAgICAgICAgICAgICAvIFwiIVwiIC8gXCIjXCIgLyBcIiRcIiAvIFwiJVwiIC8gXCImXCJcbiAqICAgICAgICAgICAgICAgLyBcIitcIiAvIFwiLVwiIC8gXCJeXCIgLyBcIl9cIiAvIFwiYFwiXG4gKiAgICAgICAgICAgICAgIC8gXCJ7XCIgLyBcIn1cIiAvIFwiflwiXG4gKiBsYW5ndWFnZSAgICAgID0gKCAyKjNBTFBIQSBbIGV4dGxhbmcgXSApXG4gKiAgICAgICAgICAgICAgIC8gNEFMUEhBXG4gKiAgICAgICAgICAgICAgIC8gNSo4QUxQSEFcbiAqIGV4dGxhbmcgICAgICAgPSAqMyggXCItXCIgM0FMUEhBIClcbiAqIHZhbHVlLWNoYXJzICAgPSAqKCBwY3QtZW5jb2RlZCAvIGF0dHItY2hhciApXG4gKiBwY3QtZW5jb2RlZCAgID0gXCIlXCIgSEVYRElHIEhFWERJR1xuICogYXR0ci1jaGFyICAgICA9IEFMUEhBIC8gRElHSVRcbiAqICAgICAgICAgICAgICAgLyBcIiFcIiAvIFwiI1wiIC8gXCIkXCIgLyBcIiZcIiAvIFwiK1wiIC8gXCItXCIgLyBcIi5cIlxuICogICAgICAgICAgICAgICAvIFwiXlwiIC8gXCJfXCIgLyBcImBcIiAvIFwifFwiIC8gXCJ+XCJcbiAqL1xuXG52YXIgRVhUX1ZBTFVFX1JFR0VYUCA9IC9eKFtBLVphLXowLTkhIyQlJitcXC1eX2B7fX5dKyknKD86W0EtWmEtel17MiwzfSg/Oi1bQS1aYS16XXszfSl7MCwzfXxbQS1aYS16XXs0LDh9fCknKCg/OiVbMC05QS1GYS1mXXsyfXxbQS1aYS16MC05ISMkJisuXl9gfH4tXSkrKSQvXG5cbi8qKlxuICogUmVnRXhwIGZvciB2YXJpb3VzIFJGQyA2MjY2IGdyYW1tYXJcbiAqXG4gKiBkaXNwb3NpdGlvbi10eXBlID0gXCJpbmxpbmVcIiB8IFwiYXR0YWNobWVudFwiIHwgZGlzcC1leHQtdHlwZVxuICogZGlzcC1leHQtdHlwZSAgICA9IHRva2VuXG4gKiBkaXNwb3NpdGlvbi1wYXJtID0gZmlsZW5hbWUtcGFybSB8IGRpc3AtZXh0LXBhcm1cbiAqIGZpbGVuYW1lLXBhcm0gICAgPSBcImZpbGVuYW1lXCIgXCI9XCIgdmFsdWVcbiAqICAgICAgICAgICAgICAgICAgfCBcImZpbGVuYW1lKlwiIFwiPVwiIGV4dC12YWx1ZVxuICogZGlzcC1leHQtcGFybSAgICA9IHRva2VuIFwiPVwiIHZhbHVlXG4gKiAgICAgICAgICAgICAgICAgIHwgZXh0LXRva2VuIFwiPVwiIGV4dC12YWx1ZVxuICogZXh0LXRva2VuICAgICAgICA9IDx0aGUgY2hhcmFjdGVycyBpbiB0b2tlbiwgZm9sbG93ZWQgYnkgXCIqXCI+XG4gKi9cblxudmFyIERJU1BPU0lUSU9OX1RZUEVfUkVHRVhQID0gL14oWyEjJCUmJyorLjAtOUEtWl5fYGEtenx+LV0rKVtcXHgwOVxceDIwXSooPzokfDspLyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblxuLyoqXG4gKiBDcmVhdGUgYW4gYXR0YWNobWVudCBDb250ZW50LURpc3Bvc2l0aW9uIGhlYWRlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW2ZpbGVuYW1lXVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnR5cGU9YXR0YWNobWVudF1cbiAqIEBwYXJhbSB7c3RyaW5nfGJvb2xlYW59IFtvcHRpb25zLmZhbGxiYWNrPXRydWVdXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNvbnRlbnREaXNwb3NpdGlvbiAoZmlsZW5hbWUsIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9XG5cbiAgLy8gZ2V0IHR5cGVcbiAgdmFyIHR5cGUgPSBvcHRzLnR5cGUgfHwgJ2F0dGFjaG1lbnQnXG5cbiAgLy8gZ2V0IHBhcmFtZXRlcnNcbiAgdmFyIHBhcmFtcyA9IGNyZWF0ZXBhcmFtcyhmaWxlbmFtZSwgb3B0cy5mYWxsYmFjaylcblxuICAvLyBmb3JtYXQgaW50byBzdHJpbmdcbiAgcmV0dXJuIGZvcm1hdChuZXcgQ29udGVudERpc3Bvc2l0aW9uKHR5cGUsIHBhcmFtcykpXG59XG5cbi8qKlxuICogQ3JlYXRlIHBhcmFtZXRlcnMgb2JqZWN0IGZyb20gZmlsZW5hbWUgYW5kIGZhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZmlsZW5hbWVdXG4gKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSBbZmFsbGJhY2s9dHJ1ZV1cbiAqIEByZXR1cm4ge29iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZXBhcmFtcyAoZmlsZW5hbWUsIGZhbGxiYWNrKSB7XG4gIGlmIChmaWxlbmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgcGFyYW1zID0ge31cblxuICBpZiAodHlwZW9mIGZpbGVuYW1lICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZpbGVuYW1lIG11c3QgYmUgYSBzdHJpbmcnKVxuICB9XG5cbiAgLy8gZmFsbGJhY2sgZGVmYXVsdHMgdG8gdHJ1ZVxuICBpZiAoZmFsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIGZhbGxiYWNrID0gdHJ1ZVxuICB9XG5cbiAgaWYgKHR5cGVvZiBmYWxsYmFjayAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGZhbGxiYWNrICE9PSAnYm9vbGVhbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmYWxsYmFjayBtdXN0IGJlIGEgc3RyaW5nIG9yIGJvb2xlYW4nKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBmYWxsYmFjayA9PT0gJ3N0cmluZycgJiYgTk9OX0xBVElOMV9SRUdFWFAudGVzdChmYWxsYmFjaykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmYWxsYmFjayBtdXN0IGJlIElTTy04ODU5LTEgc3RyaW5nJylcbiAgfVxuXG4gIC8vIHJlc3RyaWN0IHRvIGZpbGUgYmFzZSBuYW1lXG4gIHZhciBuYW1lID0gYmFzZW5hbWUoZmlsZW5hbWUpXG5cbiAgLy8gZGV0ZXJtaW5lIGlmIG5hbWUgaXMgc3VpdGFibGUgZm9yIHF1b3RlZCBzdHJpbmdcbiAgdmFyIGlzUXVvdGVkU3RyaW5nID0gVEVYVF9SRUdFWFAudGVzdChuYW1lKVxuXG4gIC8vIGdlbmVyYXRlIGZhbGxiYWNrIG5hbWVcbiAgdmFyIGZhbGxiYWNrTmFtZSA9IHR5cGVvZiBmYWxsYmFjayAhPT0gJ3N0cmluZydcbiAgICA/IGZhbGxiYWNrICYmIGdldGxhdGluMShuYW1lKVxuICAgIDogYmFzZW5hbWUoZmFsbGJhY2spXG4gIHZhciBoYXNGYWxsYmFjayA9IHR5cGVvZiBmYWxsYmFja05hbWUgPT09ICdzdHJpbmcnICYmIGZhbGxiYWNrTmFtZSAhPT0gbmFtZVxuXG4gIC8vIHNldCBleHRlbmRlZCBmaWxlbmFtZSBwYXJhbWV0ZXJcbiAgaWYgKGhhc0ZhbGxiYWNrIHx8ICFpc1F1b3RlZFN0cmluZyB8fCBIRVhfRVNDQVBFX1JFR0VYUC50ZXN0KG5hbWUpKSB7XG4gICAgcGFyYW1zWydmaWxlbmFtZSonXSA9IG5hbWVcbiAgfVxuXG4gIC8vIHNldCBmaWxlbmFtZSBwYXJhbWV0ZXJcbiAgaWYgKGlzUXVvdGVkU3RyaW5nIHx8IGhhc0ZhbGxiYWNrKSB7XG4gICAgcGFyYW1zLmZpbGVuYW1lID0gaGFzRmFsbGJhY2tcbiAgICAgID8gZmFsbGJhY2tOYW1lXG4gICAgICA6IG5hbWVcbiAgfVxuXG4gIHJldHVybiBwYXJhbXNcbn1cblxuLyoqXG4gKiBGb3JtYXQgb2JqZWN0IHRvIENvbnRlbnQtRGlzcG9zaXRpb24gaGVhZGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBvYmoudHlwZVxuICogQHBhcmFtIHtvYmplY3R9IFtvYmoucGFyYW1ldGVyc11cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdCAob2JqKSB7XG4gIHZhciBwYXJhbWV0ZXJzID0gb2JqLnBhcmFtZXRlcnNcbiAgdmFyIHR5cGUgPSBvYmoudHlwZVxuXG4gIGlmICghdHlwZSB8fCB0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycgfHwgIVRPS0VOX1JFR0VYUC50ZXN0KHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCB0eXBlJylcbiAgfVxuXG4gIC8vIHN0YXJ0IHdpdGggbm9ybWFsaXplZCB0eXBlXG4gIHZhciBzdHJpbmcgPSBTdHJpbmcodHlwZSkudG9Mb3dlckNhc2UoKVxuXG4gIC8vIGFwcGVuZCBwYXJhbWV0ZXJzXG4gIGlmIChwYXJhbWV0ZXJzICYmIHR5cGVvZiBwYXJhbWV0ZXJzID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBwYXJhbVxuICAgIHZhciBwYXJhbXMgPSBPYmplY3Qua2V5cyhwYXJhbWV0ZXJzKS5zb3J0KClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXJhbSA9IHBhcmFtc1tpXVxuXG4gICAgICB2YXIgdmFsID0gcGFyYW0uc3Vic3RyKC0xKSA9PT0gJyonXG4gICAgICAgID8gdXN0cmluZyhwYXJhbWV0ZXJzW3BhcmFtXSlcbiAgICAgICAgOiBxc3RyaW5nKHBhcmFtZXRlcnNbcGFyYW1dKVxuXG4gICAgICBzdHJpbmcgKz0gJzsgJyArIHBhcmFtICsgJz0nICsgdmFsXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZ1xufVxuXG4vKipcbiAqIERlY29kZSBhIFJGQyA2OTg3IGZpZWxkIHZhbHVlIChncmFjZWZ1bGx5KS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBkZWNvZGVmaWVsZCAoc3RyKSB7XG4gIHZhciBtYXRjaCA9IEVYVF9WQUxVRV9SRUdFWFAuZXhlYyhzdHIpXG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZXh0ZW5kZWQgZmllbGQgdmFsdWUnKVxuICB9XG5cbiAgdmFyIGNoYXJzZXQgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpXG4gIHZhciBlbmNvZGVkID0gbWF0Y2hbMl1cbiAgdmFyIHZhbHVlXG5cbiAgLy8gdG8gYmluYXJ5IHN0cmluZ1xuICB2YXIgYmluYXJ5ID0gZW5jb2RlZC5yZXBsYWNlKEhFWF9FU0NBUEVfUkVQTEFDRV9SRUdFWFAsIHBkZWNvZGUpXG5cbiAgc3dpdGNoIChjaGFyc2V0KSB7XG4gICAgY2FzZSAnaXNvLTg4NTktMSc6XG4gICAgICB2YWx1ZSA9IGdldGxhdGluMShiaW5hcnkpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHZhbHVlID0gbmV3IEJ1ZmZlcihiaW5hcnksICdiaW5hcnknKS50b1N0cmluZygndXRmOCcpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bnN1cHBvcnRlZCBjaGFyc2V0IGluIGV4dGVuZGVkIGZpZWxkJylcbiAgfVxuXG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCBJU08tODg1OS0xIHZlcnNpb24gb2Ygc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGdldGxhdGluMSAodmFsKSB7XG4gIC8vIHNpbXBsZSBVbmljb2RlIC0+IElTTy04ODU5LTEgdHJhbnNmb3JtYXRpb25cbiAgcmV0dXJuIFN0cmluZyh2YWwpLnJlcGxhY2UoTk9OX0xBVElOMV9SRUdFWFAsICc/Jylcbn1cblxuLyoqXG4gKiBQYXJzZSBDb250ZW50LURpc3Bvc2l0aW9uIGhlYWRlciBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7b2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2UgKHN0cmluZykge1xuICBpZiAoIXN0cmluZyB8fCB0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHN0cmluZyBpcyByZXF1aXJlZCcpXG4gIH1cblxuICB2YXIgbWF0Y2ggPSBESVNQT1NJVElPTl9UWVBFX1JFR0VYUC5leGVjKHN0cmluZylcblxuICBpZiAoIW1hdGNoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCB0eXBlIGZvcm1hdCcpXG4gIH1cblxuICAvLyBub3JtYWxpemUgdHlwZVxuICB2YXIgaW5kZXggPSBtYXRjaFswXS5sZW5ndGhcbiAgdmFyIHR5cGUgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpXG5cbiAgdmFyIGtleVxuICB2YXIgbmFtZXMgPSBbXVxuICB2YXIgcGFyYW1zID0ge31cbiAgdmFyIHZhbHVlXG5cbiAgLy8gY2FsY3VsYXRlIGluZGV4IHRvIHN0YXJ0IGF0XG4gIGluZGV4ID0gUEFSQU1fUkVHRVhQLmxhc3RJbmRleCA9IG1hdGNoWzBdLnN1YnN0cigtMSkgPT09ICc7J1xuICAgID8gaW5kZXggLSAxXG4gICAgOiBpbmRleFxuXG4gIC8vIG1hdGNoIHBhcmFtZXRlcnNcbiAgd2hpbGUgKChtYXRjaCA9IFBBUkFNX1JFR0VYUC5leGVjKHN0cmluZykpKSB7XG4gICAgaWYgKG1hdGNoLmluZGV4ICE9PSBpbmRleCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXJhbWV0ZXIgZm9ybWF0JylcbiAgICB9XG5cbiAgICBpbmRleCArPSBtYXRjaFswXS5sZW5ndGhcbiAgICBrZXkgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpXG4gICAgdmFsdWUgPSBtYXRjaFsyXVxuXG4gICAgaWYgKG5hbWVzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZHVwbGljYXRlIHBhcmFtZXRlcicpXG4gICAgfVxuXG4gICAgbmFtZXMucHVzaChrZXkpXG5cbiAgICBpZiAoa2V5LmluZGV4T2YoJyonKSArIDEgPT09IGtleS5sZW5ndGgpIHtcbiAgICAgIC8vIGRlY29kZSBleHRlbmRlZCB2YWx1ZVxuICAgICAga2V5ID0ga2V5LnNsaWNlKDAsIC0xKVxuICAgICAgdmFsdWUgPSBkZWNvZGVmaWVsZCh2YWx1ZSlcblxuICAgICAgLy8gb3ZlcndyaXRlIGV4aXN0aW5nIHZhbHVlXG4gICAgICBwYXJhbXNba2V5XSA9IHZhbHVlXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcGFyYW1zW2tleV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmICh2YWx1ZVswXSA9PT0gJ1wiJykge1xuICAgICAgLy8gcmVtb3ZlIHF1b3RlcyBhbmQgZXNjYXBlc1xuICAgICAgdmFsdWUgPSB2YWx1ZVxuICAgICAgICAuc3Vic3RyKDEsIHZhbHVlLmxlbmd0aCAtIDIpXG4gICAgICAgIC5yZXBsYWNlKFFFU0NfUkVHRVhQLCAnJDEnKVxuICAgIH1cblxuICAgIHBhcmFtc1trZXldID0gdmFsdWVcbiAgfVxuXG4gIGlmIChpbmRleCAhPT0gLTEgJiYgaW5kZXggIT09IHN0cmluZy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhcmFtZXRlciBmb3JtYXQnKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBDb250ZW50RGlzcG9zaXRpb24odHlwZSwgcGFyYW1zKVxufVxuXG4vKipcbiAqIFBlcmNlbnQgZGVjb2RlIGEgc2luZ2xlIGNoYXJhY3Rlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge3N0cmluZ30gaGV4XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwZGVjb2RlIChzdHIsIGhleCkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChoZXgsIDE2KSlcbn1cblxuLyoqXG4gKiBQZXJjZW50IGVuY29kZSBhIHNpbmdsZSBjaGFyYWN0ZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNoYXJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBlbmNvZGUgKGNoYXIpIHtcbiAgdmFyIGhleCA9IFN0cmluZyhjaGFyKVxuICAgIC5jaGFyQ29kZUF0KDApXG4gICAgLnRvU3RyaW5nKDE2KVxuICAgIC50b1VwcGVyQ2FzZSgpXG4gIHJldHVybiBoZXgubGVuZ3RoID09PSAxXG4gICAgPyAnJTAnICsgaGV4XG4gICAgOiAnJScgKyBoZXhcbn1cblxuLyoqXG4gKiBRdW90ZSBhIHN0cmluZyBmb3IgSFRUUC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBxc3RyaW5nICh2YWwpIHtcbiAgdmFyIHN0ciA9IFN0cmluZyh2YWwpXG5cbiAgcmV0dXJuICdcIicgKyBzdHIucmVwbGFjZShRVU9URV9SRUdFWFAsICdcXFxcJDEnKSArICdcIidcbn1cblxuLyoqXG4gKiBFbmNvZGUgYSBVbmljb2RlIHN0cmluZyBmb3IgSFRUUCAoUkZDIDU5ODcpLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHVzdHJpbmcgKHZhbCkge1xuICB2YXIgc3RyID0gU3RyaW5nKHZhbClcblxuICAvLyBwZXJjZW50IGVuY29kZSBhcyBVVEYtOFxuICB2YXIgZW5jb2RlZCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIpXG4gICAgLnJlcGxhY2UoRU5DT0RFX1VSTF9BVFRSX0NIQVJfUkVHRVhQLCBwZW5jb2RlKVxuXG4gIHJldHVybiAnVVRGLThcXCdcXCcnICsgZW5jb2RlZFxufVxuXG4vKipcbiAqIENsYXNzIGZvciBwYXJzZWQgQ29udGVudC1EaXNwb3NpdGlvbiBoZWFkZXIgZm9yIHY4IG9wdGltaXphdGlvblxuICovXG5cbmZ1bmN0aW9uIENvbnRlbnREaXNwb3NpdGlvbiAodHlwZSwgcGFyYW1ldGVycykge1xuICB0aGlzLnR5cGUgPSB0eXBlXG4gIHRoaXMucGFyYW1ldGVycyA9IHBhcmFtZXRlcnNcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvbnRlbnQtZGlzcG9zaXRpb24vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogZXRhZ1xuICogQ29weXJpZ2h0KGMpIDIwMTQtMjAxNiBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBldGFnXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpXG52YXIgU3RhdHMgPSByZXF1aXJlKCdmcycpLlN0YXRzXG5cbi8qKlxuICogTW9kdWxlIHZhcmlhYmxlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuXG4vKipcbiAqIEdlbmVyYXRlIGFuIGVudGl0eSB0YWcuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ8c3RyaW5nfSBlbnRpdHlcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW50aXR5dGFnIChlbnRpdHkpIHtcbiAgaWYgKGVudGl0eS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBmYXN0LXBhdGggZW1wdHlcbiAgICByZXR1cm4gJ1wiMC0yam1qN2w1clN3MHlWYi92bFdBWWtLL1lCd2tcIidcbiAgfVxuXG4gIC8vIGNvbXB1dGUgaGFzaCBvZiBlbnRpdHlcbiAgdmFyIGhhc2ggPSBjcnlwdG9cbiAgICAuY3JlYXRlSGFzaCgnc2hhMScpXG4gICAgLnVwZGF0ZShlbnRpdHksICd1dGY4JylcbiAgICAuZGlnZXN0KCdiYXNlNjQnKVxuICAgIC5zdWJzdHJpbmcoMCwgMjcpXG5cbiAgLy8gY29tcHV0ZSBsZW5ndGggb2YgZW50aXR5XG4gIHZhciBsZW4gPSB0eXBlb2YgZW50aXR5ID09PSAnc3RyaW5nJ1xuICAgID8gQnVmZmVyLmJ5dGVMZW5ndGgoZW50aXR5LCAndXRmOCcpXG4gICAgOiBlbnRpdHkubGVuZ3RoXG5cbiAgcmV0dXJuICdcIicgKyBsZW4udG9TdHJpbmcoMTYpICsgJy0nICsgaGFzaCArICdcIidcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBzaW1wbGUgRVRhZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8U3RhdHN9IGVudGl0eVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy53ZWFrXVxuICogQHJldHVybiB7U3RyaW5nfVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGV0YWcgKGVudGl0eSwgb3B0aW9ucykge1xuICBpZiAoZW50aXR5ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBlbnRpdHkgaXMgcmVxdWlyZWQnKVxuICB9XG5cbiAgLy8gc3VwcG9ydCBmcy5TdGF0cyBvYmplY3RcbiAgdmFyIGlzU3RhdHMgPSBpc3N0YXRzKGVudGl0eSlcbiAgdmFyIHdlYWsgPSBvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLndlYWsgPT09ICdib29sZWFuJ1xuICAgID8gb3B0aW9ucy53ZWFrXG4gICAgOiBpc1N0YXRzXG5cbiAgLy8gdmFsaWRhdGUgYXJndW1lbnRcbiAgaWYgKCFpc1N0YXRzICYmIHR5cGVvZiBlbnRpdHkgIT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNCdWZmZXIoZW50aXR5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IGVudGl0eSBtdXN0IGJlIHN0cmluZywgQnVmZmVyLCBvciBmcy5TdGF0cycpXG4gIH1cblxuICAvLyBnZW5lcmF0ZSBlbnRpdHkgdGFnXG4gIHZhciB0YWcgPSBpc1N0YXRzXG4gICAgPyBzdGF0dGFnKGVudGl0eSlcbiAgICA6IGVudGl0eXRhZyhlbnRpdHkpXG5cbiAgcmV0dXJuIHdlYWtcbiAgICA/ICdXLycgKyB0YWdcbiAgICA6IHRhZ1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBvYmplY3QgaXMgYSBTdGF0cyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzc3RhdHMgKG9iaikge1xuICAvLyBnZW51aW5lIGZzLlN0YXRzXG4gIGlmICh0eXBlb2YgU3RhdHMgPT09ICdmdW5jdGlvbicgJiYgb2JqIGluc3RhbmNlb2YgU3RhdHMpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gcXVhY2sgcXVhY2tcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJlxuICAgICdjdGltZScgaW4gb2JqICYmIHRvU3RyaW5nLmNhbGwob2JqLmN0aW1lKSA9PT0gJ1tvYmplY3QgRGF0ZV0nICYmXG4gICAgJ210aW1lJyBpbiBvYmogJiYgdG9TdHJpbmcuY2FsbChvYmoubXRpbWUpID09PSAnW29iamVjdCBEYXRlXScgJiZcbiAgICAnaW5vJyBpbiBvYmogJiYgdHlwZW9mIG9iai5pbm8gPT09ICdudW1iZXInICYmXG4gICAgJ3NpemUnIGluIG9iaiAmJiB0eXBlb2Ygb2JqLnNpemUgPT09ICdudW1iZXInXG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSB0YWcgZm9yIGEgc3RhdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdFxuICogQHJldHVybiB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzdGF0dGFnIChzdGF0KSB7XG4gIHZhciBtdGltZSA9IHN0YXQubXRpbWUuZ2V0VGltZSgpLnRvU3RyaW5nKDE2KVxuICB2YXIgc2l6ZSA9IHN0YXQuc2l6ZS50b1N0cmluZygxNilcblxuICByZXR1cm4gJ1wiJyArIHNpemUgKyAnLScgKyBtdGltZSArICdcIidcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2V0YWcvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogZnJlc2hcbiAqIENvcHlyaWdodChjKSAyMDEyIFRKIEhvbG93YXljaHVrXG4gKiBDb3B5cmlnaHQoYykgMjAxNi0yMDE3IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBSZWdFeHAgdG8gY2hlY2sgZm9yIG5vLWNhY2hlIHRva2VuIGluIENhY2hlLUNvbnRyb2wuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBDQUNIRV9DT05UUk9MX05PX0NBQ0hFX1JFR0VYUCA9IC8oPzpefCwpXFxzKj9uby1jYWNoZVxccyo/KD86LHwkKS9cblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZXNoXG5cbi8qKlxuICogQ2hlY2sgZnJlc2huZXNzIG9mIHRoZSByZXNwb25zZSB1c2luZyByZXF1ZXN0IGFuZCByZXNwb25zZSBoZWFkZXJzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXFIZWFkZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzSGVhZGVyc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmcmVzaCAocmVxSGVhZGVycywgcmVzSGVhZGVycykge1xuICAvLyBmaWVsZHNcbiAgdmFyIG1vZGlmaWVkU2luY2UgPSByZXFIZWFkZXJzWydpZi1tb2RpZmllZC1zaW5jZSddXG4gIHZhciBub25lTWF0Y2ggPSByZXFIZWFkZXJzWydpZi1ub25lLW1hdGNoJ11cblxuICAvLyB1bmNvbmRpdGlvbmFsIHJlcXVlc3RcbiAgaWYgKCFtb2RpZmllZFNpbmNlICYmICFub25lTWF0Y2gpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIEFsd2F5cyByZXR1cm4gc3RhbGUgd2hlbiBDYWNoZS1Db250cm9sOiBuby1jYWNoZVxuICAvLyB0byBzdXBwb3J0IGVuZC10by1lbmQgcmVsb2FkIHJlcXVlc3RzXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyNjE2I3NlY3Rpb24tMTQuOS40XG4gIHZhciBjYWNoZUNvbnRyb2wgPSByZXFIZWFkZXJzWydjYWNoZS1jb250cm9sJ11cbiAgaWYgKGNhY2hlQ29udHJvbCAmJiBDQUNIRV9DT05UUk9MX05PX0NBQ0hFX1JFR0VYUC50ZXN0KGNhY2hlQ29udHJvbCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIGlmLW5vbmUtbWF0Y2hcbiAgaWYgKG5vbmVNYXRjaCAmJiBub25lTWF0Y2ggIT09ICcqJykge1xuICAgIHZhciBldGFnID0gcmVzSGVhZGVyc1snZXRhZyddXG5cbiAgICBpZiAoIWV0YWcpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHZhciBldGFnU3RhbGUgPSB0cnVlXG4gICAgdmFyIG1hdGNoZXMgPSBwYXJzZVRva2VuTGlzdChub25lTWF0Y2gpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBtYXRjaGVzW2ldXG4gICAgICBpZiAobWF0Y2ggPT09IGV0YWcgfHwgbWF0Y2ggPT09ICdXLycgKyBldGFnIHx8ICdXLycgKyBtYXRjaCA9PT0gZXRhZykge1xuICAgICAgICBldGFnU3RhbGUgPSBmYWxzZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChldGFnU3RhbGUpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIGlmLW1vZGlmaWVkLXNpbmNlXG4gIGlmIChtb2RpZmllZFNpbmNlKSB7XG4gICAgdmFyIGxhc3RNb2RpZmllZCA9IHJlc0hlYWRlcnNbJ2xhc3QtbW9kaWZpZWQnXVxuICAgIHZhciBtb2RpZmllZFN0YWxlID0gIWxhc3RNb2RpZmllZCB8fCAhKHBhcnNlSHR0cERhdGUobGFzdE1vZGlmaWVkKSA8PSBwYXJzZUh0dHBEYXRlKG1vZGlmaWVkU2luY2UpKVxuXG4gICAgaWYgKG1vZGlmaWVkU3RhbGUpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogUGFyc2UgYW4gSFRUUCBEYXRlIGludG8gYSBudW1iZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGVcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VIdHRwRGF0ZSAoZGF0ZSkge1xuICB2YXIgdGltZXN0YW1wID0gZGF0ZSAmJiBEYXRlLnBhcnNlKGRhdGUpXG5cbiAgLy8gaXN0YW5idWwgaWdub3JlIG5leHQ6IGd1YXJkIGFnYWluc3QgZGF0ZS5qcyBEYXRlLnBhcnNlIHBhdGNoaW5nXG4gIHJldHVybiB0eXBlb2YgdGltZXN0YW1wID09PSAnbnVtYmVyJ1xuICAgID8gdGltZXN0YW1wXG4gICAgOiBOYU5cbn1cblxuLyoqXG4gKiBQYXJzZSBhIEhUVFAgdG9rZW4gbGlzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlVG9rZW5MaXN0IChzdHIpIHtcbiAgdmFyIGVuZCA9IDBcbiAgdmFyIGxpc3QgPSBbXVxuICB2YXIgc3RhcnQgPSAwXG5cbiAgLy8gZ2F0aGVyIHRva2Vuc1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgc3dpdGNoIChzdHIuY2hhckNvZGVBdChpKSkge1xuICAgICAgY2FzZSAweDIwOiAvKiAgICovXG4gICAgICAgIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgICAgICAgc3RhcnQgPSBlbmQgPSBpICsgMVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDB4MmM6IC8qICwgKi9cbiAgICAgICAgbGlzdC5wdXNoKHN0ci5zdWJzdHJpbmcoc3RhcnQsIGVuZCkpXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gaSArIDFcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGVuZCA9IGkgKyAxXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gZmluYWwgdG9rZW5cbiAgbGlzdC5wdXNoKHN0ci5zdWJzdHJpbmcoc3RhcnQsIGVuZCkpXG5cbiAgcmV0dXJuIGxpc3Rcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZyZXNoL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIHJhbmdlLXBhcnNlclxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBUSiBIb2xvd2F5Y2h1a1xuICogQ29weXJpZ2h0KGMpIDIwMTUtMjAxNiBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByYW5nZVBhcnNlclxuXG4vKipcbiAqIFBhcnNlIFwiUmFuZ2VcIiBoZWFkZXIgYHN0cmAgcmVsYXRpdmUgdG8gdGhlIGdpdmVuIGZpbGUgYHNpemVgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzaXplXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiByYW5nZVBhcnNlciAoc2l6ZSwgc3RyLCBvcHRpb25zKSB7XG4gIHZhciBpbmRleCA9IHN0ci5pbmRleE9mKCc9JylcblxuICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIC0yXG4gIH1cblxuICAvLyBzcGxpdCB0aGUgcmFuZ2Ugc3RyaW5nXG4gIHZhciBhcnIgPSBzdHIuc2xpY2UoaW5kZXggKyAxKS5zcGxpdCgnLCcpXG4gIHZhciByYW5nZXMgPSBbXVxuXG4gIC8vIGFkZCByYW5nZXMgdHlwZVxuICByYW5nZXMudHlwZSA9IHN0ci5zbGljZSgwLCBpbmRleClcblxuICAvLyBwYXJzZSBhbGwgcmFuZ2VzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJhbmdlID0gYXJyW2ldLnNwbGl0KCctJylcbiAgICB2YXIgc3RhcnQgPSBwYXJzZUludChyYW5nZVswXSwgMTApXG4gICAgdmFyIGVuZCA9IHBhcnNlSW50KHJhbmdlWzFdLCAxMClcblxuICAgIC8vIC1ubm5cbiAgICBpZiAoaXNOYU4oc3RhcnQpKSB7XG4gICAgICBzdGFydCA9IHNpemUgLSBlbmRcbiAgICAgIGVuZCA9IHNpemUgLSAxXG4gICAgLy8gbm5uLVxuICAgIH0gZWxzZSBpZiAoaXNOYU4oZW5kKSkge1xuICAgICAgZW5kID0gc2l6ZSAtIDFcbiAgICB9XG5cbiAgICAvLyBsaW1pdCBsYXN0LWJ5dGUtcG9zIHRvIGN1cnJlbnQgbGVuZ3RoXG4gICAgaWYgKGVuZCA+IHNpemUgLSAxKSB7XG4gICAgICBlbmQgPSBzaXplIC0gMVxuICAgIH1cblxuICAgIC8vIGludmFsaWQgb3IgdW5zYXRpc2lmaWFibGVcbiAgICBpZiAoaXNOYU4oc3RhcnQpIHx8IGlzTmFOKGVuZCkgfHwgc3RhcnQgPiBlbmQgfHwgc3RhcnQgPCAwKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIC8vIGFkZCByYW5nZVxuICAgIHJhbmdlcy5wdXNoKHtcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogZW5kXG4gICAgfSlcbiAgfVxuXG4gIGlmIChyYW5nZXMubGVuZ3RoIDwgMSkge1xuICAgIC8vIHVuc2F0aXNpZmlhYmxlXG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmNvbWJpbmVcbiAgICA/IGNvbWJpbmVSYW5nZXMocmFuZ2VzKVxuICAgIDogcmFuZ2VzXG59XG5cbi8qKlxuICogQ29tYmluZSBvdmVybGFwcGluZyAmIGFkamFjZW50IHJhbmdlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29tYmluZVJhbmdlcyAocmFuZ2VzKSB7XG4gIHZhciBvcmRlcmVkID0gcmFuZ2VzLm1hcChtYXBXaXRoSW5kZXgpLnNvcnQoc29ydEJ5UmFuZ2VTdGFydClcblxuICBmb3IgKHZhciBqID0gMCwgaSA9IDE7IGkgPCBvcmRlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJhbmdlID0gb3JkZXJlZFtpXVxuICAgIHZhciBjdXJyZW50ID0gb3JkZXJlZFtqXVxuXG4gICAgaWYgKHJhbmdlLnN0YXJ0ID4gY3VycmVudC5lbmQgKyAxKSB7XG4gICAgICAvLyBuZXh0IHJhbmdlXG4gICAgICBvcmRlcmVkWysral0gPSByYW5nZVxuICAgIH0gZWxzZSBpZiAocmFuZ2UuZW5kID4gY3VycmVudC5lbmQpIHtcbiAgICAgIC8vIGV4dGVuZCByYW5nZVxuICAgICAgY3VycmVudC5lbmQgPSByYW5nZS5lbmRcbiAgICAgIGN1cnJlbnQuaW5kZXggPSBNYXRoLm1pbihjdXJyZW50LmluZGV4LCByYW5nZS5pbmRleClcbiAgICB9XG4gIH1cblxuICAvLyB0cmltIG9yZGVyZWQgYXJyYXlcbiAgb3JkZXJlZC5sZW5ndGggPSBqICsgMVxuXG4gIC8vIGdlbmVyYXRlIGNvbWJpbmVkIHJhbmdlXG4gIHZhciBjb21iaW5lZCA9IG9yZGVyZWQuc29ydChzb3J0QnlSYW5nZUluZGV4KS5tYXAobWFwV2l0aG91dEluZGV4KVxuXG4gIC8vIGNvcHkgcmFuZ2VzIHR5cGVcbiAgY29tYmluZWQudHlwZSA9IHJhbmdlcy50eXBlXG5cbiAgcmV0dXJuIGNvbWJpbmVkXG59XG5cbi8qKlxuICogTWFwIGZ1bmN0aW9uIHRvIGFkZCBpbmRleCB2YWx1ZSB0byByYW5nZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1hcFdpdGhJbmRleCAocmFuZ2UsIGluZGV4KSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHJhbmdlLnN0YXJ0LFxuICAgIGVuZDogcmFuZ2UuZW5kLFxuICAgIGluZGV4OiBpbmRleFxuICB9XG59XG5cbi8qKlxuICogTWFwIGZ1bmN0aW9uIHRvIHJlbW92ZSBpbmRleCB2YWx1ZSBmcm9tIHJhbmdlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWFwV2l0aG91dEluZGV4IChyYW5nZSkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiByYW5nZS5zdGFydCxcbiAgICBlbmQ6IHJhbmdlLmVuZFxuICB9XG59XG5cbi8qKlxuICogU29ydCBmdW5jdGlvbiB0byBzb3J0IHJhbmdlcyBieSBpbmRleC5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc29ydEJ5UmFuZ2VJbmRleCAoYSwgYikge1xuICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXhcbn1cblxuLyoqXG4gKiBTb3J0IGZ1bmN0aW9uIHRvIHNvcnQgcmFuZ2VzIGJ5IHN0YXJ0IHBvc2l0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzb3J0QnlSYW5nZVN0YXJ0IChhLCBiKSB7XG4gIHJldHVybiBhLnN0YXJ0IC0gYi5zdGFydFxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmFuZ2UtcGFyc2VyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIHByb3h5LWFkZHJcbiAqIENvcHlyaWdodChjKSAyMDE0LTIwMTYgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcHJveHlhZGRyXG5tb2R1bGUuZXhwb3J0cy5hbGwgPSBhbGxhZGRyc1xubW9kdWxlLmV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGVcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgZm9yd2FyZGVkID0gcmVxdWlyZSgnZm9yd2FyZGVkJylcbnZhciBpcGFkZHIgPSByZXF1aXJlKCdpcGFkZHIuanMnKVxuXG4vKipcbiAqIFZhcmlhYmxlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIERJR0lUX1JFR0VYUCA9IC9eWzAtOV0rJC9cbnZhciBpc2lwID0gaXBhZGRyLmlzVmFsaWRcbnZhciBwYXJzZWlwID0gaXBhZGRyLnBhcnNlXG5cbi8qKlxuICogUHJlLWRlZmluZWQgSVAgcmFuZ2VzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgSVBfUkFOR0VTID0ge1xuICBsaW5rbG9jYWw6IFsnMTY5LjI1NC4wLjAvMTYnLCAnZmU4MDo6LzEwJ10sXG4gIGxvb3BiYWNrOiBbJzEyNy4wLjAuMS84JywgJzo6MS8xMjgnXSxcbiAgdW5pcXVlbG9jYWw6IFsnMTAuMC4wLjAvOCcsICcxNzIuMTYuMC4wLzEyJywgJzE5Mi4xNjguMC4wLzE2JywgJ2ZjMDA6Oi83J11cbn1cblxuLyoqXG4gKiBHZXQgYWxsIGFkZHJlc3NlcyBpbiB0aGUgcmVxdWVzdCwgb3B0aW9uYWxseSBzdG9wcGluZ1xuICogYXQgdGhlIGZpcnN0IHVudHJ1c3RlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdFxuICogQHBhcmFtIHtGdW5jdGlvbnxBcnJheXxTdHJpbmd9IFt0cnVzdF1cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBhbGxhZGRycyAocmVxLCB0cnVzdCkge1xuICAvLyBnZXQgYWRkcmVzc2VzXG4gIHZhciBhZGRycyA9IGZvcndhcmRlZChyZXEpXG5cbiAgaWYgKCF0cnVzdCkge1xuICAgIC8vIFJldHVybiBhbGwgYWRkcmVzc2VzXG4gICAgcmV0dXJuIGFkZHJzXG4gIH1cblxuICBpZiAodHlwZW9mIHRydXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ1c3QgPSBjb21waWxlKHRydXN0KVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZGRycy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBpZiAodHJ1c3QoYWRkcnNbaV0sIGkpKSBjb250aW51ZVxuXG4gICAgYWRkcnMubGVuZ3RoID0gaSArIDFcbiAgfVxuXG4gIHJldHVybiBhZGRyc1xufVxuXG4vKipcbiAqIENvbXBpbGUgYXJndW1lbnQgaW50byB0cnVzdCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gdmFsXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGUgKHZhbCkge1xuICBpZiAoIXZhbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IGlzIHJlcXVpcmVkJylcbiAgfVxuXG4gIHZhciB0cnVzdFxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHRydXN0ID0gW3ZhbF1cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICB0cnVzdCA9IHZhbC5zbGljZSgpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5zdXBwb3J0ZWQgdHJ1c3QgYXJndW1lbnQnKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cnVzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhbCA9IHRydXN0W2ldXG5cbiAgICBpZiAoIUlQX1JBTkdFUy5oYXNPd25Qcm9wZXJ0eSh2YWwpKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIC8vIFNwbGljZSBpbiBwcmUtZGVmaW5lZCByYW5nZVxuICAgIHZhbCA9IElQX1JBTkdFU1t2YWxdXG4gICAgdHJ1c3Quc3BsaWNlLmFwcGx5KHRydXN0LCBbaSwgMV0uY29uY2F0KHZhbCkpXG4gICAgaSArPSB2YWwubGVuZ3RoIC0gMVxuICB9XG5cbiAgcmV0dXJuIGNvbXBpbGVUcnVzdChjb21waWxlUmFuZ2VTdWJuZXRzKHRydXN0KSlcbn1cblxuLyoqXG4gKiBDb21waWxlIGBhcnJgIGVsZW1lbnRzIGludG8gcmFuZ2Ugc3VibmV0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZVJhbmdlU3VibmV0cyAoYXJyKSB7XG4gIHZhciByYW5nZVN1Ym5ldHMgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIHJhbmdlU3VibmV0c1tpXSA9IHBhcnNlaXBOb3RhdGlvbihhcnJbaV0pXG4gIH1cblxuICByZXR1cm4gcmFuZ2VTdWJuZXRzXG59XG5cbi8qKlxuICogQ29tcGlsZSByYW5nZSBzdWJuZXQgYXJyYXkgaW50byB0cnVzdCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSByYW5nZVN1Ym5ldHNcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZVRydXN0IChyYW5nZVN1Ym5ldHMpIHtcbiAgLy8gUmV0dXJuIG9wdGltaXplZCBmdW5jdGlvbiBiYXNlZCBvbiBsZW5ndGhcbiAgdmFyIGxlbiA9IHJhbmdlU3VibmV0cy5sZW5ndGhcbiAgcmV0dXJuIGxlbiA9PT0gMFxuICAgID8gdHJ1c3ROb25lXG4gICAgOiBsZW4gPT09IDFcbiAgICAgID8gdHJ1c3RTaW5nbGUocmFuZ2VTdWJuZXRzWzBdKVxuICAgICAgOiB0cnVzdE11bHRpKHJhbmdlU3VibmV0cylcbn1cblxuLyoqXG4gKiBQYXJzZSBJUCBub3RhdGlvbiBzdHJpbmcgaW50byByYW5nZSBzdWJuZXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5vdGVcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VpcE5vdGF0aW9uIChub3RlKSB7XG4gIHZhciBwb3MgPSBub3RlLmxhc3RJbmRleE9mKCcvJylcbiAgdmFyIHN0ciA9IHBvcyAhPT0gLTFcbiAgICA/IG5vdGUuc3Vic3RyaW5nKDAsIHBvcylcbiAgICA6IG5vdGVcblxuICBpZiAoIWlzaXAoc3RyKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgSVAgYWRkcmVzczogJyArIHN0cilcbiAgfVxuXG4gIHZhciBpcCA9IHBhcnNlaXAoc3RyKVxuXG4gIGlmIChwb3MgPT09IC0xICYmIGlwLmtpbmQoKSA9PT0gJ2lwdjYnICYmIGlwLmlzSVB2NE1hcHBlZEFkZHJlc3MoKSkge1xuICAgIC8vIFN0b3JlIGFzIElQdjRcbiAgICBpcCA9IGlwLnRvSVB2NEFkZHJlc3MoKVxuICB9XG5cbiAgdmFyIG1heCA9IGlwLmtpbmQoKSA9PT0gJ2lwdjYnXG4gICAgPyAxMjhcbiAgICA6IDMyXG5cbiAgdmFyIHJhbmdlID0gcG9zICE9PSAtMVxuICAgID8gbm90ZS5zdWJzdHJpbmcocG9zICsgMSwgbm90ZS5sZW5ndGgpXG4gICAgOiBudWxsXG5cbiAgaWYgKHJhbmdlID09PSBudWxsKSB7XG4gICAgcmFuZ2UgPSBtYXhcbiAgfSBlbHNlIGlmIChESUdJVF9SRUdFWFAudGVzdChyYW5nZSkpIHtcbiAgICByYW5nZSA9IHBhcnNlSW50KHJhbmdlLCAxMClcbiAgfSBlbHNlIGlmIChpcC5raW5kKCkgPT09ICdpcHY0JyAmJiBpc2lwKHJhbmdlKSkge1xuICAgIHJhbmdlID0gcGFyc2VOZXRtYXNrKHJhbmdlKVxuICB9IGVsc2Uge1xuICAgIHJhbmdlID0gbnVsbFxuICB9XG5cbiAgaWYgKHJhbmdlIDw9IDAgfHwgcmFuZ2UgPiBtYXgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJhbmdlIG9uIGFkZHJlc3M6ICcgKyBub3RlKVxuICB9XG5cbiAgcmV0dXJuIFtpcCwgcmFuZ2VdXG59XG5cbi8qKlxuICogUGFyc2UgbmV0bWFzayBzdHJpbmcgaW50byBDSURSIHJhbmdlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuZXRtYXNrXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlTmV0bWFzayAobmV0bWFzaykge1xuICB2YXIgaXAgPSBwYXJzZWlwKG5ldG1hc2spXG4gIHZhciBraW5kID0gaXAua2luZCgpXG5cbiAgcmV0dXJuIGtpbmQgPT09ICdpcHY0J1xuICAgID8gaXAucHJlZml4TGVuZ3RoRnJvbVN1Ym5ldE1hc2soKVxuICAgIDogbnVsbFxufVxuXG4vKipcbiAqIERldGVybWluZSBhZGRyZXNzIG9mIHByb3hpZWQgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdFxuICogQHBhcmFtIHtGdW5jdGlvbnxBcnJheXxTdHJpbmd9IHRydXN0XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gcHJveHlhZGRyIChyZXEsIHRydXN0KSB7XG4gIGlmICghcmVxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVxIGFyZ3VtZW50IGlzIHJlcXVpcmVkJylcbiAgfVxuXG4gIGlmICghdHJ1c3QpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0cnVzdCBhcmd1bWVudCBpcyByZXF1aXJlZCcpXG4gIH1cblxuICB2YXIgYWRkcnMgPSBhbGxhZGRycyhyZXEsIHRydXN0KVxuICB2YXIgYWRkciA9IGFkZHJzW2FkZHJzLmxlbmd0aCAtIDFdXG5cbiAgcmV0dXJuIGFkZHJcbn1cblxuLyoqXG4gKiBTdGF0aWMgdHJ1c3QgZnVuY3Rpb24gdG8gdHJ1c3Qgbm90aGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHRydXN0Tm9uZSAoKSB7XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIENvbXBpbGUgdHJ1c3QgZnVuY3Rpb24gZm9yIG11bHRpcGxlIHN1Ym5ldHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc3VibmV0c1xuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiB0cnVzdE11bHRpIChzdWJuZXRzKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0cnVzdCAoYWRkcikge1xuICAgIGlmICghaXNpcChhZGRyKSkgcmV0dXJuIGZhbHNlXG5cbiAgICB2YXIgaXAgPSBwYXJzZWlwKGFkZHIpXG4gICAgdmFyIGlwY29udlxuICAgIHZhciBraW5kID0gaXAua2luZCgpXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1Ym5ldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdWJuZXQgPSBzdWJuZXRzW2ldXG4gICAgICB2YXIgc3VibmV0aXAgPSBzdWJuZXRbMF1cbiAgICAgIHZhciBzdWJuZXRraW5kID0gc3VibmV0aXAua2luZCgpXG4gICAgICB2YXIgc3VibmV0cmFuZ2UgPSBzdWJuZXRbMV1cbiAgICAgIHZhciB0cnVzdGVkID0gaXBcblxuICAgICAgaWYgKGtpbmQgIT09IHN1Ym5ldGtpbmQpIHtcbiAgICAgICAgaWYgKHN1Ym5ldGtpbmQgPT09ICdpcHY0JyAmJiAhaXAuaXNJUHY0TWFwcGVkQWRkcmVzcygpKSB7XG4gICAgICAgICAgLy8gSW5jb21wYXRpYmxlIElQIGFkZHJlc3Nlc1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlwY29udikge1xuICAgICAgICAgIC8vIENvbnZlcnQgSVAgdG8gbWF0Y2ggc3VibmV0IElQIGtpbmRcbiAgICAgICAgICBpcGNvbnYgPSBzdWJuZXRraW5kID09PSAnaXB2NCdcbiAgICAgICAgICAgID8gaXAudG9JUHY0QWRkcmVzcygpXG4gICAgICAgICAgICA6IGlwLnRvSVB2NE1hcHBlZEFkZHJlc3MoKVxuICAgICAgICB9XG5cbiAgICAgICAgdHJ1c3RlZCA9IGlwY29udlxuICAgICAgfVxuXG4gICAgICBpZiAodHJ1c3RlZC5tYXRjaChzdWJuZXRpcCwgc3VibmV0cmFuZ2UpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBDb21waWxlIHRydXN0IGZ1bmN0aW9uIGZvciBzaW5nbGUgc3VibmV0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdWJuZXRcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gdHJ1c3RTaW5nbGUgKHN1Ym5ldCkge1xuICB2YXIgc3VibmV0aXAgPSBzdWJuZXRbMF1cbiAgdmFyIHN1Ym5ldGtpbmQgPSBzdWJuZXRpcC5raW5kKClcbiAgdmFyIHN1Ym5ldGlzaXB2NCA9IHN1Ym5ldGtpbmQgPT09ICdpcHY0J1xuICB2YXIgc3VibmV0cmFuZ2UgPSBzdWJuZXRbMV1cblxuICByZXR1cm4gZnVuY3Rpb24gdHJ1c3QgKGFkZHIpIHtcbiAgICBpZiAoIWlzaXAoYWRkcikpIHJldHVybiBmYWxzZVxuXG4gICAgdmFyIGlwID0gcGFyc2VpcChhZGRyKVxuICAgIHZhciBraW5kID0gaXAua2luZCgpXG5cbiAgICBpZiAoa2luZCAhPT0gc3VibmV0a2luZCkge1xuICAgICAgaWYgKHN1Ym5ldGlzaXB2NCAmJiAhaXAuaXNJUHY0TWFwcGVkQWRkcmVzcygpKSB7XG4gICAgICAgIC8vIEluY29tcGF0aWJsZSBJUCBhZGRyZXNzZXNcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIC8vIENvbnZlcnQgSVAgdG8gbWF0Y2ggc3VibmV0IElQIGtpbmRcbiAgICAgIGlwID0gc3VibmV0aXNpcHY0XG4gICAgICAgID8gaXAudG9JUHY0QWRkcmVzcygpXG4gICAgICAgIDogaXAudG9JUHY0TWFwcGVkQWRkcmVzcygpXG4gICAgfVxuXG4gICAgcmV0dXJuIGlwLm1hdGNoKHN1Ym5ldGlwLCBzdWJuZXRyYW5nZSlcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJveHktYWRkci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBhY2NlcHRzXG4gKiBDb3B5cmlnaHQoYykgMjAxNCBKb25hdGhhbiBPbmdcbiAqIENvcHlyaWdodChjKSAyMDE1IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgTmVnb3RpYXRvciA9IHJlcXVpcmUoJ25lZ290aWF0b3InKVxudmFyIG1pbWUgPSByZXF1aXJlKCdtaW1lLXR5cGVzJylcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFjY2VwdHNcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgQWNjZXB0cyBvYmplY3QgZm9yIHRoZSBnaXZlbiByZXEuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHJlcVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEFjY2VwdHMgKHJlcSkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQWNjZXB0cykpIHtcbiAgICByZXR1cm4gbmV3IEFjY2VwdHMocmVxKVxuICB9XG5cbiAgdGhpcy5oZWFkZXJzID0gcmVxLmhlYWRlcnNcbiAgdGhpcy5uZWdvdGlhdG9yID0gbmV3IE5lZ290aWF0b3IocmVxKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBgdHlwZShzKWAgaXMgYWNjZXB0YWJsZSwgcmV0dXJuaW5nXG4gKiB0aGUgYmVzdCBtYXRjaCB3aGVuIHRydWUsIG90aGVyd2lzZSBgdW5kZWZpbmVkYCwgaW4gd2hpY2hcbiAqIGNhc2UgeW91IHNob3VsZCByZXNwb25kIHdpdGggNDA2IFwiTm90IEFjY2VwdGFibGVcIi5cbiAqXG4gKiBUaGUgYHR5cGVgIHZhbHVlIG1heSBiZSBhIHNpbmdsZSBtaW1lIHR5cGUgc3RyaW5nXG4gKiBzdWNoIGFzIFwiYXBwbGljYXRpb24vanNvblwiLCB0aGUgZXh0ZW5zaW9uIG5hbWVcbiAqIHN1Y2ggYXMgXCJqc29uXCIgb3IgYW4gYXJyYXkgYFtcImpzb25cIiwgXCJodG1sXCIsIFwidGV4dC9wbGFpblwiXWAuIFdoZW4gYSBsaXN0XG4gKiBvciBhcnJheSBpcyBnaXZlbiB0aGUgX2Jlc3RfIG1hdGNoLCBpZiBhbnkgaXMgcmV0dXJuZWQuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgIC8vIEFjY2VwdDogdGV4dC9odG1sXG4gKiAgICAgdGhpcy50eXBlcygnaHRtbCcpO1xuICogICAgIC8vID0+IFwiaHRtbFwiXG4gKlxuICogICAgIC8vIEFjY2VwdDogdGV4dC8qLCBhcHBsaWNhdGlvbi9qc29uXG4gKiAgICAgdGhpcy50eXBlcygnaHRtbCcpO1xuICogICAgIC8vID0+IFwiaHRtbFwiXG4gKiAgICAgdGhpcy50eXBlcygndGV4dC9odG1sJyk7XG4gKiAgICAgLy8gPT4gXCJ0ZXh0L2h0bWxcIlxuICogICAgIHRoaXMudHlwZXMoJ2pzb24nLCAndGV4dCcpO1xuICogICAgIC8vID0+IFwianNvblwiXG4gKiAgICAgdGhpcy50eXBlcygnYXBwbGljYXRpb24vanNvbicpO1xuICogICAgIC8vID0+IFwiYXBwbGljYXRpb24vanNvblwiXG4gKlxuICogICAgIC8vIEFjY2VwdDogdGV4dC8qLCBhcHBsaWNhdGlvbi9qc29uXG4gKiAgICAgdGhpcy50eXBlcygnaW1hZ2UvcG5nJyk7XG4gKiAgICAgdGhpcy50eXBlcygncG5nJyk7XG4gKiAgICAgLy8gPT4gdW5kZWZpbmVkXG4gKlxuICogICAgIC8vIEFjY2VwdDogdGV4dC8qO3E9LjUsIGFwcGxpY2F0aW9uL2pzb25cbiAqICAgICB0aGlzLnR5cGVzKFsnaHRtbCcsICdqc29uJ10pO1xuICogICAgIHRoaXMudHlwZXMoJ2h0bWwnLCAnanNvbicpO1xuICogICAgIC8vID0+IFwianNvblwiXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHR5cGVzLi4uXG4gKiBAcmV0dXJuIHtTdHJpbmd8QXJyYXl8Qm9vbGVhbn1cbiAqIEBwdWJsaWNcbiAqL1xuXG5BY2NlcHRzLnByb3RvdHlwZS50eXBlID1cbkFjY2VwdHMucHJvdG90eXBlLnR5cGVzID0gZnVuY3Rpb24gKHR5cGVzXykge1xuICB2YXIgdHlwZXMgPSB0eXBlc19cblxuICAvLyBzdXBwb3J0IGZsYXR0ZW5lZCBhcmd1bWVudHNcbiAgaWYgKHR5cGVzICYmICFBcnJheS5pc0FycmF5KHR5cGVzKSkge1xuICAgIHR5cGVzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdHlwZXNbaV0gPSBhcmd1bWVudHNbaV1cbiAgICB9XG4gIH1cblxuICAvLyBubyB0eXBlcywgcmV0dXJuIGFsbCByZXF1ZXN0ZWQgdHlwZXNcbiAgaWYgKCF0eXBlcyB8fCB0eXBlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5uZWdvdGlhdG9yLm1lZGlhVHlwZXMoKVxuICB9XG5cbiAgLy8gbm8gYWNjZXB0IGhlYWRlciwgcmV0dXJuIGZpcnN0IGdpdmVuIHR5cGVcbiAgaWYgKCF0aGlzLmhlYWRlcnMuYWNjZXB0KSB7XG4gICAgcmV0dXJuIHR5cGVzWzBdXG4gIH1cblxuICB2YXIgbWltZXMgPSB0eXBlcy5tYXAoZXh0VG9NaW1lKVxuICB2YXIgYWNjZXB0cyA9IHRoaXMubmVnb3RpYXRvci5tZWRpYVR5cGVzKG1pbWVzLmZpbHRlcih2YWxpZE1pbWUpKVxuICB2YXIgZmlyc3QgPSBhY2NlcHRzWzBdXG5cbiAgcmV0dXJuIGZpcnN0XG4gICAgPyB0eXBlc1ttaW1lcy5pbmRleE9mKGZpcnN0KV1cbiAgICA6IGZhbHNlXG59XG5cbi8qKlxuICogUmV0dXJuIGFjY2VwdGVkIGVuY29kaW5ncyBvciBiZXN0IGZpdCBiYXNlZCBvbiBgZW5jb2RpbmdzYC5cbiAqXG4gKiBHaXZlbiBgQWNjZXB0LUVuY29kaW5nOiBnemlwLCBkZWZsYXRlYFxuICogYW4gYXJyYXkgc29ydGVkIGJ5IHF1YWxpdHkgaXMgcmV0dXJuZWQ6XG4gKlxuICogICAgIFsnZ3ppcCcsICdkZWZsYXRlJ11cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gZW5jb2RpbmdzLi4uXG4gKiBAcmV0dXJuIHtTdHJpbmd8QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cblxuQWNjZXB0cy5wcm90b3R5cGUuZW5jb2RpbmcgPVxuQWNjZXB0cy5wcm90b3R5cGUuZW5jb2RpbmdzID0gZnVuY3Rpb24gKGVuY29kaW5nc18pIHtcbiAgdmFyIGVuY29kaW5ncyA9IGVuY29kaW5nc19cblxuICAvLyBzdXBwb3J0IGZsYXR0ZW5lZCBhcmd1bWVudHNcbiAgaWYgKGVuY29kaW5ncyAmJiAhQXJyYXkuaXNBcnJheShlbmNvZGluZ3MpKSB7XG4gICAgZW5jb2RpbmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVuY29kaW5nc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vIGVuY29kaW5ncywgcmV0dXJuIGFsbCByZXF1ZXN0ZWQgZW5jb2RpbmdzXG4gIGlmICghZW5jb2RpbmdzIHx8IGVuY29kaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5uZWdvdGlhdG9yLmVuY29kaW5ncygpXG4gIH1cblxuICByZXR1cm4gdGhpcy5uZWdvdGlhdG9yLmVuY29kaW5ncyhlbmNvZGluZ3MpWzBdIHx8IGZhbHNlXG59XG5cbi8qKlxuICogUmV0dXJuIGFjY2VwdGVkIGNoYXJzZXRzIG9yIGJlc3QgZml0IGJhc2VkIG9uIGBjaGFyc2V0c2AuXG4gKlxuICogR2l2ZW4gYEFjY2VwdC1DaGFyc2V0OiB1dGYtOCwgaXNvLTg4NTktMTtxPTAuMiwgdXRmLTc7cT0wLjVgXG4gKiBhbiBhcnJheSBzb3J0ZWQgYnkgcXVhbGl0eSBpcyByZXR1cm5lZDpcbiAqXG4gKiAgICAgWyd1dGYtOCcsICd1dGYtNycsICdpc28tODg1OS0xJ11cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gY2hhcnNldHMuLi5cbiAqIEByZXR1cm4ge1N0cmluZ3xBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuXG5BY2NlcHRzLnByb3RvdHlwZS5jaGFyc2V0ID1cbkFjY2VwdHMucHJvdG90eXBlLmNoYXJzZXRzID0gZnVuY3Rpb24gKGNoYXJzZXRzXykge1xuICB2YXIgY2hhcnNldHMgPSBjaGFyc2V0c19cblxuICAvLyBzdXBwb3J0IGZsYXR0ZW5lZCBhcmd1bWVudHNcbiAgaWYgKGNoYXJzZXRzICYmICFBcnJheS5pc0FycmF5KGNoYXJzZXRzKSkge1xuICAgIGNoYXJzZXRzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFyc2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhcnNldHNbaV0gPSBhcmd1bWVudHNbaV1cbiAgICB9XG4gIH1cblxuICAvLyBubyBjaGFyc2V0cywgcmV0dXJuIGFsbCByZXF1ZXN0ZWQgY2hhcnNldHNcbiAgaWYgKCFjaGFyc2V0cyB8fCBjaGFyc2V0cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5uZWdvdGlhdG9yLmNoYXJzZXRzKClcbiAgfVxuXG4gIHJldHVybiB0aGlzLm5lZ290aWF0b3IuY2hhcnNldHMoY2hhcnNldHMpWzBdIHx8IGZhbHNlXG59XG5cbi8qKlxuICogUmV0dXJuIGFjY2VwdGVkIGxhbmd1YWdlcyBvciBiZXN0IGZpdCBiYXNlZCBvbiBgbGFuZ3NgLlxuICpcbiAqIEdpdmVuIGBBY2NlcHQtTGFuZ3VhZ2U6IGVuO3E9MC44LCBlcywgcHRgXG4gKiBhbiBhcnJheSBzb3J0ZWQgYnkgcXVhbGl0eSBpcyByZXR1cm5lZDpcbiAqXG4gKiAgICAgWydlcycsICdwdCcsICdlbiddXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGxhbmdzLi4uXG4gKiBAcmV0dXJuIHtBcnJheXxTdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuQWNjZXB0cy5wcm90b3R5cGUubGFuZyA9XG5BY2NlcHRzLnByb3RvdHlwZS5sYW5ncyA9XG5BY2NlcHRzLnByb3RvdHlwZS5sYW5ndWFnZSA9XG5BY2NlcHRzLnByb3RvdHlwZS5sYW5ndWFnZXMgPSBmdW5jdGlvbiAobGFuZ3VhZ2VzXykge1xuICB2YXIgbGFuZ3VhZ2VzID0gbGFuZ3VhZ2VzX1xuXG4gIC8vIHN1cHBvcnQgZmxhdHRlbmVkIGFyZ3VtZW50c1xuICBpZiAobGFuZ3VhZ2VzICYmICFBcnJheS5pc0FycmF5KGxhbmd1YWdlcykpIHtcbiAgICBsYW5ndWFnZXMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhbmd1YWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGFuZ3VhZ2VzW2ldID0gYXJndW1lbnRzW2ldXG4gICAgfVxuICB9XG5cbiAgLy8gbm8gbGFuZ3VhZ2VzLCByZXR1cm4gYWxsIHJlcXVlc3RlZCBsYW5ndWFnZXNcbiAgaWYgKCFsYW5ndWFnZXMgfHwgbGFuZ3VhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLm5lZ290aWF0b3IubGFuZ3VhZ2VzKClcbiAgfVxuXG4gIHJldHVybiB0aGlzLm5lZ290aWF0b3IubGFuZ3VhZ2VzKGxhbmd1YWdlcylbMF0gfHwgZmFsc2Vcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGV4dG5hbWVzIHRvIG1pbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZXh0VG9NaW1lICh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmluZGV4T2YoJy8nKSA9PT0gLTFcbiAgICA/IG1pbWUubG9va3VwKHR5cGUpXG4gICAgOiB0eXBlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgbWltZSBpcyB2YWxpZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7U3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiB2YWxpZE1pbWUgKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJ1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYWNjZXB0cy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBjb29raWVcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgUm9tYW4gU2h0eWxtYW5cbiAqIENvcHlyaWdodChjKSAyMDE1IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG5cbi8qKlxuICogTW9kdWxlIHZhcmlhYmxlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIGRlY29kZSA9IGRlY29kZVVSSUNvbXBvbmVudDtcbnZhciBlbmNvZGUgPSBlbmNvZGVVUklDb21wb25lbnQ7XG52YXIgcGFpclNwbGl0UmVnRXhwID0gLzsgKi87XG5cbi8qKlxuICogUmVnRXhwIHRvIG1hdGNoIGZpZWxkLWNvbnRlbnQgaW4gUkZDIDcyMzAgc2VjIDMuMlxuICpcbiAqIGZpZWxkLWNvbnRlbnQgPSBmaWVsZC12Y2hhciBbIDEqKCBTUCAvIEhUQUIgKSBmaWVsZC12Y2hhciBdXG4gKiBmaWVsZC12Y2hhciAgID0gVkNIQVIgLyBvYnMtdGV4dFxuICogb2JzLXRleHQgICAgICA9ICV4ODAtRkZcbiAqL1xuXG52YXIgZmllbGRDb250ZW50UmVnRXhwID0gL15bXFx1MDAwOVxcdTAwMjAtXFx1MDA3ZVxcdTAwODAtXFx1MDBmZl0rJC87XG5cbi8qKlxuICogUGFyc2UgYSBjb29raWUgaGVhZGVyLlxuICpcbiAqIFBhcnNlIHRoZSBnaXZlbiBjb29raWUgaGVhZGVyIHN0cmluZyBpbnRvIGFuIG9iamVjdFxuICogVGhlIG9iamVjdCBoYXMgdGhlIHZhcmlvdXMgY29va2llcyBhcyBrZXlzKG5hbWVzKSA9PiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHN0ciBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICB2YXIgb2JqID0ge31cbiAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XG4gIHZhciBwYWlycyA9IHN0ci5zcGxpdChwYWlyU3BsaXRSZWdFeHApO1xuICB2YXIgZGVjID0gb3B0LmRlY29kZSB8fCBkZWNvZGU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwYWlyID0gcGFpcnNbaV07XG4gICAgdmFyIGVxX2lkeCA9IHBhaXIuaW5kZXhPZignPScpO1xuXG4gICAgLy8gc2tpcCB0aGluZ3MgdGhhdCBkb24ndCBsb29rIGxpa2Uga2V5PXZhbHVlXG4gICAgaWYgKGVxX2lkeCA8IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBrZXkgPSBwYWlyLnN1YnN0cigwLCBlcV9pZHgpLnRyaW0oKVxuICAgIHZhciB2YWwgPSBwYWlyLnN1YnN0cigrK2VxX2lkeCwgcGFpci5sZW5ndGgpLnRyaW0oKTtcblxuICAgIC8vIHF1b3RlZCB2YWx1ZXNcbiAgICBpZiAoJ1wiJyA9PSB2YWxbMF0pIHtcbiAgICAgIHZhbCA9IHZhbC5zbGljZSgxLCAtMSk7XG4gICAgfVxuXG4gICAgLy8gb25seSBhc3NpZ24gb25jZVxuICAgIGlmICh1bmRlZmluZWQgPT0gb2JqW2tleV0pIHtcbiAgICAgIG9ialtrZXldID0gdHJ5RGVjb2RlKHZhbCwgZGVjKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBkYXRhIGludG8gYSBjb29raWUgaGVhZGVyLlxuICpcbiAqIFNlcmlhbGl6ZSB0aGUgYSBuYW1lIHZhbHVlIHBhaXIgaW50byBhIGNvb2tpZSBzdHJpbmcgc3VpdGFibGUgZm9yXG4gKiBodHRwIGhlYWRlcnMuIEFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHNwZWNpZmllZCBjb29raWUgcGFyYW1ldGVycy5cbiAqXG4gKiBzZXJpYWxpemUoJ2ZvbycsICdiYXInLCB7IGh0dHBPbmx5OiB0cnVlIH0pXG4gKiAgID0+IFwiZm9vPWJhcjsgaHR0cE9ubHlcIlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gc2VyaWFsaXplKG5hbWUsIHZhbCwgb3B0aW9ucykge1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGVuYyA9IG9wdC5lbmNvZGUgfHwgZW5jb2RlO1xuXG4gIGlmICh0eXBlb2YgZW5jICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIGVuY29kZSBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICBpZiAoIWZpZWxkQ29udGVudFJlZ0V4cC50ZXN0KG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbmFtZSBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBlbmModmFsKTtcblxuICBpZiAodmFsdWUgJiYgIWZpZWxkQ29udGVudFJlZ0V4cC50ZXN0KHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHZhbCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICB2YXIgc3RyID0gbmFtZSArICc9JyArIHZhbHVlO1xuXG4gIGlmIChudWxsICE9IG9wdC5tYXhBZ2UpIHtcbiAgICB2YXIgbWF4QWdlID0gb3B0Lm1heEFnZSAtIDA7XG4gICAgaWYgKGlzTmFOKG1heEFnZSkpIHRocm93IG5ldyBFcnJvcignbWF4QWdlIHNob3VsZCBiZSBhIE51bWJlcicpO1xuICAgIHN0ciArPSAnOyBNYXgtQWdlPScgKyBNYXRoLmZsb29yKG1heEFnZSk7XG4gIH1cblxuICBpZiAob3B0LmRvbWFpbikge1xuICAgIGlmICghZmllbGRDb250ZW50UmVnRXhwLnRlc3Qob3B0LmRvbWFpbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBkb21haW4gaXMgaW52YWxpZCcpO1xuICAgIH1cblxuICAgIHN0ciArPSAnOyBEb21haW49JyArIG9wdC5kb21haW47XG4gIH1cblxuICBpZiAob3B0LnBhdGgpIHtcbiAgICBpZiAoIWZpZWxkQ29udGVudFJlZ0V4cC50ZXN0KG9wdC5wYXRoKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIHBhdGggaXMgaW52YWxpZCcpO1xuICAgIH1cblxuICAgIHN0ciArPSAnOyBQYXRoPScgKyBvcHQucGF0aDtcbiAgfVxuXG4gIGlmIChvcHQuZXhwaXJlcykge1xuICAgIGlmICh0eXBlb2Ygb3B0LmV4cGlyZXMudG9VVENTdHJpbmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBleHBpcmVzIGlzIGludmFsaWQnKTtcbiAgICB9XG5cbiAgICBzdHIgKz0gJzsgRXhwaXJlcz0nICsgb3B0LmV4cGlyZXMudG9VVENTdHJpbmcoKTtcbiAgfVxuXG4gIGlmIChvcHQuaHR0cE9ubHkpIHtcbiAgICBzdHIgKz0gJzsgSHR0cE9ubHknO1xuICB9XG5cbiAgaWYgKG9wdC5zZWN1cmUpIHtcbiAgICBzdHIgKz0gJzsgU2VjdXJlJztcbiAgfVxuXG4gIGlmIChvcHQuc2FtZVNpdGUpIHtcbiAgICB2YXIgc2FtZVNpdGUgPSB0eXBlb2Ygb3B0LnNhbWVTaXRlID09PSAnc3RyaW5nJ1xuICAgICAgPyBvcHQuc2FtZVNpdGUudG9Mb3dlckNhc2UoKSA6IG9wdC5zYW1lU2l0ZTtcblxuICAgIHN3aXRjaCAoc2FtZVNpdGUpIHtcbiAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAgc3RyICs9ICc7IFNhbWVTaXRlPVN0cmljdCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGF4JzpcbiAgICAgICAgc3RyICs9ICc7IFNhbWVTaXRlPUxheCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc3RyaWN0JzpcbiAgICAgICAgc3RyICs9ICc7IFNhbWVTaXRlPVN0cmljdCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIHNhbWVTaXRlIGlzIGludmFsaWQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIFRyeSBkZWNvZGluZyBhIHN0cmluZyB1c2luZyBhIGRlY29kaW5nIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRlY29kZVxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiB0cnlEZWNvZGUoc3RyLCBkZWNvZGUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlKHN0cik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb29raWUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBYSFIgPSByZXF1aXJlKCcuL3BvbGxpbmcteGhyJyk7XG52YXIgSlNPTlAgPSByZXF1aXJlKCcuL3BvbGxpbmctanNvbnAnKTtcblxuLyoqXG4gKiBFeHBvcnQgdHJhbnNwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSB7XG4gIHBvbGxpbmc6IHBvbGxpbmcsXG4gIHdlYnNvY2tldDogcmVxdWlyZSgnLi93ZWJzb2NrZXQnKVxufTtcblxuLyoqXG4gKiBFeHBvcnQgdXBncmFkZXMgbWFwLlxuICovXG5cbmV4cG9ydHMucG9sbGluZy51cGdyYWRlc1RvID0gWyd3ZWJzb2NrZXQnXTtcblxuLyoqXG4gKiBQb2xsaW5nIHBvbHltb3JwaGljIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBvbGxpbmcgKHJlcSkge1xuICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiByZXEuX3F1ZXJ5LmopIHtcbiAgICByZXR1cm4gbmV3IEpTT05QKHJlcSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBYSFIocmVxKTtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2xpYi90cmFuc3BvcnRzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0Jyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG52YXIgYWNjZXB0cyA9IHJlcXVpcmUoJ2FjY2VwdHMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lOnBvbGxpbmcnKTtcblxudmFyIGNvbXByZXNzaW9uTWV0aG9kcyA9IHtcbiAgZ3ppcDogemxpYi5jcmVhdGVHemlwLFxuICBkZWZsYXRlOiB6bGliLmNyZWF0ZURlZmxhdGVcbn07XG5cbi8qKlxuICogRXhwb3J0cyB0aGUgY29uc3RydWN0b3IuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXG4vKipcbiAqIEhUVFAgcG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpYy5cbiAqL1xuXG5mdW5jdGlvbiBQb2xsaW5nIChyZXEpIHtcbiAgVHJhbnNwb3J0LmNhbGwodGhpcywgcmVxKTtcblxuICB0aGlzLmNsb3NlVGltZW91dCA9IDMwICogMTAwMDtcbiAgdGhpcy5tYXhIdHRwQnVmZmVyU2l6ZSA9IG51bGw7XG4gIHRoaXMuaHR0cENvbXByZXNzaW9uID0gbnVsbDtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHB1YmxpYy5cbiAqL1xuXG51dGlsLmluaGVyaXRzKFBvbGxpbmcsIFRyYW5zcG9ydCk7XG5cbi8qKlxuICogVHJhbnNwb3J0IG5hbWVcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm5hbWUgPSAncG9sbGluZyc7XG5cbi8qKlxuICogT3ZlcnJpZGVzIG9uUmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUub25SZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcSkge1xuICB2YXIgcmVzID0gcmVxLnJlcztcblxuICBpZiAoJ0dFVCcgPT09IHJlcS5tZXRob2QpIHtcbiAgICB0aGlzLm9uUG9sbFJlcXVlc3QocmVxLCByZXMpO1xuICB9IGVsc2UgaWYgKCdQT1NUJyA9PT0gcmVxLm1ldGhvZCkge1xuICAgIHRoaXMub25EYXRhUmVxdWVzdChyZXEsIHJlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVzLndyaXRlSGVhZCg1MDApO1xuICAgIHJlcy5lbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgY2xpZW50IHNlbmRzIGEgcmVxdWVzdCBhd2FpdGluZyBmb3IgdXMgdG8gc2VuZCBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm9uUG9sbFJlcXVlc3QgPSBmdW5jdGlvbiAocmVxLCByZXMpIHtcbiAgaWYgKHRoaXMucmVxKSB7XG4gICAgZGVidWcoJ3JlcXVlc3Qgb3ZlcmxhcCcpO1xuICAgIC8vIGFzc2VydDogdGhpcy5yZXMsICcucmVxIGFuZCAucmVzIHNob3VsZCBiZSAodW4pc2V0IHRvZ2V0aGVyJ1xuICAgIHRoaXMub25FcnJvcignb3ZlcmxhcCBmcm9tIGNsaWVudCcpO1xuICAgIHJlcy53cml0ZUhlYWQoNTAwKTtcbiAgICByZXMuZW5kKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGVidWcoJ3NldHRpbmcgcmVxdWVzdCcpO1xuXG4gIHRoaXMucmVxID0gcmVxO1xuICB0aGlzLnJlcyA9IHJlcztcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25DbG9zZSAoKSB7XG4gICAgc2VsZi5vbkVycm9yKCdwb2xsIGNvbm5lY3Rpb24gY2xvc2VkIHByZW1hdHVyZWx5Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwICgpIHtcbiAgICByZXEucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25DbG9zZSk7XG4gICAgc2VsZi5yZXEgPSBzZWxmLnJlcyA9IG51bGw7XG4gIH1cblxuICByZXEuY2xlYW51cCA9IGNsZWFudXA7XG4gIHJlcS5vbignY2xvc2UnLCBvbkNsb3NlKTtcblxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdkcmFpbicpO1xuXG4gIC8vIGlmIHdlJ3JlIHN0aWxsIHdyaXRhYmxlIGJ1dCBoYWQgYSBwZW5kaW5nIGNsb3NlLCB0cmlnZ2VyIGFuIGVtcHR5IHNlbmRcbiAgaWYgKHRoaXMud3JpdGFibGUgJiYgdGhpcy5zaG91bGRDbG9zZSkge1xuICAgIGRlYnVnKCd0cmlnZ2VyaW5nIGVtcHR5IHNlbmQgdG8gYXBwZW5kIGNsb3NlIHBhY2tldCcpO1xuICAgIHRoaXMuc2VuZChbeyB0eXBlOiAnbm9vcCcgfV0pO1xuICB9XG59O1xuXG4vKipcbiAqIFRoZSBjbGllbnQgc2VuZHMgYSByZXF1ZXN0IHdpdGggZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5vbkRhdGFSZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7XG4gIGlmICh0aGlzLmRhdGFSZXEpIHtcbiAgICAvLyBhc3NlcnQ6IHRoaXMuZGF0YVJlcywgJy5kYXRhUmVxIGFuZCAuZGF0YVJlcyBzaG91bGQgYmUgKHVuKXNldCB0b2dldGhlcidcbiAgICB0aGlzLm9uRXJyb3IoJ2RhdGEgcmVxdWVzdCBvdmVybGFwIGZyb20gY2xpZW50Jyk7XG4gICAgcmVzLndyaXRlSGVhZCg1MDApO1xuICAgIHJlcy5lbmQoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaXNCaW5hcnkgPSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyA9PT0gcmVxLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddO1xuXG4gIHRoaXMuZGF0YVJlcSA9IHJlcTtcbiAgdGhpcy5kYXRhUmVzID0gcmVzO1xuXG4gIHZhciBjaHVua3MgPSBpc0JpbmFyeSA/IEJ1ZmZlci5jb25jYXQoW10pIDogJyc7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmdW5jdGlvbiBjbGVhbnVwICgpIHtcbiAgICByZXEucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbkRhdGEpO1xuICAgIHJlcS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25FbmQpO1xuICAgIHJlcS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbkNsb3NlKTtcbiAgICBzZWxmLmRhdGFSZXEgPSBzZWxmLmRhdGFSZXMgPSBjaHVua3MgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gb25DbG9zZSAoKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIHNlbGYub25FcnJvcignZGF0YSByZXF1ZXN0IGNvbm5lY3Rpb24gY2xvc2VkIHByZW1hdHVyZWx5Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkRhdGEgKGRhdGEpIHtcbiAgICB2YXIgY29udGVudExlbmd0aDtcbiAgICBpZiAoaXNCaW5hcnkpIHtcbiAgICAgIGNodW5rcyA9IEJ1ZmZlci5jb25jYXQoW2NodW5rcywgZGF0YV0pO1xuICAgICAgY29udGVudExlbmd0aCA9IGNodW5rcy5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNodW5rcyArPSBkYXRhO1xuICAgICAgY29udGVudExlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGNodW5rcyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRlbnRMZW5ndGggPiBzZWxmLm1heEh0dHBCdWZmZXJTaXplKSB7XG4gICAgICBjaHVua3MgPSBpc0JpbmFyeSA/IEJ1ZmZlci5jb25jYXQoW10pIDogJyc7XG4gICAgICByZXEuY29ubmVjdGlvbi5kZXN0cm95KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25FbmQgKCkge1xuICAgIHNlbGYub25EYXRhKGNodW5rcyk7XG5cbiAgICB2YXIgaGVhZGVycyA9IHtcbiAgICAgIC8vIHRleHQvaHRtbCBpcyByZXF1aXJlZCBpbnN0ZWFkIG9mIHRleHQvcGxhaW4gdG8gYXZvaWQgYW5cbiAgICAgIC8vIHVud2FudGVkIGRvd25sb2FkIGRpYWxvZyBvbiBjZXJ0YWluIHVzZXItYWdlbnRzIChHSC00MylcbiAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9odG1sJyxcbiAgICAgICdDb250ZW50LUxlbmd0aCc6IDJcbiAgICB9O1xuXG4gICAgcmVzLndyaXRlSGVhZCgyMDAsIHNlbGYuaGVhZGVycyhyZXEsIGhlYWRlcnMpKTtcbiAgICByZXMuZW5kKCdvaycpO1xuICAgIGNsZWFudXAoKTtcbiAgfVxuXG4gIHJlcS5vbignY2xvc2UnLCBvbkNsb3NlKTtcbiAgaWYgKCFpc0JpbmFyeSkgcmVxLnNldEVuY29kaW5nKCd1dGY4Jyk7XG4gIHJlcS5vbignZGF0YScsIG9uRGF0YSk7XG4gIHJlcS5vbignZW5kJywgb25FbmQpO1xufTtcblxuLyoqXG4gKiBQcm9jZXNzZXMgdGhlIGluY29taW5nIGRhdGEgcGF5bG9hZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RlZCBwYXlsb2FkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICBkZWJ1ZygncmVjZWl2ZWQgXCIlc1wiJywgZGF0YSk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICAgIGlmICgnY2xvc2UnID09PSBwYWNrZXQudHlwZSkge1xuICAgICAgZGVidWcoJ2dvdCB4aHIgY2xvc2UgcGFja2V0Jyk7XG4gICAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH07XG5cbiAgcGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZXMgb25DbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy53cml0YWJsZSkge1xuICAgIC8vIGNsb3NlIHBlbmRpbmcgcG9sbCByZXF1ZXN0XG4gICAgdGhpcy5zZW5kKFt7IHR5cGU6ICdub29wJyB9XSk7XG4gIH1cbiAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldCBwYXlsb2FkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAocGFja2V0cykge1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuc2hvdWxkQ2xvc2UpIHtcbiAgICBkZWJ1ZygnYXBwZW5kaW5nIGNsb3NlIHBhY2tldCB0byBwYXlsb2FkJyk7XG4gICAgcGFja2V0cy5wdXNoKHsgdHlwZTogJ2Nsb3NlJyB9KTtcbiAgICB0aGlzLnNob3VsZENsb3NlKCk7XG4gICAgdGhpcy5zaG91bGRDbG9zZSA9IG51bGw7XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHBhcnNlci5lbmNvZGVQYXlsb2FkKHBhY2tldHMsIHRoaXMuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGNvbXByZXNzID0gcGFja2V0cy5zb21lKGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgICAgIHJldHVybiBwYWNrZXQub3B0aW9ucyAmJiBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcbiAgICB9KTtcbiAgICBzZWxmLndyaXRlKGRhdGEsIHsgY29tcHJlc3M6IGNvbXByZXNzIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGRhdGEgYXMgcmVzcG9uc2UgdG8gcG9sbCByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgb3B0aW9ucykge1xuICBkZWJ1Zygnd3JpdGluZyBcIiVzXCInLCBkYXRhKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmRvV3JpdGUoZGF0YSwgb3B0aW9ucywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYucmVxLmNsZWFudXAoKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIHRoZSB3cml0ZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBleHBsaWNpdCBVVEYtOCBpcyByZXF1aXJlZCBmb3IgcGFnZXMgbm90IHNlcnZlZCB1bmRlciB1dGZcbiAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnO1xuICB2YXIgY29udGVudFR5cGUgPSBpc1N0cmluZ1xuICAgID8gJ3RleHQvcGxhaW47IGNoYXJzZXQ9VVRGLTgnXG4gICAgOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcblxuICB2YXIgaGVhZGVycyA9IHtcbiAgICAnQ29udGVudC1UeXBlJzogY29udGVudFR5cGVcbiAgfTtcblxuICBpZiAoIXRoaXMuaHR0cENvbXByZXNzaW9uIHx8ICFvcHRpb25zLmNvbXByZXNzKSB7XG4gICAgcmVzcG9uZChkYXRhKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbGVuID0gaXNTdHJpbmcgPyBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSA6IGRhdGEubGVuZ3RoO1xuICBpZiAobGVuIDwgdGhpcy5odHRwQ29tcHJlc3Npb24udGhyZXNob2xkKSB7XG4gICAgcmVzcG9uZChkYXRhKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZW5jb2RpbmcgPSBhY2NlcHRzKHRoaXMucmVxKS5lbmNvZGluZ3MoWydnemlwJywgJ2RlZmxhdGUnXSk7XG4gIGlmICghZW5jb2RpbmcpIHtcbiAgICByZXNwb25kKGRhdGEpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuY29tcHJlc3MoZGF0YSwgZW5jb2RpbmcsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzZWxmLnJlcy53cml0ZUhlYWQoNTAwKTtcbiAgICAgIHNlbGYucmVzLmVuZCgpO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoZWFkZXJzWydDb250ZW50LUVuY29kaW5nJ10gPSBlbmNvZGluZztcbiAgICByZXNwb25kKGRhdGEpO1xuICB9KTtcblxuICBmdW5jdGlvbiByZXNwb25kIChkYXRhKSB7XG4gICAgaGVhZGVyc1snQ29udGVudC1MZW5ndGgnXSA9ICdzdHJpbmcnID09PSB0eXBlb2YgZGF0YSA/IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpIDogZGF0YS5sZW5ndGg7XG4gICAgc2VsZi5yZXMud3JpdGVIZWFkKDIwMCwgc2VsZi5oZWFkZXJzKHNlbGYucmVxLCBoZWFkZXJzKSk7XG4gICAgc2VsZi5yZXMuZW5kKGRhdGEpO1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ29tcHJlc3NlcyBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmNvbXByZXNzID0gZnVuY3Rpb24gKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICBkZWJ1ZygnY29tcHJlc3NpbmcnKTtcblxuICB2YXIgYnVmZmVycyA9IFtdO1xuICB2YXIgbnJlYWQgPSAwO1xuXG4gIGNvbXByZXNzaW9uTWV0aG9kc1tlbmNvZGluZ10odGhpcy5odHRwQ29tcHJlc3Npb24pXG4gICAgLm9uKCdlcnJvcicsIGNhbGxiYWNrKVxuICAgIC5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICAgIG5yZWFkICs9IGNodW5rLmxlbmd0aDtcbiAgICB9KVxuICAgIC5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2sobnVsbCwgQnVmZmVyLmNvbmNhdChidWZmZXJzLCBucmVhZCkpO1xuICAgIH0pXG4gICAgLmVuZChkYXRhKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uIChmbikge1xuICBkZWJ1ZygnY2xvc2luZycpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNsb3NlVGltZW91dFRpbWVyO1xuXG4gIGlmICh0aGlzLmRhdGFSZXEpIHtcbiAgICBkZWJ1ZygnYWJvcnRpbmcgb25nb2luZyBkYXRhIHJlcXVlc3QnKTtcbiAgICB0aGlzLmRhdGFSZXEuZGVzdHJveSgpO1xuICB9XG5cbiAgaWYgKHRoaXMud3JpdGFibGUpIHtcbiAgICBkZWJ1ZygndHJhbnNwb3J0IHdyaXRhYmxlIC0gY2xvc2luZyByaWdodCBhd2F5Jyk7XG4gICAgdGhpcy5zZW5kKFt7IHR5cGU6ICdjbG9zZScgfV0pO1xuICAgIG9uQ2xvc2UoKTtcbiAgfSBlbHNlIGlmICh0aGlzLmRpc2NhcmRlZCkge1xuICAgIGRlYnVnKCd0cmFuc3BvcnQgZGlzY2FyZGVkIC0gY2xvc2luZyByaWdodCBhd2F5Jyk7XG4gICAgb25DbG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIGRlYnVnKCd0cmFuc3BvcnQgbm90IHdyaXRhYmxlIC0gYnVmZmVyaW5nIG9yZGVybHkgY2xvc2UnKTtcbiAgICB0aGlzLnNob3VsZENsb3NlID0gb25DbG9zZTtcbiAgICBjbG9zZVRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQob25DbG9zZSwgdGhpcy5jbG9zZVRpbWVvdXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25DbG9zZSAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KGNsb3NlVGltZW91dFRpbWVyKTtcbiAgICBmbigpO1xuICAgIHNlbGYub25DbG9zZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgaGVhZGVycyBmb3IgYSByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXF1ZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gZXh0cmEgaGVhZGVyc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuaGVhZGVycyA9IGZ1bmN0aW9uIChyZXEsIGhlYWRlcnMpIHtcbiAgaGVhZGVycyA9IGhlYWRlcnMgfHwge307XG5cbiAgLy8gcHJldmVudCBYU1Mgd2FybmluZ3Mgb24gSUVcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0xlYXJuQm9vc3Qvc29ja2V0LmlvL3B1bGwvMTMzM1xuICB2YXIgdWEgPSByZXEuaGVhZGVyc1sndXNlci1hZ2VudCddO1xuICBpZiAodWEgJiYgKH51YS5pbmRleE9mKCc7TVNJRScpIHx8IH51YS5pbmRleE9mKCdUcmlkZW50LycpKSkge1xuICAgIGhlYWRlcnNbJ1gtWFNTLVByb3RlY3Rpb24nXSA9ICcwJztcbiAgfVxuXG4gIHRoaXMuZW1pdCgnaGVhZGVycycsIGhlYWRlcnMpO1xuICByZXR1cm4gaGVhZGVycztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vbGliL3RyYW5zcG9ydHMvcG9sbGluZy5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICovXG5leHBvcnRzLmluc3RhbmNlcyA9IFtdO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICB2YXIgcHJldlRpbWU7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG4gIGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgfVxuXG4gIGV4cG9ydHMuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xuXG4gIHJldHVybiBkZWJ1Zztcbn1cblxuZnVuY3Rpb24gZGVzdHJveSAoKSB7XG4gIHZhciBpbmRleCA9IGV4cG9ydHMuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBleHBvcnRzLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBpO1xuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwb3J0cy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBleHBvcnRzLmluc3RhbmNlc1tpXTtcbiAgICBpbnN0YW5jZS5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvZGVidWcuanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmU6c29ja2V0Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogQ2xpZW50IGNsYXNzIChhYnN0cmFjdCkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0IChpZCwgc2VydmVyLCB0cmFuc3BvcnQsIHJlcSkge1xuICB0aGlzLmlkID0gaWQ7XG4gIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICB0aGlzLnVwZ3JhZGluZyA9IGZhbHNlO1xuICB0aGlzLnVwZ3JhZGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcbiAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnBhY2tldHNGbiA9IFtdO1xuICB0aGlzLnNlbnRDYWxsYmFja0ZuID0gW107XG4gIHRoaXMuY2xlYW51cEZuID0gW107XG4gIHRoaXMucmVxdWVzdCA9IHJlcTtcblxuICAvLyBDYWNoZSBJUCBzaW5jZSBpdCBtaWdodCBub3QgYmUgaW4gdGhlIHJlcSBsYXRlclxuICBpZiAocmVxLndlYnNvY2tldCAmJiByZXEud2Vic29ja2V0Ll9zb2NrZXQpIHtcbiAgICB0aGlzLnJlbW90ZUFkZHJlc3MgPSByZXEud2Vic29ja2V0Ll9zb2NrZXQucmVtb3RlQWRkcmVzcztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlbW90ZUFkZHJlc3MgPSByZXEuY29ubmVjdGlvbi5yZW1vdGVBZGRyZXNzO1xuICB9XG5cbiAgdGhpcy5jaGVja0ludGVydmFsVGltZXIgPSBudWxsO1xuICB0aGlzLnVwZ3JhZGVUaW1lb3V0VGltZXIgPSBudWxsO1xuICB0aGlzLnBpbmdUaW1lb3V0VGltZXIgPSBudWxsO1xuXG4gIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gIHRoaXMub25PcGVuKCk7XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBFdmVudEVtaXR0ZXIuXG4gKi9cblxudXRpbC5pbmhlcml0cyhTb2NrZXQsIEV2ZW50RW1pdHRlcik7XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNvbnNpZGVyZWQgb3Blbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuXG4gIC8vIHNlbmRzIGFuIGBvcGVuYCBwYWNrZXRcbiAgdGhpcy50cmFuc3BvcnQuc2lkID0gdGhpcy5pZDtcbiAgdGhpcy5zZW5kUGFja2V0KCdvcGVuJywgSlNPTi5zdHJpbmdpZnkoe1xuICAgIHNpZDogdGhpcy5pZCxcbiAgICB1cGdyYWRlczogdGhpcy5nZXRBdmFpbGFibGVVcGdyYWRlcygpLFxuICAgIHBpbmdJbnRlcnZhbDogdGhpcy5zZXJ2ZXIucGluZ0ludGVydmFsLFxuICAgIHBpbmdUaW1lb3V0OiB0aGlzLnNlcnZlci5waW5nVGltZW91dFxuICB9KSk7XG5cbiAgaWYgKHRoaXMuc2VydmVyLmluaXRpYWxQYWNrZXQpIHtcbiAgICB0aGlzLnNlbmRQYWNrZXQoJ21lc3NhZ2UnLCB0aGlzLnNlcnZlci5pbml0aWFsUGFja2V0KTtcbiAgfVxuXG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuICB0aGlzLnNldFBpbmdUaW1lb3V0KCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgLy8gZXhwb3J0IHBhY2tldCBldmVudFxuICAgIGRlYnVnKCdwYWNrZXQnKTtcbiAgICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG5cbiAgICAvLyBSZXNldCBwaW5nIHRpbWVvdXQgb24gYW55IHBhY2tldCwgaW5jb21pbmcgZGF0YSBpcyBhIGdvb2Qgc2lnbiBvZlxuICAgIC8vIG90aGVyIHNpZGUncyBsaXZlbmVzc1xuICAgIHRoaXMuc2V0UGluZ1RpbWVvdXQoKTtcblxuICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ3BpbmcnOlxuICAgICAgICBkZWJ1ZygnZ290IHBpbmcnKTtcbiAgICAgICAgdGhpcy5zZW5kUGFja2V0KCdwb25nJyk7XG4gICAgICAgIHRoaXMuZW1pdCgnaGVhcnRiZWF0Jyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHRoaXMub25DbG9zZSgncGFyc2UgZXJyb3InKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ21lc3NhZ2UnOlxuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdwYWNrZXQgcmVjZWl2ZWQgd2l0aCBjbG9zZWQgc29ja2V0Jyk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIG9iamVjdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICBkZWJ1ZygndHJhbnNwb3J0IGVycm9yJyk7XG4gIHRoaXMub25DbG9zZSgndHJhbnNwb3J0IGVycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogU2V0cyBhbmQgcmVzZXRzIHBpbmcgdGltZW91dCB0aW1lciBiYXNlZCBvbiBjbGllbnQgcGluZ3MuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXRQaW5nVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjbGVhclRpbWVvdXQoc2VsZi5waW5nVGltZW91dFRpbWVyKTtcbiAgc2VsZi5waW5nVGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbkNsb3NlKCdwaW5nIHRpbWVvdXQnKTtcbiAgfSwgc2VsZi5zZXJ2ZXIucGluZ0ludGVydmFsICsgc2VsZi5zZXJ2ZXIucGluZ1RpbWVvdXQpO1xufTtcblxuLyoqXG4gKiBBdHRhY2hlcyBoYW5kbGVycyBmb3IgdGhlIGdpdmVuIHRyYW5zcG9ydC5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zcG9ydH0gdHJhbnNwb3J0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNldFRyYW5zcG9ydCA9IGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgdmFyIG9uRXJyb3IgPSB0aGlzLm9uRXJyb3IuYmluZCh0aGlzKTtcbiAgdmFyIG9uUGFja2V0ID0gdGhpcy5vblBhY2tldC5iaW5kKHRoaXMpO1xuICB2YXIgZmx1c2ggPSB0aGlzLmZsdXNoLmJpbmQodGhpcyk7XG4gIHZhciBvbkNsb3NlID0gdGhpcy5vbkNsb3NlLmJpbmQodGhpcywgJ3RyYW5zcG9ydCBjbG9zZScpO1xuXG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB0aGlzLnRyYW5zcG9ydC5vbmNlKCdlcnJvcicsIG9uRXJyb3IpO1xuICB0aGlzLnRyYW5zcG9ydC5vbigncGFja2V0Jywgb25QYWNrZXQpO1xuICB0aGlzLnRyYW5zcG9ydC5vbignZHJhaW4nLCBmbHVzaCk7XG4gIHRoaXMudHJhbnNwb3J0Lm9uY2UoJ2Nsb3NlJywgb25DbG9zZSk7XG4gIC8vIHRoaXMgZnVuY3Rpb24gd2lsbCBtYW5hZ2UgcGFja2V0IGV2ZW50cyAoYWxzbyBtZXNzYWdlIGNhbGxiYWNrcylcbiAgdGhpcy5zZXR1cFNlbmRDYWxsYmFjaygpO1xuXG4gIHRoaXMuY2xlYW51cEZuLnB1c2goZnVuY3Rpb24gKCkge1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ3BhY2tldCcsIG9uUGFja2V0KTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgZmx1c2gpO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbkNsb3NlKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFVwZ3JhZGVzIHNvY2tldCB0byB0aGUgZ2l2ZW4gdHJhbnNwb3J0XG4gKlxuICogQHBhcmFtIHtUcmFuc3BvcnR9IHRyYW5zcG9ydFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5tYXliZVVwZ3JhZGUgPSBmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gIGRlYnVnKCdtaWdodCB1cGdyYWRlIHNvY2tldCB0cmFuc3BvcnQgZnJvbSBcIiVzXCIgdG8gXCIlc1wiJ1xuICAgICwgdGhpcy50cmFuc3BvcnQubmFtZSwgdHJhbnNwb3J0Lm5hbWUpO1xuXG4gIHRoaXMudXBncmFkaW5nID0gdHJ1ZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gc2V0IHRyYW5zcG9ydCB1cGdyYWRlIHRpbWVyXG4gIHNlbGYudXBncmFkZVRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCdjbGllbnQgZGlkIG5vdCBjb21wbGV0ZSB1cGdyYWRlIC0gY2xvc2luZyB0cmFuc3BvcnQnKTtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKCdvcGVuJyA9PT0gdHJhbnNwb3J0LnJlYWR5U3RhdGUpIHtcbiAgICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIH1cbiAgfSwgdGhpcy5zZXJ2ZXIudXBncmFkZVRpbWVvdXQpO1xuXG4gIGZ1bmN0aW9uIG9uUGFja2V0IChwYWNrZXQpIHtcbiAgICBpZiAoJ3BpbmcnID09PSBwYWNrZXQudHlwZSAmJiAncHJvYmUnID09PSBwYWNrZXQuZGF0YSkge1xuICAgICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3BvbmcnLCBkYXRhOiAncHJvYmUnIH1dKTtcbiAgICAgIHNlbGYuZW1pdCgndXBncmFkaW5nJywgdHJhbnNwb3J0KTtcbiAgICAgIGNsZWFySW50ZXJ2YWwoc2VsZi5jaGVja0ludGVydmFsVGltZXIpO1xuICAgICAgc2VsZi5jaGVja0ludGVydmFsVGltZXIgPSBzZXRJbnRlcnZhbChjaGVjaywgMTAwKTtcbiAgICB9IGVsc2UgaWYgKCd1cGdyYWRlJyA9PT0gcGFja2V0LnR5cGUgJiYgc2VsZi5yZWFkeVN0YXRlICE9PSAnY2xvc2VkJykge1xuICAgICAgZGVidWcoJ2dvdCB1cGdyYWRlIHBhY2tldCAtIHVwZ3JhZGluZycpO1xuICAgICAgY2xlYW51cCgpO1xuICAgICAgc2VsZi50cmFuc3BvcnQuZGlzY2FyZCgpO1xuICAgICAgc2VsZi51cGdyYWRlZCA9IHRydWU7XG4gICAgICBzZWxmLmNsZWFyVHJhbnNwb3J0KCk7XG4gICAgICBzZWxmLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlJywgdHJhbnNwb3J0KTtcbiAgICAgIHNlbGYuc2V0UGluZ1RpbWVvdXQoKTtcbiAgICAgIHNlbGYuZmx1c2goKTtcbiAgICAgIGlmIChzZWxmLnJlYWR5U3RhdGUgPT09ICdjbG9zaW5nJykge1xuICAgICAgICB0cmFuc3BvcnQuY2xvc2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYub25DbG9zZSgnZm9yY2VkIGNsb3NlJyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyB3ZSBmb3JjZSBhIHBvbGxpbmcgY3ljbGUgdG8gZW5zdXJlIGEgZmFzdCB1cGdyYWRlXG4gIGZ1bmN0aW9uIGNoZWNrICgpIHtcbiAgICBpZiAoJ3BvbGxpbmcnID09PSBzZWxmLnRyYW5zcG9ydC5uYW1lICYmIHNlbGYudHJhbnNwb3J0LndyaXRhYmxlKSB7XG4gICAgICBkZWJ1Zygnd3JpdGluZyBhIG5vb3AgcGFja2V0IHRvIHBvbGxpbmcgZm9yIGZhc3QgdXBncmFkZScpO1xuICAgICAgc2VsZi50cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAnbm9vcCcgfV0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXAgKCkge1xuICAgIHNlbGYudXBncmFkaW5nID0gZmFsc2U7XG5cbiAgICBjbGVhckludGVydmFsKHNlbGYuY2hlY2tJbnRlcnZhbFRpbWVyKTtcbiAgICBzZWxmLmNoZWNrSW50ZXJ2YWxUaW1lciA9IG51bGw7XG5cbiAgICBjbGVhclRpbWVvdXQoc2VsZi51cGdyYWRlVGltZW91dFRpbWVyKTtcbiAgICBzZWxmLnVwZ3JhZGVUaW1lb3V0VGltZXIgPSBudWxsO1xuXG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdwYWNrZXQnLCBvblBhY2tldCk7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uQ2xvc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25FcnJvciAoZXJyKSB7XG4gICAgZGVidWcoJ2NsaWVudCBkaWQgbm90IGNvbXBsZXRlIHVwZ3JhZGUgLSAlcycsIGVycik7XG4gICAgY2xlYW51cCgpO1xuICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBvblRyYW5zcG9ydENsb3NlICgpIHtcbiAgICBvbkVycm9yKCd0cmFuc3BvcnQgY2xvc2VkJyk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkNsb3NlICgpIHtcbiAgICBvbkVycm9yKCdzb2NrZXQgY2xvc2VkJyk7XG4gIH1cblxuICB0cmFuc3BvcnQub24oJ3BhY2tldCcsIG9uUGFja2V0KTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Nsb3NlJywgb25UcmFuc3BvcnRDbG9zZSk7XG4gIHRyYW5zcG9ydC5vbmNlKCdlcnJvcicsIG9uRXJyb3IpO1xuXG4gIHNlbGYub25jZSgnY2xvc2UnLCBvbkNsb3NlKTtcbn07XG5cbi8qKlxuICogQ2xlYXJzIGxpc3RlbmVycyBhbmQgdGltZXJzIGFzc29jaWF0ZWQgd2l0aCBjdXJyZW50IHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNsZWFyVHJhbnNwb3J0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2xlYW51cDtcblxuICB2YXIgdG9DbGVhblVwID0gdGhpcy5jbGVhbnVwRm4ubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9DbGVhblVwOyBpKyspIHtcbiAgICBjbGVhbnVwID0gdGhpcy5jbGVhbnVwRm4uc2hpZnQoKTtcbiAgICBjbGVhbnVwKCk7XG4gIH1cblxuICAvLyBzaWxlbmNlIGZ1cnRoZXIgdHJhbnNwb3J0IGVycm9ycyBhbmQgcHJldmVudCB1bmNhdWdodCBleGNlcHRpb25zXG4gIHRoaXMudHJhbnNwb3J0Lm9uKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1ZygnZXJyb3IgdHJpZ2dlcmVkIGJ5IGRpc2NhcmRlZCB0cmFuc3BvcnQnKTtcbiAgfSk7XG5cbiAgLy8gZW5zdXJlIHRyYW5zcG9ydCB3b24ndCBzdGF5IG9wZW5cbiAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcblxuICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNvbnNpZGVyZWQgY2xvc2VkLlxuICogUG9zc2libGUgcmVhc29uczogYHBpbmcgdGltZW91dGAsIGBjbGllbnQgZXJyb3JgLCBgcGFyc2UgZXJyb3JgLFxuICogYHRyYW5zcG9ydCBlcnJvcmAsIGBzZXJ2ZXIgY2xvc2VgLCBgdHJhbnNwb3J0IGNsb3NlYFxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24sIGRlc2NyaXB0aW9uKSB7XG4gIGlmICgnY2xvc2VkJyAhPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNoZWNrSW50ZXJ2YWxUaW1lcik7XG4gICAgdGhpcy5jaGVja0ludGVydmFsVGltZXIgPSBudWxsO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnVwZ3JhZGVUaW1lb3V0VGltZXIpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBjbGVhbiB3cml0ZUJ1ZmZlciBpbiBuZXh0IHRpY2ssIHNvIGRldmVsb3BlcnMgY2FuIHN0aWxsXG4gICAgLy8gZ3JhYiB0aGUgd3JpdGVCdWZmZXIgb24gJ2Nsb3NlJyBldmVudFxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi53cml0ZUJ1ZmZlciA9IFtdO1xuICAgIH0pO1xuICAgIHRoaXMucGFja2V0c0ZuID0gW107XG4gICAgdGhpcy5zZW50Q2FsbGJhY2tGbiA9IFtdO1xuICAgIHRoaXMuY2xlYXJUcmFuc3BvcnQoKTtcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uLCBkZXNjcmlwdGlvbik7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0dXAgYW5kIG1hbmFnZSBzZW5kIGNhbGxiYWNrXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXR1cFNlbmRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnRyYW5zcG9ydC5vbignZHJhaW4nLCBvbkRyYWluKTtcblxuICB0aGlzLmNsZWFudXBGbi5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLnRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbkRyYWluKTtcbiAgfSk7XG5cbiAgLy8gdGhlIG1lc3NhZ2Ugd2FzIHNlbnQgc3VjY2Vzc2Z1bGx5LCBleGVjdXRlIHRoZSBjYWxsYmFja1xuICBmdW5jdGlvbiBvbkRyYWluICgpIHtcbiAgICBpZiAoc2VsZi5zZW50Q2FsbGJhY2tGbi5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgc2VxRm4gPSBzZWxmLnNlbnRDYWxsYmFja0ZuLnNwbGljZSgwLCAxKVswXTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2Ygc2VxRm4pIHtcbiAgICAgICAgZGVidWcoJ2V4ZWN1dGluZyBzZW5kIGNhbGxiYWNrJyk7XG4gICAgICAgIHNlcUZuKHNlbGYudHJhbnNwb3J0KTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzZXFGbikpIHtcbiAgICAgICAgZGVidWcoJ2V4ZWN1dGluZyBiYXRjaCBzZW5kIGNhbGxiYWNrJyk7XG4gICAgICAgIGZvciAodmFyIGwgPSBzZXFGbi5sZW5ndGgsIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBzZXFGbltpXSkge1xuICAgICAgICAgICAgc2VxRm5baV0oc2VsZi50cmFuc3BvcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTZW5kcyBhIG1lc3NhZ2UgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge1NvY2tldH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9XG5Tb2NrZXQucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHRoaXMuc2VuZFBhY2tldCgnbWVzc2FnZScsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWNrZXQgdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbmFsLCBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kUGFja2V0ID0gZnVuY3Rpb24gKHR5cGUsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2Ygb3B0aW9ucykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdGlvbnMuY29tcHJlc3M7XG5cbiAgaWYgKCdjbG9zaW5nJyAhPT0gdGhpcy5yZWFkeVN0YXRlICYmICdjbG9zZWQnICE9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc2VuZGluZyBwYWNrZXQgXCIlc1wiICglcyknLCB0eXBlLCBkYXRhKTtcblxuICAgIHZhciBwYWNrZXQgPSB7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH07XG4gICAgaWYgKGRhdGEpIHBhY2tldC5kYXRhID0gZGF0YTtcblxuICAgIC8vIGV4cG9ydHMgcGFja2V0Q3JlYXRlIGV2ZW50XG4gICAgdGhpcy5lbWl0KCdwYWNrZXRDcmVhdGUnLCBwYWNrZXQpO1xuXG4gICAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKHBhY2tldCk7XG5cbiAgICAvLyBhZGQgc2VuZCBjYWxsYmFjayB0byBvYmplY3QsIGlmIGRlZmluZWRcbiAgICBpZiAoY2FsbGJhY2spIHRoaXMucGFja2V0c0ZuLnB1c2goY2FsbGJhY2spO1xuXG4gICAgdGhpcy5mbHVzaCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGZsdXNoIHRoZSBwYWNrZXRzIGJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ2Nsb3NlZCcgIT09IHRoaXMucmVhZHlTdGF0ZSAmJlxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LndyaXRhYmxlICYmXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICBkZWJ1ZygnZmx1c2hpbmcgYnVmZmVyIHRvIHRyYW5zcG9ydCcpO1xuICAgIHRoaXMuZW1pdCgnZmx1c2gnLCB0aGlzLndyaXRlQnVmZmVyKTtcbiAgICB0aGlzLnNlcnZlci5lbWl0KCdmbHVzaCcsIHRoaXMsIHRoaXMud3JpdGVCdWZmZXIpO1xuICAgIHZhciB3YnVmID0gdGhpcy53cml0ZUJ1ZmZlcjtcbiAgICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gICAgaWYgKCF0aGlzLnRyYW5zcG9ydC5zdXBwb3J0c0ZyYW1pbmcpIHtcbiAgICAgIHRoaXMuc2VudENhbGxiYWNrRm4ucHVzaCh0aGlzLnBhY2tldHNGbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VudENhbGxiYWNrRm4ucHVzaC5hcHBseSh0aGlzLnNlbnRDYWxsYmFja0ZuLCB0aGlzLnBhY2tldHNGbik7XG4gICAgfVxuICAgIHRoaXMucGFja2V0c0ZuID0gW107XG4gICAgdGhpcy50cmFuc3BvcnQuc2VuZCh3YnVmKTtcbiAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gICAgdGhpcy5zZXJ2ZXIuZW1pdCgnZHJhaW4nLCB0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgYXZhaWxhYmxlIHVwZ3JhZGVzIGZvciB0aGlzIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmdldEF2YWlsYWJsZVVwZ3JhZGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXZhaWxhYmxlVXBncmFkZXMgPSBbXTtcbiAgdmFyIGFsbFVwZ3JhZGVzID0gdGhpcy5zZXJ2ZXIudXBncmFkZXModGhpcy50cmFuc3BvcnQubmFtZSk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYWxsVXBncmFkZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgdmFyIHVwZyA9IGFsbFVwZ3JhZGVzW2ldO1xuICAgIGlmICh0aGlzLnNlcnZlci50cmFuc3BvcnRzLmluZGV4T2YodXBnKSAhPT0gLTEpIHtcbiAgICAgIGF2YWlsYWJsZVVwZ3JhZGVzLnB1c2godXBnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGF2YWlsYWJsZVVwZ3JhZGVzO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHNvY2tldCBhbmQgdW5kZXJseWluZyB0cmFuc3BvcnQuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25hbCwgZGlzY2FyZFxuICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChkaXNjYXJkKSB7XG4gIGlmICgnb3BlbicgIT09IHRoaXMucmVhZHlTdGF0ZSkgcmV0dXJuO1xuXG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zaW5nJztcblxuICBpZiAodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICB0aGlzLm9uY2UoJ2RyYWluJywgdGhpcy5jbG9zZVRyYW5zcG9ydC5iaW5kKHRoaXMsIGRpc2NhcmQpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmNsb3NlVHJhbnNwb3J0KGRpc2NhcmQpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHVuZGVybHlpbmcgdHJhbnNwb3J0LlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzY2FyZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChkaXNjYXJkKSB7XG4gIGlmIChkaXNjYXJkKSB0aGlzLnRyYW5zcG9ydC5kaXNjYXJkKCk7XG4gIHRoaXMudHJhbnNwb3J0LmNsb3NlKHRoaXMub25DbG9zZS5iaW5kKHRoaXMsICdmb3JjZWQgY2xvc2UnKSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2xpYi9zb2NrZXQuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoJ3RscycpO1xuY29uc3QgdXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9ldmVudC10YXJnZXQnKTtcbmNvbnN0IGV4dGVuc2lvbiA9IHJlcXVpcmUoJy4vZXh0ZW5zaW9uJyk7XG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyJyk7XG5jb25zdCBTZW5kZXIgPSByZXF1aXJlKCcuL3NlbmRlcicpO1xuXG5jb25zdCByZWFkeVN0YXRlcyA9IFsnQ09OTkVDVElORycsICdPUEVOJywgJ0NMT1NJTkcnLCAnQ0xPU0VEJ107XG5jb25zdCBrV2ViU29ja2V0ID0gY29uc3RhbnRzLmtXZWJTb2NrZXQ7XG5jb25zdCBwcm90b2NvbFZlcnNpb25zID0gWzgsIDEzXTtcbmNvbnN0IGNsb3NlVGltZW91dCA9IDMwICogMTAwMDsgLy8gQWxsb3cgMzAgc2Vjb25kcyB0byB0ZXJtaW5hdGUgdGhlIGNvbm5lY3Rpb24gY2xlYW5seS5cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBXZWJTb2NrZXQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYFdlYlNvY2tldGAuXG4gICAqXG4gICAqIEBwYXJhbSB7KFN0cmluZ3x1cmwuVXJsfHVybC5VUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICAgKiBAcGFyYW0geyhTdHJpbmd8U3RyaW5nW10pfSBwcm90b2NvbHMgVGhlIHN1YnByb3RvY29sc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ09OTkVDVElORztcbiAgICB0aGlzLnByb3RvY29sID0gJyc7XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gY29uc3RhbnRzLkJJTkFSWV9UWVBFU1swXTtcbiAgICB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlTWVzc2FnZSA9ICcnO1xuICAgIHRoaXMuX2Nsb3NlVGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2Nsb3NlQ29kZSA9IDEwMDY7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IHt9O1xuICAgIHRoaXMuX2lzU2VydmVyID0gdHJ1ZTtcbiAgICB0aGlzLl9yZWNlaXZlciA9IG51bGw7XG4gICAgdGhpcy5fc2VuZGVyID0gbnVsbDtcbiAgICB0aGlzLl9zb2NrZXQgPSBudWxsO1xuXG4gICAgaWYgKGFkZHJlc3MgIT09IG51bGwpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3RvY29scykpIHtcbiAgICAgICAgcHJvdG9jb2xzID0gcHJvdG9jb2xzLmpvaW4oJywgJyk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm90b2NvbHMgPT09ICdvYmplY3QnICYmIHByb3RvY29scyAhPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0gcHJvdG9jb2xzO1xuICAgICAgICBwcm90b2NvbHMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGluaXRBc0NsaWVudC5jYWxsKHRoaXMsIGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IENPTk5FQ1RJTkcoKSB7XG4gICAgcmV0dXJuIFdlYlNvY2tldC5DT05ORUNUSU5HO1xuICB9XG4gIGdldCBDTE9TSU5HKCkge1xuICAgIHJldHVybiBXZWJTb2NrZXQuQ0xPU0lORztcbiAgfVxuICBnZXQgQ0xPU0VEKCkge1xuICAgIHJldHVybiBXZWJTb2NrZXQuQ0xPU0VEO1xuICB9XG4gIGdldCBPUEVOKCkge1xuICAgIHJldHVybiBXZWJTb2NrZXQuT1BFTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGRldmlhdGVzIGZyb20gdGhlIFdIQVRXRyBpbnRlcmZhY2Ugc2luY2Ugd3MgZG9lc24ndCBzdXBwb3J0IHRoZSByZXF1aXJlZFxuICAgKiBkZWZhdWx0IFwiYmxvYlwiIHR5cGUgKGluc3RlYWQgd2UgZGVmaW5lIGEgY3VzdG9tIFwibm9kZWJ1ZmZlclwiIHR5cGUpLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGJpbmFyeVR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JpbmFyeVR5cGU7XG4gIH1cblxuICBzZXQgYmluYXJ5VHlwZSh0eXBlKSB7XG4gICAgaWYgKCFjb25zdGFudHMuQklOQVJZX1RZUEVTLmluY2x1ZGVzKHR5cGUpKSByZXR1cm47XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gdHlwZTtcblxuICAgIC8vXG4gICAgLy8gQWxsb3cgdG8gY2hhbmdlIGBiaW5hcnlUeXBlYCBvbiB0aGUgZmx5LlxuICAgIC8vXG4gICAgaWYgKHRoaXMuX3JlY2VpdmVyKSB0aGlzLl9yZWNlaXZlci5fYmluYXJ5VHlwZSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBidWZmZXJlZEFtb3VudCgpIHtcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkgcmV0dXJuIDA7XG5cbiAgICAvL1xuICAgIC8vIGBzb2NrZXQuYnVmZmVyU2l6ZWAgaXMgYHVuZGVmaW5lZGAgaWYgdGhlIHNvY2tldCBpcyBjbG9zZWQuXG4gICAgLy9cbiAgICByZXR1cm4gKHRoaXMuX3NvY2tldC5idWZmZXJTaXplIHx8IDApICsgdGhpcy5fc2VuZGVyLl9idWZmZXJlZEJ5dGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgZXh0ZW5zaW9ucygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fZXh0ZW5zaW9ucykuam9pbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB1cCB0aGUgc29ja2V0IGFuZCB0aGUgaW50ZXJuYWwgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge25ldC5Tb2NrZXR9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGUgc2VydmVyIGFuZCBjbGllbnRcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhQYXlsb2FkIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBzaXplXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRTb2NrZXQoc29ja2V0LCBoZWFkLCBtYXhQYXlsb2FkKSB7XG4gICAgY29uc3QgcmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoXG4gICAgICB0aGlzLl9iaW5hcnlUeXBlLFxuICAgICAgdGhpcy5fZXh0ZW5zaW9ucyxcbiAgICAgIG1heFBheWxvYWRcbiAgICApO1xuXG4gICAgdGhpcy5fc2VuZGVyID0gbmV3IFNlbmRlcihzb2NrZXQsIHRoaXMuX2V4dGVuc2lvbnMpO1xuICAgIHRoaXMuX3JlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuXG4gICAgcmVjZWl2ZXJba1dlYlNvY2tldF0gPSB0aGlzO1xuICAgIHNvY2tldFtrV2ViU29ja2V0XSA9IHRoaXM7XG5cbiAgICByZWNlaXZlci5vbignY29uY2x1ZGUnLCByZWNlaXZlck9uQ29uY2x1ZGUpO1xuICAgIHJlY2VpdmVyLm9uKCdkcmFpbicsIHJlY2VpdmVyT25EcmFpbik7XG4gICAgcmVjZWl2ZXIub24oJ2Vycm9yJywgcmVjZWl2ZXJPbkVycm9yKTtcbiAgICByZWNlaXZlci5vbignbWVzc2FnZScsIHJlY2VpdmVyT25NZXNzYWdlKTtcbiAgICByZWNlaXZlci5vbigncGluZycsIHJlY2VpdmVyT25QaW5nKTtcbiAgICByZWNlaXZlci5vbigncG9uZycsIHJlY2VpdmVyT25Qb25nKTtcblxuICAgIHNvY2tldC5zZXRUaW1lb3V0KDApO1xuICAgIHNvY2tldC5zZXROb0RlbGF5KCk7XG5cbiAgICBpZiAoaGVhZC5sZW5ndGggPiAwKSBzb2NrZXQudW5zaGlmdChoZWFkKTtcblxuICAgIHNvY2tldC5vbignY2xvc2UnLCBzb2NrZXRPbkNsb3NlKTtcbiAgICBzb2NrZXQub24oJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuICAgIHNvY2tldC5vbignZW5kJywgc29ja2V0T25FbmQpO1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5PUEVOO1xuICAgIHRoaXMuZW1pdCgnb3BlbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgdGhlIGAnY2xvc2UnYCBldmVudC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVtaXRDbG9zZSgpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0VEO1xuXG4gICAgaWYgKCF0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLl9jbG9zZUNvZGUsIHRoaXMuX2Nsb3NlTWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0uY2xlYW51cCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlY2VpdmVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLl9jbG9zZUNvZGUsIHRoaXMuX2Nsb3NlTWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYSBjbG9zaW5nIGhhbmRzaGFrZS5cbiAgICpcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tK1xuICAgKiAgICAgLSAtIC18d3MuY2xvc2UoKXwtLT58Y2xvc2UgZnJhbWV8LS0+fHdzLmNsb3NlKCl8LSAtIC1cbiAgICogICAgfCAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tKyAgICAgfFxuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgICAgICAgfFxuICAgKiBDTE9TSU5HICB8d3MuY2xvc2UoKXw8LS18Y2xvc2UgZnJhbWV8PC0tKy0tLS0tKyAgICAgICBDTE9TSU5HXG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICB8XG4gICAqICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgKy0tLSsgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLT58ZmlufCAtIC0gLSAtXG4gICAqICAgIHwgICAgICAgICArLS0tKyAgICAgICAgICAgICAgICAgICAgICB8ICAgKy0tLStcbiAgICogICAgIC0gLSAtIC0gLXxmaW58PC0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICogICAgICAgICAgICAgICstLS0rXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGNsb3NpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgQSBzdHJpbmcgZXhwbGFpbmluZyB3aHkgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2luZ1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZShjb2RlLCBkYXRhKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICBjb25zdCBtc2cgPSAnV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCc7XG4gICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2UodGhpcywgdGhpcy5fcmVxLCBtc2cpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TSU5HKSB7XG4gICAgICBpZiAodGhpcy5fY2xvc2VGcmFtZVNlbnQgJiYgdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkKSB0aGlzLl9zb2NrZXQuZW5kKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgdGhpcy5fc2VuZGVyLmNsb3NlKGNvZGUsIGRhdGEsICF0aGlzLl9pc1NlcnZlciwgKGVycikgPT4ge1xuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgaGFuZGxlZCBieSB0aGUgYCdlcnJvcidgIGxpc3RlbmVyIG9uIHRoZSBzb2NrZXQuIFdlIG9ubHlcbiAgICAgIC8vIHdhbnQgdG8ga25vdyBpZiB0aGUgY2xvc2UgZnJhbWUgaGFzIGJlZW4gc2VudCBoZXJlLlxuICAgICAgLy9cbiAgICAgIGlmIChlcnIpIHJldHVybjtcblxuICAgICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5fc29ja2V0LndyaXRhYmxlKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQpIHRoaXMuX3NvY2tldC5lbmQoKTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgY29ubmVjdGlvbiBpcyBjbG9zZWQgZXZlbiBpZiB0aGUgY2xvc2luZyBoYW5kc2hha2VcbiAgICAgICAgLy8gZmFpbHMuXG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMuX2Nsb3NlVGltZXIgPSBzZXRUaW1lb3V0KFxuICAgICAgICAgIHRoaXMuX3NvY2tldC5kZXN0cm95LmJpbmQodGhpcy5fc29ja2V0KSxcbiAgICAgICAgICBjbG9zZVRpbWVvdXRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgcGluZy5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBkYXRhIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBtYXNrIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIHRoZSBwaW5nIGlzIHNlbnRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcGluZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBkYXRhO1xuICAgICAgZGF0YSA9IG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWFzayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBtYXNrO1xuICAgICAgbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICBgV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlICR7dGhpcy5yZWFkeVN0YXRlfSBgICtcbiAgICAgICAgICBgKCR7cmVhZHlTdGF0ZXNbdGhpcy5yZWFkeVN0YXRlXX0pYFxuICAgICAgKTtcblxuICAgICAgaWYgKGNiKSByZXR1cm4gY2IoZXJyKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XG4gICAgdGhpcy5fc2VuZGVyLnBpbmcoZGF0YSB8fCBjb25zdGFudHMuRU1QVFlfQlVGRkVSLCBtYXNrLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHBvbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgZGF0YSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFzayBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgcG9uZyBpcyBzZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBvbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZGF0YTtcbiAgICAgIGRhdGEgPSBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gbWFzaztcbiAgICAgIG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgYFdlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAke3RoaXMucmVhZHlTdGF0ZX0gYCArXG4gICAgICAgICAgYCgke3JlYWR5U3RhdGVzW3RoaXMucmVhZHlTdGF0ZV19KWBcbiAgICAgICk7XG5cbiAgICAgIGlmIChjYikgcmV0dXJuIGNiKGVycik7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICBpZiAobWFzayA9PT0gdW5kZWZpbmVkKSBtYXNrID0gIXRoaXMuX2lzU2VydmVyO1xuICAgIHRoaXMuX3NlbmRlci5wb25nKGRhdGEgfHwgY29uc3RhbnRzLkVNUFRZX0JVRkZFUiwgbWFzaywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBkYXRhIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5jb21wcmVzcyBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3MgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5iaW5hcnkgU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGlzIGJpbmFyeSBvciB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5maW4gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGZyYWdtZW50IGlzIHRoZSBsYXN0IG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMubWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiBkYXRhIGlzIHdyaXR0ZW4gb3V0XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNlbmQoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICBgV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlICR7dGhpcy5yZWFkeVN0YXRlfSBgICtcbiAgICAgICAgICBgKCR7cmVhZHlTdGF0ZXNbdGhpcy5yZWFkeVN0YXRlXX0pYFxuICAgICAgKTtcblxuICAgICAgaWYgKGNiKSByZXR1cm4gY2IoZXJyKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuXG4gICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7XG4gICAgICAgIGJpbmFyeTogdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnLFxuICAgICAgICBtYXNrOiAhdGhpcy5faXNTZXJ2ZXIsXG4gICAgICAgIGNvbXByZXNzOiB0cnVlLFxuICAgICAgICBmaW46IHRydWVcbiAgICAgIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcblxuICAgIGlmICghdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3NlbmRlci5zZW5kKGRhdGEgfHwgY29uc3RhbnRzLkVNUFRZX0JVRkZFUiwgb3B0cywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNpYmx5IGNsb3NlIHRoZSBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0ZXJtaW5hdGUoKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICBjb25zdCBtc2cgPSAnV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCc7XG4gICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2UodGhpcywgdGhpcy5fcmVxLCBtc2cpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgICAgdGhpcy5fc29ja2V0LmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn1cblxucmVhZHlTdGF0ZXMuZm9yRWFjaCgocmVhZHlTdGF0ZSwgaSkgPT4ge1xuICBXZWJTb2NrZXRbcmVhZHlTdGF0ZV0gPSBpO1xufSk7XG5cbi8vXG4vLyBBZGQgdGhlIGBvbm9wZW5gLCBgb25lcnJvcmAsIGBvbmNsb3NlYCwgYW5kIGBvbm1lc3NhZ2VgIGF0dHJpYnV0ZXMuXG4vLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvY29tbXMuaHRtbCN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxuLy9cblsnb3BlbicsICdlcnJvcicsICdjbG9zZScsICdtZXNzYWdlJ10uZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCBgb24ke21ldGhvZH1gLCB7XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBsaXN0ZW5lciBvZiB0aGUgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsoRnVuY3Rpb258dW5kZWZpbmVkKX0gVGhlIGV2ZW50IGxpc3RlbmVyIG9yIGB1bmRlZmluZWRgXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGdldCgpIHtcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzKG1ldGhvZCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGlzdGVuZXJzW2ldLl9saXN0ZW5lcikgcmV0dXJuIGxpc3RlbmVyc1tpXS5fbGlzdGVuZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGQgYSBsaXN0ZW5lciBmb3IgdGhlIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIGFkZFxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzZXQobGlzdGVuZXIpIHtcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzKG1ldGhvZCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvL1xuICAgICAgICAvLyBSZW1vdmUgb25seSB0aGUgbGlzdGVuZXJzIGFkZGVkIHZpYSBgYWRkRXZlbnRMaXN0ZW5lcmAuXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uX2xpc3RlbmVyKSB0aGlzLnJlbW92ZUxpc3RlbmVyKG1ldGhvZCwgbGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihtZXRob2QsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbldlYlNvY2tldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXI7XG5XZWJTb2NrZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBFdmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldDtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgV2ViU29ja2V0IGNsaWVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8dXJsLlVybHx1cmwuVVJMKX0gYWRkcmVzcyBUaGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbHMgVGhlIHN1YnByb3RvY29sc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0geyhCb29sZWFufE9iamVjdCl9IG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgRW5hYmxlL2Rpc2FibGUgcGVybWVzc2FnZS1kZWZsYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5oYW5kc2hha2VUaW1lb3V0IFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgaGFuZHNoYWtlIHJlcXVlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnByb3RvY29sVmVyc2lvbiBWYWx1ZSBvZiB0aGUgYFNlYy1XZWJTb2NrZXQtVmVyc2lvbmAgaGVhZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5vcmlnaW4gVmFsdWUgb2YgdGhlIGBPcmlnaW5gIG9yIGBTZWMtV2ViU29ja2V0LU9yaWdpbmAgaGVhZGVyXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5tYXhQYXlsb2FkIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBzaXplXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbml0QXNDbGllbnQoYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKFxuICAgIHtcbiAgICAgIHByb3RvY29sVmVyc2lvbjogcHJvdG9jb2xWZXJzaW9uc1sxXSxcbiAgICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0cnVlLFxuICAgICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjRcbiAgICB9LFxuICAgIG9wdGlvbnMsXG4gICAge1xuICAgICAgY3JlYXRlQ29ubmVjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgc29ja2V0UGF0aDogdW5kZWZpbmVkLFxuICAgICAgaG9zdG5hbWU6IHVuZGVmaW5lZCxcbiAgICAgIHByb3RvY29sOiB1bmRlZmluZWQsXG4gICAgICB0aW1lb3V0OiB1bmRlZmluZWQsXG4gICAgICBtZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgIGF1dGg6IHVuZGVmaW5lZCxcbiAgICAgIGhvc3Q6IHVuZGVmaW5lZCxcbiAgICAgIHBhdGg6IHVuZGVmaW5lZCxcbiAgICAgIHBvcnQ6IHVuZGVmaW5lZFxuICAgIH1cbiAgKTtcblxuICBpZiAoIXByb3RvY29sVmVyc2lvbnMuaW5jbHVkZXMob3B0aW9ucy5wcm90b2NvbFZlcnNpb24pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICBgVW5zdXBwb3J0ZWQgcHJvdG9jb2wgdmVyc2lvbjogJHtvcHRpb25zLnByb3RvY29sVmVyc2lvbn0gYCArXG4gICAgICAgIGAoc3VwcG9ydGVkIHZlcnNpb25zOiAke3Byb3RvY29sVmVyc2lvbnMuam9pbignLCAnKX0pYFxuICAgICk7XG4gIH1cblxuICB0aGlzLl9pc1NlcnZlciA9IGZhbHNlO1xuXG4gIHZhciBwYXJzZWRVcmw7XG5cbiAgaWYgKHR5cGVvZiBhZGRyZXNzID09PSAnb2JqZWN0JyAmJiBhZGRyZXNzLmhyZWYgIT09IHVuZGVmaW5lZCkge1xuICAgIHBhcnNlZFVybCA9IGFkZHJlc3M7XG4gICAgdGhpcy51cmwgPSBhZGRyZXNzLmhyZWY7XG4gIH0gZWxzZSB7XG4gICAgLy9cbiAgICAvLyBUaGUgV0hBVFdHIFVSTCBjb25zdHJ1Y3RvciBpcyBub3QgYXZhaWxhYmxlIG9uIE5vZGUuanMgPCA2LjEzLjBcbiAgICAvL1xuICAgIHBhcnNlZFVybCA9IHVybC5VUkwgPyBuZXcgdXJsLlVSTChhZGRyZXNzKSA6IHVybC5wYXJzZShhZGRyZXNzKTtcbiAgICB0aGlzLnVybCA9IGFkZHJlc3M7XG4gIH1cblxuICBjb25zdCBpc1VuaXhTb2NrZXQgPSBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICd3cyt1bml4Oic7XG5cbiAgaWYgKCFwYXJzZWRVcmwuaG9zdCAmJiAoIWlzVW5peFNvY2tldCB8fCAhcGFyc2VkVXJsLnBhdGhuYW1lKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBVUkw6ICR7dGhpcy51cmx9YCk7XG4gIH1cblxuICBjb25zdCBpc1NlY3VyZSA9XG4gICAgcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3NzOicgfHwgcGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgY29uc3QgZGVmYXVsdFBvcnQgPSBpc1NlY3VyZSA/IDQ0MyA6IDgwO1xuICBjb25zdCBrZXkgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgY29uc3QgaHR0cE9iaiA9IGlzU2VjdXJlID8gaHR0cHMgOiBodHRwO1xuICBjb25zdCBwYXRoID0gcGFyc2VkVXJsLnNlYXJjaFxuICAgID8gYCR7cGFyc2VkVXJsLnBhdGhuYW1lIHx8ICcvJ30ke3BhcnNlZFVybC5zZWFyY2h9YFxuICAgIDogcGFyc2VkVXJsLnBhdGhuYW1lIHx8ICcvJztcbiAgdmFyIHBlck1lc3NhZ2VEZWZsYXRlO1xuXG4gIG9wdGlvbnMuY3JlYXRlQ29ubmVjdGlvbiA9IGlzU2VjdXJlID8gdGxzQ29ubmVjdCA6IG5ldENvbm5lY3Q7XG4gIG9wdGlvbnMuZGVmYXVsdFBvcnQgPSBvcHRpb25zLmRlZmF1bHRQb3J0IHx8IGRlZmF1bHRQb3J0O1xuICBvcHRpb25zLnBvcnQgPSBwYXJzZWRVcmwucG9ydCB8fCBkZWZhdWx0UG9ydDtcbiAgb3B0aW9ucy5ob3N0ID0gcGFyc2VkVXJsLmhvc3RuYW1lLnN0YXJ0c1dpdGgoJ1snKVxuICAgID8gcGFyc2VkVXJsLmhvc3RuYW1lLnNsaWNlKDEsIC0xKVxuICAgIDogcGFyc2VkVXJsLmhvc3RuYW1lO1xuICBvcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKFxuICAgIHtcbiAgICAgICdTZWMtV2ViU29ja2V0LVZlcnNpb24nOiBvcHRpb25zLnByb3RvY29sVmVyc2lvbixcbiAgICAgICdTZWMtV2ViU29ja2V0LUtleSc6IGtleSxcbiAgICAgIENvbm5lY3Rpb246ICdVcGdyYWRlJyxcbiAgICAgIFVwZ3JhZGU6ICd3ZWJzb2NrZXQnXG4gICAgfSxcbiAgICBvcHRpb25zLmhlYWRlcnNcbiAgKTtcbiAgb3B0aW9ucy5wYXRoID0gcGF0aDtcbiAgb3B0aW9ucy50aW1lb3V0ID0gb3B0aW9ucy5oYW5kc2hha2VUaW1lb3V0O1xuXG4gIGlmIChvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgcGVyTWVzc2FnZURlZmxhdGUgPSBuZXcgUGVyTWVzc2FnZURlZmxhdGUoXG4gICAgICBvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlICE9PSB0cnVlID8gb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA6IHt9LFxuICAgICAgZmFsc2UsXG4gICAgICBvcHRpb25zLm1heFBheWxvYWRcbiAgICApO1xuICAgIG9wdGlvbnMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zJ10gPSBleHRlbnNpb24uZm9ybWF0KHtcbiAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTogcGVyTWVzc2FnZURlZmxhdGUub2ZmZXIoKVxuICAgIH0pO1xuICB9XG4gIGlmIChwcm90b2NvbHMpIHtcbiAgICBvcHRpb25zLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnXSA9IHByb3RvY29scztcbiAgfVxuICBpZiAob3B0aW9ucy5vcmlnaW4pIHtcbiAgICBpZiAob3B0aW9ucy5wcm90b2NvbFZlcnNpb24gPCAxMykge1xuICAgICAgb3B0aW9ucy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LU9yaWdpbiddID0gb3B0aW9ucy5vcmlnaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuaGVhZGVycy5PcmlnaW4gPSBvcHRpb25zLm9yaWdpbjtcbiAgICB9XG4gIH1cbiAgaWYgKHBhcnNlZFVybC5hdXRoKSB7XG4gICAgb3B0aW9ucy5hdXRoID0gcGFyc2VkVXJsLmF1dGg7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLnVzZXJuYW1lIHx8IHBhcnNlZFVybC5wYXNzd29yZCkge1xuICAgIG9wdGlvbnMuYXV0aCA9IGAke3BhcnNlZFVybC51c2VybmFtZX06JHtwYXJzZWRVcmwucGFzc3dvcmR9YDtcbiAgfVxuXG4gIGlmIChpc1VuaXhTb2NrZXQpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoJzonKTtcblxuICAgIG9wdGlvbnMuc29ja2V0UGF0aCA9IHBhcnRzWzBdO1xuICAgIG9wdGlvbnMucGF0aCA9IHBhcnRzWzFdO1xuICB9XG5cbiAgdmFyIHJlcSA9ICh0aGlzLl9yZXEgPSBodHRwT2JqLmdldChvcHRpb25zKSk7XG5cbiAgaWYgKG9wdGlvbnMuaGFuZHNoYWtlVGltZW91dCkge1xuICAgIHJlcS5vbigndGltZW91dCcsICgpID0+IHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHRoaXMsIHJlcSwgJ09wZW5pbmcgaGFuZHNoYWtlIGhhcyB0aW1lZCBvdXQnKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlcS5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgaWYgKHRoaXMuX3JlcS5hYm9ydGVkKSByZXR1cm47XG5cbiAgICByZXEgPSB0aGlzLl9yZXEgPSBudWxsO1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIHRoaXMuZW1pdENsb3NlKCk7XG4gIH0pO1xuXG4gIHJlcS5vbigncmVzcG9uc2UnLCAocmVzKSA9PiB7XG4gICAgaWYgKHRoaXMuZW1pdCgndW5leHBlY3RlZC1yZXNwb25zZScsIHJlcSwgcmVzKSkgcmV0dXJuO1xuXG4gICAgYWJvcnRIYW5kc2hha2UodGhpcywgcmVxLCBgVW5leHBlY3RlZCBzZXJ2ZXIgcmVzcG9uc2U6ICR7cmVzLnN0YXR1c0NvZGV9YCk7XG4gIH0pO1xuXG4gIHJlcS5vbigndXBncmFkZScsIChyZXMsIHNvY2tldCwgaGVhZCkgPT4ge1xuICAgIHRoaXMuZW1pdCgndXBncmFkZScsIHJlcyk7XG5cbiAgICAvL1xuICAgIC8vIFRoZSB1c2VyIG1heSBoYXZlIGNsb3NlZCB0aGUgY29ubmVjdGlvbiBmcm9tIGEgbGlzdGVuZXIgb2YgdGhlIGB1cGdyYWRlYFxuICAgIC8vIGV2ZW50LlxuICAgIC8vXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHJldHVybjtcblxuICAgIHJlcSA9IHRoaXMuX3JlcSA9IG51bGw7XG5cbiAgICBjb25zdCBkaWdlc3QgPSBjcnlwdG9cbiAgICAgIC5jcmVhdGVIYXNoKCdzaGExJylcbiAgICAgIC51cGRhdGUoa2V5ICsgY29uc3RhbnRzLkdVSUQsICdiaW5hcnknKVxuICAgICAgLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cbiAgICBpZiAocmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtYWNjZXB0J10gIT09IGRpZ2VzdCkge1xuICAgICAgYWJvcnRIYW5kc2hha2UodGhpcywgc29ja2V0LCAnSW52YWxpZCBTZWMtV2ViU29ja2V0LUFjY2VwdCBoZWFkZXInKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzZXJ2ZXJQcm90ID0gcmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnXTtcbiAgICBjb25zdCBwcm90TGlzdCA9IChwcm90b2NvbHMgfHwgJycpLnNwbGl0KC8sICovKTtcbiAgICB2YXIgcHJvdEVycm9yO1xuXG4gICAgaWYgKCFwcm90b2NvbHMgJiYgc2VydmVyUHJvdCkge1xuICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IGEgc3VicHJvdG9jb2wgYnV0IG5vbmUgd2FzIHJlcXVlc3RlZCc7XG4gICAgfSBlbHNlIGlmIChwcm90b2NvbHMgJiYgIXNlcnZlclByb3QpIHtcbiAgICAgIHByb3RFcnJvciA9ICdTZXJ2ZXIgc2VudCBubyBzdWJwcm90b2NvbCc7XG4gICAgfSBlbHNlIGlmIChzZXJ2ZXJQcm90ICYmICFwcm90TGlzdC5pbmNsdWRlcyhzZXJ2ZXJQcm90KSkge1xuICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IGFuIGludmFsaWQgc3VicHJvdG9jb2wnO1xuICAgIH1cblxuICAgIGlmIChwcm90RXJyb3IpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHRoaXMsIHNvY2tldCwgcHJvdEVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2VydmVyUHJvdCkgdGhpcy5wcm90b2NvbCA9IHNlcnZlclByb3Q7XG5cbiAgICBpZiAocGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBleHRlbnNpb24ucGFyc2UoXG4gICAgICAgICAgcmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSk7XG4gICAgICAgICAgdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSA9IHBlck1lc3NhZ2VEZWZsYXRlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgYWJvcnRIYW5kc2hha2UodGhpcywgc29ja2V0LCAnSW52YWxpZCBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldFNvY2tldChzb2NrZXQsIGhlYWQsIG9wdGlvbnMubWF4UGF5bG9hZCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGBuZXQuU29ja2V0YCBhbmQgaW5pdGlhdGUgYSBjb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHJldHVybiB7bmV0LlNvY2tldH0gVGhlIG5ld2x5IGNyZWF0ZWQgc29ja2V0IHVzZWQgdG8gc3RhcnQgdGhlIGNvbm5lY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5ldENvbm5lY3Qob3B0aW9ucykge1xuICAvL1xuICAvLyBPdmVycmlkZSBgb3B0aW9ucy5wYXRoYCBvbmx5IGlmIGBvcHRpb25zYCBpcyBhIGNvcHkgb2YgdGhlIG9yaWdpbmFsIG9wdGlvbnNcbiAgLy8gb2JqZWN0LiBUaGlzIGlzIGFsd2F5cyB0cnVlIG9uIE5vZGUuanMgPj0gOCBidXQgbm90IG9uIE5vZGUuanMgNiB3aGVyZVxuICAvLyBgb3B0aW9ucy5zb2NrZXRQYXRoYCBtaWdodCBiZSBgdW5kZWZpbmVkYCBldmVuIGlmIHRoZSBgc29ja2V0UGF0aGAgb3B0aW9uXG4gIC8vIHdhcyBvcmlnaW5hbGx5IHNldC5cbiAgLy9cbiAgaWYgKG9wdGlvbnMucHJvdG9jb2xWZXJzaW9uKSBvcHRpb25zLnBhdGggPSBvcHRpb25zLnNvY2tldFBhdGg7XG4gIHJldHVybiBuZXQuY29ubmVjdChvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgdGxzLlRMU1NvY2tldGAgYW5kIGluaXRpYXRlIGEgY29ubmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm4ge3Rscy5UTFNTb2NrZXR9IFRoZSBuZXdseSBjcmVhdGVkIHNvY2tldCB1c2VkIHRvIHN0YXJ0IHRoZSBjb25uZWN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0bHNDb25uZWN0KG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5wYXRoID0gdW5kZWZpbmVkO1xuICBvcHRpb25zLnNlcnZlcm5hbWUgPSBvcHRpb25zLnNlcnZlcm5hbWUgfHwgb3B0aW9ucy5ob3N0O1xuICByZXR1cm4gdGxzLmNvbm5lY3Qob3B0aW9ucyk7XG59XG5cbi8qKlxuICogQWJvcnQgdGhlIGhhbmRzaGFrZSBhbmQgZW1pdCBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7KGh0dHAuQ2xpZW50UmVxdWVzdHxuZXQuU29ja2V0KX0gc3RyZWFtIFRoZSByZXF1ZXN0IHRvIGFib3J0IG9yIHRoZVxuICogICAgIHNvY2tldCB0byBkZXN0cm95XG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzdHJlYW0sIG1lc3NhZ2UpIHtcbiAgd2Vic29ja2V0LnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcblxuICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgYWJvcnRIYW5kc2hha2UpO1xuXG4gIGlmIChzdHJlYW0uc2V0SGVhZGVyKSB7XG4gICAgc3RyZWFtLmFib3J0KCk7XG4gICAgc3RyZWFtLm9uY2UoJ2Fib3J0Jywgd2Vic29ja2V0LmVtaXRDbG9zZS5iaW5kKHdlYnNvY2tldCkpO1xuICAgIHdlYnNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLmRlc3Ryb3koZXJyKTtcbiAgICBzdHJlYW0ub25jZSgnZXJyb3InLCB3ZWJzb2NrZXQuZW1pdC5iaW5kKHdlYnNvY2tldCwgJ2Vycm9yJykpO1xuICAgIHN0cmVhbS5vbmNlKCdjbG9zZScsIHdlYnNvY2tldC5lbWl0Q2xvc2UuYmluZCh3ZWJzb2NrZXQpKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2NvbmNsdWRlJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIHN0YXR1cyBjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uIFRoZSByZWFzb24gZm9yIGNsb3NpbmdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25Db25jbHVkZShjb2RlLCByZWFzb24pIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB3ZWJzb2NrZXQuX3NvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gIHdlYnNvY2tldC5fc29ja2V0LnJlc3VtZSgpO1xuXG4gIHdlYnNvY2tldC5fY2xvc2VGcmFtZVJlY2VpdmVkID0gdHJ1ZTtcbiAgd2Vic29ja2V0Ll9jbG9zZU1lc3NhZ2UgPSByZWFzb247XG4gIHdlYnNvY2tldC5fY2xvc2VDb2RlID0gY29kZTtcblxuICBpZiAoY29kZSA9PT0gMTAwNSkgd2Vic29ja2V0LmNsb3NlKCk7XG4gIGVsc2Ugd2Vic29ja2V0LmNsb3NlKGNvZGUsIHJlYXNvbik7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZHJhaW4nYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uRHJhaW4oKSB7XG4gIHRoaXNba1dlYlNvY2tldF0uX3NvY2tldC5yZXN1bWUoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFJhbmdlRXJyb3J8RXJyb3IpfSBlcnIgVGhlIGVtaXR0ZWQgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25FcnJvcihlcnIpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB3ZWJzb2NrZXQuX3NvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG5cbiAgd2Vic29ja2V0LnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgd2Vic29ja2V0Ll9jbG9zZUNvZGUgPSBlcnJbY29uc3RhbnRzLmtTdGF0dXNDb2RlXTtcbiAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgd2Vic29ja2V0Ll9zb2NrZXQuZGVzdHJveSgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2ZpbmlzaCdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25GaW5pc2goKSB7XG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdENsb3NlKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnbWVzc2FnZSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xCdWZmZXJ8QXJyYXlCdWZmZXJ8QnVmZmVyW10pfSBkYXRhIFRoZSBtZXNzYWdlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uTWVzc2FnZShkYXRhKSB7XG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdCgnbWVzc2FnZScsIGRhdGEpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ3BpbmcnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGUgcGluZyBmcmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPblBpbmcoZGF0YSkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHdlYnNvY2tldC5wb25nKGRhdGEsICF3ZWJzb2NrZXQuX2lzU2VydmVyLCBjb25zdGFudHMuTk9PUCk7XG4gIHdlYnNvY2tldC5lbWl0KCdwaW5nJywgZGF0YSk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAncG9uZydgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoZSBwb25nIGZyYW1lXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uUG9uZyhkYXRhKSB7XG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdCgncG9uZycsIGRhdGEpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYG5ldC5Tb2NrZXRgIGAnY2xvc2UnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkNsb3NlKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgc29ja2V0T25DbG9zZSk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHNvY2tldE9uRW5kKTtcblxuICB3ZWJzb2NrZXQucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXG4gIC8vXG4gIC8vIFRoZSBjbG9zZSBmcmFtZSBtaWdodCBub3QgaGF2ZSBiZWVuIHJlY2VpdmVkIG9yIHRoZSBgJ2VuZCdgIGV2ZW50IGVtaXR0ZWQsXG4gIC8vIGZvciBleGFtcGxlLCBpZiB0aGUgc29ja2V0IHdhcyBkZXN0cm95ZWQgZHVlIHRvIGFuIGVycm9yLiBFbnN1cmUgdGhhdCB0aGVcbiAgLy8gYHJlY2VpdmVyYCBzdHJlYW0gaXMgY2xvc2VkIGFmdGVyIHdyaXRpbmcgYW55IHJlbWFpbmluZyBidWZmZXJlZCBkYXRhIHRvXG4gIC8vIGl0LiBJZiB0aGUgcmVhZGFibGUgc2lkZSBvZiB0aGUgc29ja2V0IGlzIGluIGZsb3dpbmcgbW9kZSB0aGVuIHRoZXJlIGlzIG5vXG4gIC8vIGJ1ZmZlcmVkIGRhdGEgYXMgZXZlcnl0aGluZyBoYXMgYmVlbiBhbHJlYWR5IHdyaXR0ZW4gYW5kIGByZWFkYWJsZS5yZWFkKClgXG4gIC8vIHdpbGwgcmV0dXJuIGBudWxsYC4gSWYgaW5zdGVhZCwgdGhlIHNvY2tldCBpcyBwYXVzZWQsIGFueSBwb3NzaWJsZSBidWZmZXJlZFxuICAvLyBkYXRhIHdpbGwgYmUgcmVhZCBhcyBhIHNpbmdsZSBjaHVuayBhbmQgZW1pdHRlZCBzeW5jaHJvbm91c2x5IGluIGEgc2luZ2xlXG4gIC8vIGAnZGF0YSdgIGV2ZW50LlxuICAvL1xuICB3ZWJzb2NrZXQuX3NvY2tldC5yZWFkKCk7XG4gIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XG5cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG5cbiAgY2xlYXJUaW1lb3V0KHdlYnNvY2tldC5fY2xvc2VUaW1lcik7XG5cbiAgaWYgKFxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgfHxcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZFxuICApIHtcbiAgICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5vbignZXJyb3InLCByZWNlaXZlck9uRmluaXNoKTtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLm9uKCdmaW5pc2gnLCByZWNlaXZlck9uRmluaXNoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYG5ldC5Tb2NrZXRgIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRGF0YShjaHVuaykge1xuICBpZiAoIXRoaXNba1dlYlNvY2tldF0uX3JlY2VpdmVyLndyaXRlKGNodW5rKSkge1xuICAgIHRoaXMucGF1c2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYG5ldC5Tb2NrZXRgIGAnZW5kJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FbmQoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0LnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgd2Vic29ja2V0Ll9yZWNlaXZlci5lbmQoKTtcbiAgdGhpcy5lbmQoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBuZXQuU29ja2V0YCBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FcnJvcigpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuICB0aGlzLm9uKCdlcnJvcicsIGNvbnN0YW50cy5OT09QKTtcblxuICBpZiAod2Vic29ja2V0KSB7XG4gICAgd2Vic29ja2V0LnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC5qc1xuLy8gbW9kdWxlIGlkID0gNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vL1xuLy8gQWxsb3dlZCB0b2tlbiBjaGFyYWN0ZXJzOlxuLy9cbi8vICchJywgJyMnLCAnJCcsICclJywgJyYnLCAnJycsICcqJywgJysnLCAnLScsXG4vLyAnLicsIDAtOSwgQS1aLCAnXicsICdfJywgJ2AnLCBhLXosICd8JywgJ34nXG4vL1xuLy8gdG9rZW5DaGFyc1szMl0gPT09IDAgLy8gJyAnXG4vLyB0b2tlbkNoYXJzWzMzXSA9PT0gMSAvLyAnISdcbi8vIHRva2VuQ2hhcnNbMzRdID09PSAwIC8vICdcIidcbi8vIC4uLlxuLy9cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdG9rZW5DaGFycyA9IFtcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMCAtIDE1XG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDE2IC0gMzFcbiAgMCwgMSwgMCwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMSwgMSwgMCwgMSwgMSwgMCwgLy8gMzIgLSA0N1xuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyA0OCAtIDYzXG4gIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDY0IC0gNzlcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMSwgMSwgLy8gODAgLSA5NVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA5NiAtIDExMVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAxLCAwLCAxLCAwIC8vIDExMiAtIDEyN1xuXTtcblxuLyoqXG4gKiBBZGRzIGFuIG9mZmVyIHRvIHRoZSBtYXAgb2YgZXh0ZW5zaW9uIG9mZmVycyBvciBhIHBhcmFtZXRlciB0byB0aGUgbWFwIG9mXG4gKiBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0IFRoZSBtYXAgb2YgZXh0ZW5zaW9uIG9mZmVycyBvciBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgZXh0ZW5zaW9uIG9yIHBhcmFtZXRlciBuYW1lXG4gKiBAcGFyYW0geyhPYmplY3R8Qm9vbGVhbnxTdHJpbmcpfSBlbGVtIFRoZSBleHRlbnNpb24gcGFyYW1ldGVycyBvciB0aGVcbiAqICAgICBwYXJhbWV0ZXIgdmFsdWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1c2goZGVzdCwgbmFtZSwgZWxlbSkge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlc3QsIG5hbWUpKSBkZXN0W25hbWVdLnB1c2goZWxlbSk7XG4gIGVsc2UgZGVzdFtuYW1lXSA9IFtlbGVtXTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgdGhlIGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnNgIGhlYWRlciBpbnRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVyIFRoZSBmaWVsZCB2YWx1ZSBvZiB0aGUgaGVhZGVyXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBwYXJzZWQgb2JqZWN0XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKGhlYWRlcikge1xuICBjb25zdCBvZmZlcnMgPSB7fTtcblxuICBpZiAoaGVhZGVyID09PSB1bmRlZmluZWQgfHwgaGVhZGVyID09PSAnJykgcmV0dXJuIG9mZmVycztcblxuICB2YXIgcGFyYW1zID0ge307XG4gIHZhciBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgdmFyIGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgdmFyIGluUXVvdGVzID0gZmFsc2U7XG4gIHZhciBleHRlbnNpb25OYW1lO1xuICB2YXIgcGFyYW1OYW1lO1xuICB2YXIgc3RhcnQgPSAtMTtcbiAgdmFyIGVuZCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IGhlYWRlci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGV4dGVuc2lvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjAgLyogJyAnICovIHx8IGNvZGUgPT09IDB4MDkgLyogJ1xcdCcgKi8pIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIC8qICc7JyAqLyB8fCBjb2RlID09PSAweDJjIC8qICcsJyAqLykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgbmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMCB8fCBjb2RlID09PSAweDA5KSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiB8fCBjb2RlID09PSAweDJjKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgICBwdXNoKHBhcmFtcywgaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpLCB0cnVlKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgZXh0ZW5zaW9uTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzZCAvKiAnPScgKi8gJiYgc3RhcnQgIT09IC0xICYmIGVuZCA9PT0gLTEpIHtcbiAgICAgICAgcGFyYW1OYW1lID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBpKTtcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvL1xuICAgICAgLy8gVGhlIHZhbHVlIG9mIGEgcXVvdGVkLXN0cmluZyBhZnRlciB1bmVzY2FwaW5nIG11c3QgY29uZm9ybSB0byB0aGVcbiAgICAgIC8vIHRva2VuIEFCTkYsIHNvIG9ubHkgdG9rZW4gY2hhcmFjdGVycyBhcmUgdmFsaWQuXG4gICAgICAvLyBSZWY6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NDU1I3NlY3Rpb24tOS4xXG4gICAgICAvL1xuICAgICAgaWYgKGlzRXNjYXBpbmcpIHtcbiAgICAgICAgaWYgKHRva2VuQ2hhcnNbY29kZV0gIT09IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICAgIGVsc2UgaWYgKCFtdXN0VW5lc2NhcGUpIG11c3RVbmVzY2FwZSA9IHRydWU7XG4gICAgICAgIGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaW5RdW90ZXMpIHtcbiAgICAgICAgaWYgKHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMiAvKiAnXCInICovICYmIHN0YXJ0ICE9PSAtMSkge1xuICAgICAgICAgIGluUXVvdGVzID0gZmFsc2U7XG4gICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDVjIC8qICdcXCcgKi8pIHtcbiAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIyICYmIGhlYWRlci5jaGFyQ29kZUF0KGkgLSAxKSA9PT0gMHgzZCkge1xuICAgICAgICBpblF1b3RlcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0ICE9PSAtMSAmJiAoY29kZSA9PT0gMHgyMCB8fCBjb2RlID09PSAweDA5KSkge1xuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiB8fCBjb2RlID09PSAweDJjKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgICB2YXIgdmFsdWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChtdXN0VW5lc2NhcGUpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcXFwvZywgJycpO1xuICAgICAgICAgIG11c3RVbmVzY2FwZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHZhbHVlKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgZXh0ZW5zaW9uTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBpblF1b3Rlcykge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnKTtcbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICBjb25zdCB0b2tlbiA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgaWYgKGV4dGVuc2lvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHB1c2gob2ZmZXJzLCB0b2tlbiwge30pO1xuICB9IGVsc2Uge1xuICAgIGlmIChwYXJhbU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcHVzaChwYXJhbXMsIHRva2VuLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKG11c3RVbmVzY2FwZSkge1xuICAgICAgcHVzaChwYXJhbXMsIHBhcmFtTmFtZSwgdG9rZW4ucmVwbGFjZSgvXFxcXC9nLCAnJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbik7XG4gICAgfVxuICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICB9XG5cbiAgcmV0dXJuIG9mZmVycztcbn1cblxuLyoqXG4gKiBCdWlsZHMgdGhlIGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnNgIGhlYWRlciBmaWVsZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5zaW9ucyBUaGUgbWFwIG9mIGV4dGVuc2lvbnMgYW5kIHBhcmFtZXRlcnMgdG8gZm9ybWF0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gb2JqZWN0XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdChleHRlbnNpb25zKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhleHRlbnNpb25zKVxuICAgIC5tYXAoKGV4dGVuc2lvbikgPT4ge1xuICAgICAgdmFyIGNvbmZpZ3VyYXRpb25zID0gZXh0ZW5zaW9uc1tleHRlbnNpb25dO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZ3VyYXRpb25zKSkgY29uZmlndXJhdGlvbnMgPSBbY29uZmlndXJhdGlvbnNdO1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zXG4gICAgICAgIC5tYXAoKHBhcmFtcykgPT4ge1xuICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uXVxuICAgICAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5tYXAoKGspID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gcGFyYW1zW2tdO1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzXG4gICAgICAgICAgICAgICAgICAubWFwKCh2KSA9PiAodiA9PT0gdHJ1ZSA/IGsgOiBgJHtrfT0ke3Z9YCkpXG4gICAgICAgICAgICAgICAgICAuam9pbignOyAnKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgICAgICB9KVxuICAgICAgICAuam9pbignLCAnKTtcbiAgICB9KVxuICAgIC5qb2luKCcsICcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZm9ybWF0LCBwYXJzZSB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvd3MvbGliL2V4dGVuc2lvbi5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3QgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcbmNvbnN0IHZhbGlkYXRpb24gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IEdFVF9JTkZPID0gMDtcbmNvbnN0IEdFVF9QQVlMT0FEX0xFTkdUSF8xNiA9IDE7XG5jb25zdCBHRVRfUEFZTE9BRF9MRU5HVEhfNjQgPSAyO1xuY29uc3QgR0VUX01BU0sgPSAzO1xuY29uc3QgR0VUX0RBVEEgPSA0O1xuY29uc3QgSU5GTEFUSU5HID0gNTtcblxuLyoqXG4gKiBIeUJpIFJlY2VpdmVyIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBleHRlbmRzIHN0cmVhbS5Xcml0YWJsZVxuICovXG5jbGFzcyBSZWNlaXZlciBleHRlbmRzIHN0cmVhbS5Xcml0YWJsZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUmVjZWl2ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBiaW5hcnlUeXBlIFRoZSB0eXBlIGZvciBiaW5hcnkgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5zaW9ucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhQYXlsb2FkIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBsZW5ndGhcbiAgICovXG4gIGNvbnN0cnVjdG9yKGJpbmFyeVR5cGUsIGV4dGVuc2lvbnMsIG1heFBheWxvYWQpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IGJpbmFyeVR5cGUgfHwgY29uc3RhbnRzLkJJTkFSWV9UWVBFU1swXTtcbiAgICB0aGlzW2NvbnN0YW50cy5rV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gZXh0ZW5zaW9ucyB8fCB7fTtcbiAgICB0aGlzLl9tYXhQYXlsb2FkID0gbWF4UGF5bG9hZCB8IDA7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzID0gMDtcbiAgICB0aGlzLl9idWZmZXJzID0gW107XG5cbiAgICB0aGlzLl9jb21wcmVzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWFzayA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mcmFnbWVudGVkID0gMDtcbiAgICB0aGlzLl9tYXNrZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9maW4gPSBmYWxzZTtcbiAgICB0aGlzLl9vcGNvZGUgPSAwO1xuXG4gICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9mcmFnbWVudHMgPSBbXTtcblxuICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgYFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBUaGUgY2h1bmsgb2YgZGF0YSB0byB3cml0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RpbmcgVGhlIGNoYXJhY3RlciBlbmNvZGluZyBvZiBgY2h1bmtgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqL1xuICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDggJiYgdGhpcy5fc3RhdGUgPT0gR0VUX0lORk8pIHJldHVybiBjYigpO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBjaHVuay5sZW5ndGg7XG4gICAgdGhpcy5fYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3VtZXMgYG5gIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gY29uc3VtZVxuICAgKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSBjb25zdW1lZCBieXRlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3VtZShuKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBuO1xuXG4gICAgaWYgKG4gPT09IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKSByZXR1cm4gdGhpcy5fYnVmZmVycy5zaGlmdCgpO1xuXG4gICAgaWYgKG4gPCB0aGlzLl9idWZmZXJzWzBdLmxlbmd0aCkge1xuICAgICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyc1swXTtcbiAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgICByZXR1cm4gYnVmLnNsaWNlKDAsIG4pO1xuICAgIH1cblxuICAgIGNvbnN0IGRzdCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcblxuICAgIGRvIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuX2J1ZmZlcnNbMF07XG5cbiAgICAgIGlmIChuID49IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fYnVmZmVycy5zaGlmdCgpLmNvcHkoZHN0LCBkc3QubGVuZ3RoIC0gbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWYuY29weShkc3QsIGRzdC5sZW5ndGggLSBuLCAwLCBuKTtcbiAgICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IGJ1Zi5zbGljZShuKTtcbiAgICAgIH1cblxuICAgICAgbiAtPSBidWYubGVuZ3RoO1xuICAgIH0gd2hpbGUgKG4gPiAwKTtcblxuICAgIHJldHVybiBkc3Q7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIHRoZSBwYXJzaW5nIGxvb3AuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGFydExvb3AoY2IpIHtcbiAgICB2YXIgZXJyO1xuICAgIHRoaXMuX2xvb3AgPSB0cnVlO1xuXG4gICAgZG8ge1xuICAgICAgc3dpdGNoICh0aGlzLl9zdGF0ZSkge1xuICAgICAgICBjYXNlIEdFVF9JTkZPOlxuICAgICAgICAgIGVyciA9IHRoaXMuZ2V0SW5mbygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9QQVlMT0FEX0xFTkdUSF8xNjpcbiAgICAgICAgICBlcnIgPSB0aGlzLmdldFBheWxvYWRMZW5ndGgxNigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9QQVlMT0FEX0xFTkdUSF82NDpcbiAgICAgICAgICBlcnIgPSB0aGlzLmdldFBheWxvYWRMZW5ndGg2NCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9NQVNLOlxuICAgICAgICAgIHRoaXMuZ2V0TWFzaygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9EQVRBOlxuICAgICAgICAgIGVyciA9IHRoaXMuZ2V0RGF0YShjYik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gYElORkxBVElOR2BcbiAgICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHRoaXMuX2xvb3ApO1xuXG4gICAgY2IoZXJyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgZmlyc3QgdHdvIGJ5dGVzIG9mIGEgZnJhbWUuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEluZm8oKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCAyKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnVmID0gdGhpcy5jb25zdW1lKDIpO1xuXG4gICAgaWYgKChidWZbMF0gJiAweDMwKSAhPT0gMHgwMCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFJhbmdlRXJyb3IsICdSU1YyIGFuZCBSU1YzIG11c3QgYmUgY2xlYXInLCB0cnVlLCAxMDAyKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb21wcmVzc2VkID0gKGJ1ZlswXSAmIDB4NDApID09PSAweDQwO1xuXG4gICAgaWYgKGNvbXByZXNzZWQgJiYgIXRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihSYW5nZUVycm9yLCAnUlNWMSBtdXN0IGJlIGNsZWFyJywgdHJ1ZSwgMTAwMik7XG4gICAgfVxuXG4gICAgdGhpcy5fZmluID0gKGJ1ZlswXSAmIDB4ODApID09PSAweDgwO1xuICAgIHRoaXMuX29wY29kZSA9IGJ1ZlswXSAmIDB4MGY7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IGJ1ZlsxXSAmIDB4N2Y7XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAwKSB7XG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihSYW5nZUVycm9yLCAnUlNWMSBtdXN0IGJlIGNsZWFyJywgdHJ1ZSwgMTAwMik7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fZnJhZ21lbnRlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihSYW5nZUVycm9yLCAnaW52YWxpZCBvcGNvZGUgMCcsIHRydWUsIDEwMDIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vcGNvZGUgPSB0aGlzLl9mcmFnbWVudGVkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAxIHx8IHRoaXMuX29wY29kZSA9PT0gMHgwMikge1xuICAgICAgaWYgKHRoaXMuX2ZyYWdtZW50ZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoUmFuZ2VFcnJvciwgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsIHRydWUsIDEwMDIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jb21wcmVzc2VkID0gY29tcHJlc3NlZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA+IDB4MDcgJiYgdGhpcy5fb3Bjb2RlIDwgMHgwYikge1xuICAgICAgaWYgKCF0aGlzLl9maW4pIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoUmFuZ2VFcnJvciwgJ0ZJTiBtdXN0IGJlIHNldCcsIHRydWUsIDEwMDIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihSYW5nZUVycm9yLCAnUlNWMSBtdXN0IGJlIGNsZWFyJywgdHJ1ZSwgMTAwMik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID4gMHg3ZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgIGBpbnZhbGlkIHBheWxvYWQgbGVuZ3RoICR7dGhpcy5fcGF5bG9hZExlbmd0aH1gLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3IoUmFuZ2VFcnJvciwgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsIHRydWUsIDEwMDIpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZmluICYmICF0aGlzLl9mcmFnbWVudGVkKSB0aGlzLl9mcmFnbWVudGVkID0gdGhpcy5fb3Bjb2RlO1xuICAgIHRoaXMuX21hc2tlZCA9IChidWZbMV0gJiAweDgwKSA9PT0gMHg4MDtcblxuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxMjYpIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzE2O1xuICAgIGVsc2UgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEyNykgdGhpcy5fc3RhdGUgPSBHRVRfUEFZTE9BRF9MRU5HVEhfNjQ7XG4gICAgZWxzZSByZXR1cm4gdGhpcy5oYXZlTGVuZ3RoKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNysxNikuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBheWxvYWRMZW5ndGgxNigpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDIpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gdGhpcy5jb25zdW1lKDIpLnJlYWRVSW50MTZCRSgwKTtcbiAgICByZXR1cm4gdGhpcy5oYXZlTGVuZ3RoKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNys2NCkuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBheWxvYWRMZW5ndGg2NCgpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDgpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoOCk7XG4gICAgY29uc3QgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKTtcblxuICAgIC8vXG4gICAgLy8gVGhlIG1heGltdW0gc2FmZSBpbnRlZ2VyIGluIEphdmFTY3JpcHQgaXMgMl41MyAtIDEuIEFuIGVycm9yIGlzIHJldHVybmVkXG4gICAgLy8gaWYgcGF5bG9hZCBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIHRoaXMgbnVtYmVyLlxuICAgIC8vXG4gICAgaWYgKG51bSA+IE1hdGgucG93KDIsIDUzIC0gMzIpIC0gMSkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnVW5zdXBwb3J0ZWQgV2ViU29ja2V0IGZyYW1lOiBwYXlsb2FkIGxlbmd0aCA+IDJeNTMgLSAxJyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIDEwMDlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IG51bSAqIE1hdGgucG93KDIsIDMyKSArIGJ1Zi5yZWFkVUludDMyQkUoNCk7XG4gICAgcmV0dXJuIHRoaXMuaGF2ZUxlbmd0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBheWxvYWQgbGVuZ3RoIGhhcyBiZWVuIHJlYWQuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhdmVMZW5ndGgoKSB7XG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggJiYgdGhpcy5fb3Bjb2RlIDwgMHgwOCkge1xuICAgICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoICs9IHRoaXMuX3BheWxvYWRMZW5ndGg7XG4gICAgICBpZiAodGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID4gdGhpcy5fbWF4UGF5bG9hZCAmJiB0aGlzLl9tYXhQYXlsb2FkID4gMCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihSYW5nZUVycm9yLCAnTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcsIGZhbHNlLCAxMDA5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbWFza2VkKSB0aGlzLl9zdGF0ZSA9IEdFVF9NQVNLO1xuICAgIGVsc2UgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBtYXNrIGJ5dGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TWFzaygpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDQpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9tYXNrID0gdGhpcy5jb25zdW1lKDQpO1xuICAgIHRoaXMuX3N0YXRlID0gR0VUX0RBVEE7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgZGF0YSBieXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHJldHVybiB7KEVycm9yfFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0RGF0YShjYikge1xuICAgIHZhciBkYXRhID0gY29uc3RhbnRzLkVNUFRZX0JVRkZFUjtcblxuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IHRoaXMuX3BheWxvYWRMZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRhdGEgPSB0aGlzLmNvbnN1bWUodGhpcy5fcGF5bG9hZExlbmd0aCk7XG4gICAgICBpZiAodGhpcy5fbWFza2VkKSBidWZmZXJVdGlsLnVubWFzayhkYXRhLCB0aGlzLl9tYXNrKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNykgcmV0dXJuIHRoaXMuY29udHJvbE1lc3NhZ2UoZGF0YSk7XG5cbiAgICBpZiAodGhpcy5fY29tcHJlc3NlZCkge1xuICAgICAgdGhpcy5fc3RhdGUgPSBJTkZMQVRJTkc7XG4gICAgICB0aGlzLmRlY29tcHJlc3MoZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCkge1xuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgbWVzc2FnZSBpcyBub3QgY29tcHJlc3NlZCBzbyBpdHMgbGVuZ2h0IGlzIHRoZSBzdW0gb2YgdGhlIHBheWxvYWRcbiAgICAgIC8vIGxlbmd0aCBvZiBhbGwgZnJhZ21lbnRzLlxuICAgICAgLy9cbiAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGg7XG4gICAgICB0aGlzLl9mcmFnbWVudHMucHVzaChkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhTWVzc2FnZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3NlcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlY29tcHJlc3MoZGF0YSwgY2IpIHtcbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XG5cbiAgICBwZXJNZXNzYWdlRGVmbGF0ZS5kZWNvbXByZXNzKGRhdGEsIHRoaXMuX2ZpbiwgKGVyciwgYnVmKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgICAgaWYgKGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbWVzc2FnZUxlbmd0aCArPSBidWYubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5fbWVzc2FnZUxlbmd0aCA+IHRoaXMuX21heFBheWxvYWQgJiYgdGhpcy5fbWF4UGF5bG9hZCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gY2IoXG4gICAgICAgICAgICBlcnJvcihSYW5nZUVycm9yLCAnTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcsIGZhbHNlLCAxMDA5KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9mcmFnbWVudHMucHVzaChidWYpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBlciA9IHRoaXMuZGF0YU1lc3NhZ2UoKTtcbiAgICAgIGlmIChlcikgcmV0dXJuIGNiKGVyKTtcblxuICAgICAgdGhpcy5zdGFydExvb3AoY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBkYXRhIG1lc3NhZ2UuXG4gICAqXG4gICAqIEByZXR1cm4geyhFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkYXRhTWVzc2FnZSgpIHtcbiAgICBpZiAodGhpcy5fZmluKSB7XG4gICAgICBjb25zdCBtZXNzYWdlTGVuZ3RoID0gdGhpcy5fbWVzc2FnZUxlbmd0aDtcbiAgICAgIGNvbnN0IGZyYWdtZW50cyA9IHRoaXMuX2ZyYWdtZW50cztcblxuICAgICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgICAgdGhpcy5fZnJhZ21lbnRlZCA9IDA7XG4gICAgICB0aGlzLl9mcmFnbWVudHMgPSBbXTtcblxuICAgICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMikge1xuICAgICAgICB2YXIgZGF0YTtcblxuICAgICAgICBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ25vZGVidWZmZXInKSB7XG4gICAgICAgICAgZGF0YSA9IHRvQnVmZmVyKGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICAgIGRhdGEgPSB0b0FycmF5QnVmZmVyKHRvQnVmZmVyKGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEgPSBmcmFnbWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRvQnVmZmVyKGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG5cbiAgICAgICAgaWYgKCF2YWxpZGF0aW9uLmlzVmFsaWRVVEY4KGJ1ZikpIHtcbiAgICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIGVycm9yKEVycm9yLCAnaW52YWxpZCBVVEYtOCBzZXF1ZW5jZScsIHRydWUsIDEwMDcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgYnVmLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGNvbnRyb2wgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgRGF0YSB0byBoYW5kbGVcbiAgICogQHJldHVybiB7KEVycm9yfFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29udHJvbE1lc3NhZ2UoZGF0YSkge1xuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDgpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcblxuICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnY29uY2x1ZGUnLCAxMDA1LCAnJyk7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBlcnJvcihSYW5nZUVycm9yLCAnaW52YWxpZCBwYXlsb2FkIGxlbmd0aCAxJywgdHJ1ZSwgMTAwMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2RlID0gZGF0YS5yZWFkVUludDE2QkUoMCk7XG5cbiAgICAgICAgaWYgKCF2YWxpZGF0aW9uLmlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yKFJhbmdlRXJyb3IsIGBpbnZhbGlkIHN0YXR1cyBjb2RlICR7Y29kZX1gLCB0cnVlLCAxMDAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZiA9IGRhdGEuc2xpY2UoMik7XG5cbiAgICAgICAgaWYgKCF2YWxpZGF0aW9uLmlzVmFsaWRVVEY4KGJ1ZikpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3IoRXJyb3IsICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJywgdHJ1ZSwgMTAwNyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoJ2NvbmNsdWRlJywgY29kZSwgYnVmLnRvU3RyaW5nKCkpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID09PSAweDA5KSB7XG4gICAgICB0aGlzLmVtaXQoJ3BpbmcnLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCdwb25nJywgZGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY2VpdmVyO1xuXG4vKipcbiAqIEJ1aWxkcyBhbiBlcnJvciBvYmplY3QuXG4gKlxuICogQHBhcmFtIHsoRXJyb3J8UmFuZ2VFcnJvcil9IEVycm9yQ3RvciBUaGUgZXJyb3IgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZpeCBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gYWRkIGEgZGVmYXVsdCBwcmVmaXggdG9cbiAqICAgICBgbWVzc2FnZWBcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0dXNDb2RlIFRoZSBzdGF0dXMgY29kZVxuICogQHJldHVybiB7KEVycm9yfFJhbmdlRXJyb3IpfSBUaGUgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVycm9yKEVycm9yQ3RvciwgbWVzc2FnZSwgcHJlZml4LCBzdGF0dXNDb2RlKSB7XG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvckN0b3IoXG4gICAgcHJlZml4ID8gYEludmFsaWQgV2ViU29ja2V0IGZyYW1lOiAke21lc3NhZ2V9YCA6IG1lc3NhZ2VcbiAgKTtcblxuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIGVycm9yKTtcbiAgZXJyW2NvbnN0YW50cy5rU3RhdHVzQ29kZV0gPSBzdGF0dXNDb2RlO1xuICByZXR1cm4gZXJyO1xufVxuXG4vKipcbiAqIE1ha2VzIGEgYnVmZmVyIGZyb20gYSBsaXN0IG9mIGZyYWdtZW50cy5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcltdfSBmcmFnbWVudHMgVGhlIGxpc3Qgb2YgZnJhZ21lbnRzIGNvbXBvc2luZyB0aGUgbWVzc2FnZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1lc3NhZ2VMZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZVxuICogQHJldHVybiB7QnVmZmVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdG9CdWZmZXIoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKSB7XG4gIGlmIChmcmFnbWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gZnJhZ21lbnRzWzBdO1xuICBpZiAoZnJhZ21lbnRzLmxlbmd0aCA+IDEpIHJldHVybiBidWZmZXJVdGlsLmNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpO1xuICByZXR1cm4gY29uc3RhbnRzLkVNUFRZX0JVRkZFUjtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhbiBgQXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgVGhlIGJ1ZmZlciB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gQ29udmVydGVkIGJ1ZmZlclxuICovXG5mdW5jdGlvbiB0b0FycmF5QnVmZmVyKGJ1Zikge1xuICBpZiAoYnVmLmJ5dGVMZW5ndGggPT09IGJ1Zi5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBidWYuYnVmZmVyO1xuICB9XG5cbiAgcmV0dXJuIGJ1Zi5idWZmZXIuc2xpY2UoYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlT2Zmc2V0ICsgYnVmLmJ5dGVMZW5ndGgpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvd3MvbGliL3JlY2VpdmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnRyeSB7XG4gIGNvbnN0IGlzVmFsaWRVVEY4ID0gcmVxdWlyZSgndXRmLTgtdmFsaWRhdGUnKTtcblxuICBleHBvcnRzLmlzVmFsaWRVVEY4ID1cbiAgICB0eXBlb2YgaXNWYWxpZFVURjggPT09ICdvYmplY3QnXG4gICAgICA/IGlzVmFsaWRVVEY4LlZhbGlkYXRpb24uaXNWYWxpZFVURjggLy8gdXRmLTgtdmFsaWRhdGVAPDMuMC4wXG4gICAgICA6IGlzVmFsaWRVVEY4O1xufSBjYXRjaCAoZSkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge1xuICBleHBvcnRzLmlzVmFsaWRVVEY4ID0gKCkgPT4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGF0dXMgY29kZSBpcyBhbGxvd2VkIGluIGEgY2xvc2UgZnJhbWUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIHN0YXR1cyBjb2RlXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHN0YXR1cyBjb2RlIGlzIHZhbGlkLCBlbHNlIGBmYWxzZWBcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0cy5pc1ZhbGlkU3RhdHVzQ29kZSA9IChjb2RlKSA9PiB7XG4gIHJldHVybiAoXG4gICAgKGNvZGUgPj0gMTAwMCAmJlxuICAgICAgY29kZSA8PSAxMDEzICYmXG4gICAgICBjb2RlICE9PSAxMDA0ICYmXG4gICAgICBjb2RlICE9PSAxMDA1ICYmXG4gICAgICBjb2RlICE9PSAxMDA2KSB8fFxuICAgIChjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5KVxuICApO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3dzL2xpYi92YWxpZGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBidWZmZXJVdGlsID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuY29uc3QgdmFsaWRhdGlvbiA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuLyoqXG4gKiBIeUJpIFNlbmRlciBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgU2VuZGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBTZW5kZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7bmV0LlNvY2tldH0gc29ja2V0IFRoZSBjb25uZWN0aW9uIHNvY2tldFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5zaW9ucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZCBleHRlbnNpb25zXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb2NrZXQsIGV4dGVuc2lvbnMpIHtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gZXh0ZW5zaW9ucyB8fCB7fTtcbiAgICB0aGlzLl9zb2NrZXQgPSBzb2NrZXQ7XG5cbiAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcbiAgICB0aGlzLl9jb21wcmVzcyA9IGZhbHNlO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyA9IDA7XG4gICAgdGhpcy5fZGVmbGF0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGcmFtZXMgYSBwaWVjZSBvZiBkYXRhIGFjY29yZGluZyB0byB0aGUgSHlCaSBXZWJTb2NrZXQgcHJvdG9jb2wuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIHRvIGZyYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5yZWFkT25seSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5maW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGUgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMubWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnJzdjEgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGUgUlNWMSBiaXRcbiAgICogQHJldHVybiB7QnVmZmVyW119IFRoZSBmcmFtZWQgZGF0YSBhcyBhIGxpc3Qgb2YgYEJ1ZmZlcmAgaW5zdGFuY2VzXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHN0YXRpYyBmcmFtZShkYXRhLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbWVyZ2UgPSBkYXRhLmxlbmd0aCA8IDEwMjQgfHwgKG9wdGlvbnMubWFzayAmJiBvcHRpb25zLnJlYWRPbmx5KTtcbiAgICB2YXIgb2Zmc2V0ID0gb3B0aW9ucy5tYXNrID8gNiA6IDI7XG4gICAgdmFyIHBheWxvYWRMZW5ndGggPSBkYXRhLmxlbmd0aDtcblxuICAgIGlmIChkYXRhLmxlbmd0aCA+PSA2NTUzNikge1xuICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI3O1xuICAgIH0gZWxzZSBpZiAoZGF0YS5sZW5ndGggPiAxMjUpIHtcbiAgICAgIG9mZnNldCArPSAyO1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyNjtcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobWVyZ2UgPyBkYXRhLmxlbmd0aCArIG9mZnNldCA6IG9mZnNldCk7XG5cbiAgICB0YXJnZXRbMF0gPSBvcHRpb25zLmZpbiA/IG9wdGlvbnMub3Bjb2RlIHwgMHg4MCA6IG9wdGlvbnMub3Bjb2RlO1xuICAgIGlmIChvcHRpb25zLnJzdjEpIHRhcmdldFswXSB8PSAweDQwO1xuXG4gICAgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNikge1xuICAgICAgdGFyZ2V0LndyaXRlVUludDE2QkUoZGF0YS5sZW5ndGgsIDIpO1xuICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI3KSB7XG4gICAgICB0YXJnZXQud3JpdGVVSW50MzJCRSgwLCAyKTtcbiAgICAgIHRhcmdldC53cml0ZVVJbnQzMkJFKGRhdGEubGVuZ3RoLCA2KTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMubWFzaykge1xuICAgICAgdGFyZ2V0WzFdID0gcGF5bG9hZExlbmd0aDtcbiAgICAgIGlmIChtZXJnZSkge1xuICAgICAgICBkYXRhLmNvcHkodGFyZ2V0LCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gW3RhcmdldF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXNrID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDQpO1xuXG4gICAgdGFyZ2V0WzFdID0gcGF5bG9hZExlbmd0aCB8IDB4ODA7XG4gICAgdGFyZ2V0W29mZnNldCAtIDRdID0gbWFza1swXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gM10gPSBtYXNrWzFdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAyXSA9IG1hc2tbMl07XG4gICAgdGFyZ2V0W29mZnNldCAtIDFdID0gbWFza1szXTtcblxuICAgIGlmIChtZXJnZSkge1xuICAgICAgYnVmZmVyVXRpbC5tYXNrKGRhdGEsIG1hc2ssIHRhcmdldCwgb2Zmc2V0LCBkYXRhLmxlbmd0aCk7XG4gICAgICByZXR1cm4gW3RhcmdldF07XG4gICAgfVxuXG4gICAgYnVmZmVyVXRpbC5tYXNrKGRhdGEsIG1hc2ssIGRhdGEsIDAsIGRhdGEubGVuZ3RoKTtcbiAgICByZXR1cm4gW3RhcmdldCwgZGF0YV07XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBjbG9zZSBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyhOdW1iZXJ8dW5kZWZpbmVkKX0gY29kZSBUaGUgc3RhdHVzIGNvZGUgY29tcG9uZW50IG9mIHRoZSBib2R5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIFRoZSBtZXNzYWdlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1hc2sgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgdGhlIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY29kZSwgZGF0YSwgbWFzaywgY2IpIHtcbiAgICB2YXIgYnVmO1xuXG4gICAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYnVmID0gY29uc3RhbnRzLkVNUFRZX0JVRkZFUjtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdHlwZW9mIGNvZGUgIT09ICdudW1iZXInIHx8XG4gICAgICAhdmFsaWRhdGlvbi5pc1ZhbGlkU3RhdHVzQ29kZShjb2RlKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHZhbGlkIGVycm9yIGNvZGUgbnVtYmVyJyk7XG4gICAgfSBlbHNlIGlmIChkYXRhID09PSB1bmRlZmluZWQgfHwgZGF0YSA9PT0gJycpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyKTtcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMiArIEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpKTtcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xuICAgICAgYnVmLndyaXRlKGRhdGEsIDIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kb0Nsb3NlLCBidWYsIG1hc2ssIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG9DbG9zZShidWYsIG1hc2ssIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRnJhbWVzIGFuZCBzZW5kcyBhIGNsb3NlIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBtYXNrIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZG9DbG9zZShkYXRhLCBtYXNrLCBjYikge1xuICAgIHRoaXMuc2VuZEZyYW1lKFxuICAgICAgU2VuZGVyLmZyYW1lKGRhdGEsIHtcbiAgICAgICAgZmluOiB0cnVlLFxuICAgICAgICByc3YxOiBmYWxzZSxcbiAgICAgICAgb3Bjb2RlOiAweDA4LFxuICAgICAgICBtYXNrLFxuICAgICAgICByZWFkT25seTogZmFsc2VcbiAgICAgIH0pLFxuICAgICAgY2JcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcGluZyBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1hc2sgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICB2YXIgcmVhZE9ubHkgPSB0cnVlO1xuXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICAgICAgZGF0YSA9IHZpZXdUb0J1ZmZlcihkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZG9QaW5nLCBkYXRhLCBtYXNrLCByZWFkT25seSwgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb1BpbmcoZGF0YSwgbWFzaywgcmVhZE9ubHksIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRnJhbWVzIGFuZCBzZW5kcyBhIHBpbmcgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBtYXNrIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlYWRPbmx5IFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmUgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRvUGluZyhkYXRhLCBtYXNrLCByZWFkT25seSwgY2IpIHtcbiAgICB0aGlzLnNlbmRGcmFtZShcbiAgICAgIFNlbmRlci5mcmFtZShkYXRhLCB7XG4gICAgICAgIGZpbjogdHJ1ZSxcbiAgICAgICAgcnN2MTogZmFsc2UsXG4gICAgICAgIG9wY29kZTogMHgwOSxcbiAgICAgICAgbWFzayxcbiAgICAgICAgcmVhZE9ubHlcbiAgICAgIH0pLFxuICAgICAgY2JcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcG9uZyBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1hc2sgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBvbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICB2YXIgcmVhZE9ubHkgPSB0cnVlO1xuXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICAgICAgZGF0YSA9IHZpZXdUb0J1ZmZlcihkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZG9Qb25nLCBkYXRhLCBtYXNrLCByZWFkT25seSwgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb1BvbmcoZGF0YSwgbWFzaywgcmVhZE9ubHksIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRnJhbWVzIGFuZCBzZW5kcyBhIHBvbmcgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBtYXNrIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlYWRPbmx5IFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmUgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRvUG9uZyhkYXRhLCBtYXNrLCByZWFkT25seSwgY2IpIHtcbiAgICB0aGlzLnNlbmRGcmFtZShcbiAgICAgIFNlbmRlci5mcmFtZShkYXRhLCB7XG4gICAgICAgIGZpbjogdHJ1ZSxcbiAgICAgICAgcnN2MTogZmFsc2UsXG4gICAgICAgIG9wY29kZTogMHgwYSxcbiAgICAgICAgbWFzayxcbiAgICAgICAgcmVhZE9ubHlcbiAgICAgIH0pLFxuICAgICAgY2JcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgZGF0YSBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuY29tcHJlc3MgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuYmluYXJ5IFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBpcyBiaW5hcnkgb3IgdGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuZmluIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmcmFnbWVudCBpcyB0aGUgbGFzdCBvbmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLm1hc2sgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNlbmQoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICB2YXIgb3Bjb2RlID0gb3B0aW9ucy5iaW5hcnkgPyAyIDogMTtcbiAgICB2YXIgcnN2MSA9IG9wdGlvbnMuY29tcHJlc3M7XG4gICAgdmFyIHJlYWRPbmx5ID0gdHJ1ZTtcblxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgICAgIGRhdGEgPSB2aWV3VG9CdWZmZXIoZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgaWYgKHRoaXMuX2ZpcnN0RnJhZ21lbnQpIHtcbiAgICAgIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSBmYWxzZTtcbiAgICAgIGlmIChyc3YxICYmIHBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICAgIHJzdjEgPSBkYXRhLmxlbmd0aCA+PSBwZXJNZXNzYWdlRGVmbGF0ZS5fdGhyZXNob2xkO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29tcHJlc3MgPSByc3YxO1xuICAgIH0gZWxzZSB7XG4gICAgICByc3YxID0gZmFsc2U7XG4gICAgICBvcGNvZGUgPSAwO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmZpbikgdGhpcy5fZmlyc3RGcmFnbWVudCA9IHRydWU7XG5cbiAgICBpZiAocGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIGZpbjogb3B0aW9ucy5maW4sXG4gICAgICAgIHJzdjEsXG4gICAgICAgIG9wY29kZSxcbiAgICAgICAgbWFzazogb3B0aW9ucy5tYXNrLFxuICAgICAgICByZWFkT25seVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuX2RlZmxhdGluZykge1xuICAgICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaChkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2IpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShcbiAgICAgICAgU2VuZGVyLmZyYW1lKGRhdGEsIHtcbiAgICAgICAgICBmaW46IG9wdGlvbnMuZmluLFxuICAgICAgICAgIHJzdjE6IGZhbHNlLFxuICAgICAgICAgIG9wY29kZSxcbiAgICAgICAgICBtYXNrOiBvcHRpb25zLm1hc2ssXG4gICAgICAgICAgcmVhZE9ubHlcbiAgICAgICAgfSksXG4gICAgICAgIGNiXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29tcHJlc3MgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzIGBkYXRhYFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMucmVhZE9ubHkgU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZSBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlIEZJTiBiaXRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLm1hc2sgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5yc3YxIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlIFJTVjEgYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkaXNwYXRjaChkYXRhLCBjb21wcmVzcywgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAoIWNvbXByZXNzKSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XG5cbiAgICB0aGlzLl9kZWZsYXRpbmcgPSB0cnVlO1xuICAgIHBlck1lc3NhZ2VEZWZsYXRlLmNvbXByZXNzKGRhdGEsIG9wdGlvbnMuZmluLCAoXywgYnVmKSA9PiB7XG4gICAgICB0aGlzLl9kZWZsYXRpbmcgPSBmYWxzZTtcbiAgICAgIG9wdGlvbnMucmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShidWYsIG9wdGlvbnMpLCBjYik7XG4gICAgICB0aGlzLmRlcXVldWUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBxdWV1ZWQgc2VuZCBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGVxdWV1ZSgpIHtcbiAgICB3aGlsZSAoIXRoaXMuX2RlZmxhdGluZyAmJiB0aGlzLl9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gcGFyYW1zWzFdLmxlbmd0aDtcbiAgICAgIHBhcmFtc1swXS5hcHBseSh0aGlzLCBwYXJhbXMuc2xpY2UoMSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHNlbmQgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgU2VuZCBvcGVyYXRpb24gcGFyYW1ldGVycy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVucXVldWUocGFyYW1zKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBwYXJhbXNbMV0ubGVuZ3RoO1xuICAgIHRoaXMuX3F1ZXVlLnB1c2gocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGZyYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcltdfSBsaXN0IFRoZSBmcmFtZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZW5kRnJhbWUobGlzdCwgY2IpIHtcbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzFdLCBjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdLCBjYik7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VuZGVyO1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIGBBcnJheUJ1ZmZlcmAgdmlldyBpbnRvIGEgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7KERhdGFWaWV3fFR5cGVkQXJyYXkpfSB2aWV3IFRoZSB2aWV3IHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge0J1ZmZlcn0gQ29udmVydGVkIHZpZXdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHZpZXdUb0J1ZmZlcih2aWV3KSB7XG4gIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5mcm9tKHZpZXcuYnVmZmVyKTtcblxuICBpZiAodmlldy5ieXRlTGVuZ3RoICE9PSB2aWV3LmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJ1Zi5zbGljZSh2aWV3LmJ5dGVPZmZzZXQsIHZpZXcuYnl0ZU9mZnNldCArIHZpZXcuYnl0ZUxlbmd0aCk7XG4gIH1cblxuICByZXR1cm4gYnVmO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvd3MvbGliL3NlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICovXG5leHBvcnRzLmluc3RhbmNlcyA9IFtdO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICB2YXIgcHJldlRpbWU7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG4gIGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgfVxuXG4gIGV4cG9ydHMuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xuXG4gIHJldHVybiBkZWJ1Zztcbn1cblxuZnVuY3Rpb24gZGVzdHJveSAoKSB7XG4gIHZhciBpbmRleCA9IGV4cG9ydHMuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBleHBvcnRzLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBpO1xuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwb3J0cy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBleHBvcnRzLmluc3RhbmNlc1tpXTtcbiAgICBpbnN0YW5jZS5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZjtcblxudmFyIHdpdGhOYXRpdmVCdWZmZXIgPSB0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBCdWZmZXIuaXNCdWZmZXIgPT09ICdmdW5jdGlvbic7XG52YXIgd2l0aE5hdGl2ZUFycmF5QnVmZmVyID0gdHlwZW9mIEFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nO1xuXG52YXIgaXNWaWV3ID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyA/IEFycmF5QnVmZmVyLmlzVmlldyhvYmopIDogKG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmogaXMgYSBidWZmZXIgb3IgYW4gYXJyYXlidWZmZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNCdWYob2JqKSB7XG4gIHJldHVybiAod2l0aE5hdGl2ZUJ1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgICAod2l0aE5hdGl2ZUFycmF5QnVmZmVyICYmIChvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBpc1ZpZXcob2JqKSkpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pcy1idWZmZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIEFjdGl2ZSBgZGVidWdgIGluc3RhbmNlcy5cblx0Ki9cblx0Y3JlYXRlRGVidWcuaW5zdGFuY2VzID0gW107XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdC8vIERlYnVnLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuXHRcdC8vIGRlYnVnLnJhd0xvZyA9IHJhd0xvZztcblxuXHRcdC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMucHVzaChkZWJ1Zyk7XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnN0IGluZGV4ID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG5cdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgaW5zdGFuY2UgPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXNbaV07XG5cdFx0XHRpbnN0YW5jZS5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChpbnN0YW5jZS5uYW1lc3BhY2UpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBoYXNCaW4gPSByZXF1aXJlKCdoYXMtYmluYXJ5MicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvOm5hbWVzcGFjZScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IE5hbWVzcGFjZTtcblxuLyoqXG4gKiBCbGFja2xpc3RlZCBldmVudHMuXG4gKi9cblxuZXhwb3J0cy5ldmVudHMgPSBbXG4gICdjb25uZWN0JywgICAgLy8gZm9yIHN5bW1ldHJ5IHdpdGggY2xpZW50XG4gICdjb25uZWN0aW9uJyxcbiAgJ25ld0xpc3RlbmVyJ1xuXTtcblxuLyoqXG4gKiBGbGFncy5cbiAqL1xuXG5leHBvcnRzLmZsYWdzID0gW1xuICAnanNvbicsXG4gICd2b2xhdGlsZScsXG4gICdsb2NhbCdcbl07XG5cbi8qKlxuICogYEV2ZW50RW1pdHRlciNlbWl0YCByZWZlcmVuY2UuXG4gKi9cblxudmFyIGVtaXQgPSBFbWl0dGVyLnByb3RvdHlwZS5lbWl0O1xuXG4vKipcbiAqIE5hbWVzcGFjZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1NlcnZlcn0gc2VydmVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge1NvY2tldH0gbmFtZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gTmFtZXNwYWNlKHNlcnZlciwgbmFtZSl7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICB0aGlzLnNvY2tldHMgPSB7fTtcbiAgdGhpcy5jb25uZWN0ZWQgPSB7fTtcbiAgdGhpcy5mbnMgPSBbXTtcbiAgdGhpcy5pZHMgPSAwO1xuICB0aGlzLnJvb21zID0gW107XG4gIHRoaXMuZmxhZ3MgPSB7fTtcbiAgdGhpcy5pbml0QWRhcHRlcigpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gYEV2ZW50RW1pdHRlcmAuXG4gKi9cblxuTmFtZXNwYWNlLnByb3RvdHlwZS5fX3Byb3RvX18gPSBFbWl0dGVyLnByb3RvdHlwZTtcblxuLyoqXG4gKiBBcHBseSBmbGFncyBmcm9tIGBTb2NrZXRgLlxuICovXG5cbmV4cG9ydHMuZmxhZ3MuZm9yRWFjaChmdW5jdGlvbihmbGFnKXtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5hbWVzcGFjZS5wcm90b3R5cGUsIGZsYWcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5mbGFnc1tmbGFnXSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xufSk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGBBZGFwdGVyYCBmb3IgdGhpcyBuc3AuXG4gKiBSdW4gdXBvbiBjaGFuZ2luZyBhZGFwdGVyIGJ5IGBTZXJ2ZXIjYWRhcHRlcmBcbiAqIGluIGFkZGl0aW9uIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5OYW1lc3BhY2UucHJvdG90eXBlLmluaXRBZGFwdGVyID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5hZGFwdGVyID0gbmV3ICh0aGlzLnNlcnZlci5hZGFwdGVyKCkpKHRoaXMpO1xufTtcblxuLyoqXG4gKiBTZXRzIHVwIG5hbWVzcGFjZSBtaWRkbGV3YXJlLlxuICpcbiAqIEByZXR1cm4ge05hbWVzcGFjZX0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5OYW1lc3BhY2UucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uKGZuKXtcbiAgaWYgKHRoaXMuc2VydmVyLmVpbyAmJiB0aGlzLm5hbWUgPT09ICcvJykge1xuICAgIGRlYnVnKCdyZW1vdmluZyBpbml0aWFsIHBhY2tldCcpO1xuICAgIGRlbGV0ZSB0aGlzLnNlcnZlci5laW8uaW5pdGlhbFBhY2tldDtcbiAgfVxuICB0aGlzLmZucy5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBtaWRkbGV3YXJlIGZvciBhbiBpbmNvbWluZyBjbGllbnQuXG4gKlxuICogQHBhcmFtIHtTb2NrZXR9IHNvY2tldCB0aGF0IHdpbGwgZ2V0IGFkZGVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBsYXN0IGZuIGNhbGwgaW4gdGhlIG1pZGRsZXdhcmVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk5hbWVzcGFjZS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oc29ja2V0LCBmbil7XG4gIHZhciBmbnMgPSB0aGlzLmZucy5zbGljZSgwKTtcbiAgaWYgKCFmbnMubGVuZ3RoKSByZXR1cm4gZm4obnVsbCk7XG5cbiAgZnVuY3Rpb24gcnVuKGkpe1xuICAgIGZuc1tpXShzb2NrZXQsIGZ1bmN0aW9uKGVycil7XG4gICAgICAvLyB1cG9uIGVycm9yLCBzaG9ydC1jaXJjdWl0XG4gICAgICBpZiAoZXJyKSByZXR1cm4gZm4oZXJyKTtcblxuICAgICAgLy8gaWYgbm8gbWlkZGxld2FyZSBsZWZ0LCBzdW1tb24gY2FsbGJhY2tcbiAgICAgIGlmICghZm5zW2kgKyAxXSkgcmV0dXJuIGZuKG51bGwpO1xuXG4gICAgICAvLyBnbyBvbiB0byBuZXh0XG4gICAgICBydW4oaSArIDEpO1xuICAgIH0pO1xuICB9XG5cbiAgcnVuKDApO1xufTtcblxuLyoqXG4gKiBUYXJnZXRzIGEgcm9vbSB3aGVuIGVtaXR0aW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtOYW1lc3BhY2V9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTmFtZXNwYWNlLnByb3RvdHlwZS50byA9XG5OYW1lc3BhY2UucHJvdG90eXBlLmluID0gZnVuY3Rpb24obmFtZSl7XG4gIGlmICghfnRoaXMucm9vbXMuaW5kZXhPZihuYW1lKSkgdGhpcy5yb29tcy5wdXNoKG5hbWUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhIG5ldyBjbGllbnQuXG4gKlxuICogQHJldHVybiB7U29ja2V0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTmFtZXNwYWNlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihjbGllbnQsIHF1ZXJ5LCBmbil7XG4gIGRlYnVnKCdhZGRpbmcgc29ja2V0IHRvIG5zcCAlcycsIHRoaXMubmFtZSk7XG4gIHZhciBzb2NrZXQgPSBuZXcgU29ja2V0KHRoaXMsIGNsaWVudCwgcXVlcnkpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMucnVuKHNvY2tldCwgZnVuY3Rpb24oZXJyKXtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCl7XG4gICAgICBpZiAoJ29wZW4nID09IGNsaWVudC5jb25uLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHNvY2tldC5lcnJvcihlcnIuZGF0YSB8fCBlcnIubWVzc2FnZSk7XG5cbiAgICAgICAgLy8gdHJhY2sgc29ja2V0XG4gICAgICAgIHNlbGYuc29ja2V0c1tzb2NrZXQuaWRdID0gc29ja2V0O1xuXG4gICAgICAgIC8vIGl0J3MgcGFyYW1vdW50IHRoYXQgdGhlIGludGVybmFsIGBvbmNvbm5lY3RgIGxvZ2ljXG4gICAgICAgIC8vIGZpcmVzIGJlZm9yZSB1c2VyLXNldCBldmVudHMgdG8gcHJldmVudCBzdGF0ZSBvcmRlclxuICAgICAgICAvLyB2aW9sYXRpb25zIChzdWNoIGFzIGEgZGlzY29ubmVjdGlvbiBiZWZvcmUgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgLy8gbG9naWMgaXMgY29tcGxldGUpXG4gICAgICAgIHNvY2tldC5vbmNvbm5lY3QoKTtcbiAgICAgICAgaWYgKGZuKSBmbigpO1xuXG4gICAgICAgIC8vIGZpcmUgdXNlci1zZXQgZXZlbnRzXG4gICAgICAgIHNlbGYuZW1pdCgnY29ubmVjdCcsIHNvY2tldCk7XG4gICAgICAgIHNlbGYuZW1pdCgnY29ubmVjdGlvbicsIHNvY2tldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygnbmV4dCBjYWxsZWQgYWZ0ZXIgY2xpZW50IHdhcyBjbG9zZWQgLSBpZ25vcmluZyBzb2NrZXQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBzb2NrZXQ7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBjbGllbnQuIENhbGxlZCBieSBlYWNoIGBTb2NrZXRgLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk5hbWVzcGFjZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oc29ja2V0KXtcbiAgaWYgKHRoaXMuc29ja2V0cy5oYXNPd25Qcm9wZXJ0eShzb2NrZXQuaWQpKSB7XG4gICAgZGVsZXRlIHRoaXMuc29ja2V0c1tzb2NrZXQuaWRdO1xuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdpZ25vcmluZyByZW1vdmUgZm9yICVzJywgc29ja2V0LmlkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbWl0cyB0byBhbGwgY2xpZW50cy5cbiAqXG4gKiBAcmV0dXJuIHtOYW1lc3BhY2V9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTmFtZXNwYWNlLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXYpe1xuICBpZiAofmV4cG9ydHMuZXZlbnRzLmluZGV4T2YoZXYpKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8vIHNldCB1cCBwYWNrZXQgb2JqZWN0XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgdmFyIHBhY2tldCA9IHtcbiAgICB0eXBlOiAodGhpcy5mbGFncy5iaW5hcnkgIT09IHVuZGVmaW5lZCA/IHRoaXMuZmxhZ3MuYmluYXJ5IDogaGFzQmluKGFyZ3MpKSA/IHBhcnNlci5CSU5BUllfRVZFTlQgOiBwYXJzZXIuRVZFTlQsXG4gICAgZGF0YTogYXJnc1xuICB9O1xuXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxiYWNrcyBhcmUgbm90IHN1cHBvcnRlZCB3aGVuIGJyb2FkY2FzdGluZycpO1xuICB9XG5cbiAgdmFyIHJvb21zID0gdGhpcy5yb29tcy5zbGljZSgwKTtcbiAgdmFyIGZsYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5mbGFncyk7XG5cbiAgLy8gcmVzZXQgZmxhZ3NcbiAgdGhpcy5yb29tcyA9IFtdO1xuICB0aGlzLmZsYWdzID0ge307XG5cbiAgdGhpcy5hZGFwdGVyLmJyb2FkY2FzdChwYWNrZXQsIHtcbiAgICByb29tczogcm9vbXMsXG4gICAgZmxhZ3M6IGZsYWdzXG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudCB0byBhbGwgY2xpZW50cy5cbiAqXG4gKiBAcmV0dXJuIHtOYW1lc3BhY2V9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTmFtZXNwYWNlLnByb3RvdHlwZS5zZW5kID1cbk5hbWVzcGFjZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbigpe1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gIGFyZ3MudW5zaGlmdCgnbWVzc2FnZScpO1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgbGlzdCBvZiBjbGllbnRzLlxuICpcbiAqIEByZXR1cm4ge05hbWVzcGFjZX0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5OYW1lc3BhY2UucHJvdG90eXBlLmNsaWVudHMgPSBmdW5jdGlvbihmbil7XG4gIGlmKCF0aGlzLmFkYXB0ZXIpe1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gYWRhcHRlciBmb3IgdGhpcyBuYW1lc3BhY2UsIGFyZSB5b3UgdHJ5aW5nIHRvIGdldCB0aGUgbGlzdCBvZiBjbGllbnRzIG9mIGEgZHluYW1pYyBuYW1lc3BhY2U/JylcbiAgfVxuICB0aGlzLmFkYXB0ZXIuY2xpZW50cyh0aGlzLnJvb21zLCBmbik7XG4gIC8vIHJlc2V0IHJvb21zIGZvciBzY2VuYXJpbzpcbiAgLy8gLmluKCdyb29tJykuY2xpZW50cygpIChHSC0xOTc4KVxuICB0aGlzLnJvb21zID0gW107XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY29tcHJlc3MgaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5OYW1lc3BhY2UucHJvdG90eXBlLmNvbXByZXNzID0gZnVuY3Rpb24oY29tcHJlc3Mpe1xuICB0aGlzLmZsYWdzLmNvbXByZXNzID0gY29tcHJlc3M7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBiaW5hcnkgZmxhZ1xuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gRW5jb2RlIGFzIGlmIGl0IGhhcyBiaW5hcnkgZGF0YSBpZiBgdHJ1ZWAsIEVuY29kZSBhcyBpZiBpdCBkb2VzbnQgaGF2ZSBiaW5hcnkgZGF0YSBpZiBgZmFsc2VgXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuIE5hbWVzcGFjZS5wcm90b3R5cGUuYmluYXJ5ID0gZnVuY3Rpb24gKGJpbmFyeSkge1xuICAgdGhpcy5mbGFncy5iaW5hcnkgPSBiaW5hcnk7XG4gICByZXR1cm4gdGhpcztcbiB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2xpYi9uYW1lc3BhY2UuanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAqIGFzIGV4cHJlc3MgZnJvbSBcImV4cHJlc3NcIjtcclxuaW1wb3J0IHtTb2NrZXRTZXJ2ZXJ9IGZyb20gJy4uL3NyYy9zb2NrZXRTZXJ2ZXInO1xyXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxuXHJcbmNvbnN0IGFwcCA9IGV4cHJlc3MoKTtcclxuYXBwLnNldChcInBvcnRcIiwgcHJvY2Vzcy5lbnYuUE9SVCB8fCAzMDAwKTtcclxuY29uc3Qgcm91dGVyID0gZXhwcmVzcy5Sb3V0ZXIoKTtcclxudmFyIGh0dHAgPSByZXF1aXJlKFwiaHR0cFwiKS5TZXJ2ZXIoYXBwKTtcclxuXHJcbmFwcC51c2UoZXhwcmVzcy5zdGF0aWMocGF0aC5yZXNvbHZlKCcuLy4uL2NsaWVudC9idWlsZC8nKSkpO1xyXG5cclxuLy8gbG9naW4gcGFnZVxyXG5cclxucm91dGVyLmdldChcIi9sb2dpblwiLCAocmVxOiBhbnksIHJlczogYW55KSA9PiB7XHJcblx0cmVzLnNlbmRGaWxlKHBhdGgucmVzb2x2ZSgnLi8uLi9jbGllbnQvbG9naW4uaHRtbCcpKTtcclxufSk7XHJcblxyXG4vLyBnYW1lIHBhZ2VcclxuXHJcbnJvdXRlci5nZXQoXCIvZ2FtZVwiLCAocmVxOiBhbnksIHJlczogYW55KSA9PiB7XHJcblx0cmVzLnNlbmRGaWxlKHBhdGgucmVzb2x2ZSgnLi8uLi9jbGllbnQvZ2FtZS5odG1sJykpO1xyXG59KTtcclxuXHJcbi8vIHJlZGlyZWN0cyB0byBsb2dpbiBwYWdlIFxyXG5cclxucm91dGVyLmdldChcIipcIiwgKHJlcTogYW55LCByZXM6IGFueSkgPT4ge1xyXG5cdHJlcy5yZWRpcmVjdChcIi9sb2dpblwiKTtcclxufSk7XHJcblxyXG5hcHAudXNlKCcvJywgcm91dGVyKTtcclxuXHJcbi8vIHN0YXJ0cyBzb2NrZXQgc2VydmVyXHJcblxyXG5jb25zdCBzb2NrZXRzID0gbmV3IFNvY2tldFNlcnZlcihodHRwKTtcclxuLy8gc3RhcnQgb3VyIHNpbXBsZSBzZXJ2ZXIgdXAgb24gbG9jYWxob3N0OjMwMDBcclxuXHJcbi8vIHN0YXJ0cyBodHRwIHNlcnZlclxyXG5cclxuY29uc3Qgc2VydmVyID0gaHR0cC5saXN0ZW4oMzAwMCwgZnVuY3Rpb24oKSB7XHJcbiAgY29uc29sZS5sb2coXCJsaXN0ZW5pbmcgb24gKjozMDAwXCIpO1xyXG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW5kZXgudHMiLCIvKiFcbiAqIGV4cHJlc3NcbiAqIENvcHlyaWdodChjKSAyMDA5LTIwMTMgVEogSG9sb3dheWNodWtcbiAqIENvcHlyaWdodChjKSAyMDEzIFJvbWFuIFNodHlsbWFuXG4gKiBDb3B5cmlnaHQoYykgMjAxNC0yMDE1IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvZXhwcmVzcycpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZXhwcmVzcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBleHByZXNzXG4gKiBDb3B5cmlnaHQoYykgMjAwOS0yMDEzIFRKIEhvbG93YXljaHVrXG4gKiBDb3B5cmlnaHQoYykgMjAxMyBSb21hbiBTaHR5bG1hblxuICogQ29weXJpZ2h0KGMpIDIwMTQtMjAxNSBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGJvZHlQYXJzZXIgPSByZXF1aXJlKCdib2R5LXBhcnNlcicpXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIG1peGluID0gcmVxdWlyZSgnbWVyZ2UtZGVzY3JpcHRvcnMnKTtcbnZhciBwcm90byA9IHJlcXVpcmUoJy4vYXBwbGljYXRpb24nKTtcbnZhciBSb3V0ZSA9IHJlcXVpcmUoJy4vcm91dGVyL3JvdXRlJyk7XG52YXIgUm91dGVyID0gcmVxdWlyZSgnLi9yb3V0ZXInKTtcbnZhciByZXEgPSByZXF1aXJlKCcuL3JlcXVlc3QnKTtcbnZhciByZXMgPSByZXF1aXJlKCcuL3Jlc3BvbnNlJyk7XG5cbi8qKlxuICogRXhwb3NlIGBjcmVhdGVBcHBsaWNhdGlvbigpYC5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBcHBsaWNhdGlvbjtcblxuLyoqXG4gKiBDcmVhdGUgYW4gZXhwcmVzcyBhcHBsaWNhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlQXBwbGljYXRpb24oKSB7XG4gIHZhciBhcHAgPSBmdW5jdGlvbihyZXEsIHJlcywgbmV4dCkge1xuICAgIGFwcC5oYW5kbGUocmVxLCByZXMsIG5leHQpO1xuICB9O1xuXG4gIG1peGluKGFwcCwgRXZlbnRFbWl0dGVyLnByb3RvdHlwZSwgZmFsc2UpO1xuICBtaXhpbihhcHAsIHByb3RvLCBmYWxzZSk7XG5cbiAgLy8gZXhwb3NlIHRoZSBwcm90b3R5cGUgdGhhdCB3aWxsIGdldCBzZXQgb24gcmVxdWVzdHNcbiAgYXBwLnJlcXVlc3QgPSBPYmplY3QuY3JlYXRlKHJlcSwge1xuICAgIGFwcDogeyBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogYXBwIH1cbiAgfSlcblxuICAvLyBleHBvc2UgdGhlIHByb3RvdHlwZSB0aGF0IHdpbGwgZ2V0IHNldCBvbiByZXNwb25zZXNcbiAgYXBwLnJlc3BvbnNlID0gT2JqZWN0LmNyZWF0ZShyZXMsIHtcbiAgICBhcHA6IHsgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGFwcCB9XG4gIH0pXG5cbiAgYXBwLmluaXQoKTtcbiAgcmV0dXJuIGFwcDtcbn1cblxuLyoqXG4gKiBFeHBvc2UgdGhlIHByb3RvdHlwZXMuXG4gKi9cblxuZXhwb3J0cy5hcHBsaWNhdGlvbiA9IHByb3RvO1xuZXhwb3J0cy5yZXF1ZXN0ID0gcmVxO1xuZXhwb3J0cy5yZXNwb25zZSA9IHJlcztcblxuLyoqXG4gKiBFeHBvc2UgY29uc3RydWN0b3JzLlxuICovXG5cbmV4cG9ydHMuUm91dGUgPSBSb3V0ZTtcbmV4cG9ydHMuUm91dGVyID0gUm91dGVyO1xuXG4vKipcbiAqIEV4cG9zZSBtaWRkbGV3YXJlXG4gKi9cblxuZXhwb3J0cy5qc29uID0gYm9keVBhcnNlci5qc29uXG5leHBvcnRzLnF1ZXJ5ID0gcmVxdWlyZSgnLi9taWRkbGV3YXJlL3F1ZXJ5Jyk7XG5leHBvcnRzLnN0YXRpYyA9IHJlcXVpcmUoJ3NlcnZlLXN0YXRpYycpO1xuZXhwb3J0cy51cmxlbmNvZGVkID0gYm9keVBhcnNlci51cmxlbmNvZGVkXG5cbi8qKlxuICogUmVwbGFjZSByZW1vdmVkIG1pZGRsZXdhcmUgd2l0aCBhbiBhcHByb3ByaWF0ZSBlcnJvciBtZXNzYWdlLlxuICovXG5cbnZhciByZW1vdmVkTWlkZGxld2FyZXMgPSBbXG4gICdib2R5UGFyc2VyJyxcbiAgJ2NvbXByZXNzJyxcbiAgJ2Nvb2tpZVNlc3Npb24nLFxuICAnc2Vzc2lvbicsXG4gICdsb2dnZXInLFxuICAnY29va2llUGFyc2VyJyxcbiAgJ2Zhdmljb24nLFxuICAncmVzcG9uc2VUaW1lJyxcbiAgJ2Vycm9ySGFuZGxlcicsXG4gICd0aW1lb3V0JyxcbiAgJ21ldGhvZE92ZXJyaWRlJyxcbiAgJ3Zob3N0JyxcbiAgJ2NzcmYnLFxuICAnZGlyZWN0b3J5JyxcbiAgJ2xpbWl0JyxcbiAgJ211bHRpcGFydCcsXG4gICdzdGF0aWNDYWNoZSdcbl1cblxucmVtb3ZlZE1pZGRsZXdhcmVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTW9zdCBtaWRkbGV3YXJlIChsaWtlICcgKyBuYW1lICsgJykgaXMgbm8gbG9uZ2VyIGJ1bmRsZWQgd2l0aCBFeHByZXNzIGFuZCBtdXN0IGJlIGluc3RhbGxlZCBzZXBhcmF0ZWx5LiBQbGVhc2Ugc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zZW5jaGFsYWJzL2Nvbm5lY3QjbWlkZGxld2FyZS4nKTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZXhwcmVzcy9saWIvZXhwcmVzcy5qc1xuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBib2R5LXBhcnNlclxuICogQ29weXJpZ2h0KGMpIDIwMTQtMjAxNSBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIGRlcHJlY2F0ZSA9IHJlcXVpcmUoJ2RlcGQnKSgnYm9keS1wYXJzZXInKVxuXG4vKipcbiAqIENhY2hlIG9mIGxvYWRlZCBwYXJzZXJzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgcGFyc2VycyA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuLyoqXG4gKiBAdHlwZWRlZiBQYXJzZXJzXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBqc29uXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSByYXdcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHRleHRcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHVybGVuY29kZWRcbiAqL1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHR5cGUge1BhcnNlcnN9XG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlLmZ1bmN0aW9uKGJvZHlQYXJzZXIsXG4gICdib2R5UGFyc2VyOiB1c2UgaW5kaXZpZHVhbCBqc29uL3VybGVuY29kZWQgbWlkZGxld2FyZXMnKVxuXG4vKipcbiAqIEpTT04gcGFyc2VyLlxuICogQHB1YmxpY1xuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnanNvbicsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGNyZWF0ZVBhcnNlckdldHRlcignanNvbicpXG59KVxuXG4vKipcbiAqIFJhdyBwYXJzZXIuXG4gKiBAcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdyYXcnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBjcmVhdGVQYXJzZXJHZXR0ZXIoJ3JhdycpXG59KVxuXG4vKipcbiAqIFRleHQgcGFyc2VyLlxuICogQHB1YmxpY1xuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAndGV4dCcsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGNyZWF0ZVBhcnNlckdldHRlcigndGV4dCcpXG59KVxuXG4vKipcbiAqIFVSTC1lbmNvZGVkIHBhcnNlci5cbiAqIEBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3VybGVuY29kZWQnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBjcmVhdGVQYXJzZXJHZXR0ZXIoJ3VybGVuY29kZWQnKVxufSlcblxuLyoqXG4gKiBDcmVhdGUgYSBtaWRkbGV3YXJlIHRvIHBhcnNlIGpzb24gYW5kIHVybGVuY29kZWQgYm9kaWVzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICogQGRlcHJlY2F0ZWRcbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBib2R5UGFyc2VyIChvcHRpb25zKSB7XG4gIHZhciBvcHRzID0ge31cblxuICAvLyBleGNsdWRlIHR5cGUgb3B0aW9uXG4gIGlmIChvcHRpb25zKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAocHJvcCAhPT0gJ3R5cGUnKSB7XG4gICAgICAgIG9wdHNbcHJvcF0gPSBvcHRpb25zW3Byb3BdXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIF91cmxlbmNvZGVkID0gZXhwb3J0cy51cmxlbmNvZGVkKG9wdHMpXG4gIHZhciBfanNvbiA9IGV4cG9ydHMuanNvbihvcHRzKVxuXG4gIHJldHVybiBmdW5jdGlvbiBib2R5UGFyc2VyIChyZXEsIHJlcywgbmV4dCkge1xuICAgIF9qc29uKHJlcSwgcmVzLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gbmV4dChlcnIpXG4gICAgICBfdXJsZW5jb2RlZChyZXEsIHJlcywgbmV4dClcbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZ2V0dGVyIGZvciBsb2FkaW5nIGEgcGFyc2VyLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVQYXJzZXJHZXR0ZXIgKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgcmV0dXJuIGxvYWRQYXJzZXIobmFtZSlcbiAgfVxufVxuXG4vKipcbiAqIExvYWQgYSBwYXJzZXIgbW9kdWxlLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkUGFyc2VyIChwYXJzZXJOYW1lKSB7XG4gIHZhciBwYXJzZXIgPSBwYXJzZXJzW3BhcnNlck5hbWVdXG5cbiAgaWYgKHBhcnNlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHBhcnNlclxuICB9XG5cbiAgLy8gdGhpcyB1c2VzIGEgc3dpdGNoIGZvciBzdGF0aWMgcmVxdWlyZSBhbmFseXNpc1xuICBzd2l0Y2ggKHBhcnNlck5hbWUpIHtcbiAgICBjYXNlICdqc29uJzpcbiAgICAgIHBhcnNlciA9IHJlcXVpcmUoJy4vbGliL3R5cGVzL2pzb24nKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdyYXcnOlxuICAgICAgcGFyc2VyID0gcmVxdWlyZSgnLi9saWIvdHlwZXMvcmF3JylcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndGV4dCc6XG4gICAgICBwYXJzZXIgPSByZXF1aXJlKCcuL2xpYi90eXBlcy90ZXh0JylcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXJsZW5jb2RlZCc6XG4gICAgICBwYXJzZXIgPSByZXF1aXJlKCcuL2xpYi90eXBlcy91cmxlbmNvZGVkJylcbiAgICAgIGJyZWFrXG4gIH1cblxuICAvLyBzdG9yZSB0byBwcmV2ZW50IGludm9raW5nIHJlcXVpcmUoKVxuICByZXR1cm4gKHBhcnNlcnNbcGFyc2VyTmFtZV0gPSBwYXJzZXIpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9ib2R5LXBhcnNlci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBkZXBkXG4gKiBDb3B5cmlnaHQoYykgMjAxNCBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBjYWxsU2l0ZVRvU3RyaW5nXG5cbi8qKlxuICogRm9ybWF0IGEgQ2FsbFNpdGUgZmlsZSBsb2NhdGlvbiB0byBhIHN0cmluZy5cbiAqL1xuXG5mdW5jdGlvbiBjYWxsU2l0ZUZpbGVMb2NhdGlvbiAoY2FsbFNpdGUpIHtcbiAgdmFyIGZpbGVOYW1lXG4gIHZhciBmaWxlTG9jYXRpb24gPSAnJ1xuXG4gIGlmIChjYWxsU2l0ZS5pc05hdGl2ZSgpKSB7XG4gICAgZmlsZUxvY2F0aW9uID0gJ25hdGl2ZSdcbiAgfSBlbHNlIGlmIChjYWxsU2l0ZS5pc0V2YWwoKSkge1xuICAgIGZpbGVOYW1lID0gY2FsbFNpdGUuZ2V0U2NyaXB0TmFtZU9yU291cmNlVVJMKClcbiAgICBpZiAoIWZpbGVOYW1lKSB7XG4gICAgICBmaWxlTG9jYXRpb24gPSBjYWxsU2l0ZS5nZXRFdmFsT3JpZ2luKClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZmlsZU5hbWUgPSBjYWxsU2l0ZS5nZXRGaWxlTmFtZSgpXG4gIH1cblxuICBpZiAoZmlsZU5hbWUpIHtcbiAgICBmaWxlTG9jYXRpb24gKz0gZmlsZU5hbWVcblxuICAgIHZhciBsaW5lTnVtYmVyID0gY2FsbFNpdGUuZ2V0TGluZU51bWJlcigpXG4gICAgaWYgKGxpbmVOdW1iZXIgIT0gbnVsbCkge1xuICAgICAgZmlsZUxvY2F0aW9uICs9ICc6JyArIGxpbmVOdW1iZXJcblxuICAgICAgdmFyIGNvbHVtbk51bWJlciA9IGNhbGxTaXRlLmdldENvbHVtbk51bWJlcigpXG4gICAgICBpZiAoY29sdW1uTnVtYmVyKSB7XG4gICAgICAgIGZpbGVMb2NhdGlvbiArPSAnOicgKyBjb2x1bW5OdW1iZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmlsZUxvY2F0aW9uIHx8ICd1bmtub3duIHNvdXJjZSdcbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBDYWxsU2l0ZSB0byBhIHN0cmluZy5cbiAqL1xuXG5mdW5jdGlvbiBjYWxsU2l0ZVRvU3RyaW5nIChjYWxsU2l0ZSkge1xuICB2YXIgYWRkU3VmZml4ID0gdHJ1ZVxuICB2YXIgZmlsZUxvY2F0aW9uID0gY2FsbFNpdGVGaWxlTG9jYXRpb24oY2FsbFNpdGUpXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBjYWxsU2l0ZS5nZXRGdW5jdGlvbk5hbWUoKVxuICB2YXIgaXNDb25zdHJ1Y3RvciA9IGNhbGxTaXRlLmlzQ29uc3RydWN0b3IoKVxuICB2YXIgaXNNZXRob2RDYWxsID0gIShjYWxsU2l0ZS5pc1RvcGxldmVsKCkgfHwgaXNDb25zdHJ1Y3RvcilcbiAgdmFyIGxpbmUgPSAnJ1xuXG4gIGlmIChpc01ldGhvZENhbGwpIHtcbiAgICB2YXIgbWV0aG9kTmFtZSA9IGNhbGxTaXRlLmdldE1ldGhvZE5hbWUoKVxuICAgIHZhciB0eXBlTmFtZSA9IGdldENvbnN0cnVjdG9yTmFtZShjYWxsU2l0ZSlcblxuICAgIGlmIChmdW5jdGlvbk5hbWUpIHtcbiAgICAgIGlmICh0eXBlTmFtZSAmJiBmdW5jdGlvbk5hbWUuaW5kZXhPZih0eXBlTmFtZSkgIT09IDApIHtcbiAgICAgICAgbGluZSArPSB0eXBlTmFtZSArICcuJ1xuICAgICAgfVxuXG4gICAgICBsaW5lICs9IGZ1bmN0aW9uTmFtZVxuXG4gICAgICBpZiAobWV0aG9kTmFtZSAmJiBmdW5jdGlvbk5hbWUubGFzdEluZGV4T2YoJy4nICsgbWV0aG9kTmFtZSkgIT09IGZ1bmN0aW9uTmFtZS5sZW5ndGggLSBtZXRob2ROYW1lLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgbGluZSArPSAnIFthcyAnICsgbWV0aG9kTmFtZSArICddJ1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lICs9IHR5cGVOYW1lICsgJy4nICsgKG1ldGhvZE5hbWUgfHwgJzxhbm9ueW1vdXM+JylcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNDb25zdHJ1Y3Rvcikge1xuICAgIGxpbmUgKz0gJ25ldyAnICsgKGZ1bmN0aW9uTmFtZSB8fCAnPGFub255bW91cz4nKVxuICB9IGVsc2UgaWYgKGZ1bmN0aW9uTmFtZSkge1xuICAgIGxpbmUgKz0gZnVuY3Rpb25OYW1lXG4gIH0gZWxzZSB7XG4gICAgYWRkU3VmZml4ID0gZmFsc2VcbiAgICBsaW5lICs9IGZpbGVMb2NhdGlvblxuICB9XG5cbiAgaWYgKGFkZFN1ZmZpeCkge1xuICAgIGxpbmUgKz0gJyAoJyArIGZpbGVMb2NhdGlvbiArICcpJ1xuICB9XG5cbiAgcmV0dXJuIGxpbmVcbn1cblxuLyoqXG4gKiBHZXQgY29uc3RydWN0b3IgbmFtZSBvZiByZXZpdmVyLlxuICovXG5cbmZ1bmN0aW9uIGdldENvbnN0cnVjdG9yTmFtZSAob2JqKSB7XG4gIHZhciByZWNlaXZlciA9IG9iai5yZWNlaXZlclxuICByZXR1cm4gKHJlY2VpdmVyLmNvbnN0cnVjdG9yICYmIHJlY2VpdmVyLmNvbnN0cnVjdG9yLm5hbWUpIHx8IG51bGxcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RlcGQvbGliL2NvbXBhdC9jYWxsc2l0ZS10b3N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBkZXBkXG4gKiBDb3B5cmlnaHQoYykgMjAxNSBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBldmVudExpc3RlbmVyQ291bnRcblxuLyoqXG4gKiBHZXQgdGhlIGNvdW50IG9mIGxpc3RlbmVycyBvbiBhbiBldmVudCBlbWl0dGVyIG9mIGEgc3BlY2lmaWMgdHlwZS5cbiAqL1xuXG5mdW5jdGlvbiBldmVudExpc3RlbmVyQ291bnQgKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aFxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZGVwZC9saWIvY29tcGF0L2V2ZW50LWxpc3RlbmVyLWNvdW50LmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGJvZHktcGFyc2VyXG4gKiBDb3B5cmlnaHQoYykgMjAxNCBKb25hdGhhbiBPbmdcbiAqIENvcHlyaWdodChjKSAyMDE0LTIwMTUgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBieXRlcyA9IHJlcXVpcmUoJ2J5dGVzJylcbnZhciBjb250ZW50VHlwZSA9IHJlcXVpcmUoJ2NvbnRlbnQtdHlwZScpXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCdodHRwLWVycm9ycycpXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdib2R5LXBhcnNlcjpqc29uJylcbnZhciByZWFkID0gcmVxdWlyZSgnLi4vcmVhZCcpXG52YXIgdHlwZWlzID0gcmVxdWlyZSgndHlwZS1pcycpXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBqc29uXG5cbi8qKlxuICogUmVnRXhwIHRvIG1hdGNoIHRoZSBmaXJzdCBub24tc3BhY2UgaW4gYSBzdHJpbmcuXG4gKlxuICogQWxsb3dlZCB3aGl0ZXNwYWNlIGlzIGRlZmluZWQgaW4gUkZDIDcxNTk6XG4gKlxuICogICAgd3MgPSAqKFxuICogICAgICAgICAgICAleDIwIC8gICAgICAgICAgICAgIDsgU3BhY2VcbiAqICAgICAgICAgICAgJXgwOSAvICAgICAgICAgICAgICA7IEhvcml6b250YWwgdGFiXG4gKiAgICAgICAgICAgICV4MEEgLyAgICAgICAgICAgICAgOyBMaW5lIGZlZWQgb3IgTmV3IGxpbmVcbiAqICAgICAgICAgICAgJXgwRCApICAgICAgICAgICAgICA7IENhcnJpYWdlIHJldHVyblxuICovXG5cbnZhciBGSVJTVF9DSEFSX1JFR0VYUCA9IC9eW1xceDIwXFx4MDlcXHgwYVxceDBkXSooLikvIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udHJvbC1yZWdleFxuXG4vKipcbiAqIENyZWF0ZSBhIG1pZGRsZXdhcmUgdG8gcGFyc2UgSlNPTiBib2RpZXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24ganNvbiAob3B0aW9ucykge1xuICB2YXIgb3B0cyA9IG9wdGlvbnMgfHwge31cblxuICB2YXIgbGltaXQgPSB0eXBlb2Ygb3B0cy5saW1pdCAhPT0gJ251bWJlcidcbiAgICA/IGJ5dGVzLnBhcnNlKG9wdHMubGltaXQgfHwgJzEwMGtiJylcbiAgICA6IG9wdHMubGltaXRcbiAgdmFyIGluZmxhdGUgPSBvcHRzLmluZmxhdGUgIT09IGZhbHNlXG4gIHZhciByZXZpdmVyID0gb3B0cy5yZXZpdmVyXG4gIHZhciBzdHJpY3QgPSBvcHRzLnN0cmljdCAhPT0gZmFsc2VcbiAgdmFyIHR5cGUgPSBvcHRzLnR5cGUgfHwgJ2FwcGxpY2F0aW9uL2pzb24nXG4gIHZhciB2ZXJpZnkgPSBvcHRzLnZlcmlmeSB8fCBmYWxzZVxuXG4gIGlmICh2ZXJpZnkgIT09IGZhbHNlICYmIHR5cGVvZiB2ZXJpZnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gdmVyaWZ5IG11c3QgYmUgZnVuY3Rpb24nKVxuICB9XG5cbiAgLy8gY3JlYXRlIHRoZSBhcHByb3ByaWF0ZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9uXG4gIHZhciBzaG91bGRQYXJzZSA9IHR5cGVvZiB0eXBlICE9PSAnZnVuY3Rpb24nXG4gICAgPyB0eXBlQ2hlY2tlcih0eXBlKVxuICAgIDogdHlwZVxuXG4gIGZ1bmN0aW9uIHBhcnNlIChib2R5KSB7XG4gICAgaWYgKGJvZHkubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBzcGVjaWFsLWNhc2UgZW1wdHkganNvbiBib2R5LCBhcyBpdCdzIGEgY29tbW9uIGNsaWVudC1zaWRlIG1pc3Rha2VcbiAgICAgIC8vIFRPRE86IG1heWJlIG1ha2UgdGhpcyBjb25maWd1cmFibGUgb3IgcGFydCBvZiBcInN0cmljdFwiIG9wdGlvblxuICAgICAgcmV0dXJuIHt9XG4gICAgfVxuXG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgdmFyIGZpcnN0ID0gZmlyc3RjaGFyKGJvZHkpXG5cbiAgICAgIGlmIChmaXJzdCAhPT0gJ3snICYmIGZpcnN0ICE9PSAnWycpIHtcbiAgICAgICAgZGVidWcoJ3N0cmljdCB2aW9sYXRpb24nKVxuICAgICAgICB0aHJvdyBjcmVhdGVTdHJpY3RTeW50YXhFcnJvcihib2R5LCBmaXJzdClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgZGVidWcoJ3BhcnNlIGpzb24nKVxuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoYm9keSwgcmV2aXZlcilcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBub3JtYWxpemVKc29uU3ludGF4RXJyb3IoZSwge1xuICAgICAgICBtZXNzYWdlOiBlLm1lc3NhZ2UsXG4gICAgICAgIHN0YWNrOiBlLnN0YWNrXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBqc29uUGFyc2VyIChyZXEsIHJlcywgbmV4dCkge1xuICAgIGlmIChyZXEuX2JvZHkpIHtcbiAgICAgIGRlYnVnKCdib2R5IGFscmVhZHkgcGFyc2VkJylcbiAgICAgIG5leHQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgcmVxLmJvZHkgPSByZXEuYm9keSB8fCB7fVxuXG4gICAgLy8gc2tpcCByZXF1ZXN0cyB3aXRob3V0IGJvZGllc1xuICAgIGlmICghdHlwZWlzLmhhc0JvZHkocmVxKSkge1xuICAgICAgZGVidWcoJ3NraXAgZW1wdHkgYm9keScpXG4gICAgICBuZXh0KClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGRlYnVnKCdjb250ZW50LXR5cGUgJWonLCByZXEuaGVhZGVyc1snY29udGVudC10eXBlJ10pXG5cbiAgICAvLyBkZXRlcm1pbmUgaWYgcmVxdWVzdCBzaG91bGQgYmUgcGFyc2VkXG4gICAgaWYgKCFzaG91bGRQYXJzZShyZXEpKSB7XG4gICAgICBkZWJ1Zygnc2tpcCBwYXJzaW5nJylcbiAgICAgIG5leHQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gYXNzZXJ0IGNoYXJzZXQgcGVyIFJGQyA3MTU5IHNlYyA4LjFcbiAgICB2YXIgY2hhcnNldCA9IGdldENoYXJzZXQocmVxKSB8fCAndXRmLTgnXG4gICAgaWYgKGNoYXJzZXQuc3Vic3RyKDAsIDQpICE9PSAndXRmLScpIHtcbiAgICAgIGRlYnVnKCdpbnZhbGlkIGNoYXJzZXQnKVxuICAgICAgbmV4dChjcmVhdGVFcnJvcig0MTUsICd1bnN1cHBvcnRlZCBjaGFyc2V0IFwiJyArIGNoYXJzZXQudG9VcHBlckNhc2UoKSArICdcIicsIHtcbiAgICAgICAgY2hhcnNldDogY2hhcnNldCxcbiAgICAgICAgdHlwZTogJ2NoYXJzZXQudW5zdXBwb3J0ZWQnXG4gICAgICB9KSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHJlYWRcbiAgICByZWFkKHJlcSwgcmVzLCBuZXh0LCBwYXJzZSwgZGVidWcsIHtcbiAgICAgIGVuY29kaW5nOiBjaGFyc2V0LFxuICAgICAgaW5mbGF0ZTogaW5mbGF0ZSxcbiAgICAgIGxpbWl0OiBsaW1pdCxcbiAgICAgIHZlcmlmeTogdmVyaWZ5XG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBzdHJpY3QgdmlvbGF0aW9uIHN5bnRheCBlcnJvciBtYXRjaGluZyBuYXRpdmUgZXJyb3IuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtzdHJpbmd9IGNoYXJcbiAqIEByZXR1cm4ge0Vycm9yfVxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVTdHJpY3RTeW50YXhFcnJvciAoc3RyLCBjaGFyKSB7XG4gIHZhciBpbmRleCA9IHN0ci5pbmRleE9mKGNoYXIpXG4gIHZhciBwYXJ0aWFsID0gc3RyLnN1YnN0cmluZygwLCBpbmRleCkgKyAnIydcblxuICB0cnkge1xuICAgIEpTT04ucGFyc2UocGFydGlhbCk7IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHRocm93IG5ldyBTeW50YXhFcnJvcignc3RyaWN0IHZpb2xhdGlvbicpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplSnNvblN5bnRheEVycm9yKGUsIHtcbiAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZS5yZXBsYWNlKCcjJywgY2hhciksXG4gICAgICBzdGFjazogZS5zdGFja1xuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZpcnN0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlciBpbiBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZmlyc3RjaGFyIChzdHIpIHtcbiAgcmV0dXJuIEZJUlNUX0NIQVJfUkVHRVhQLmV4ZWMoc3RyKVsxXVxufVxuXG4vKipcbiAqIEdldCB0aGUgY2hhcnNldCBvZiBhIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHJlcVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZ2V0Q2hhcnNldCAocmVxKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIChjb250ZW50VHlwZS5wYXJzZShyZXEpLnBhcmFtZXRlcnMuY2hhcnNldCB8fCAnJykudG9Mb3dlckNhc2UoKVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgU3ludGF4RXJyb3IgZm9yIEpTT04ucGFyc2UuXG4gKlxuICogQHBhcmFtIHtTeW50YXhFcnJvcn0gZXJyb3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge1N5bnRheEVycm9yfVxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUpzb25TeW50YXhFcnJvciAoZXJyb3IsIG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVycm9yKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldXG4gICAgaWYgKGtleSAhPT0gJ3N0YWNrJyAmJiBrZXkgIT09ICdtZXNzYWdlJykge1xuICAgICAgZGVsZXRlIGVycm9yW2tleV1cbiAgICB9XG4gIH1cblxuICAvLyByZXBsYWNlIHN0YWNrIGJlZm9yZSBtZXNzYWdlIGZvciBOb2RlLmpzIDAuMTAgYW5kIGJlbG93XG4gIGVycm9yLnN0YWNrID0gb2JqLnN0YWNrLnJlcGxhY2UoZXJyb3IubWVzc2FnZSwgb2JqLm1lc3NhZ2UpXG4gIGVycm9yLm1lc3NhZ2UgPSBvYmoubWVzc2FnZVxuXG4gIHJldHVybiBlcnJvclxufVxuXG4vKipcbiAqIEdldCB0aGUgc2ltcGxlIHR5cGUgY2hlY2tlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gdHlwZUNoZWNrZXIgKHR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNoZWNrVHlwZSAocmVxKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odHlwZWlzKHJlcSwgdHlwZSkpXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JvZHktcGFyc2VyL2xpYi90eXBlcy9qc29uLmpzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcIjEwMFwiOlwiQ29udGludWVcIixcIjEwMVwiOlwiU3dpdGNoaW5nIFByb3RvY29sc1wiLFwiMTAyXCI6XCJQcm9jZXNzaW5nXCIsXCIyMDBcIjpcIk9LXCIsXCIyMDFcIjpcIkNyZWF0ZWRcIixcIjIwMlwiOlwiQWNjZXB0ZWRcIixcIjIwM1wiOlwiTm9uLUF1dGhvcml0YXRpdmUgSW5mb3JtYXRpb25cIixcIjIwNFwiOlwiTm8gQ29udGVudFwiLFwiMjA1XCI6XCJSZXNldCBDb250ZW50XCIsXCIyMDZcIjpcIlBhcnRpYWwgQ29udGVudFwiLFwiMjA3XCI6XCJNdWx0aS1TdGF0dXNcIixcIjIwOFwiOlwiQWxyZWFkeSBSZXBvcnRlZFwiLFwiMjI2XCI6XCJJTSBVc2VkXCIsXCIzMDBcIjpcIk11bHRpcGxlIENob2ljZXNcIixcIjMwMVwiOlwiTW92ZWQgUGVybWFuZW50bHlcIixcIjMwMlwiOlwiRm91bmRcIixcIjMwM1wiOlwiU2VlIE90aGVyXCIsXCIzMDRcIjpcIk5vdCBNb2RpZmllZFwiLFwiMzA1XCI6XCJVc2UgUHJveHlcIixcIjMwNlwiOlwiKFVudXNlZClcIixcIjMwN1wiOlwiVGVtcG9yYXJ5IFJlZGlyZWN0XCIsXCIzMDhcIjpcIlBlcm1hbmVudCBSZWRpcmVjdFwiLFwiNDAwXCI6XCJCYWQgUmVxdWVzdFwiLFwiNDAxXCI6XCJVbmF1dGhvcml6ZWRcIixcIjQwMlwiOlwiUGF5bWVudCBSZXF1aXJlZFwiLFwiNDAzXCI6XCJGb3JiaWRkZW5cIixcIjQwNFwiOlwiTm90IEZvdW5kXCIsXCI0MDVcIjpcIk1ldGhvZCBOb3QgQWxsb3dlZFwiLFwiNDA2XCI6XCJOb3QgQWNjZXB0YWJsZVwiLFwiNDA3XCI6XCJQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiLFwiNDA4XCI6XCJSZXF1ZXN0IFRpbWVvdXRcIixcIjQwOVwiOlwiQ29uZmxpY3RcIixcIjQxMFwiOlwiR29uZVwiLFwiNDExXCI6XCJMZW5ndGggUmVxdWlyZWRcIixcIjQxMlwiOlwiUHJlY29uZGl0aW9uIEZhaWxlZFwiLFwiNDEzXCI6XCJQYXlsb2FkIFRvbyBMYXJnZVwiLFwiNDE0XCI6XCJVUkkgVG9vIExvbmdcIixcIjQxNVwiOlwiVW5zdXBwb3J0ZWQgTWVkaWEgVHlwZVwiLFwiNDE2XCI6XCJSYW5nZSBOb3QgU2F0aXNmaWFibGVcIixcIjQxN1wiOlwiRXhwZWN0YXRpb24gRmFpbGVkXCIsXCI0MThcIjpcIkknbSBhIHRlYXBvdFwiLFwiNDIxXCI6XCJNaXNkaXJlY3RlZCBSZXF1ZXN0XCIsXCI0MjJcIjpcIlVucHJvY2Vzc2FibGUgRW50aXR5XCIsXCI0MjNcIjpcIkxvY2tlZFwiLFwiNDI0XCI6XCJGYWlsZWQgRGVwZW5kZW5jeVwiLFwiNDI1XCI6XCJVbm9yZGVyZWQgQ29sbGVjdGlvblwiLFwiNDI2XCI6XCJVcGdyYWRlIFJlcXVpcmVkXCIsXCI0MjhcIjpcIlByZWNvbmRpdGlvbiBSZXF1aXJlZFwiLFwiNDI5XCI6XCJUb28gTWFueSBSZXF1ZXN0c1wiLFwiNDMxXCI6XCJSZXF1ZXN0IEhlYWRlciBGaWVsZHMgVG9vIExhcmdlXCIsXCI0NTFcIjpcIlVuYXZhaWxhYmxlIEZvciBMZWdhbCBSZWFzb25zXCIsXCI1MDBcIjpcIkludGVybmFsIFNlcnZlciBFcnJvclwiLFwiNTAxXCI6XCJOb3QgSW1wbGVtZW50ZWRcIixcIjUwMlwiOlwiQmFkIEdhdGV3YXlcIixcIjUwM1wiOlwiU2VydmljZSBVbmF2YWlsYWJsZVwiLFwiNTA0XCI6XCJHYXRld2F5IFRpbWVvdXRcIixcIjUwNVwiOlwiSFRUUCBWZXJzaW9uIE5vdCBTdXBwb3J0ZWRcIixcIjUwNlwiOlwiVmFyaWFudCBBbHNvIE5lZ290aWF0ZXNcIixcIjUwN1wiOlwiSW5zdWZmaWNpZW50IFN0b3JhZ2VcIixcIjUwOFwiOlwiTG9vcCBEZXRlY3RlZFwiLFwiNTA5XCI6XCJCYW5kd2lkdGggTGltaXQgRXhjZWVkZWRcIixcIjUxMFwiOlwiTm90IEV4dGVuZGVkXCIsXCI1MTFcIjpcIk5ldHdvcmsgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcIn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zdGF0dXNlcy9jb2Rlcy5qc29uXG4vLyBtb2R1bGUgaWQgPSA4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ0cnkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbiAgaWYgKHR5cGVvZiB1dGlsLmluaGVyaXRzICE9PSAnZnVuY3Rpb24nKSB0aHJvdyAnJztcbiAgbW9kdWxlLmV4cG9ydHMgPSB1dGlsLmluaGVyaXRzO1xufSBjYXRjaCAoZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaW5oZXJpdHNfYnJvd3Nlci5qcycpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHMuanNcbi8vIG1vZHVsZSBpZCA9IDg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcbiAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBOb2RlLmpzIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5pbml0ID0gaW5pdDtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gWzYsIDIsIDMsIDQsIDUsIDFdO1xuXG4vKipcbiAqIEJ1aWxkIHVwIHRoZSBkZWZhdWx0IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiAgICQgREVCVUdfQ09MT1JTPW5vIERFQlVHX0RFUFRIPTEwIERFQlVHX1NIT1dfSElEREVOPWVuYWJsZWQgbm9kZSBzY3JpcHQuanNcbiAqL1xuXG5leHBvcnRzLmluc3BlY3RPcHRzID0gT2JqZWN0LmtleXMocHJvY2Vzcy5lbnYpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAvXmRlYnVnXy9pLnRlc3Qoa2V5KTtcbn0pLnJlZHVjZShmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgLy8gY2FtZWwtY2FzZVxuICB2YXIgcHJvcCA9IGtleVxuICAgIC5zdWJzdHJpbmcoNilcbiAgICAudG9Mb3dlckNhc2UoKVxuICAgIC5yZXBsYWNlKC9fKFthLXpdKS9nLCBmdW5jdGlvbiAoXywgaykgeyByZXR1cm4gay50b1VwcGVyQ2FzZSgpIH0pO1xuXG4gIC8vIGNvZXJjZSBzdHJpbmcgdmFsdWUgaW50byBKUyB2YWx1ZVxuICB2YXIgdmFsID0gcHJvY2Vzcy5lbnZba2V5XTtcbiAgaWYgKC9eKHllc3xvbnx0cnVlfGVuYWJsZWQpJC9pLnRlc3QodmFsKSkgdmFsID0gdHJ1ZTtcbiAgZWxzZSBpZiAoL14obm98b2ZmfGZhbHNlfGRpc2FibGVkKSQvaS50ZXN0KHZhbCkpIHZhbCA9IGZhbHNlO1xuICBlbHNlIGlmICh2YWwgPT09ICdudWxsJykgdmFsID0gbnVsbDtcbiAgZWxzZSB2YWwgPSBOdW1iZXIodmFsKTtcblxuICBvYmpbcHJvcF0gPSB2YWw7XG4gIHJldHVybiBvYmo7XG59LCB7fSk7XG5cbi8qKlxuICogVGhlIGZpbGUgZGVzY3JpcHRvciB0byB3cml0ZSB0aGUgYGRlYnVnKClgIGNhbGxzIHRvLlxuICogU2V0IHRoZSBgREVCVUdfRkRgIGVudiB2YXJpYWJsZSB0byBvdmVycmlkZSB3aXRoIGFub3RoZXIgdmFsdWUuIGkuZS46XG4gKlxuICogICAkIERFQlVHX0ZEPTMgbm9kZSBzY3JpcHQuanMgMz5kZWJ1Zy5sb2dcbiAqL1xuXG52YXIgZmQgPSBwYXJzZUludChwcm9jZXNzLmVudi5ERUJVR19GRCwgMTApIHx8IDI7XG5cbmlmICgxICE9PSBmZCAmJiAyICE9PSBmZCkge1xuICB1dGlsLmRlcHJlY2F0ZShmdW5jdGlvbigpe30sICdleGNlcHQgZm9yIHN0ZGVycigyKSBhbmQgc3Rkb3V0KDEpLCBhbnkgb3RoZXIgdXNhZ2Ugb2YgREVCVUdfRkQgaXMgZGVwcmVjYXRlZC4gT3ZlcnJpZGUgZGVidWcubG9nIGlmIHlvdSB3YW50IHRvIHVzZSBhIGRpZmZlcmVudCBsb2cgZnVuY3Rpb24gKGh0dHBzOi8vZ2l0LmlvL2RlYnVnX2ZkKScpKClcbn1cblxudmFyIHN0cmVhbSA9IDEgPT09IGZkID8gcHJvY2Vzcy5zdGRvdXQgOlxuICAgICAgICAgICAgIDIgPT09IGZkID8gcHJvY2Vzcy5zdGRlcnIgOlxuICAgICAgICAgICAgIGNyZWF0ZVdyaXRhYmxlU3RkaW9TdHJlYW0oZmQpO1xuXG4vKipcbiAqIElzIHN0ZG91dCBhIFRUWT8gQ29sb3JlZCBvdXRwdXQgaXMgZW5hYmxlZCB3aGVuIGB0cnVlYC5cbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIHJldHVybiAnY29sb3JzJyBpbiBleHBvcnRzLmluc3BlY3RPcHRzXG4gICAgPyBCb29sZWFuKGV4cG9ydHMuaW5zcGVjdE9wdHMuY29sb3JzKVxuICAgIDogdHR5LmlzYXR0eShmZCk7XG59XG5cbi8qKlxuICogTWFwICVvIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbCBvbiBhIHNpbmdsZSBsaW5lLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5vID0gZnVuY3Rpb24odikge1xuICB0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuICByZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpXG4gICAgLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnRyaW0oKVxuICAgIH0pLmpvaW4oJyAnKTtcbn07XG5cbi8qKlxuICogTWFwICVvIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbG93aW5nIG11bHRpcGxlIGxpbmVzIGlmIG5lZWRlZC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuTyA9IGZ1bmN0aW9uKHYpIHtcbiAgdGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcbiAgcmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKTtcbn07XG5cbi8qKlxuICogQWRkcyBBTlNJIGNvbG9yIGVzY2FwZSBjb2RlcyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciBuYW1lID0gdGhpcy5uYW1lc3BhY2U7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBpZiAodXNlQ29sb3JzKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNvbG9yO1xuICAgIHZhciBwcmVmaXggPSAnICBcXHUwMDFiWzMnICsgYyArICc7MW0nICsgbmFtZSArICcgJyArICdcXHUwMDFiWzBtJztcblxuICAgIGFyZ3NbMF0gPSBwcmVmaXggKyBhcmdzWzBdLnNwbGl0KCdcXG4nKS5qb2luKCdcXG4nICsgcHJlZml4KTtcbiAgICBhcmdzLnB1c2goJ1xcdTAwMWJbMycgKyBjICsgJ20rJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKSArICdcXHUwMDFiWzBtJyk7XG4gIH0gZWxzZSB7XG4gICAgYXJnc1swXSA9IG5ldyBEYXRlKCkudG9VVENTdHJpbmcoKVxuICAgICAgKyAnICcgKyBuYW1lICsgJyAnICsgYXJnc1swXTtcbiAgfVxufVxuXG4vKipcbiAqIEludm9rZXMgYHV0aWwuZm9ybWF0KClgIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMgYW5kIHdyaXRlcyB0byBgc3RyZWFtYC5cbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIHJldHVybiBzdHJlYW0ud3JpdGUodXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgYXJndW1lbnRzKSArICdcXG4nKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAvLyBJZiB5b3Ugc2V0IGEgcHJvY2Vzcy5lbnYgZmllbGQgdG8gbnVsbCBvciB1bmRlZmluZWQsIGl0IGdldHMgY2FzdCB0byB0aGVcbiAgICAvLyBzdHJpbmcgJ251bGwnIG9yICd1bmRlZmluZWQnLiBKdXN0IGRlbGV0ZSBpbnN0ZWFkLlxuICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLmVudi5ERUJVRyA9IG5hbWVzcGFjZXM7XG4gIH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuREVCVUc7XG59XG5cbi8qKlxuICogQ29waWVkIGZyb20gYG5vZGUvc3JjL25vZGUuanNgLlxuICpcbiAqIFhYWDogSXQncyBsYW1lIHRoYXQgbm9kZSBkb2Vzbid0IGV4cG9zZSB0aGlzIEFQSSBvdXQtb2YtdGhlLWJveC4gSXQgYWxzb1xuICogcmVsaWVzIG9uIHRoZSB1bmRvY3VtZW50ZWQgYHR0eV93cmFwLmd1ZXNzSGFuZGxlVHlwZSgpYCB3aGljaCBpcyBhbHNvIGxhbWUuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlV3JpdGFibGVTdGRpb1N0cmVhbSAoZmQpIHtcbiAgdmFyIHN0cmVhbTtcbiAgdmFyIHR0eV93cmFwID0gcHJvY2Vzcy5iaW5kaW5nKCd0dHlfd3JhcCcpO1xuXG4gIC8vIE5vdGUgc3RyZWFtLl90eXBlIGlzIHVzZWQgZm9yIHRlc3QtbW9kdWxlLWxvYWQtbGlzdC5qc1xuXG4gIHN3aXRjaCAodHR5X3dyYXAuZ3Vlc3NIYW5kbGVUeXBlKGZkKSkge1xuICAgIGNhc2UgJ1RUWSc6XG4gICAgICBzdHJlYW0gPSBuZXcgdHR5LldyaXRlU3RyZWFtKGZkKTtcbiAgICAgIHN0cmVhbS5fdHlwZSA9ICd0dHknO1xuXG4gICAgICAvLyBIYWNrIHRvIGhhdmUgc3RyZWFtIG5vdCBrZWVwIHRoZSBldmVudCBsb29wIGFsaXZlLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcyNlxuICAgICAgaWYgKHN0cmVhbS5faGFuZGxlICYmIHN0cmVhbS5faGFuZGxlLnVucmVmKSB7XG4gICAgICAgIHN0cmVhbS5faGFuZGxlLnVucmVmKCk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ0ZJTEUnOlxuICAgICAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgICAgIHN0cmVhbSA9IG5ldyBmcy5TeW5jV3JpdGVTdHJlYW0oZmQsIHsgYXV0b0Nsb3NlOiBmYWxzZSB9KTtcbiAgICAgIHN0cmVhbS5fdHlwZSA9ICdmcyc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ1BJUEUnOlxuICAgIGNhc2UgJ1RDUCc6XG4gICAgICB2YXIgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG4gICAgICBzdHJlYW0gPSBuZXcgbmV0LlNvY2tldCh7XG4gICAgICAgIGZkOiBmZCxcbiAgICAgICAgcmVhZGFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEZJWE1FIFNob3VsZCBwcm9iYWJseSBoYXZlIGFuIG9wdGlvbiBpbiBuZXQuU29ja2V0IHRvIGNyZWF0ZSBhXG4gICAgICAvLyBzdHJlYW0gZnJvbSBhbiBleGlzdGluZyBmZCB3aGljaCBpcyB3cml0YWJsZSBvbmx5LiBCdXQgZm9yIG5vd1xuICAgICAgLy8gd2UnbGwganVzdCBhZGQgdGhpcyBoYWNrIGFuZCBzZXQgdGhlIGByZWFkYWJsZWAgbWVtYmVyIHRvIGZhbHNlLlxuICAgICAgLy8gVGVzdDogLi9ub2RlIHRlc3QvZml4dHVyZXMvZWNoby5qcyA8IC9ldGMvcGFzc3dkXG4gICAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZWFkID0gbnVsbDtcbiAgICAgIHN0cmVhbS5fdHlwZSA9ICdwaXBlJztcblxuICAgICAgLy8gRklYTUUgSGFjayB0byBoYXZlIHN0cmVhbSBub3Qga2VlcCB0aGUgZXZlbnQgbG9vcCBhbGl2ZS5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MjZcbiAgICAgIGlmIChzdHJlYW0uX2hhbmRsZSAmJiBzdHJlYW0uX2hhbmRsZS51bnJlZikge1xuICAgICAgICBzdHJlYW0uX2hhbmRsZS51bnJlZigpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gUHJvYmFibHkgYW4gZXJyb3Igb24gaW4gdXZfZ3Vlc3NfaGFuZGxlKClcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW1wbGVtZW50IG1lLiBVbmtub3duIHN0cmVhbSBmaWxlIHR5cGUhJyk7XG4gIH1cblxuICAvLyBGb3Igc3VwcG9ydGluZyBsZWdhY3kgQVBJIHdlIHB1dCB0aGUgRkQgaGVyZS5cbiAgc3RyZWFtLmZkID0gZmQ7XG5cbiAgc3RyZWFtLl9pc1N0ZGlvID0gdHJ1ZTtcblxuICByZXR1cm4gc3RyZWFtO1xufVxuXG4vKipcbiAqIEluaXQgbG9naWMgZm9yIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICpcbiAqIENyZWF0ZSBhIG5ldyBgaW5zcGVjdE9wdHNgIG9iamVjdCBpbiBjYXNlIGB1c2VDb2xvcnNgIGlzIHNldFxuICogZGlmZmVyZW50bHkgZm9yIGEgcGFydGljdWxhciBgZGVidWdgIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGluaXQgKGRlYnVnKSB7XG4gIGRlYnVnLmluc3BlY3RPcHRzID0ge307XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhleHBvcnRzLmluc3BlY3RPcHRzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVidWcuaW5zcGVjdE9wdHNba2V5c1tpXV0gPSBleHBvcnRzLmluc3BlY3RPcHRzW2tleXNbaV1dO1xuICB9XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBwcm9jZXNzLmVudi5ERUJVR2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiByYXctYm9keVxuICogQ29weXJpZ2h0KGMpIDIwMTMtMjAxNCBKb25hdGhhbiBPbmdcbiAqIENvcHlyaWdodChjKSAyMDE0LTIwMTUgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBieXRlcyA9IHJlcXVpcmUoJ2J5dGVzJylcbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJ2h0dHAtZXJyb3JzJylcbnZhciBpY29udiA9IHJlcXVpcmUoJ2ljb252LWxpdGUnKVxudmFyIHVucGlwZSA9IHJlcXVpcmUoJ3VucGlwZScpXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdCb2R5XG5cbi8qKlxuICogTW9kdWxlIHZhcmlhYmxlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIElDT05WX0VOQ09ESU5HX01FU1NBR0VfUkVHRVhQID0gL15FbmNvZGluZyBub3QgcmVjb2duaXplZDogL1xuXG4vKipcbiAqIEdldCB0aGUgZGVjb2RlciBmb3IgYSBnaXZlbiBlbmNvZGluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmdcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZ2V0RGVjb2RlciAoZW5jb2RpbmcpIHtcbiAgaWYgKCFlbmNvZGluZykgcmV0dXJuIG51bGxcblxuICB0cnkge1xuICAgIHJldHVybiBpY29udi5nZXREZWNvZGVyKGVuY29kaW5nKVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gZXJyb3IgZ2V0dGluZyBkZWNvZGVyXG4gICAgaWYgKCFJQ09OVl9FTkNPRElOR19NRVNTQUdFX1JFR0VYUC50ZXN0KGUubWVzc2FnZSkpIHRocm93IGVcblxuICAgIC8vIHRoZSBlbmNvZGluZyB3YXMgbm90IGZvdW5kXG4gICAgdGhyb3cgY3JlYXRlRXJyb3IoNDE1LCAnc3BlY2lmaWVkIGVuY29kaW5nIHVuc3VwcG9ydGVkJywge1xuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgdHlwZTogJ2VuY29kaW5nLnVuc3VwcG9ydGVkJ1xuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJhdyBib2R5IG9mIGEgc3RyZWFtICh0eXBpY2FsbHkgSFRUUCkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHN0cmVhbVxuICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfGZ1bmN0aW9ufSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja11cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBnZXRSYXdCb2R5IChzdHJlYW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBkb25lID0gY2FsbGJhY2tcbiAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9XG5cbiAgaWYgKG9wdGlvbnMgPT09IHRydWUgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gc2hvcnQgY3V0IGZvciBlbmNvZGluZ1xuICAgIG9wdHMgPSB7XG4gICAgICBlbmNvZGluZzogb3B0aW9uc1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRvbmUgPSBvcHRpb25zXG4gICAgb3B0cyA9IHt9XG4gIH1cblxuICAvLyB2YWxpZGF0ZSBjYWxsYmFjayBpcyBhIGZ1bmN0aW9uLCBpZiBwcm92aWRlZFxuICBpZiAoZG9uZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBkb25lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgfVxuXG4gIC8vIHJlcXVpcmUgdGhlIGNhbGxiYWNrIHdpdGhvdXQgcHJvbWlzZXNcbiAgaWYgKCFkb25lICYmICFnbG9iYWwuUHJvbWlzZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IGNhbGxiYWNrIGlzIHJlcXVpcmVkJylcbiAgfVxuXG4gIC8vIGdldCBlbmNvZGluZ1xuICB2YXIgZW5jb2RpbmcgPSBvcHRzLmVuY29kaW5nICE9PSB0cnVlXG4gICAgPyBvcHRzLmVuY29kaW5nXG4gICAgOiAndXRmLTgnXG5cbiAgLy8gY29udmVydCB0aGUgbGltaXQgdG8gYW4gaW50ZWdlclxuICB2YXIgbGltaXQgPSBieXRlcy5wYXJzZShvcHRzLmxpbWl0KVxuXG4gIC8vIGNvbnZlcnQgdGhlIGV4cGVjdGVkIGxlbmd0aCB0byBhbiBpbnRlZ2VyXG4gIHZhciBsZW5ndGggPSBvcHRzLmxlbmd0aCAhPSBudWxsICYmICFpc05hTihvcHRzLmxlbmd0aClcbiAgICA/IHBhcnNlSW50KG9wdHMubGVuZ3RoLCAxMClcbiAgICA6IG51bGxcblxuICBpZiAoZG9uZSkge1xuICAgIC8vIGNsYXNzaWMgY2FsbGJhY2sgc3R5bGVcbiAgICByZXR1cm4gcmVhZFN0cmVhbShzdHJlYW0sIGVuY29kaW5nLCBsZW5ndGgsIGxpbWl0LCBkb25lKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGV4ZWN1dG9yIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWFkU3RyZWFtKHN0cmVhbSwgZW5jb2RpbmcsIGxlbmd0aCwgbGltaXQsIGZ1bmN0aW9uIG9uUmVhZCAoZXJyLCBidWYpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgcmVzb2x2ZShidWYpXG4gICAgfSlcbiAgfSlcbn1cblxuLyoqXG4gKiBIYWx0IGEgc3RyZWFtLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW1cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaGFsdCAoc3RyZWFtKSB7XG4gIC8vIHVucGlwZSBldmVyeXRoaW5nIGZyb20gdGhlIHN0cmVhbVxuICB1bnBpcGUoc3RyZWFtKVxuXG4gIC8vIHBhdXNlIHN0cmVhbVxuICBpZiAodHlwZW9mIHN0cmVhbS5wYXVzZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHN0cmVhbS5wYXVzZSgpXG4gIH1cbn1cblxuLyoqXG4gKiBSZWFkIHRoZSBkYXRhIGZyb20gdGhlIHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gc3RyZWFtXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiByZWFkU3RyZWFtIChzdHJlYW0sIGVuY29kaW5nLCBsZW5ndGgsIGxpbWl0LCBjYWxsYmFjaykge1xuICB2YXIgY29tcGxldGUgPSBmYWxzZVxuICB2YXIgc3luYyA9IHRydWVcblxuICAvLyBjaGVjayB0aGUgbGVuZ3RoIGFuZCBsaW1pdCBvcHRpb25zLlxuICAvLyBub3RlOiB3ZSBpbnRlbnRpb25hbGx5IGxlYXZlIHRoZSBzdHJlYW0gcGF1c2VkLFxuICAvLyBzbyB1c2VycyBzaG91bGQgaGFuZGxlIHRoZSBzdHJlYW0gdGhlbXNlbHZlcy5cbiAgaWYgKGxpbWl0ICE9PSBudWxsICYmIGxlbmd0aCAhPT0gbnVsbCAmJiBsZW5ndGggPiBsaW1pdCkge1xuICAgIHJldHVybiBkb25lKGNyZWF0ZUVycm9yKDQxMywgJ3JlcXVlc3QgZW50aXR5IHRvbyBsYXJnZScsIHtcbiAgICAgIGV4cGVjdGVkOiBsZW5ndGgsXG4gICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgIGxpbWl0OiBsaW1pdCxcbiAgICAgIHR5cGU6ICdlbnRpdHkudG9vLmxhcmdlJ1xuICAgIH0pKVxuICB9XG5cbiAgLy8gc3RyZWFtczE6IGFzc2VydCByZXF1ZXN0IGVuY29kaW5nIGlzIGJ1ZmZlci5cbiAgLy8gc3RyZWFtczIrOiBhc3NlcnQgdGhlIHN0cmVhbSBlbmNvZGluZyBpcyBidWZmZXIuXG4gIC8vICAgc3RyZWFtLl9kZWNvZGVyOiBzdHJlYW1zMVxuICAvLyAgIHN0YXRlLmVuY29kaW5nOiBzdHJlYW1zMlxuICAvLyAgIHN0YXRlLmRlY29kZXI6IHN0cmVhbXMyLCBzcGVjaWZpY2FsbHkgPCAwLjEwLjZcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGlmIChzdHJlYW0uX2RlY29kZXIgfHwgKHN0YXRlICYmIChzdGF0ZS5lbmNvZGluZyB8fCBzdGF0ZS5kZWNvZGVyKSkpIHtcbiAgICAvLyBkZXZlbG9wZXIgZXJyb3JcbiAgICByZXR1cm4gZG9uZShjcmVhdGVFcnJvcig1MDAsICdzdHJlYW0gZW5jb2Rpbmcgc2hvdWxkIG5vdCBiZSBzZXQnLCB7XG4gICAgICB0eXBlOiAnc3RyZWFtLmVuY29kaW5nLnNldCdcbiAgICB9KSlcbiAgfVxuXG4gIHZhciByZWNlaXZlZCA9IDBcbiAgdmFyIGRlY29kZXJcblxuICB0cnkge1xuICAgIGRlY29kZXIgPSBnZXREZWNvZGVyKGVuY29kaW5nKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZG9uZShlcnIpXG4gIH1cblxuICB2YXIgYnVmZmVyID0gZGVjb2RlclxuICAgID8gJydcbiAgICA6IFtdXG5cbiAgLy8gYXR0YWNoIGxpc3RlbmVyc1xuICBzdHJlYW0ub24oJ2Fib3J0ZWQnLCBvbkFib3J0ZWQpXG4gIHN0cmVhbS5vbignY2xvc2UnLCBjbGVhbnVwKVxuICBzdHJlYW0ub24oJ2RhdGEnLCBvbkRhdGEpXG4gIHN0cmVhbS5vbignZW5kJywgb25FbmQpXG4gIHN0cmVhbS5vbignZXJyb3InLCBvbkVuZClcblxuICAvLyBtYXJrIHN5bmMgc2VjdGlvbiBjb21wbGV0ZVxuICBzeW5jID0gZmFsc2VcblxuICBmdW5jdGlvbiBkb25lICgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuXG4gICAgLy8gY29weSBhcmd1bWVudHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV1cbiAgICB9XG5cbiAgICAvLyBtYXJrIGNvbXBsZXRlXG4gICAgY29tcGxldGUgPSB0cnVlXG5cbiAgICBpZiAoc3luYykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhpbnZva2VDYWxsYmFjaylcbiAgICB9IGVsc2Uge1xuICAgICAgaW52b2tlQ2FsbGJhY2soKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludm9rZUNhbGxiYWNrICgpIHtcbiAgICAgIGNsZWFudXAoKVxuXG4gICAgICBpZiAoYXJnc1swXSkge1xuICAgICAgICAvLyBoYWx0IHRoZSBzdHJlYW0gb24gZXJyb3JcbiAgICAgICAgaGFsdChzdHJlYW0pXG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3MpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25BYm9ydGVkICgpIHtcbiAgICBpZiAoY29tcGxldGUpIHJldHVyblxuXG4gICAgZG9uZShjcmVhdGVFcnJvcig0MDAsICdyZXF1ZXN0IGFib3J0ZWQnLCB7XG4gICAgICBjb2RlOiAnRUNPTk5BQk9SVEVEJyxcbiAgICAgIGV4cGVjdGVkOiBsZW5ndGgsXG4gICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgIHJlY2VpdmVkOiByZWNlaXZlZCxcbiAgICAgIHR5cGU6ICdyZXF1ZXN0LmFib3J0ZWQnXG4gICAgfSkpXG4gIH1cblxuICBmdW5jdGlvbiBvbkRhdGEgKGNodW5rKSB7XG4gICAgaWYgKGNvbXBsZXRlKSByZXR1cm5cblxuICAgIHJlY2VpdmVkICs9IGNodW5rLmxlbmd0aFxuXG4gICAgaWYgKGxpbWl0ICE9PSBudWxsICYmIHJlY2VpdmVkID4gbGltaXQpIHtcbiAgICAgIGRvbmUoY3JlYXRlRXJyb3IoNDEzLCAncmVxdWVzdCBlbnRpdHkgdG9vIGxhcmdlJywge1xuICAgICAgICBsaW1pdDogbGltaXQsXG4gICAgICAgIHJlY2VpdmVkOiByZWNlaXZlZCxcbiAgICAgICAgdHlwZTogJ2VudGl0eS50b28ubGFyZ2UnXG4gICAgICB9KSlcbiAgICB9IGVsc2UgaWYgKGRlY29kZXIpIHtcbiAgICAgIGJ1ZmZlciArPSBkZWNvZGVyLndyaXRlKGNodW5rKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIucHVzaChjaHVuaylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkVuZCAoZXJyKSB7XG4gICAgaWYgKGNvbXBsZXRlKSByZXR1cm5cbiAgICBpZiAoZXJyKSByZXR1cm4gZG9uZShlcnIpXG5cbiAgICBpZiAobGVuZ3RoICE9PSBudWxsICYmIHJlY2VpdmVkICE9PSBsZW5ndGgpIHtcbiAgICAgIGRvbmUoY3JlYXRlRXJyb3IoNDAwLCAncmVxdWVzdCBzaXplIGRpZCBub3QgbWF0Y2ggY29udGVudCBsZW5ndGgnLCB7XG4gICAgICAgIGV4cGVjdGVkOiBsZW5ndGgsXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICByZWNlaXZlZDogcmVjZWl2ZWQsXG4gICAgICAgIHR5cGU6ICdyZXF1ZXN0LnNpemUuaW52YWxpZCdcbiAgICAgIH0pKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RyaW5nID0gZGVjb2RlclxuICAgICAgICA/IGJ1ZmZlciArIChkZWNvZGVyLmVuZCgpIHx8ICcnKVxuICAgICAgICA6IEJ1ZmZlci5jb25jYXQoYnVmZmVyKVxuICAgICAgZG9uZShudWxsLCBzdHJpbmcpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW51cCAoKSB7XG4gICAgYnVmZmVyID0gbnVsbFxuXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdhYm9ydGVkJywgb25BYm9ydGVkKVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uRGF0YSlcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uRW5kKVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVuZClcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cClcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmF3LWJvZHkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgQk9NQ2hhciA9ICdcXHVGRUZGJztcblxuZXhwb3J0cy5QcmVwZW5kQk9NID0gUHJlcGVuZEJPTVdyYXBwZXJcbmZ1bmN0aW9uIFByZXBlbmRCT01XcmFwcGVyKGVuY29kZXIsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmVuY29kZXIgPSBlbmNvZGVyO1xuICAgIHRoaXMuYWRkQk9NID0gdHJ1ZTtcbn1cblxuUHJlcGVuZEJPTVdyYXBwZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKHRoaXMuYWRkQk9NKSB7XG4gICAgICAgIHN0ciA9IEJPTUNoYXIgKyBzdHI7XG4gICAgICAgIHRoaXMuYWRkQk9NID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZW5jb2Rlci53cml0ZShzdHIpO1xufVxuXG5QcmVwZW5kQk9NV3JhcHBlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2Rlci5lbmQoKTtcbn1cblxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnRzLlN0cmlwQk9NID0gU3RyaXBCT01XcmFwcGVyO1xuZnVuY3Rpb24gU3RyaXBCT01XcmFwcGVyKGRlY29kZXIsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlY29kZXIgPSBkZWNvZGVyO1xuICAgIHRoaXMucGFzcyA9IGZhbHNlO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG59XG5cblN0cmlwQk9NV3JhcHBlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWYpIHtcbiAgICB2YXIgcmVzID0gdGhpcy5kZWNvZGVyLndyaXRlKGJ1Zik7XG4gICAgaWYgKHRoaXMucGFzcyB8fCAhcmVzKVxuICAgICAgICByZXR1cm4gcmVzO1xuXG4gICAgaWYgKHJlc1swXSA9PT0gQk9NQ2hhcikge1xuICAgICAgICByZXMgPSByZXMuc2xpY2UoMSk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnN0cmlwQk9NID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnN0cmlwQk9NKCk7XG4gICAgfVxuXG4gICAgdGhpcy5wYXNzID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVzO1xufVxuXG5TdHJpcEJPTVdyYXBwZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmRlY29kZXIuZW5kKCk7XG59XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvbGliL2JvbS1oYW5kbGluZy5qc1xuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFVwZGF0ZSB0aGlzIGFycmF5IGlmIHlvdSBhZGQvcmVuYW1lL3JlbW92ZSBmaWxlcyBpbiB0aGlzIGRpcmVjdG9yeS5cbi8vIFdlIHN1cHBvcnQgQnJvd3NlcmlmeSBieSBza2lwcGluZyBhdXRvbWF0aWMgbW9kdWxlIGRpc2NvdmVyeSBhbmQgcmVxdWlyaW5nIG1vZHVsZXMgZGlyZWN0bHkuXG52YXIgbW9kdWxlcyA9IFtcbiAgICByZXF1aXJlKFwiLi9pbnRlcm5hbFwiKSxcbiAgICByZXF1aXJlKFwiLi91dGYxNlwiKSxcbiAgICByZXF1aXJlKFwiLi91dGY3XCIpLFxuICAgIHJlcXVpcmUoXCIuL3NiY3MtY29kZWNcIiksXG4gICAgcmVxdWlyZShcIi4vc2Jjcy1kYXRhXCIpLFxuICAgIHJlcXVpcmUoXCIuL3NiY3MtZGF0YS1nZW5lcmF0ZWRcIiksXG4gICAgcmVxdWlyZShcIi4vZGJjcy1jb2RlY1wiKSxcbiAgICByZXF1aXJlKFwiLi9kYmNzLWRhdGFcIiksXG5dO1xuXG4vLyBQdXQgYWxsIGVuY29kaW5nL2FsaWFzL2NvZGVjIGRlZmluaXRpb25zIHRvIHNpbmdsZSBvYmplY3QgYW5kIGV4cG9ydCBpdC4gXG5mb3IgKHZhciBpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbW9kdWxlID0gbW9kdWxlc1tpXTtcbiAgICBmb3IgKHZhciBlbmMgaW4gbW9kdWxlKVxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZHVsZSwgZW5jKSlcbiAgICAgICAgICAgIGV4cG9ydHNbZW5jXSA9IG1vZHVsZVtlbmNdO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaWNvbnYtbGl0ZS9lbmNvZGluZ3MvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoXCJzYWZlci1idWZmZXJcIikuQnVmZmVyO1xuXG4vLyBFeHBvcnQgTm9kZS5qcyBpbnRlcm5hbCBlbmNvZGluZ3MuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8vIEVuY29kaW5nc1xuICAgIHV0Zjg6ICAgeyB0eXBlOiBcIl9pbnRlcm5hbFwiLCBib21Bd2FyZTogdHJ1ZX0sXG4gICAgY2VzdTg6ICB7IHR5cGU6IFwiX2ludGVybmFsXCIsIGJvbUF3YXJlOiB0cnVlfSxcbiAgICB1bmljb2RlMTF1dGY4OiBcInV0ZjhcIixcblxuICAgIHVjczI6ICAgeyB0eXBlOiBcIl9pbnRlcm5hbFwiLCBib21Bd2FyZTogdHJ1ZX0sXG4gICAgdXRmMTZsZTogXCJ1Y3MyXCIsXG5cbiAgICBiaW5hcnk6IHsgdHlwZTogXCJfaW50ZXJuYWxcIiB9LFxuICAgIGJhc2U2NDogeyB0eXBlOiBcIl9pbnRlcm5hbFwiIH0sXG4gICAgaGV4OiAgICB7IHR5cGU6IFwiX2ludGVybmFsXCIgfSxcblxuICAgIC8vIENvZGVjLlxuICAgIF9pbnRlcm5hbDogSW50ZXJuYWxDb2RlYyxcbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIEludGVybmFsQ29kZWMoY29kZWNPcHRpb25zLCBpY29udikge1xuICAgIHRoaXMuZW5jID0gY29kZWNPcHRpb25zLmVuY29kaW5nTmFtZTtcbiAgICB0aGlzLmJvbUF3YXJlID0gY29kZWNPcHRpb25zLmJvbUF3YXJlO1xuXG4gICAgaWYgKHRoaXMuZW5jID09PSBcImJhc2U2NFwiKVxuICAgICAgICB0aGlzLmVuY29kZXIgPSBJbnRlcm5hbEVuY29kZXJCYXNlNjQ7XG4gICAgZWxzZSBpZiAodGhpcy5lbmMgPT09IFwiY2VzdThcIikge1xuICAgICAgICB0aGlzLmVuYyA9IFwidXRmOFwiOyAvLyBVc2UgdXRmOCBmb3IgZGVjb2RpbmcuXG4gICAgICAgIHRoaXMuZW5jb2RlciA9IEludGVybmFsRW5jb2RlckNlc3U4O1xuXG4gICAgICAgIC8vIEFkZCBkZWNvZGVyIGZvciB2ZXJzaW9ucyBvZiBOb2RlIG5vdCBzdXBwb3J0aW5nIENFU1UtOFxuICAgICAgICBpZiAoQnVmZmVyLmZyb20oJ2VkYTBiZGVkYjJhOScsICdoZXgnKS50b1N0cmluZygpICE9PSAn8J+SqScpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlciA9IEludGVybmFsRGVjb2RlckNlc3U4O1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0Q2hhclVuaWNvZGUgPSBpY29udi5kZWZhdWx0Q2hhclVuaWNvZGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkludGVybmFsQ29kZWMucHJvdG90eXBlLmVuY29kZXIgPSBJbnRlcm5hbEVuY29kZXI7XG5JbnRlcm5hbENvZGVjLnByb3RvdHlwZS5kZWNvZGVyID0gSW50ZXJuYWxEZWNvZGVyO1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBXZSB1c2Ugbm9kZS5qcyBpbnRlcm5hbCBkZWNvZGVyLiBJdHMgc2lnbmF0dXJlIGlzIHRoZSBzYW1lIGFzIG91cnMuXG52YXIgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlcjtcblxuaWYgKCFTdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQpIC8vIE5vZGUgdjAuOCBkb2Vzbid0IGhhdmUgdGhpcyBtZXRob2QuXG4gICAgU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7fTtcblxuXG5mdW5jdGlvbiBJbnRlcm5hbERlY29kZXIob3B0aW9ucywgY29kZWMpIHtcbiAgICBTdHJpbmdEZWNvZGVyLmNhbGwodGhpcywgY29kZWMuZW5jKTtcbn1cblxuSW50ZXJuYWxEZWNvZGVyLnByb3RvdHlwZSA9IFN0cmluZ0RlY29kZXIucHJvdG90eXBlO1xuXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFbmNvZGVyIGlzIG1vc3RseSB0cml2aWFsXG5cbmZ1bmN0aW9uIEludGVybmFsRW5jb2RlcihvcHRpb25zLCBjb2RlYykge1xuICAgIHRoaXMuZW5jID0gY29kZWMuZW5jO1xufVxuXG5JbnRlcm5hbEVuY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0ciwgdGhpcy5lbmMpO1xufVxuXG5JbnRlcm5hbEVuY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xufVxuXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeGNlcHQgYmFzZTY0IGVuY29kZXIsIHdoaWNoIG11c3Qga2VlcCBpdHMgc3RhdGUuXG5cbmZ1bmN0aW9uIEludGVybmFsRW5jb2RlckJhc2U2NChvcHRpb25zLCBjb2RlYykge1xuICAgIHRoaXMucHJldlN0ciA9ICcnO1xufVxuXG5JbnRlcm5hbEVuY29kZXJCYXNlNjQucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgc3RyID0gdGhpcy5wcmV2U3RyICsgc3RyO1xuICAgIHZhciBjb21wbGV0ZVF1YWRzID0gc3RyLmxlbmd0aCAtIChzdHIubGVuZ3RoICUgNCk7XG4gICAgdGhpcy5wcmV2U3RyID0gc3RyLnNsaWNlKGNvbXBsZXRlUXVhZHMpO1xuICAgIHN0ciA9IHN0ci5zbGljZSgwLCBjb21wbGV0ZVF1YWRzKTtcblxuICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIsIFwiYmFzZTY0XCIpO1xufVxuXG5JbnRlcm5hbEVuY29kZXJCYXNlNjQucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLnByZXZTdHIsIFwiYmFzZTY0XCIpO1xufVxuXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDRVNVLTggZW5jb2RlciBpcyBhbHNvIHNwZWNpYWwuXG5cbmZ1bmN0aW9uIEludGVybmFsRW5jb2RlckNlc3U4KG9wdGlvbnMsIGNvZGVjKSB7XG59XG5cbkludGVybmFsRW5jb2RlckNlc3U4LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciBidWYgPSBCdWZmZXIuYWxsb2Moc3RyLmxlbmd0aCAqIDMpLCBidWZJZHggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAvLyBOYWl2ZSBpbXBsZW1lbnRhdGlvbiwgYnV0IGl0IHdvcmtzIGJlY2F1c2UgQ0VTVS04IGlzIGVzcGVjaWFsbHkgZWFzeVxuICAgICAgICAvLyB0byBjb252ZXJ0IGZyb20gVVRGLTE2ICh3aGljaCBhbGwgSlMgc3RyaW5ncyBhcmUgZW5jb2RlZCBpbikuXG4gICAgICAgIGlmIChjaGFyQ29kZSA8IDB4ODApXG4gICAgICAgICAgICBidWZbYnVmSWR4KytdID0gY2hhckNvZGU7XG4gICAgICAgIGVsc2UgaWYgKGNoYXJDb2RlIDwgMHg4MDApIHtcbiAgICAgICAgICAgIGJ1ZltidWZJZHgrK10gPSAweEMwICsgKGNoYXJDb2RlID4+PiA2KTtcbiAgICAgICAgICAgIGJ1ZltidWZJZHgrK10gPSAweDgwICsgKGNoYXJDb2RlICYgMHgzZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIGNoYXJDb2RlIHdpbGwgYWx3YXlzIGJlIDwgMHgxMDAwMCBpbiBqYXZhc2NyaXB0LlxuICAgICAgICAgICAgYnVmW2J1ZklkeCsrXSA9IDB4RTAgKyAoY2hhckNvZGUgPj4+IDEyKTtcbiAgICAgICAgICAgIGJ1ZltidWZJZHgrK10gPSAweDgwICsgKChjaGFyQ29kZSA+Pj4gNikgJiAweDNmKTtcbiAgICAgICAgICAgIGJ1ZltidWZJZHgrK10gPSAweDgwICsgKGNoYXJDb2RlICYgMHgzZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ1Zi5zbGljZSgwLCBidWZJZHgpO1xufVxuXG5JbnRlcm5hbEVuY29kZXJDZXN1OC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDRVNVLTggZGVjb2RlciBpcyBub3QgaW1wbGVtZW50ZWQgaW4gTm9kZSB2NC4wK1xuXG5mdW5jdGlvbiBJbnRlcm5hbERlY29kZXJDZXN1OChvcHRpb25zLCBjb2RlYykge1xuICAgIHRoaXMuYWNjID0gMDtcbiAgICB0aGlzLmNvbnRCeXRlcyA9IDA7XG4gICAgdGhpcy5hY2NCeXRlcyA9IDA7XG4gICAgdGhpcy5kZWZhdWx0Q2hhclVuaWNvZGUgPSBjb2RlYy5kZWZhdWx0Q2hhclVuaWNvZGU7XG59XG5cbkludGVybmFsRGVjb2RlckNlc3U4LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1Zikge1xuICAgIHZhciBhY2MgPSB0aGlzLmFjYywgY29udEJ5dGVzID0gdGhpcy5jb250Qnl0ZXMsIGFjY0J5dGVzID0gdGhpcy5hY2NCeXRlcywgXG4gICAgICAgIHJlcyA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJCeXRlID0gYnVmW2ldO1xuICAgICAgICBpZiAoKGN1ckJ5dGUgJiAweEMwKSAhPT0gMHg4MCkgeyAvLyBMZWFkaW5nIGJ5dGVcbiAgICAgICAgICAgIGlmIChjb250Qnl0ZXMgPiAwKSB7IC8vIFByZXZpb3VzIGNvZGUgaXMgaW52YWxpZFxuICAgICAgICAgICAgICAgIHJlcyArPSB0aGlzLmRlZmF1bHRDaGFyVW5pY29kZTtcbiAgICAgICAgICAgICAgICBjb250Qnl0ZXMgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VyQnl0ZSA8IDB4ODApIHsgLy8gU2luZ2xlLWJ5dGUgY29kZVxuICAgICAgICAgICAgICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGN1ckJ5dGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJCeXRlIDwgMHhFMCkgeyAvLyBUd28tYnl0ZSBjb2RlXG4gICAgICAgICAgICAgICAgYWNjID0gY3VyQnl0ZSAmIDB4MUY7XG4gICAgICAgICAgICAgICAgY29udEJ5dGVzID0gMTsgYWNjQnl0ZXMgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJCeXRlIDwgMHhGMCkgeyAvLyBUaHJlZS1ieXRlIGNvZGVcbiAgICAgICAgICAgICAgICBhY2MgPSBjdXJCeXRlICYgMHgwRjtcbiAgICAgICAgICAgICAgICBjb250Qnl0ZXMgPSAyOyBhY2NCeXRlcyA9IDE7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBGb3VyIG9yIG1vcmUgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIENFU1UtOC5cbiAgICAgICAgICAgICAgICByZXMgKz0gdGhpcy5kZWZhdWx0Q2hhclVuaWNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIENvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgICAgICBpZiAoY29udEJ5dGVzID4gMCkgeyAvLyBXZSdyZSB3YWl0aW5nIGZvciBpdC5cbiAgICAgICAgICAgICAgICBhY2MgPSAoYWNjIDw8IDYpIHwgKGN1ckJ5dGUgJiAweDNmKTtcbiAgICAgICAgICAgICAgICBjb250Qnl0ZXMtLTsgYWNjQnl0ZXMrKztcbiAgICAgICAgICAgICAgICBpZiAoY29udEJ5dGVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBvdmVybG9uZyBlbmNvZGluZywgYnV0IHN1cHBvcnQgTW9kaWZpZWQgVVRGLTggKGVuY29kaW5nIE5VTEwgYXMgQzAgODApXG4gICAgICAgICAgICAgICAgICAgIGlmIChhY2NCeXRlcyA9PT0gMiAmJiBhY2MgPCAweDgwICYmIGFjYyA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgKz0gdGhpcy5kZWZhdWx0Q2hhclVuaWNvZGU7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFjY0J5dGVzID09PSAzICYmIGFjYyA8IDB4ODAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IHRoaXMuZGVmYXVsdENoYXJVbmljb2RlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBY3R1YWxseSBhZGQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYWNjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBVbmV4cGVjdGVkIGNvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgICAgICAgICAgcmVzICs9IHRoaXMuZGVmYXVsdENoYXJVbmljb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWNjID0gYWNjOyB0aGlzLmNvbnRCeXRlcyA9IGNvbnRCeXRlczsgdGhpcy5hY2NCeXRlcyA9IGFjY0J5dGVzO1xuICAgIHJldHVybiByZXM7XG59XG5cbkludGVybmFsRGVjb2RlckNlc3U4LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzID0gMDtcbiAgICBpZiAodGhpcy5jb250Qnl0ZXMgPiAwKVxuICAgICAgICByZXMgKz0gdGhpcy5kZWZhdWx0Q2hhclVuaWNvZGU7XG4gICAgcmV0dXJuIHJlcztcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL2ludGVybmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzdHJpbmdfZGVjb2RlclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInN0cmluZ19kZWNvZGVyXCJcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoXCJzYWZlci1idWZmZXJcIikuQnVmZmVyO1xuXG4vLyBOb3RlOiBVVEYxNi1MRSAob3IgVUNTMikgY29kZWMgaXMgTm9kZS5qcyBuYXRpdmUuIFNlZSBlbmNvZGluZ3MvaW50ZXJuYWwuanNcblxuLy8gPT0gVVRGMTYtQkUgY29kZWMuID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0cy51dGYxNmJlID0gVXRmMTZCRUNvZGVjO1xuZnVuY3Rpb24gVXRmMTZCRUNvZGVjKCkge1xufVxuXG5VdGYxNkJFQ29kZWMucHJvdG90eXBlLmVuY29kZXIgPSBVdGYxNkJFRW5jb2RlcjtcblV0ZjE2QkVDb2RlYy5wcm90b3R5cGUuZGVjb2RlciA9IFV0ZjE2QkVEZWNvZGVyO1xuVXRmMTZCRUNvZGVjLnByb3RvdHlwZS5ib21Bd2FyZSA9IHRydWU7XG5cblxuLy8gLS0gRW5jb2RpbmdcblxuZnVuY3Rpb24gVXRmMTZCRUVuY29kZXIoKSB7XG59XG5cblV0ZjE2QkVFbmNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciBidWYgPSBCdWZmZXIuZnJvbShzdHIsICd1Y3MyJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIHRtcCA9IGJ1ZltpXTsgYnVmW2ldID0gYnVmW2krMV07IGJ1ZltpKzFdID0gdG1wO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xufVxuXG5VdGYxNkJFRW5jb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XG59XG5cblxuLy8gLS0gRGVjb2RpbmdcblxuZnVuY3Rpb24gVXRmMTZCRURlY29kZXIoKSB7XG4gICAgdGhpcy5vdmVyZmxvd0J5dGUgPSAtMTtcbn1cblxuVXRmMTZCRURlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmKSB7XG4gICAgaWYgKGJ1Zi5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuICcnO1xuXG4gICAgdmFyIGJ1ZjIgPSBCdWZmZXIuYWxsb2MoYnVmLmxlbmd0aCArIDEpLFxuICAgICAgICBpID0gMCwgaiA9IDA7XG5cbiAgICBpZiAodGhpcy5vdmVyZmxvd0J5dGUgIT09IC0xKSB7XG4gICAgICAgIGJ1ZjJbMF0gPSBidWZbMF07XG4gICAgICAgIGJ1ZjJbMV0gPSB0aGlzLm92ZXJmbG93Qnl0ZTtcbiAgICAgICAgaSA9IDE7IGogPSAyO1xuICAgIH1cblxuICAgIGZvciAoOyBpIDwgYnVmLmxlbmd0aC0xOyBpICs9IDIsIGorPSAyKSB7XG4gICAgICAgIGJ1ZjJbal0gPSBidWZbaSsxXTtcbiAgICAgICAgYnVmMltqKzFdID0gYnVmW2ldO1xuICAgIH1cblxuICAgIHRoaXMub3ZlcmZsb3dCeXRlID0gKGkgPT0gYnVmLmxlbmd0aC0xKSA/IGJ1ZltidWYubGVuZ3RoLTFdIDogLTE7XG5cbiAgICByZXR1cm4gYnVmMi5zbGljZSgwLCBqKS50b1N0cmluZygndWNzMicpO1xufVxuXG5VdGYxNkJFRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XG59XG5cblxuLy8gPT0gVVRGLTE2IGNvZGVjID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERlY29kZXIgY2hvb3NlcyBhdXRvbWF0aWNhbGx5IGZyb20gVVRGLTE2TEUgYW5kIFVURi0xNkJFIHVzaW5nIEJPTSBhbmQgc3BhY2UtYmFzZWQgaGV1cmlzdGljLlxuLy8gRGVmYXVsdHMgdG8gVVRGLTE2TEUsIGFzIGl0J3MgcHJldmFsZW50IGFuZCBkZWZhdWx0IGluIE5vZGUuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi0xNiBhbmQgaHR0cDovL2VuY29kaW5nLnNwZWMud2hhdHdnLm9yZy8jdXRmLTE2bGVcbi8vIERlY29kZXIgZGVmYXVsdCBjYW4gYmUgY2hhbmdlZDogaWNvbnYuZGVjb2RlKGJ1ZiwgJ3V0ZjE2Jywge2RlZmF1bHRFbmNvZGluZzogJ3V0Zi0xNmJlJ30pO1xuXG4vLyBFbmNvZGVyIHVzZXMgVVRGLTE2TEUgYW5kIHByZXBlbmRzIEJPTSAod2hpY2ggY2FuIGJlIG92ZXJyaWRkZW4gd2l0aCBhZGRCT006IGZhbHNlKS5cblxuZXhwb3J0cy51dGYxNiA9IFV0ZjE2Q29kZWM7XG5mdW5jdGlvbiBVdGYxNkNvZGVjKGNvZGVjT3B0aW9ucywgaWNvbnYpIHtcbiAgICB0aGlzLmljb252ID0gaWNvbnY7XG59XG5cblV0ZjE2Q29kZWMucHJvdG90eXBlLmVuY29kZXIgPSBVdGYxNkVuY29kZXI7XG5VdGYxNkNvZGVjLnByb3RvdHlwZS5kZWNvZGVyID0gVXRmMTZEZWNvZGVyO1xuXG5cbi8vIC0tIEVuY29kaW5nIChwYXNzLXRocm91Z2gpXG5cbmZ1bmN0aW9uIFV0ZjE2RW5jb2RlcihvcHRpb25zLCBjb2RlYykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChvcHRpb25zLmFkZEJPTSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBvcHRpb25zLmFkZEJPTSA9IHRydWU7XG4gICAgdGhpcy5lbmNvZGVyID0gY29kZWMuaWNvbnYuZ2V0RW5jb2RlcigndXRmLTE2bGUnLCBvcHRpb25zKTtcbn1cblxuVXRmMTZFbmNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiB0aGlzLmVuY29kZXIud3JpdGUoc3RyKTtcbn1cblxuVXRmMTZFbmNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGVyLmVuZCgpO1xufVxuXG5cbi8vIC0tIERlY29kaW5nXG5cbmZ1bmN0aW9uIFV0ZjE2RGVjb2RlcihvcHRpb25zLCBjb2RlYykge1xuICAgIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gICAgdGhpcy5pbml0aWFsQnl0ZXMgPSBbXTtcbiAgICB0aGlzLmluaXRpYWxCeXRlc0xlbiA9IDA7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuaWNvbnYgPSBjb2RlYy5pY29udjtcbn1cblxuVXRmMTZEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1Zikge1xuICAgIGlmICghdGhpcy5kZWNvZGVyKSB7XG4gICAgICAgIC8vIENvZGVjIGlzIG5vdCBjaG9zZW4geWV0LiBBY2N1bXVsYXRlIGluaXRpYWwgYnl0ZXMuXG4gICAgICAgIHRoaXMuaW5pdGlhbEJ5dGVzLnB1c2goYnVmKTtcbiAgICAgICAgdGhpcy5pbml0aWFsQnl0ZXNMZW4gKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgXG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxCeXRlc0xlbiA8IDE2KSAvLyBXZSBuZWVkIG1vcmUgYnl0ZXMgdG8gdXNlIHNwYWNlIGhldXJpc3RpYyAoc2VlIGJlbG93KVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuXG4gICAgICAgIC8vIFdlIGhhdmUgZW5vdWdoIGJ5dGVzIC0+IGRldGVjdCBlbmRpYW5uZXNzLlxuICAgICAgICB2YXIgYnVmID0gQnVmZmVyLmNvbmNhdCh0aGlzLmluaXRpYWxCeXRlcyksXG4gICAgICAgICAgICBlbmNvZGluZyA9IGRldGVjdEVuY29kaW5nKGJ1ZiwgdGhpcy5vcHRpb25zLmRlZmF1bHRFbmNvZGluZyk7XG4gICAgICAgIHRoaXMuZGVjb2RlciA9IHRoaXMuaWNvbnYuZ2V0RGVjb2RlcihlbmNvZGluZywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgdGhpcy5pbml0aWFsQnl0ZXMubGVuZ3RoID0gdGhpcy5pbml0aWFsQnl0ZXNMZW4gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRlY29kZXIud3JpdGUoYnVmKTtcbn1cblxuVXRmMTZEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuZGVjb2Rlcikge1xuICAgICAgICB2YXIgYnVmID0gQnVmZmVyLmNvbmNhdCh0aGlzLmluaXRpYWxCeXRlcyksXG4gICAgICAgICAgICBlbmNvZGluZyA9IGRldGVjdEVuY29kaW5nKGJ1ZiwgdGhpcy5vcHRpb25zLmRlZmF1bHRFbmNvZGluZyk7XG4gICAgICAgIHRoaXMuZGVjb2RlciA9IHRoaXMuaWNvbnYuZ2V0RGVjb2RlcihlbmNvZGluZywgdGhpcy5vcHRpb25zKTtcblxuICAgICAgICB2YXIgcmVzID0gdGhpcy5kZWNvZGVyLndyaXRlKGJ1ZiksXG4gICAgICAgICAgICB0cmFpbCA9IHRoaXMuZGVjb2Rlci5lbmQoKTtcblxuICAgICAgICByZXR1cm4gdHJhaWwgPyAocmVzICsgdHJhaWwpIDogcmVzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kZWNvZGVyLmVuZCgpO1xufVxuXG5mdW5jdGlvbiBkZXRlY3RFbmNvZGluZyhidWYsIGRlZmF1bHRFbmNvZGluZykge1xuICAgIHZhciBlbmMgPSBkZWZhdWx0RW5jb2RpbmcgfHwgJ3V0Zi0xNmxlJztcblxuICAgIGlmIChidWYubGVuZ3RoID49IDIpIHtcbiAgICAgICAgLy8gQ2hlY2sgQk9NLlxuICAgICAgICBpZiAoYnVmWzBdID09IDB4RkUgJiYgYnVmWzFdID09IDB4RkYpIC8vIFVURi0xNkJFIEJPTVxuICAgICAgICAgICAgZW5jID0gJ3V0Zi0xNmJlJztcbiAgICAgICAgZWxzZSBpZiAoYnVmWzBdID09IDB4RkYgJiYgYnVmWzFdID09IDB4RkUpIC8vIFVURi0xNkxFIEJPTVxuICAgICAgICAgICAgZW5jID0gJ3V0Zi0xNmxlJztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBObyBCT00gZm91bmQuIFRyeSB0byBkZWR1Y2UgZW5jb2RpbmcgZnJvbSBpbml0aWFsIGNvbnRlbnQuXG4gICAgICAgICAgICAvLyBNb3N0IG9mIHRoZSB0aW1lLCB0aGUgY29udGVudCBoYXMgQVNDSUkgY2hhcnMgKFUrMDAqKiksIGJ1dCB0aGUgb3Bwb3NpdGUgKFUrKiowMCkgaXMgdW5jb21tb24uXG4gICAgICAgICAgICAvLyBTbywgd2UgY291bnQgQVNDSUkgYXMgaWYgaXQgd2FzIExFIG9yIEJFLCBhbmQgZGVjaWRlIGZyb20gdGhhdC5cbiAgICAgICAgICAgIHZhciBhc2NpaUNoYXJzTEUgPSAwLCBhc2NpaUNoYXJzQkUgPSAwLCAvLyBDb3VudHMgb2YgY2hhcnMgaW4gYm90aCBwb3NpdGlvbnNcbiAgICAgICAgICAgICAgICBfbGVuID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIChidWYubGVuZ3RoICUgMiksIDY0KTsgLy8gTGVuIGlzIGFsd2F5cyBldmVuLlxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9sZW47IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGlmIChidWZbaV0gPT09IDAgJiYgYnVmW2krMV0gIT09IDApIGFzY2lpQ2hhcnNCRSsrO1xuICAgICAgICAgICAgICAgIGlmIChidWZbaV0gIT09IDAgJiYgYnVmW2krMV0gPT09IDApIGFzY2lpQ2hhcnNMRSsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXNjaWlDaGFyc0JFID4gYXNjaWlDaGFyc0xFKVxuICAgICAgICAgICAgICAgIGVuYyA9ICd1dGYtMTZiZSc7XG4gICAgICAgICAgICBlbHNlIGlmIChhc2NpaUNoYXJzQkUgPCBhc2NpaUNoYXJzTEUpXG4gICAgICAgICAgICAgICAgZW5jID0gJ3V0Zi0xNmxlJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbmM7XG59XG5cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaWNvbnYtbGl0ZS9lbmNvZGluZ3MvdXRmMTYuanNcbi8vIG1vZHVsZSBpZCA9IDk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoXCJzYWZlci1idWZmZXJcIikuQnVmZmVyO1xuXG4vLyBVVEYtNyBjb2RlYywgYWNjb3JkaW5nIHRvIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyMTUyXG4vLyBTZWUgYWxzbyBiZWxvdyBhIFVURi03LUlNQVAgY29kZWMsIGFjY29yZGluZyB0byBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNTAxI3NlY3Rpb24tNS4xLjNcblxuZXhwb3J0cy51dGY3ID0gVXRmN0NvZGVjO1xuZXhwb3J0cy51bmljb2RlMTF1dGY3ID0gJ3V0ZjcnOyAvLyBBbGlhcyBVTklDT0RFLTEtMS1VVEYtN1xuZnVuY3Rpb24gVXRmN0NvZGVjKGNvZGVjT3B0aW9ucywgaWNvbnYpIHtcbiAgICB0aGlzLmljb252ID0gaWNvbnY7XG59O1xuXG5VdGY3Q29kZWMucHJvdG90eXBlLmVuY29kZXIgPSBVdGY3RW5jb2RlcjtcblV0ZjdDb2RlYy5wcm90b3R5cGUuZGVjb2RlciA9IFV0ZjdEZWNvZGVyO1xuVXRmN0NvZGVjLnByb3RvdHlwZS5ib21Bd2FyZSA9IHRydWU7XG5cblxuLy8gLS0gRW5jb2RpbmdcblxudmFyIG5vbkRpcmVjdENoYXJzID0gL1teQS1aYS16MC05J1xcKFxcKSwtXFwuXFwvOlxcPyBcXG5cXHJcXHRdKy9nO1xuXG5mdW5jdGlvbiBVdGY3RW5jb2RlcihvcHRpb25zLCBjb2RlYykge1xuICAgIHRoaXMuaWNvbnYgPSBjb2RlYy5pY29udjtcbn1cblxuVXRmN0VuY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgLy8gTmFpdmUgaW1wbGVtZW50YXRpb24uXG4gICAgLy8gTm9uLWRpcmVjdCBjaGFycyBhcmUgZW5jb2RlZCBhcyBcIis8YmFzZTY0Pi1cIjsgc2luZ2xlIFwiK1wiIGNoYXIgaXMgZW5jb2RlZCBhcyBcIistXCIuXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0ci5yZXBsYWNlKG5vbkRpcmVjdENoYXJzLCBmdW5jdGlvbihjaHVuaykge1xuICAgICAgICByZXR1cm4gXCIrXCIgKyAoY2h1bmsgPT09ICcrJyA/ICcnIDogXG4gICAgICAgICAgICB0aGlzLmljb252LmVuY29kZShjaHVuaywgJ3V0ZjE2LWJlJykudG9TdHJpbmcoJ2Jhc2U2NCcpLnJlcGxhY2UoLz0rJC8sICcnKSkgXG4gICAgICAgICAgICArIFwiLVwiO1xuICAgIH0uYmluZCh0aGlzKSkpO1xufVxuXG5VdGY3RW5jb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XG59XG5cblxuLy8gLS0gRGVjb2RpbmdcblxuZnVuY3Rpb24gVXRmN0RlY29kZXIob3B0aW9ucywgY29kZWMpIHtcbiAgICB0aGlzLmljb252ID0gY29kZWMuaWNvbnY7XG4gICAgdGhpcy5pbkJhc2U2NCA9IGZhbHNlO1xuICAgIHRoaXMuYmFzZTY0QWNjdW0gPSAnJztcbn1cblxudmFyIGJhc2U2NFJlZ2V4ID0gL1tBLVphLXowLTlcXC8rXS87XG52YXIgYmFzZTY0Q2hhcnMgPSBbXTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspXG4gICAgYmFzZTY0Q2hhcnNbaV0gPSBiYXNlNjRSZWdleC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoaSkpO1xuXG52YXIgcGx1c0NoYXIgPSAnKycuY2hhckNvZGVBdCgwKSwgXG4gICAgbWludXNDaGFyID0gJy0nLmNoYXJDb2RlQXQoMCksXG4gICAgYW5kQ2hhciA9ICcmJy5jaGFyQ29kZUF0KDApO1xuXG5VdGY3RGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWYpIHtcbiAgICB2YXIgcmVzID0gXCJcIiwgbGFzdEkgPSAwLFxuICAgICAgICBpbkJhc2U2NCA9IHRoaXMuaW5CYXNlNjQsXG4gICAgICAgIGJhc2U2NEFjY3VtID0gdGhpcy5iYXNlNjRBY2N1bTtcblxuICAgIC8vIFRoZSBkZWNvZGVyIGlzIG1vcmUgaW52b2x2ZWQgYXMgd2UgbXVzdCBoYW5kbGUgY2h1bmtzIGluIHN0cmVhbS5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghaW5CYXNlNjQpIHsgLy8gV2UncmUgaW4gZGlyZWN0IG1vZGUuXG4gICAgICAgICAgICAvLyBXcml0ZSBkaXJlY3QgY2hhcnMgdW50aWwgJysnXG4gICAgICAgICAgICBpZiAoYnVmW2ldID09IHBsdXNDaGFyKSB7XG4gICAgICAgICAgICAgICAgcmVzICs9IHRoaXMuaWNvbnYuZGVjb2RlKGJ1Zi5zbGljZShsYXN0SSwgaSksIFwiYXNjaWlcIik7IC8vIFdyaXRlIGRpcmVjdCBjaGFycy5cbiAgICAgICAgICAgICAgICBsYXN0SSA9IGkrMTtcbiAgICAgICAgICAgICAgICBpbkJhc2U2NCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIFdlIGRlY29kZSBiYXNlNjQuXG4gICAgICAgICAgICBpZiAoIWJhc2U2NENoYXJzW2J1ZltpXV0pIHsgLy8gQmFzZTY0IGVuZGVkLlxuICAgICAgICAgICAgICAgIGlmIChpID09IGxhc3RJICYmIGJ1ZltpXSA9PSBtaW51c0NoYXIpIHsvLyBcIistXCIgLT4gXCIrXCJcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IFwiK1wiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiNjRzdHIgPSBiYXNlNjRBY2N1bSArIGJ1Zi5zbGljZShsYXN0SSwgaSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IHRoaXMuaWNvbnYuZGVjb2RlKEJ1ZmZlci5mcm9tKGI2NHN0ciwgJ2Jhc2U2NCcpLCBcInV0ZjE2LWJlXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChidWZbaV0gIT0gbWludXNDaGFyKSAvLyBNaW51cyBpcyBhYnNvcmJlZCBhZnRlciBiYXNlNjQuXG4gICAgICAgICAgICAgICAgICAgIGktLTtcblxuICAgICAgICAgICAgICAgIGxhc3RJID0gaSsxO1xuICAgICAgICAgICAgICAgIGluQmFzZTY0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYmFzZTY0QWNjdW0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaW5CYXNlNjQpIHtcbiAgICAgICAgcmVzICs9IHRoaXMuaWNvbnYuZGVjb2RlKGJ1Zi5zbGljZShsYXN0SSksIFwiYXNjaWlcIik7IC8vIFdyaXRlIGRpcmVjdCBjaGFycy5cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYjY0c3RyID0gYmFzZTY0QWNjdW0gKyBidWYuc2xpY2UobGFzdEkpLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgdmFyIGNhbkJlRGVjb2RlZCA9IGI2NHN0ci5sZW5ndGggLSAoYjY0c3RyLmxlbmd0aCAlIDgpOyAvLyBNaW5pbWFsIGNodW5rOiAyIHF1YWRzIC0+IDJ4MyBieXRlcyAtPiAzIGNoYXJzLlxuICAgICAgICBiYXNlNjRBY2N1bSA9IGI2NHN0ci5zbGljZShjYW5CZURlY29kZWQpOyAvLyBUaGUgcmVzdCB3aWxsIGJlIGRlY29kZWQgaW4gZnV0dXJlLlxuICAgICAgICBiNjRzdHIgPSBiNjRzdHIuc2xpY2UoMCwgY2FuQmVEZWNvZGVkKTtcblxuICAgICAgICByZXMgKz0gdGhpcy5pY29udi5kZWNvZGUoQnVmZmVyLmZyb20oYjY0c3RyLCAnYmFzZTY0JyksIFwidXRmMTYtYmVcIik7XG4gICAgfVxuXG4gICAgdGhpcy5pbkJhc2U2NCA9IGluQmFzZTY0O1xuICAgIHRoaXMuYmFzZTY0QWNjdW0gPSBiYXNlNjRBY2N1bTtcblxuICAgIHJldHVybiByZXM7XG59XG5cblV0ZjdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzID0gXCJcIjtcbiAgICBpZiAodGhpcy5pbkJhc2U2NCAmJiB0aGlzLmJhc2U2NEFjY3VtLmxlbmd0aCA+IDApXG4gICAgICAgIHJlcyA9IHRoaXMuaWNvbnYuZGVjb2RlKEJ1ZmZlci5mcm9tKHRoaXMuYmFzZTY0QWNjdW0sICdiYXNlNjQnKSwgXCJ1dGYxNi1iZVwiKTtcblxuICAgIHRoaXMuaW5CYXNlNjQgPSBmYWxzZTtcbiAgICB0aGlzLmJhc2U2NEFjY3VtID0gJyc7XG4gICAgcmV0dXJuIHJlcztcbn1cblxuXG4vLyBVVEYtNy1JTUFQIGNvZGVjLlxuLy8gUkZDMzUwMSBTZWMuIDUuMS4zIE1vZGlmaWVkIFVURi03IChodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNTAxI3NlY3Rpb24tNS4xLjMpXG4vLyBEaWZmZXJlbmNlczpcbi8vICAqIEJhc2U2NCBwYXJ0IGlzIHN0YXJ0ZWQgYnkgXCImXCIgaW5zdGVhZCBvZiBcIitcIlxuLy8gICogRGlyZWN0IGNoYXJhY3RlcnMgYXJlIDB4MjAtMHg3RSwgZXhjZXB0IFwiJlwiICgweDI2KVxuLy8gICogSW4gQmFzZTY0LCBcIixcIiBpcyB1c2VkIGluc3RlYWQgb2YgXCIvXCJcbi8vICAqIEJhc2U2NCBtdXN0IG5vdCBiZSB1c2VkIHRvIHJlcHJlc2VudCBkaXJlY3QgY2hhcmFjdGVycy5cbi8vICAqIE5vIGltcGxpY2l0IHNoaWZ0IGJhY2sgZnJvbSBCYXNlNjQgKHNob3VsZCBhbHdheXMgZW5kIHdpdGggJy0nKVxuLy8gICogU3RyaW5nIG11c3QgZW5kIGluIG5vbi1zaGlmdGVkIHBvc2l0aW9uLlxuLy8gICogXCItJlwiIHdoaWxlIGluIGJhc2U2NCBpcyBub3QgYWxsb3dlZC5cblxuXG5leHBvcnRzLnV0ZjdpbWFwID0gVXRmN0lNQVBDb2RlYztcbmZ1bmN0aW9uIFV0ZjdJTUFQQ29kZWMoY29kZWNPcHRpb25zLCBpY29udikge1xuICAgIHRoaXMuaWNvbnYgPSBpY29udjtcbn07XG5cblV0ZjdJTUFQQ29kZWMucHJvdG90eXBlLmVuY29kZXIgPSBVdGY3SU1BUEVuY29kZXI7XG5VdGY3SU1BUENvZGVjLnByb3RvdHlwZS5kZWNvZGVyID0gVXRmN0lNQVBEZWNvZGVyO1xuVXRmN0lNQVBDb2RlYy5wcm90b3R5cGUuYm9tQXdhcmUgPSB0cnVlO1xuXG5cbi8vIC0tIEVuY29kaW5nXG5cbmZ1bmN0aW9uIFV0ZjdJTUFQRW5jb2RlcihvcHRpb25zLCBjb2RlYykge1xuICAgIHRoaXMuaWNvbnYgPSBjb2RlYy5pY29udjtcbiAgICB0aGlzLmluQmFzZTY0ID0gZmFsc2U7XG4gICAgdGhpcy5iYXNlNjRBY2N1bSA9IEJ1ZmZlci5hbGxvYyg2KTtcbiAgICB0aGlzLmJhc2U2NEFjY3VtSWR4ID0gMDtcbn1cblxuVXRmN0lNQVBFbmNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciBpbkJhc2U2NCA9IHRoaXMuaW5CYXNlNjQsXG4gICAgICAgIGJhc2U2NEFjY3VtID0gdGhpcy5iYXNlNjRBY2N1bSxcbiAgICAgICAgYmFzZTY0QWNjdW1JZHggPSB0aGlzLmJhc2U2NEFjY3VtSWR4LFxuICAgICAgICBidWYgPSBCdWZmZXIuYWxsb2Moc3RyLmxlbmd0aCo1ICsgMTApLCBidWZJZHggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHVDaGFyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmICgweDIwIDw9IHVDaGFyICYmIHVDaGFyIDw9IDB4N0UpIHsgLy8gRGlyZWN0IGNoYXJhY3RlciBvciAnJicuXG4gICAgICAgICAgICBpZiAoaW5CYXNlNjQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmFzZTY0QWNjdW1JZHggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZklkeCArPSBidWYud3JpdGUoYmFzZTY0QWNjdW0uc2xpY2UoMCwgYmFzZTY0QWNjdW1JZHgpLnRvU3RyaW5nKCdiYXNlNjQnKS5yZXBsYWNlKC9cXC8vZywgJywnKS5yZXBsYWNlKC89KyQvLCAnJyksIGJ1ZklkeCk7XG4gICAgICAgICAgICAgICAgICAgIGJhc2U2NEFjY3VtSWR4ID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBidWZbYnVmSWR4KytdID0gbWludXNDaGFyOyAvLyBXcml0ZSAnLScsIHRoZW4gZ28gdG8gZGlyZWN0IG1vZGUuXG4gICAgICAgICAgICAgICAgaW5CYXNlNjQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpbkJhc2U2NCkge1xuICAgICAgICAgICAgICAgIGJ1ZltidWZJZHgrK10gPSB1Q2hhcjsgLy8gV3JpdGUgZGlyZWN0IGNoYXJhY3RlclxuXG4gICAgICAgICAgICAgICAgaWYgKHVDaGFyID09PSBhbmRDaGFyKSAgLy8gQW1wZXJzYW5kIC0+ICcmLSdcbiAgICAgICAgICAgICAgICAgICAgYnVmW2J1ZklkeCsrXSA9IG1pbnVzQ2hhcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgeyAvLyBOb24tZGlyZWN0IGNoYXJhY3RlclxuICAgICAgICAgICAgaWYgKCFpbkJhc2U2NCkge1xuICAgICAgICAgICAgICAgIGJ1ZltidWZJZHgrK10gPSBhbmRDaGFyOyAvLyBXcml0ZSAnJicsIHRoZW4gZ28gdG8gYmFzZTY0IG1vZGUuXG4gICAgICAgICAgICAgICAgaW5CYXNlNjQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluQmFzZTY0KSB7XG4gICAgICAgICAgICAgICAgYmFzZTY0QWNjdW1bYmFzZTY0QWNjdW1JZHgrK10gPSB1Q2hhciA+PiA4O1xuICAgICAgICAgICAgICAgIGJhc2U2NEFjY3VtW2Jhc2U2NEFjY3VtSWR4KytdID0gdUNoYXIgJiAweEZGO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJhc2U2NEFjY3VtSWR4ID09IGJhc2U2NEFjY3VtLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBidWZJZHggKz0gYnVmLndyaXRlKGJhc2U2NEFjY3VtLnRvU3RyaW5nKCdiYXNlNjQnKS5yZXBsYWNlKC9cXC8vZywgJywnKSwgYnVmSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgYmFzZTY0QWNjdW1JZHggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaW5CYXNlNjQgPSBpbkJhc2U2NDtcbiAgICB0aGlzLmJhc2U2NEFjY3VtSWR4ID0gYmFzZTY0QWNjdW1JZHg7XG5cbiAgICByZXR1cm4gYnVmLnNsaWNlKDAsIGJ1ZklkeCk7XG59XG5cblV0ZjdJTUFQRW5jb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYygxMCksIGJ1ZklkeCA9IDA7XG4gICAgaWYgKHRoaXMuaW5CYXNlNjQpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFzZTY0QWNjdW1JZHggPiAwKSB7XG4gICAgICAgICAgICBidWZJZHggKz0gYnVmLndyaXRlKHRoaXMuYmFzZTY0QWNjdW0uc2xpY2UoMCwgdGhpcy5iYXNlNjRBY2N1bUlkeCkudG9TdHJpbmcoJ2Jhc2U2NCcpLnJlcGxhY2UoL1xcLy9nLCAnLCcpLnJlcGxhY2UoLz0rJC8sICcnKSwgYnVmSWR4KTtcbiAgICAgICAgICAgIHRoaXMuYmFzZTY0QWNjdW1JZHggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVmW2J1ZklkeCsrXSA9IG1pbnVzQ2hhcjsgLy8gV3JpdGUgJy0nLCB0aGVuIGdvIHRvIGRpcmVjdCBtb2RlLlxuICAgICAgICB0aGlzLmluQmFzZTY0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1Zi5zbGljZSgwLCBidWZJZHgpO1xufVxuXG5cbi8vIC0tIERlY29kaW5nXG5cbmZ1bmN0aW9uIFV0ZjdJTUFQRGVjb2RlcihvcHRpb25zLCBjb2RlYykge1xuICAgIHRoaXMuaWNvbnYgPSBjb2RlYy5pY29udjtcbiAgICB0aGlzLmluQmFzZTY0ID0gZmFsc2U7XG4gICAgdGhpcy5iYXNlNjRBY2N1bSA9ICcnO1xufVxuXG52YXIgYmFzZTY0SU1BUENoYXJzID0gYmFzZTY0Q2hhcnMuc2xpY2UoKTtcbmJhc2U2NElNQVBDaGFyc1snLCcuY2hhckNvZGVBdCgwKV0gPSB0cnVlO1xuXG5VdGY3SU1BUERlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmKSB7XG4gICAgdmFyIHJlcyA9IFwiXCIsIGxhc3RJID0gMCxcbiAgICAgICAgaW5CYXNlNjQgPSB0aGlzLmluQmFzZTY0LFxuICAgICAgICBiYXNlNjRBY2N1bSA9IHRoaXMuYmFzZTY0QWNjdW07XG5cbiAgICAvLyBUaGUgZGVjb2RlciBpcyBtb3JlIGludm9sdmVkIGFzIHdlIG11c3QgaGFuZGxlIGNodW5rcyBpbiBzdHJlYW0uXG4gICAgLy8gSXQgaXMgZm9yZ2l2aW5nLCBjbG9zZXIgdG8gc3RhbmRhcmQgVVRGLTcgKGZvciBleGFtcGxlLCAnLScgaXMgb3B0aW9uYWwgYXQgdGhlIGVuZCkuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWluQmFzZTY0KSB7IC8vIFdlJ3JlIGluIGRpcmVjdCBtb2RlLlxuICAgICAgICAgICAgLy8gV3JpdGUgZGlyZWN0IGNoYXJzIHVudGlsICcmJ1xuICAgICAgICAgICAgaWYgKGJ1ZltpXSA9PSBhbmRDaGFyKSB7XG4gICAgICAgICAgICAgICAgcmVzICs9IHRoaXMuaWNvbnYuZGVjb2RlKGJ1Zi5zbGljZShsYXN0SSwgaSksIFwiYXNjaWlcIik7IC8vIFdyaXRlIGRpcmVjdCBjaGFycy5cbiAgICAgICAgICAgICAgICBsYXN0SSA9IGkrMTtcbiAgICAgICAgICAgICAgICBpbkJhc2U2NCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIFdlIGRlY29kZSBiYXNlNjQuXG4gICAgICAgICAgICBpZiAoIWJhc2U2NElNQVBDaGFyc1tidWZbaV1dKSB7IC8vIEJhc2U2NCBlbmRlZC5cbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBsYXN0SSAmJiBidWZbaV0gPT0gbWludXNDaGFyKSB7IC8vIFwiJi1cIiAtPiBcIiZcIlxuICAgICAgICAgICAgICAgICAgICByZXMgKz0gXCImXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGI2NHN0ciA9IGJhc2U2NEFjY3VtICsgYnVmLnNsaWNlKGxhc3RJLCBpKS50b1N0cmluZygpLnJlcGxhY2UoLywvZywgJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IHRoaXMuaWNvbnYuZGVjb2RlKEJ1ZmZlci5mcm9tKGI2NHN0ciwgJ2Jhc2U2NCcpLCBcInV0ZjE2LWJlXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChidWZbaV0gIT0gbWludXNDaGFyKSAvLyBNaW51cyBtYXkgYmUgYWJzb3JiZWQgYWZ0ZXIgYmFzZTY0LlxuICAgICAgICAgICAgICAgICAgICBpLS07XG5cbiAgICAgICAgICAgICAgICBsYXN0SSA9IGkrMTtcbiAgICAgICAgICAgICAgICBpbkJhc2U2NCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJhc2U2NEFjY3VtID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWluQmFzZTY0KSB7XG4gICAgICAgIHJlcyArPSB0aGlzLmljb252LmRlY29kZShidWYuc2xpY2UobGFzdEkpLCBcImFzY2lpXCIpOyAvLyBXcml0ZSBkaXJlY3QgY2hhcnMuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGI2NHN0ciA9IGJhc2U2NEFjY3VtICsgYnVmLnNsaWNlKGxhc3RJKS50b1N0cmluZygpLnJlcGxhY2UoLywvZywgJy8nKTtcblxuICAgICAgICB2YXIgY2FuQmVEZWNvZGVkID0gYjY0c3RyLmxlbmd0aCAtIChiNjRzdHIubGVuZ3RoICUgOCk7IC8vIE1pbmltYWwgY2h1bms6IDIgcXVhZHMgLT4gMngzIGJ5dGVzIC0+IDMgY2hhcnMuXG4gICAgICAgIGJhc2U2NEFjY3VtID0gYjY0c3RyLnNsaWNlKGNhbkJlRGVjb2RlZCk7IC8vIFRoZSByZXN0IHdpbGwgYmUgZGVjb2RlZCBpbiBmdXR1cmUuXG4gICAgICAgIGI2NHN0ciA9IGI2NHN0ci5zbGljZSgwLCBjYW5CZURlY29kZWQpO1xuXG4gICAgICAgIHJlcyArPSB0aGlzLmljb252LmRlY29kZShCdWZmZXIuZnJvbShiNjRzdHIsICdiYXNlNjQnKSwgXCJ1dGYxNi1iZVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmluQmFzZTY0ID0gaW5CYXNlNjQ7XG4gICAgdGhpcy5iYXNlNjRBY2N1bSA9IGJhc2U2NEFjY3VtO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuVXRmN0lNQVBEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzID0gXCJcIjtcbiAgICBpZiAodGhpcy5pbkJhc2U2NCAmJiB0aGlzLmJhc2U2NEFjY3VtLmxlbmd0aCA+IDApXG4gICAgICAgIHJlcyA9IHRoaXMuaWNvbnYuZGVjb2RlKEJ1ZmZlci5mcm9tKHRoaXMuYmFzZTY0QWNjdW0sICdiYXNlNjQnKSwgXCJ1dGYxNi1iZVwiKTtcblxuICAgIHRoaXMuaW5CYXNlNjQgPSBmYWxzZTtcbiAgICB0aGlzLmJhc2U2NEFjY3VtID0gJyc7XG4gICAgcmV0dXJuIHJlcztcbn1cblxuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9pY29udi1saXRlL2VuY29kaW5ncy91dGY3LmpzXG4vLyBtb2R1bGUgaWQgPSA5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBCdWZmZXIgPSByZXF1aXJlKFwic2FmZXItYnVmZmVyXCIpLkJ1ZmZlcjtcblxuLy8gU2luZ2xlLWJ5dGUgY29kZWMuIE5lZWRzIGEgJ2NoYXJzJyBzdHJpbmcgcGFyYW1ldGVyIHRoYXQgY29udGFpbnMgMjU2IG9yIDEyOCBjaGFycyB0aGF0XG4vLyBjb3JyZXNwb25kIHRvIGVuY29kZWQgYnl0ZXMgKGlmIDEyOCAtIHRoZW4gbG93ZXIgaGFsZiBpcyBBU0NJSSkuIFxuXG5leHBvcnRzLl9zYmNzID0gU0JDU0NvZGVjO1xuZnVuY3Rpb24gU0JDU0NvZGVjKGNvZGVjT3B0aW9ucywgaWNvbnYpIHtcbiAgICBpZiAoIWNvZGVjT3B0aW9ucylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU0JDUyBjb2RlYyBpcyBjYWxsZWQgd2l0aG91dCB0aGUgZGF0YS5cIilcbiAgICBcbiAgICAvLyBQcmVwYXJlIGNoYXIgYnVmZmVyIGZvciBkZWNvZGluZy5cbiAgICBpZiAoIWNvZGVjT3B0aW9ucy5jaGFycyB8fCAoY29kZWNPcHRpb25zLmNoYXJzLmxlbmd0aCAhPT0gMTI4ICYmIGNvZGVjT3B0aW9ucy5jaGFycy5sZW5ndGggIT09IDI1NikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuY29kaW5nICdcIitjb2RlY09wdGlvbnMudHlwZStcIicgaGFzIGluY29ycmVjdCAnY2hhcnMnIChtdXN0IGJlIG9mIGxlbiAxMjggb3IgMjU2KVwiKTtcbiAgICBcbiAgICBpZiAoY29kZWNPcHRpb25zLmNoYXJzLmxlbmd0aCA9PT0gMTI4KSB7XG4gICAgICAgIHZhciBhc2NpaVN0cmluZyA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTI4OyBpKyspXG4gICAgICAgICAgICBhc2NpaVN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgICAgICBjb2RlY09wdGlvbnMuY2hhcnMgPSBhc2NpaVN0cmluZyArIGNvZGVjT3B0aW9ucy5jaGFycztcbiAgICB9XG5cbiAgICB0aGlzLmRlY29kZUJ1ZiA9IG5ldyBCdWZmZXIuZnJvbShjb2RlY09wdGlvbnMuY2hhcnMsICd1Y3MyJyk7XG4gICAgXG4gICAgLy8gRW5jb2RpbmcgYnVmZmVyLlxuICAgIHZhciBlbmNvZGVCdWYgPSBuZXcgQnVmZmVyLmFsbG9jKDY1NTM2LCBpY29udi5kZWZhdWx0Q2hhclNpbmdsZUJ5dGUuY2hhckNvZGVBdCgwKSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvZGVjT3B0aW9ucy5jaGFycy5sZW5ndGg7IGkrKylcbiAgICAgICAgZW5jb2RlQnVmW2NvZGVjT3B0aW9ucy5jaGFycy5jaGFyQ29kZUF0KGkpXSA9IGk7XG5cbiAgICB0aGlzLmVuY29kZUJ1ZiA9IGVuY29kZUJ1Zjtcbn1cblxuU0JDU0NvZGVjLnByb3RvdHlwZS5lbmNvZGVyID0gU0JDU0VuY29kZXI7XG5TQkNTQ29kZWMucHJvdG90eXBlLmRlY29kZXIgPSBTQkNTRGVjb2RlcjtcblxuXG5mdW5jdGlvbiBTQkNTRW5jb2RlcihvcHRpb25zLCBjb2RlYykge1xuICAgIHRoaXMuZW5jb2RlQnVmID0gY29kZWMuZW5jb2RlQnVmO1xufVxuXG5TQkNTRW5jb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICB2YXIgYnVmID0gQnVmZmVyLmFsbG9jKHN0ci5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKVxuICAgICAgICBidWZbaV0gPSB0aGlzLmVuY29kZUJ1ZltzdHIuY2hhckNvZGVBdChpKV07XG4gICAgXG4gICAgcmV0dXJuIGJ1Zjtcbn1cblxuU0JDU0VuY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xufVxuXG5cbmZ1bmN0aW9uIFNCQ1NEZWNvZGVyKG9wdGlvbnMsIGNvZGVjKSB7XG4gICAgdGhpcy5kZWNvZGVCdWYgPSBjb2RlYy5kZWNvZGVCdWY7XG59XG5cblNCQ1NEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1Zikge1xuICAgIC8vIFN0cmluZ3MgYXJlIGltbXV0YWJsZSBpbiBKUyAtPiB3ZSB1c2UgdWNzMiBidWZmZXIgdG8gc3BlZWQgdXAgY29tcHV0YXRpb25zLlxuICAgIHZhciBkZWNvZGVCdWYgPSB0aGlzLmRlY29kZUJ1ZjtcbiAgICB2YXIgbmV3QnVmID0gQnVmZmVyLmFsbG9jKGJ1Zi5sZW5ndGgqMik7XG4gICAgdmFyIGlkeDEgPSAwLCBpZHgyID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZHgxID0gYnVmW2ldKjI7IGlkeDIgPSBpKjI7XG4gICAgICAgIG5ld0J1ZltpZHgyXSA9IGRlY29kZUJ1ZltpZHgxXTtcbiAgICAgICAgbmV3QnVmW2lkeDIrMV0gPSBkZWNvZGVCdWZbaWR4MSsxXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0J1Zi50b1N0cmluZygndWNzMicpO1xufVxuXG5TQkNTRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9pY29udi1saXRlL2VuY29kaW5ncy9zYmNzLWNvZGVjLmpzXG4vLyBtb2R1bGUgaWQgPSA5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gTWFudWFsbHkgYWRkZWQgZGF0YSB0byBiZSB1c2VkIGJ5IHNiY3MgY29kZWMgaW4gYWRkaXRpb24gdG8gZ2VuZXJhdGVkIG9uZS5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLy8gTm90IHN1cHBvcnRlZCBieSBpY29udiwgbm90IHN1cmUgd2h5LlxuICAgIFwiMTAwMjlcIjogXCJtYWNjZW50ZXVyb1wiLFxuICAgIFwibWFjY2VudGV1cm9cIjoge1xuICAgICAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgICAgICBcImNoYXJzXCI6IFwiw4TEgMSBw4nEhMOWw5zDocSFxIzDpMSNxIbEh8OpxbnFusSOw63Ej8SSxJPElsOzxJfDtMO2w7XDusSaxJvDvOKAoMKwxJjCo8Kn4oCiwrbDn8KuwqnihKLEmcKo4omgxKPErsSvxKriiaTiiaXEq8S24oiC4oiRxYLEu8S8xL3EvsS5xLrFhcWGxYPCrOKImsWExYfiiIbCq8K74oCmwqDFiMWQw5XFkcWM4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rFjcWUxZXFmOKAueKAusWZxZbFl8Wg4oCa4oCexaHFmsWbw4HFpMWlw43FvcW+xarDk8OUxavFrsOaxa/FsMWxxbLFs8Odw73Et8W7xYHFvMSiy4dcIlxuICAgIH0sXG5cbiAgICBcIjgwOFwiOiBcImNwODA4XCIsXG4gICAgXCJpYm04MDhcIjogXCJjcDgwOFwiLFxuICAgIFwiY3A4MDhcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgICAgICBcImNoYXJzXCI6IFwi0JDQkdCS0JPQlNCV0JbQl9CY0JnQmtCb0JzQndCe0J/QoNCh0KLQo9Ck0KXQptCn0KjQqdCq0KvQrNCt0K7Qr9Cw0LHQstCz0LTQtdC20LfQuNC50LrQu9C80L3QvtC/4paR4paS4paT4pSC4pSk4pWh4pWi4pWW4pWV4pWj4pWR4pWX4pWd4pWc4pWb4pSQ4pSU4pS04pSs4pSc4pSA4pS84pWe4pWf4pWa4pWU4pWp4pWm4pWg4pWQ4pWs4pWn4pWo4pWk4pWl4pWZ4pWY4pWS4pWT4pWr4pWq4pSY4pSM4paI4paE4paM4paQ4paA0YDRgdGC0YPRhNGF0YbRh9GI0YnRitGL0YzRjdGO0Y/QgdGR0ITRlNCH0ZfQjtGewrDiiJnCt+KImuKEluKCrOKWoMKgXCJcbiAgICB9LFxuXG4gICAgLy8gQWxpYXNlcyBvZiBnZW5lcmF0ZWQgZW5jb2RpbmdzLlxuICAgIFwiYXNjaWk4Yml0XCI6IFwiYXNjaWlcIixcbiAgICBcInVzYXNjaWlcIjogXCJhc2NpaVwiLFxuICAgIFwiYW5zaXgzNFwiOiBcImFzY2lpXCIsXG4gICAgXCJhbnNpeDM0MTk2OFwiOiBcImFzY2lpXCIsXG4gICAgXCJhbnNpeDM0MTk4NlwiOiBcImFzY2lpXCIsXG4gICAgXCJjc2FzY2lpXCI6IFwiYXNjaWlcIixcbiAgICBcImNwMzY3XCI6IFwiYXNjaWlcIixcbiAgICBcImlibTM2N1wiOiBcImFzY2lpXCIsXG4gICAgXCJpc29pcjZcIjogXCJhc2NpaVwiLFxuICAgIFwiaXNvNjQ2dXNcIjogXCJhc2NpaVwiLFxuICAgIFwiaXNvNjQ2aXJ2XCI6IFwiYXNjaWlcIixcbiAgICBcInVzXCI6IFwiYXNjaWlcIixcblxuICAgIFwibGF0aW4xXCI6IFwiaXNvODg1OTFcIixcbiAgICBcImxhdGluMlwiOiBcImlzbzg4NTkyXCIsXG4gICAgXCJsYXRpbjNcIjogXCJpc284ODU5M1wiLFxuICAgIFwibGF0aW40XCI6IFwiaXNvODg1OTRcIixcbiAgICBcImxhdGluNVwiOiBcImlzbzg4NTk5XCIsXG4gICAgXCJsYXRpbjZcIjogXCJpc284ODU5MTBcIixcbiAgICBcImxhdGluN1wiOiBcImlzbzg4NTkxM1wiLFxuICAgIFwibGF0aW44XCI6IFwiaXNvODg1OTE0XCIsXG4gICAgXCJsYXRpbjlcIjogXCJpc284ODU5MTVcIixcbiAgICBcImxhdGluMTBcIjogXCJpc284ODU5MTZcIixcblxuICAgIFwiY3Npc29sYXRpbjFcIjogXCJpc284ODU5MVwiLFxuICAgIFwiY3Npc29sYXRpbjJcIjogXCJpc284ODU5MlwiLFxuICAgIFwiY3Npc29sYXRpbjNcIjogXCJpc284ODU5M1wiLFxuICAgIFwiY3Npc29sYXRpbjRcIjogXCJpc284ODU5NFwiLFxuICAgIFwiY3Npc29sYXRpbmN5cmlsbGljXCI6IFwiaXNvODg1OTVcIixcbiAgICBcImNzaXNvbGF0aW5hcmFiaWNcIjogXCJpc284ODU5NlwiLFxuICAgIFwiY3Npc29sYXRpbmdyZWVrXCIgOiBcImlzbzg4NTk3XCIsXG4gICAgXCJjc2lzb2xhdGluaGVicmV3XCI6IFwiaXNvODg1OThcIixcbiAgICBcImNzaXNvbGF0aW41XCI6IFwiaXNvODg1OTlcIixcbiAgICBcImNzaXNvbGF0aW42XCI6IFwiaXNvODg1OTEwXCIsXG5cbiAgICBcImwxXCI6IFwiaXNvODg1OTFcIixcbiAgICBcImwyXCI6IFwiaXNvODg1OTJcIixcbiAgICBcImwzXCI6IFwiaXNvODg1OTNcIixcbiAgICBcImw0XCI6IFwiaXNvODg1OTRcIixcbiAgICBcImw1XCI6IFwiaXNvODg1OTlcIixcbiAgICBcImw2XCI6IFwiaXNvODg1OTEwXCIsXG4gICAgXCJsN1wiOiBcImlzbzg4NTkxM1wiLFxuICAgIFwibDhcIjogXCJpc284ODU5MTRcIixcbiAgICBcImw5XCI6IFwiaXNvODg1OTE1XCIsXG4gICAgXCJsMTBcIjogXCJpc284ODU5MTZcIixcblxuICAgIFwiaXNvaXIxNFwiOiBcImlzbzY0NmpwXCIsXG4gICAgXCJpc29pcjU3XCI6IFwiaXNvNjQ2Y25cIixcbiAgICBcImlzb2lyMTAwXCI6IFwiaXNvODg1OTFcIixcbiAgICBcImlzb2lyMTAxXCI6IFwiaXNvODg1OTJcIixcbiAgICBcImlzb2lyMTA5XCI6IFwiaXNvODg1OTNcIixcbiAgICBcImlzb2lyMTEwXCI6IFwiaXNvODg1OTRcIixcbiAgICBcImlzb2lyMTQ0XCI6IFwiaXNvODg1OTVcIixcbiAgICBcImlzb2lyMTI3XCI6IFwiaXNvODg1OTZcIixcbiAgICBcImlzb2lyMTI2XCI6IFwiaXNvODg1OTdcIixcbiAgICBcImlzb2lyMTM4XCI6IFwiaXNvODg1OThcIixcbiAgICBcImlzb2lyMTQ4XCI6IFwiaXNvODg1OTlcIixcbiAgICBcImlzb2lyMTU3XCI6IFwiaXNvODg1OTEwXCIsXG4gICAgXCJpc29pcjE2NlwiOiBcInRpczYyMFwiLFxuICAgIFwiaXNvaXIxNzlcIjogXCJpc284ODU5MTNcIixcbiAgICBcImlzb2lyMTk5XCI6IFwiaXNvODg1OTE0XCIsXG4gICAgXCJpc29pcjIwM1wiOiBcImlzbzg4NTkxNVwiLFxuICAgIFwiaXNvaXIyMjZcIjogXCJpc284ODU5MTZcIixcblxuICAgIFwiY3A4MTlcIjogXCJpc284ODU5MVwiLFxuICAgIFwiaWJtODE5XCI6IFwiaXNvODg1OTFcIixcblxuICAgIFwiY3lyaWxsaWNcIjogXCJpc284ODU5NVwiLFxuXG4gICAgXCJhcmFiaWNcIjogXCJpc284ODU5NlwiLFxuICAgIFwiYXJhYmljOFwiOiBcImlzbzg4NTk2XCIsXG4gICAgXCJlY21hMTE0XCI6IFwiaXNvODg1OTZcIixcbiAgICBcImFzbW83MDhcIjogXCJpc284ODU5NlwiLFxuXG4gICAgXCJncmVla1wiIDogXCJpc284ODU5N1wiLFxuICAgIFwiZ3JlZWs4XCIgOiBcImlzbzg4NTk3XCIsXG4gICAgXCJlY21hMTE4XCIgOiBcImlzbzg4NTk3XCIsXG4gICAgXCJlbG90OTI4XCIgOiBcImlzbzg4NTk3XCIsXG5cbiAgICBcImhlYnJld1wiOiBcImlzbzg4NTk4XCIsXG4gICAgXCJoZWJyZXc4XCI6IFwiaXNvODg1OThcIixcblxuICAgIFwidHVya2lzaFwiOiBcImlzbzg4NTk5XCIsXG4gICAgXCJ0dXJraXNoOFwiOiBcImlzbzg4NTk5XCIsXG5cbiAgICBcInRoYWlcIjogXCJpc284ODU5MTFcIixcbiAgICBcInRoYWk4XCI6IFwiaXNvODg1OTExXCIsXG5cbiAgICBcImNlbHRpY1wiOiBcImlzbzg4NTkxNFwiLFxuICAgIFwiY2VsdGljOFwiOiBcImlzbzg4NTkxNFwiLFxuICAgIFwiaXNvY2VsdGljXCI6IFwiaXNvODg1OTE0XCIsXG5cbiAgICBcInRpczYyMDBcIjogXCJ0aXM2MjBcIixcbiAgICBcInRpczYyMDI1MjkxXCI6IFwidGlzNjIwXCIsXG4gICAgXCJ0aXM2MjAyNTMzMFwiOiBcInRpczYyMFwiLFxuXG4gICAgXCIxMDAwMFwiOiBcIm1hY3JvbWFuXCIsXG4gICAgXCIxMDAwNlwiOiBcIm1hY2dyZWVrXCIsXG4gICAgXCIxMDAwN1wiOiBcIm1hY2N5cmlsbGljXCIsXG4gICAgXCIxMDA3OVwiOiBcIm1hY2ljZWxhbmRcIixcbiAgICBcIjEwMDgxXCI6IFwibWFjdHVya2lzaFwiLFxuXG4gICAgXCJjc3BjOGNvZGVwYWdlNDM3XCI6IFwiY3A0MzdcIixcbiAgICBcImNzcGM3NzViYWx0aWNcIjogXCJjcDc3NVwiLFxuICAgIFwiY3NwYzg1MG11bHRpbGluZ3VhbFwiOiBcImNwODUwXCIsXG4gICAgXCJjc3BjcDg1MlwiOiBcImNwODUyXCIsXG4gICAgXCJjc3BjODYybGF0aW5oZWJyZXdcIjogXCJjcDg2MlwiLFxuICAgIFwiY3BnclwiOiBcImNwODY5XCIsXG5cbiAgICBcIm1zZWVcIjogXCJjcDEyNTBcIixcbiAgICBcIm1zY3lybFwiOiBcImNwMTI1MVwiLFxuICAgIFwibXNhbnNpXCI6IFwiY3AxMjUyXCIsXG4gICAgXCJtc2dyZWVrXCI6IFwiY3AxMjUzXCIsXG4gICAgXCJtc3R1cmtcIjogXCJjcDEyNTRcIixcbiAgICBcIm1zaGViclwiOiBcImNwMTI1NVwiLFxuICAgIFwibXNhcmFiXCI6IFwiY3AxMjU2XCIsXG4gICAgXCJ3aW5iYWx0cmltXCI6IFwiY3AxMjU3XCIsXG5cbiAgICBcImNwMjA4NjZcIjogXCJrb2k4clwiLFxuICAgIFwiMjA4NjZcIjogXCJrb2k4clwiLFxuICAgIFwiaWJtODc4XCI6IFwia29pOHJcIixcbiAgICBcImNza29pOHJcIjogXCJrb2k4clwiLFxuXG4gICAgXCJjcDIxODY2XCI6IFwia29pOHVcIixcbiAgICBcIjIxODY2XCI6IFwia29pOHVcIixcbiAgICBcImlibTExNjhcIjogXCJrb2k4dVwiLFxuXG4gICAgXCJzdHJrMTA0ODIwMDJcIjogXCJyazEwNDhcIixcblxuICAgIFwidGN2bjU3MTJcIjogXCJ0Y3ZuXCIsXG4gICAgXCJ0Y3ZuNTcxMjFcIjogXCJ0Y3ZuXCIsXG5cbiAgICBcImdiMTk4ODgwXCI6IFwiaXNvNjQ2Y25cIixcbiAgICBcImNuXCI6IFwiaXNvNjQ2Y25cIixcblxuICAgIFwiY3Npc28xNGppc2M2MjIwcm9cIjogXCJpc282NDZqcFwiLFxuICAgIFwiamlzYzYyMjAxOTY5cm9cIjogXCJpc282NDZqcFwiLFxuICAgIFwianBcIjogXCJpc282NDZqcFwiLFxuXG4gICAgXCJjc2hwcm9tYW44XCI6IFwiaHByb21hbjhcIixcbiAgICBcInI4XCI6IFwiaHByb21hbjhcIixcbiAgICBcInJvbWFuOFwiOiBcImhwcm9tYW44XCIsXG4gICAgXCJ4cm9tYW44XCI6IFwiaHByb21hbjhcIixcbiAgICBcImlibTEwNTFcIjogXCJocHJvbWFuOFwiLFxuXG4gICAgXCJtYWNcIjogXCJtYWNpbnRvc2hcIixcbiAgICBcImNzbWFjaW50b3NoXCI6IFwibWFjaW50b3NoXCIsXG59O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9pY29udi1saXRlL2VuY29kaW5ncy9zYmNzLWRhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDEwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gR2VuZXJhdGVkIGRhdGEgZm9yIHNiY3MgY29kZWMuIERvbid0IGVkaXQgbWFudWFsbHkuIFJlZ2VuZXJhdGUgdXNpbmcgZ2VuZXJhdGlvbi9nZW4tc2Jjcy5qcyBzY3JpcHQuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgXCI0MzdcIjogXCJjcDQzN1wiLFxuICBcIjczN1wiOiBcImNwNzM3XCIsXG4gIFwiNzc1XCI6IFwiY3A3NzVcIixcbiAgXCI4NTBcIjogXCJjcDg1MFwiLFxuICBcIjg1MlwiOiBcImNwODUyXCIsXG4gIFwiODU1XCI6IFwiY3A4NTVcIixcbiAgXCI4NTZcIjogXCJjcDg1NlwiLFxuICBcIjg1N1wiOiBcImNwODU3XCIsXG4gIFwiODU4XCI6IFwiY3A4NThcIixcbiAgXCI4NjBcIjogXCJjcDg2MFwiLFxuICBcIjg2MVwiOiBcImNwODYxXCIsXG4gIFwiODYyXCI6IFwiY3A4NjJcIixcbiAgXCI4NjNcIjogXCJjcDg2M1wiLFxuICBcIjg2NFwiOiBcImNwODY0XCIsXG4gIFwiODY1XCI6IFwiY3A4NjVcIixcbiAgXCI4NjZcIjogXCJjcDg2NlwiLFxuICBcIjg2OVwiOiBcImNwODY5XCIsXG4gIFwiODc0XCI6IFwid2luZG93czg3NFwiLFxuICBcIjkyMlwiOiBcImNwOTIyXCIsXG4gIFwiMTA0NlwiOiBcImNwMTA0NlwiLFxuICBcIjExMjRcIjogXCJjcDExMjRcIixcbiAgXCIxMTI1XCI6IFwiY3AxMTI1XCIsXG4gIFwiMTEyOVwiOiBcImNwMTEyOVwiLFxuICBcIjExMzNcIjogXCJjcDExMzNcIixcbiAgXCIxMTYxXCI6IFwiY3AxMTYxXCIsXG4gIFwiMTE2MlwiOiBcImNwMTE2MlwiLFxuICBcIjExNjNcIjogXCJjcDExNjNcIixcbiAgXCIxMjUwXCI6IFwid2luZG93czEyNTBcIixcbiAgXCIxMjUxXCI6IFwid2luZG93czEyNTFcIixcbiAgXCIxMjUyXCI6IFwid2luZG93czEyNTJcIixcbiAgXCIxMjUzXCI6IFwid2luZG93czEyNTNcIixcbiAgXCIxMjU0XCI6IFwid2luZG93czEyNTRcIixcbiAgXCIxMjU1XCI6IFwid2luZG93czEyNTVcIixcbiAgXCIxMjU2XCI6IFwid2luZG93czEyNTZcIixcbiAgXCIxMjU3XCI6IFwid2luZG93czEyNTdcIixcbiAgXCIxMjU4XCI6IFwid2luZG93czEyNThcIixcbiAgXCIyODU5MVwiOiBcImlzbzg4NTkxXCIsXG4gIFwiMjg1OTJcIjogXCJpc284ODU5MlwiLFxuICBcIjI4NTkzXCI6IFwiaXNvODg1OTNcIixcbiAgXCIyODU5NFwiOiBcImlzbzg4NTk0XCIsXG4gIFwiMjg1OTVcIjogXCJpc284ODU5NVwiLFxuICBcIjI4NTk2XCI6IFwiaXNvODg1OTZcIixcbiAgXCIyODU5N1wiOiBcImlzbzg4NTk3XCIsXG4gIFwiMjg1OThcIjogXCJpc284ODU5OFwiLFxuICBcIjI4NTk5XCI6IFwiaXNvODg1OTlcIixcbiAgXCIyODYwMFwiOiBcImlzbzg4NTkxMFwiLFxuICBcIjI4NjAxXCI6IFwiaXNvODg1OTExXCIsXG4gIFwiMjg2MDNcIjogXCJpc284ODU5MTNcIixcbiAgXCIyODYwNFwiOiBcImlzbzg4NTkxNFwiLFxuICBcIjI4NjA1XCI6IFwiaXNvODg1OTE1XCIsXG4gIFwiMjg2MDZcIjogXCJpc284ODU5MTZcIixcbiAgXCJ3aW5kb3dzODc0XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLigqzvv73vv73vv73vv73igKbvv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73igJjigJnigJzigJ3igKLigJPigJTvv73vv73vv73vv73vv73vv73vv73vv73CoOC4geC4guC4g+C4hOC4heC4huC4h+C4iOC4ieC4iuC4i+C4jOC4jeC4juC4j+C4kOC4keC4kuC4k+C4lOC4leC4luC4l+C4mOC4meC4muC4m+C4nOC4neC4nuC4n+C4oOC4oeC4ouC4o+C4pOC4peC4puC4p+C4qOC4qeC4quC4q+C4rOC4reC4ruC4r+C4sOC4seC4suC4s+C4tOC4teC4tuC4t+C4uOC4ueC4uu+/ve+/ve+/ve+/veC4v+C5gOC5geC5guC5g+C5hOC5heC5huC5h+C5iOC5ieC5iuC5i+C5jOC5jeC5juC5j+C5kOC5keC5kuC5k+C5lOC5leC5luC5l+C5mOC5meC5muC5m++/ve+/ve+/ve+/vVwiXG4gIH0sXG4gIFwid2luODc0XCI6IFwid2luZG93czg3NFwiLFxuICBcImNwODc0XCI6IFwid2luZG93czg3NFwiLFxuICBcIndpbmRvd3MxMjUwXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLigqzvv73igJrvv73igJ7igKbigKDigKHvv73igLDFoOKAucWaxaTFvcW577+94oCY4oCZ4oCc4oCd4oCi4oCT4oCU77+94oSixaHigLrFm8Wlxb7FusKgy4fLmMWBwqTEhMKmwqfCqMKpxZ7Cq8Kswq3CrsW7wrDCscubxYLCtMK1wrbCt8K4xIXFn8K7xL3LncS+xbzFlMOBw4LEgsOExLnEhsOHxIzDicSYw4vEmsONw47EjsSQxYPFh8OTw5TFkMOWw5fFmMWuw5rFsMOcw53FosOfxZXDocOixIPDpMS6xIfDp8SNw6nEmcOrxJvDrcOuxI/EkcWExYjDs8O0xZHDtsO3xZnFr8O6xbHDvMO9xaPLmVwiXG4gIH0sXG4gIFwid2luMTI1MFwiOiBcIndpbmRvd3MxMjUwXCIsXG4gIFwiY3AxMjUwXCI6IFwid2luZG93czEyNTBcIixcbiAgXCJ3aW5kb3dzMTI1MVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwi0ILQg+KAmtGT4oCe4oCm4oCg4oCh4oKs4oCw0InigLnQitCM0IvQj9GS4oCY4oCZ4oCc4oCd4oCi4oCT4oCU77+94oSi0ZnigLrRmtGc0ZvRn8Kg0I7RntCIwqTSkMKmwqfQgcKp0ITCq8Kswq3CrtCHwrDCsdCG0ZbSkcK1wrbCt9GR4oSW0ZTCu9GY0IXRldGX0JDQkdCS0JPQlNCV0JbQl9CY0JnQmtCb0JzQndCe0J/QoNCh0KLQo9Ck0KXQptCn0KjQqdCq0KvQrNCt0K7Qr9Cw0LHQstCz0LTQtdC20LfQuNC50LrQu9C80L3QvtC/0YDRgdGC0YPRhNGF0YbRh9GI0YnRitGL0YzRjdGO0Y9cIlxuICB9LFxuICBcIndpbjEyNTFcIjogXCJ3aW5kb3dzMTI1MVwiLFxuICBcImNwMTI1MVwiOiBcIndpbmRvd3MxMjUxXCIsXG4gIFwid2luZG93czEyNTJcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIuKCrO+/veKAmsaS4oCe4oCm4oCg4oChy4bigLDFoOKAucWS77+9xb3vv73vv73igJjigJnigJzigJ3igKLigJPigJTLnOKEosWh4oC6xZPvv73FvsW4wqDCocKiwqPCpMKlwqbCp8KowqnCqsKrwqzCrcKuwq/CsMKxwrLCs8K0wrXCtsK3wrjCucK6wrvCvMK9wr7Cv8OAw4HDgsODw4TDhcOGw4fDiMOJw4rDi8OMw43DjsOPw5DDkcOSw5PDlMOVw5bDl8OYw5nDmsObw5zDncOew5/DoMOhw6LDo8Okw6XDpsOnw6jDqcOqw6vDrMOtw67Dr8Oww7HDssOzw7TDtcO2w7fDuMO5w7rDu8O8w73DvsO/XCJcbiAgfSxcbiAgXCJ3aW4xMjUyXCI6IFwid2luZG93czEyNTJcIixcbiAgXCJjcDEyNTJcIjogXCJ3aW5kb3dzMTI1MlwiLFxuICBcIndpbmRvd3MxMjUzXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLigqzvv73igJrGkuKAnuKApuKAoOKAoe+/veKAsO+/veKAue+/ve+/ve+/ve+/ve+/veKAmOKAmeKAnOKAneKAouKAk+KAlO+/veKEou+/veKAuu+/ve+/ve+/ve+/vcKgzoXOhsKjwqTCpcKmwqfCqMKp77+9wqvCrMKtwq7igJXCsMKxwrLCs86EwrXCtsK3zojOic6KwrvOjMK9zo7Oj86QzpHOks6TzpTOlc6WzpfOmM6ZzprOm86czp3Ons6fzqDOoe+/vc6jzqTOpc6mzqfOqM6pzqrOq86szq3Ors6vzrDOsc6yzrPOtM61zrbOt864zrnOus67zrzOvc6+zr/PgM+Bz4LPg8+Ez4XPhs+Hz4jPic+Kz4vPjM+Nz47vv71cIlxuICB9LFxuICBcIndpbjEyNTNcIjogXCJ3aW5kb3dzMTI1M1wiLFxuICBcImNwMTI1M1wiOiBcIndpbmRvd3MxMjUzXCIsXG4gIFwid2luZG93czEyNTRcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIuKCrO+/veKAmsaS4oCe4oCm4oCg4oChy4bigLDFoOKAucWS77+977+977+977+94oCY4oCZ4oCc4oCd4oCi4oCT4oCUy5zihKLFoeKAusWT77+977+9xbjCoMKhwqLCo8KkwqXCpsKnwqjCqcKqwqvCrMKtwq7Cr8KwwrHCssKzwrTCtcK2wrfCuMK5wrrCu8K8wr3CvsK/w4DDgcOCw4PDhMOFw4bDh8OIw4nDisOLw4zDjcOOw4/EnsORw5LDk8OUw5XDlsOXw5jDmcOaw5vDnMSwxZ7Dn8Ogw6HDosOjw6TDpcOmw6fDqMOpw6rDq8Osw63DrsOvxJ/DscOyw7PDtMO1w7bDt8O4w7nDusO7w7zEscWfw79cIlxuICB9LFxuICBcIndpbjEyNTRcIjogXCJ3aW5kb3dzMTI1NFwiLFxuICBcImNwMTI1NFwiOiBcIndpbmRvd3MxMjU0XCIsXG4gIFwid2luZG93czEyNTVcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIuKCrO+/veKAmsaS4oCe4oCm4oCg4oChy4bigLDvv73igLnvv73vv73vv73vv73vv73igJjigJnigJzigJ3igKLigJPigJTLnOKEou+/veKAuu+/ve+/ve+/ve+/vcKgwqHCosKj4oKqwqXCpsKnwqjCqcOXwqvCrMKtwq7Cr8KwwrHCssKzwrTCtcK2wrfCuMK5w7fCu8K8wr3CvsK/1rDWsday1rPWtNa11rbWt9a41rnWuta71rzWvda+1r/XgNeB14LXg9ew17HXstez17Tvv73vv73vv73vv73vv73vv73vv73XkNeR15LXk9eU15XXlteX15jXmdea15vXnNed157Xn9eg16HXotej16TXpdem16fXqNep16rvv73vv73igI7igI/vv71cIlxuICB9LFxuICBcIndpbjEyNTVcIjogXCJ3aW5kb3dzMTI1NVwiLFxuICBcImNwMTI1NVwiOiBcIndpbmRvd3MxMjU1XCIsXG4gIFwid2luZG93czEyNTZcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIuKCrNm+4oCaxpLigJ7igKbigKDigKHLhuKAsNm54oC5xZLahtqY2ojar+KAmOKAmeKAnOKAneKAouKAk+KAlNqp4oSi2pHigLrFk+KAjOKAjdq6wqDYjMKiwqPCpMKlwqbCp8KowqnavsKrwqzCrcKuwq/CsMKxwrLCs8K0wrXCtsK3wrjCudibwrvCvMK9wr7Yn9uB2KHYotij2KTYpdim2KfYqNip2KrYq9is2K3Yrtiv2LDYsdiy2LPYtNi12LbDl9i32LjYudi62YDZgdmC2YPDoNmEw6LZhdmG2YfZiMOnw6jDqcOqw6vZidmKw67Dr9mL2YzZjdmOw7TZj9mQw7fZkcO52ZLDu8O84oCO4oCP25JcIlxuICB9LFxuICBcIndpbjEyNTZcIjogXCJ3aW5kb3dzMTI1NlwiLFxuICBcImNwMTI1NlwiOiBcIndpbmRvd3MxMjU2XCIsXG4gIFwid2luZG93czEyNTdcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIuKCrO+/veKAmu+/veKAnuKApuKAoOKAoe+/veKAsO+/veKAue+/vcKoy4fCuO+/veKAmOKAmeKAnOKAneKAouKAk+KAlO+/veKEou+/veKAuu+/vcKvy5vvv73CoO+/vcKiwqPCpO+/vcKmwqfDmMKpxZbCq8Kswq3CrsOGwrDCscKywrPCtMK1wrbCt8O4wrnFl8K7wrzCvcK+w6bEhMSuxIDEhsOEw4XEmMSSxIzDicW5xJbEosS2xKrEu8WgxYPFhcOTxYzDlcOWw5fFssWBxZrFqsOcxbvFvcOfxIXEr8SBxIfDpMOlxJnEk8SNw6nFusSXxKPEt8SrxLzFocWExYbDs8WNw7XDtsO3xbPFgsWbxavDvMW8xb7LmVwiXG4gIH0sXG4gIFwid2luMTI1N1wiOiBcIndpbmRvd3MxMjU3XCIsXG4gIFwiY3AxMjU3XCI6IFwid2luZG93czEyNTdcIixcbiAgXCJ3aW5kb3dzMTI1OFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwi4oKs77+94oCaxpLigJ7igKbigKDigKHLhuKAsO+/veKAucWS77+977+977+977+94oCY4oCZ4oCc4oCd4oCi4oCT4oCUy5zihKLvv73igLrFk++/ve+/vcW4wqDCocKiwqPCpMKlwqbCp8KowqnCqsKrwqzCrcKuwq/CsMKxwrLCs8K0wrXCtsK3wrjCucK6wrvCvMK9wr7Cv8OAw4HDgsSCw4TDhcOGw4fDiMOJw4rDi8yAw43DjsOPxJDDkcyJw5PDlMagw5bDl8OYw5nDmsObw5zGr8yDw5/DoMOhw6LEg8Okw6XDpsOnw6jDqcOqw6vMgcOtw67Dr8SRw7HMo8Ozw7TGocO2w7fDuMO5w7rDu8O8xrDigqvDv1wiXG4gIH0sXG4gIFwid2luMTI1OFwiOiBcIndpbmRvd3MxMjU4XCIsXG4gIFwiY3AxMjU4XCI6IFwid2luZG93czEyNThcIixcbiAgXCJpc284ODU5MVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiwoDCgcKCwoPChMKFwobCh8KIwonCisKLwozCjcKOwo/CkMKRwpLCk8KUwpXClsKXwpjCmcKawpvCnMKdwp7Cn8KgwqHCosKjwqTCpcKmwqfCqMKpwqrCq8Kswq3CrsKvwrDCscKywrPCtMK1wrbCt8K4wrnCusK7wrzCvcK+wr/DgMOBw4LDg8OEw4XDhsOHw4jDicOKw4vDjMONw47Dj8OQw5HDksOTw5TDlcOWw5fDmMOZw5rDm8Ocw53DnsOfw6DDocOiw6PDpMOlw6bDp8Oow6nDqsOrw6zDrcOuw6/DsMOxw7LDs8O0w7XDtsO3w7jDucO6w7vDvMO9w77Dv1wiXG4gIH0sXG4gIFwiY3AyODU5MVwiOiBcImlzbzg4NTkxXCIsXG4gIFwiaXNvODg1OTJcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp/CoMSEy5jFgcKkxL3FmsKnwqjFoMWexaTFucKtxb3Fu8KwxIXLm8WCwrTEvsWby4fCuMWhxZ/FpcW6y53FvsW8xZTDgcOCxILDhMS5xIbDh8SMw4nEmMOLxJrDjcOOxI7EkMWDxYfDk8OUxZDDlsOXxZjFrsOaxbDDnMOdxaLDn8WVw6HDosSDw6TEusSHw6fEjcOpxJnDq8Sbw63DrsSPxJHFhMWIw7PDtMWRw7bDt8WZxa/DusWxw7zDvcWjy5lcIlxuICB9LFxuICBcImNwMjg1OTJcIjogXCJpc284ODU5MlwiLFxuICBcImlzbzg4NTkzXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfwqDEpsuYwqPCpO+/vcSkwqfCqMSwxZ7EnsS0wq3vv73Fu8KwxKfCssKzwrTCtcSlwrfCuMSxxZ/En8S1wr3vv73FvMOAw4HDgu+/vcOExIrEiMOHw4jDicOKw4vDjMONw47Dj++/vcORw5LDk8OUxKDDlsOXxJzDmcOaw5vDnMWsxZzDn8Ogw6HDou+/vcOkxIvEicOnw6jDqcOqw6vDrMOtw67Dr++/vcOxw7LDs8O0xKHDtsO3xJ3DucO6w7vDvMWtxZ3LmVwiXG4gIH0sXG4gIFwiY3AyODU5M1wiOiBcImlzbzg4NTkzXCIsXG4gIFwiaXNvODg1OTRcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp/CoMSExLjFlsKkxKjEu8KnwqjFoMSSxKLFpsKtxb3Cr8KwxIXLm8WXwrTEqcS8y4fCuMWhxJPEo8WnxYrFvsWLxIDDgcOCw4PDhMOFw4bErsSMw4nEmMOLxJbDjcOOxKrEkMWFxYzEtsOUw5XDlsOXw5jFssOaw5vDnMWoxarDn8SBw6HDosOjw6TDpcOmxK/EjcOpxJnDq8SXw63DrsSrxJHFhsWNxLfDtMO1w7bDt8O4xbPDusO7w7zFqcWry5lcIlxuICB9LFxuICBcImNwMjg1OTRcIjogXCJpc284ODU5NFwiLFxuICBcImlzbzg4NTk1XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfwqDQgdCC0IPQhNCF0IbQh9CI0InQitCL0IzCrdCO0I/QkNCR0JLQk9CU0JXQltCX0JjQmdCa0JvQnNCd0J7Qn9Cg0KHQotCj0KTQpdCm0KfQqNCp0KrQq9Cs0K3QrtCv0LDQsdCy0LPQtNC10LbQt9C40LnQutC70LzQvdC+0L/RgNGB0YLRg9GE0YXRhtGH0YjRidGK0YvRjNGN0Y7Rj+KEltGR0ZLRk9GU0ZXRltGX0ZjRmdGa0ZvRnMKn0Z7Rn1wiXG4gIH0sXG4gIFwiY3AyODU5NVwiOiBcImlzbzg4NTk1XCIsXG4gIFwiaXNvODg1OTZcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp/CoO+/ve+/ve+/vcKk77+977+977+977+977+977+977+92IzCre+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/vdib77+977+977+92J/vv73Yodii2KPYpNil2KbYp9io2KnYqtir2KzYrdiu2K/YsNix2LLYs9i02LXYtti32LjYudi677+977+977+977+977+92YDZgdmC2YPZhNmF2YbZh9mI2YnZitmL2YzZjdmO2Y/ZkNmR2ZLvv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv71cIlxuICB9LFxuICBcImNwMjg1OTZcIjogXCJpc284ODU5NlwiLFxuICBcImlzbzg4NTk3XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfwqDigJjigJnCo+KCrOKCr8KmwqfCqMKpzbrCq8Kswq3vv73igJXCsMKxwrLCs86EzoXOhsK3zojOic6KwrvOjMK9zo7Oj86QzpHOks6TzpTOlc6WzpfOmM6ZzprOm86czp3Ons6fzqDOoe+/vc6jzqTOpc6mzqfOqM6pzqrOq86szq3Ors6vzrDOsc6yzrPOtM61zrbOt864zrnOus67zrzOvc6+zr/PgM+Bz4LPg8+Ez4XPhs+Hz4jPic+Kz4vPjM+Nz47vv71cIlxuICB9LFxuICBcImNwMjg1OTdcIjogXCJpc284ODU5N1wiLFxuICBcImlzbzg4NTk4XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfwqDvv73CosKjwqTCpcKmwqfCqMKpw5fCq8Kswq3CrsKvwrDCscKywrPCtMK1wrbCt8K4wrnDt8K7wrzCvcK+77+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+94oCX15DXkdeS15PXlNeV15bXl9eY15nXmteb15zXndee15/XoNeh16LXo9ek16XXpten16jXqdeq77+977+94oCO4oCP77+9XCJcbiAgfSxcbiAgXCJjcDI4NTk4XCI6IFwiaXNvODg1OThcIixcbiAgXCJpc284ODU5OVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiwoDCgcKCwoPChMKFwobCh8KIwonCisKLwozCjcKOwo/CkMKRwpLCk8KUwpXClsKXwpjCmcKawpvCnMKdwp7Cn8KgwqHCosKjwqTCpcKmwqfCqMKpwqrCq8Kswq3CrsKvwrDCscKywrPCtMK1wrbCt8K4wrnCusK7wrzCvcK+wr/DgMOBw4LDg8OEw4XDhsOHw4jDicOKw4vDjMONw47Dj8Sew5HDksOTw5TDlcOWw5fDmMOZw5rDm8OcxLDFnsOfw6DDocOiw6PDpMOlw6bDp8Oow6nDqsOrw6zDrcOuw6/En8Oxw7LDs8O0w7XDtsO3w7jDucO6w7vDvMSxxZ/Dv1wiXG4gIH0sXG4gIFwiY3AyODU5OVwiOiBcImlzbzg4NTk5XCIsXG4gIFwiaXNvODg1OTEwXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfwqDEhMSSxKLEqsSoxLbCp8S7xJDFoMWmxb3CrcWqxYrCsMSFxJPEo8SrxKnEt8K3xLzEkcWhxafFvuKAlcWrxYvEgMOBw4LDg8OEw4XDhsSuxIzDicSYw4vElsONw47Dj8OQxYXFjMOTw5TDlcOWxajDmMWyw5rDm8Ocw53DnsOfxIHDocOiw6PDpMOlw6bEr8SNw6nEmcOrxJfDrcOuw6/DsMWGxY3Ds8O0w7XDtsWpw7jFs8O6w7vDvMO9w77EuFwiXG4gIH0sXG4gIFwiY3AyODYwMFwiOiBcImlzbzg4NTkxMFwiLFxuICBcImlzbzg4NTkxMVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiwoDCgcKCwoPChMKFwobCh8KIwonCisKLwozCjcKOwo/CkMKRwpLCk8KUwpXClsKXwpjCmcKawpvCnMKdwp7Cn8Kg4LiB4LiC4LiD4LiE4LiF4LiG4LiH4LiI4LiJ4LiK4LiL4LiM4LiN4LiO4LiP4LiQ4LiR4LiS4LiT4LiU4LiV4LiW4LiX4LiY4LiZ4Lia4Lib4Lic4Lid4Lie4Lif4Lig4Lih4Lii4Lij4Lik4Lil4Lim4Lin4Lio4Lip4Liq4Lir4Lis4Lit4Liu4Liv4Liw4Lix4Liy4Liz4Li04Li14Li24Li34Li44Li54Li677+977+977+977+94Li/4LmA4LmB4LmC4LmD4LmE4LmF4LmG4LmH4LmI4LmJ4LmK4LmL4LmM4LmN4LmO4LmP4LmQ4LmR4LmS4LmT4LmU4LmV4LmW4LmX4LmY4LmZ4Lma4Lmb77+977+977+977+9XCJcbiAgfSxcbiAgXCJjcDI4NjAxXCI6IFwiaXNvODg1OTExXCIsXG4gIFwiaXNvODg1OTEzXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfwqDigJ3CosKjwqTigJ7CpsKnw5jCqcWWwqvCrMKtwq7DhsKwwrHCssKz4oCcwrXCtsK3w7jCucWXwrvCvMK9wr7DpsSExK7EgMSGw4TDhcSYxJLEjMOJxbnElsSixLbEqsS7xaDFg8WFw5PFjMOVw5bDl8WyxYHFmsWqw5zFu8W9w5/EhcSvxIHEh8Okw6XEmcSTxI3DqcW6xJfEo8S3xKvEvMWhxYTFhsOzxY3DtcO2w7fFs8WCxZvFq8O8xbzFvuKAmVwiXG4gIH0sXG4gIFwiY3AyODYwM1wiOiBcImlzbzg4NTkxM1wiLFxuICBcImlzbzg4NTkxNFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiwoDCgcKCwoPChMKFwobCh8KIwonCisKLwozCjcKOwo/CkMKRwpLCk8KUwpXClsKXwpjCmcKawpvCnMKdwp7Cn8Kg4biC4biDwqPEisSL4biKwqfhuoDCqeG6guG4i+G7ssKtwq7FuOG4nuG4n8SgxKHhuYDhuYHCtuG5luG6geG5l+G6g+G5oOG7s+G6hOG6heG5ocOAw4HDgsODw4TDhcOGw4fDiMOJw4rDi8OMw43DjsOPxbTDkcOSw5PDlMOVw5bhuarDmMOZw5rDm8Ocw53FtsOfw6DDocOiw6PDpMOlw6bDp8Oow6nDqsOrw6zDrcOuw6/FtcOxw7LDs8O0w7XDtuG5q8O4w7nDusO7w7zDvcW3w79cIlxuICB9LFxuICBcImNwMjg2MDRcIjogXCJpc284ODU5MTRcIixcbiAgXCJpc284ODU5MTVcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp/CoMKhwqLCo+KCrMKlxaDCp8WhwqnCqsKrwqzCrcKuwq/CsMKxwrLCs8W9wrXCtsK3xb7CucK6wrvFksWTxbjCv8OAw4HDgsODw4TDhcOGw4fDiMOJw4rDi8OMw43DjsOPw5DDkcOSw5PDlMOVw5bDl8OYw5nDmsObw5zDncOew5/DoMOhw6LDo8Okw6XDpsOnw6jDqcOqw6vDrMOtw67Dr8Oww7HDssOzw7TDtcO2w7fDuMO5w7rDu8O8w73DvsO/XCJcbiAgfSxcbiAgXCJjcDI4NjA1XCI6IFwiaXNvODg1OTE1XCIsXG4gIFwiaXNvODg1OTE2XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfwqDEhMSFxYHigqzigJ7FoMKnxaHCqciYwqvFucKtxbrFu8KwwrHEjMWCxb3igJ3CtsK3xb7EjciZwrvFksWTxbjFvMOAw4HDgsSCw4TEhsOGw4fDiMOJw4rDi8OMw43DjsOPxJDFg8OSw5PDlMWQw5bFmsWww5nDmsObw5zEmMiaw5/DoMOhw6LEg8OkxIfDpsOnw6jDqcOqw6vDrMOtw67Dr8SRxYTDssOzw7TFkcO2xZvFscO5w7rDu8O8xJnIm8O/XCJcbiAgfSxcbiAgXCJjcDI4NjA2XCI6IFwiaXNvODg1OTE2XCIsXG4gIFwiY3A0MzdcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsOHw7zDqcOiw6TDoMOlw6fDqsOrw6jDr8Ouw6zDhMOFw4nDpsOGw7TDtsOyw7vDucO/w5bDnMKiwqPCpeKCp8aSw6HDrcOzw7rDscORwqrCusK/4oyQwqzCvcK8wqHCq8K74paR4paS4paT4pSC4pSk4pWh4pWi4pWW4pWV4pWj4pWR4pWX4pWd4pWc4pWb4pSQ4pSU4pS04pSs4pSc4pSA4pS84pWe4pWf4pWa4pWU4pWp4pWm4pWg4pWQ4pWs4pWn4pWo4pWk4pWl4pWZ4pWY4pWS4pWT4pWr4pWq4pSY4pSM4paI4paE4paM4paQ4paAzrHDn86Tz4DOo8+DwrXPhM6mzpjOqc604oiez4bOteKIqeKJocKx4oml4omk4oyg4oyhw7fiiYjCsOKImcK34oia4oG/wrLilqDCoFwiXG4gIH0sXG4gIFwiaWJtNDM3XCI6IFwiY3A0MzdcIixcbiAgXCJjc2libTQzN1wiOiBcImNwNDM3XCIsXG4gIFwiY3A3MzdcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIs6RzpLOk86UzpXOls6XzpjOmc6azpvOnM6dzp7On86gzqHOo86kzqXOps6nzqjOqc6xzrLOs860zrXOts63zrjOuc66zrvOvM69zr7Ov8+Az4HPg8+Cz4TPhc+Gz4fPiOKWkeKWkuKWk+KUguKUpOKVoeKVouKVluKVleKVo+KVkeKVl+KVneKVnOKVm+KUkOKUlOKUtOKUrOKUnOKUgOKUvOKVnuKVn+KVmuKVlOKVqeKVpuKVoOKVkOKVrOKVp+KVqOKVpOKVpeKVmeKVmOKVkuKVk+KVq+KVquKUmOKUjOKWiOKWhOKWjOKWkOKWgM+JzqzOrc6uz4rOr8+Mz43Pi8+OzobOiM6JzorOjM6Ozo/CseKJpeKJpM6qzqvDt+KJiMKw4oiZwrfiiJrigb/CsuKWoMKgXCJcbiAgfSxcbiAgXCJpYm03MzdcIjogXCJjcDczN1wiLFxuICBcImNzaWJtNzM3XCI6IFwiY3A3MzdcIixcbiAgXCJjcDc3NVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwixIbDvMOpxIHDpMSjw6XEh8WCxJPFlsWXxKvFucOEw4XDicOmw4bFjcO2xKLCosWaxZvDlsOcw7jCo8OYw5fCpMSAxKrDs8W7xbzFuuKAncKmwqnCrsKswr3CvMWBwqvCu+KWkeKWkuKWk+KUguKUpMSExIzEmMSW4pWj4pWR4pWX4pWdxK7FoOKUkOKUlOKUtOKUrOKUnOKUgOKUvMWyxarilZrilZTilanilabilaDilZDilazFvcSFxI3EmcSXxK/FocWzxavFvuKUmOKUjOKWiOKWhOKWjOKWkOKWgMOTw5/FjMWDw7XDlcK1xYTEtsS3xLvEvMWGxJLFheKAmcKtwrHigJzCvsK2wqfDt+KAnsKw4oiZwrfCucKzwrLilqDCoFwiXG4gIH0sXG4gIFwiaWJtNzc1XCI6IFwiY3A3NzVcIixcbiAgXCJjc2libTc3NVwiOiBcImNwNzc1XCIsXG4gIFwiY3A4NTBcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsOHw7zDqcOiw6TDoMOlw6fDqsOrw6jDr8Ouw6zDhMOFw4nDpsOGw7TDtsOyw7vDucO/w5bDnMO4wqPDmMOXxpLDocOtw7PDusOxw5HCqsK6wr/CrsKswr3CvMKhwqvCu+KWkeKWkuKWk+KUguKUpMOBw4LDgMKp4pWj4pWR4pWX4pWdwqLCpeKUkOKUlOKUtOKUrOKUnOKUgOKUvMOjw4PilZrilZTilanilabilaDilZDilazCpMOww5DDisOLw4jEscONw47Dj+KUmOKUjOKWiOKWhMKmw4ziloDDk8Ofw5TDksO1w5XCtcO+w57DmsObw5nDvcOdwq/CtMKtwrHigJfCvsK2wqfDt8K4wrDCqMK3wrnCs8Ky4pagwqBcIlxuICB9LFxuICBcImlibTg1MFwiOiBcImNwODUwXCIsXG4gIFwiY3NpYm04NTBcIjogXCJjcDg1MFwiLFxuICBcImNwODUyXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLDh8O8w6nDosOkxa/Eh8OnxYLDq8WQxZHDrsW5w4TEhsOJxLnEusO0w7bEvcS+xZrFm8OWw5zFpMWlxYHDl8SNw6HDrcOzw7rEhMSFxb3FvsSYxJnCrMW6xIzFn8KrwrvilpHilpLilpPilILilKTDgcOCxJrFnuKVo+KVkeKVl+KVncW7xbzilJDilJTilLTilKzilJzilIDilLzEgsSD4pWa4pWU4pWp4pWm4pWg4pWQ4pWswqTEkcSQxI7Di8SPxYfDjcOOxJvilJjilIzilojiloTFosWu4paAw5PDn8OUxYPFhMWIxaDFocWUw5rFlcWww73DncWjwrTCrcudy5vLh8uYwqfDt8K4wrDCqMuZxbHFmMWZ4pagwqBcIlxuICB9LFxuICBcImlibTg1MlwiOiBcImNwODUyXCIsXG4gIFwiY3NpYm04NTJcIjogXCJjcDg1MlwiLFxuICBcImNwODU1XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLRktCC0ZPQg9GR0IHRlNCE0ZXQhdGW0IbRl9CH0ZjQiNGZ0InRmtCK0ZvQi9Gc0IzRntCO0Z/Qj9GO0K7RitCq0LDQkNCx0JHRhtCm0LTQlNC10JXRhNCk0LPQk8KrwrvilpHilpLilpPilILilKTRhdCl0LjQmOKVo+KVkeKVl+KVndC50JnilJDilJTilLTilKzilJzilIDilLzQutCa4pWa4pWU4pWp4pWm4pWg4pWQ4pWswqTQu9Cb0LzQnNC90J3QvtCe0L/ilJjilIzilojiloTQn9GP4paA0K/RgNCg0YHQodGC0KLRg9Cj0LbQltCy0JLRjNCs4oSWwq3Ri9Cr0LfQl9GI0KjRjdCt0YnQqdGH0KfCp+KWoMKgXCJcbiAgfSxcbiAgXCJpYm04NTVcIjogXCJjcDg1NVwiLFxuICBcImNzaWJtODU1XCI6IFwiY3A4NTVcIixcbiAgXCJjcDg1NlwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwi15DXkdeS15PXlNeV15bXl9eY15nXmteb15zXndee15/XoNeh16LXo9ek16XXpten16jXqdeq77+9wqPvv73Dl++/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/vcKuwqzCvcK877+9wqvCu+KWkeKWkuKWk+KUguKUpO+/ve+/ve+/vcKp4pWj4pWR4pWX4pWdwqLCpeKUkOKUlOKUtOKUrOKUnOKUgOKUvO+/ve+/veKVmuKVlOKVqeKVpuKVoOKVkOKVrMKk77+977+977+977+977+977+977+977+977+94pSY4pSM4paI4paEwqbvv73iloDvv73vv73vv73vv73vv73vv73Cte+/ve+/ve+/ve+/ve+/ve+/ve+/vcKvwrTCrcKx4oCXwr7CtsKnw7fCuMKwwqjCt8K5wrPCsuKWoMKgXCJcbiAgfSxcbiAgXCJpYm04NTZcIjogXCJjcDg1NlwiLFxuICBcImNzaWJtODU2XCI6IFwiY3A4NTZcIixcbiAgXCJjcDg1N1wiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiw4fDvMOpw6LDpMOgw6XDp8Oqw6vDqMOvw67EscOEw4XDicOmw4bDtMO2w7LDu8O5xLDDlsOcw7jCo8OYxZ7Fn8Ohw63Ds8O6w7HDkcSexJ/Cv8KuwqzCvcK8wqHCq8K74paR4paS4paT4pSC4pSkw4HDgsOAwqnilaPilZHilZfilZ3CosKl4pSQ4pSU4pS04pSs4pSc4pSA4pS8w6PDg+KVmuKVlOKVqeKVpuKVoOKVkOKVrMKkwrrCqsOKw4vDiO+/vcONw47Dj+KUmOKUjOKWiOKWhMKmw4ziloDDk8Ofw5TDksO1w5XCte+/vcOXw5rDm8OZw6zDv8KvwrTCrcKx77+9wr7CtsKnw7fCuMKwwqjCt8K5wrPCsuKWoMKgXCJcbiAgfSxcbiAgXCJpYm04NTdcIjogXCJjcDg1N1wiLFxuICBcImNzaWJtODU3XCI6IFwiY3A4NTdcIixcbiAgXCJjcDg1OFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiw4fDvMOpw6LDpMOgw6XDp8Oqw6vDqMOvw67DrMOEw4XDicOmw4bDtMO2w7LDu8O5w7/DlsOcw7jCo8OYw5fGksOhw63Ds8O6w7HDkcKqwrrCv8KuwqzCvcK8wqHCq8K74paR4paS4paT4pSC4pSkw4HDgsOAwqnilaPilZHilZfilZ3CosKl4pSQ4pSU4pS04pSs4pSc4pSA4pS8w6PDg+KVmuKVlOKVqeKVpuKVoOKVkOKVrMKkw7DDkMOKw4vDiOKCrMONw47Dj+KUmOKUjOKWiOKWhMKmw4ziloDDk8Ofw5TDksO1w5XCtcO+w57DmsObw5nDvcOdwq/CtMKtwrHigJfCvsK2wqfDt8K4wrDCqMK3wrnCs8Ky4pagwqBcIlxuICB9LFxuICBcImlibTg1OFwiOiBcImNwODU4XCIsXG4gIFwiY3NpYm04NThcIjogXCJjcDg1OFwiLFxuICBcImNwODYwXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLDh8O8w6nDosOjw6DDgcOnw6rDisOow43DlMOsw4PDgsOJw4DDiMO0w7XDssOaw7nDjMOVw5zCosKjw5nigqfDk8Ohw63Ds8O6w7HDkcKqwrrCv8OSwqzCvcK8wqHCq8K74paR4paS4paT4pSC4pSk4pWh4pWi4pWW4pWV4pWj4pWR4pWX4pWd4pWc4pWb4pSQ4pSU4pS04pSs4pSc4pSA4pS84pWe4pWf4pWa4pWU4pWp4pWm4pWg4pWQ4pWs4pWn4pWo4pWk4pWl4pWZ4pWY4pWS4pWT4pWr4pWq4pSY4pSM4paI4paE4paM4paQ4paAzrHDn86Tz4DOo8+DwrXPhM6mzpjOqc604oiez4bOteKIqeKJocKx4oml4omk4oyg4oyhw7fiiYjCsOKImcK34oia4oG/wrLilqDCoFwiXG4gIH0sXG4gIFwiaWJtODYwXCI6IFwiY3A4NjBcIixcbiAgXCJjc2libTg2MFwiOiBcImNwODYwXCIsXG4gIFwiY3A4NjFcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsOHw7zDqcOiw6TDoMOlw6fDqsOrw6jDkMOww57DhMOFw4nDpsOGw7TDtsO+w7vDncO9w5bDnMO4wqPDmOKCp8aSw6HDrcOzw7rDgcONw5PDmsK/4oyQwqzCvcK8wqHCq8K74paR4paS4paT4pSC4pSk4pWh4pWi4pWW4pWV4pWj4pWR4pWX4pWd4pWc4pWb4pSQ4pSU4pS04pSs4pSc4pSA4pS84pWe4pWf4pWa4pWU4pWp4pWm4pWg4pWQ4pWs4pWn4pWo4pWk4pWl4pWZ4pWY4pWS4pWT4pWr4pWq4pSY4pSM4paI4paE4paM4paQ4paAzrHDn86Tz4DOo8+DwrXPhM6mzpjOqc604oiez4bOteKIqeKJocKx4oml4omk4oyg4oyhw7fiiYjCsOKImcK34oia4oG/wrLilqDCoFwiXG4gIH0sXG4gIFwiaWJtODYxXCI6IFwiY3A4NjFcIixcbiAgXCJjc2libTg2MVwiOiBcImNwODYxXCIsXG4gIFwiY3A4NjJcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIteQ15HXkteT15TXldeW15fXmNeZ15rXm9ec153Xntef16DXodei16PXpNel16bXp9eo16nXqsKiwqPCpeKCp8aSw6HDrcOzw7rDscORwqrCusK/4oyQwqzCvcK8wqHCq8K74paR4paS4paT4pSC4pSk4pWh4pWi4pWW4pWV4pWj4pWR4pWX4pWd4pWc4pWb4pSQ4pSU4pS04pSs4pSc4pSA4pS84pWe4pWf4pWa4pWU4pWp4pWm4pWg4pWQ4pWs4pWn4pWo4pWk4pWl4pWZ4pWY4pWS4pWT4pWr4pWq4pSY4pSM4paI4paE4paM4paQ4paAzrHDn86Tz4DOo8+DwrXPhM6mzpjOqc604oiez4bOteKIqeKJocKx4oml4omk4oyg4oyhw7fiiYjCsOKImcK34oia4oG/wrLilqDCoFwiXG4gIH0sXG4gIFwiaWJtODYyXCI6IFwiY3A4NjJcIixcbiAgXCJjc2libTg2MlwiOiBcImNwODYyXCIsXG4gIFwiY3A4NjNcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsOHw7zDqcOiw4LDoMK2w6fDqsOrw6jDr8Ou4oCXw4DCp8OJw4jDisO0w4vDj8O7w7nCpMOUw5zCosKjw5nDm8aSwqbCtMOzw7rCqMK4wrPCr8OO4oyQwqzCvcK8wr7Cq8K74paR4paS4paT4pSC4pSk4pWh4pWi4pWW4pWV4pWj4pWR4pWX4pWd4pWc4pWb4pSQ4pSU4pS04pSs4pSc4pSA4pS84pWe4pWf4pWa4pWU4pWp4pWm4pWg4pWQ4pWs4pWn4pWo4pWk4pWl4pWZ4pWY4pWS4pWT4pWr4pWq4pSY4pSM4paI4paE4paM4paQ4paAzrHDn86Tz4DOo8+DwrXPhM6mzpjOqc604oiez4bOteKIqeKJocKx4oml4omk4oyg4oyhw7fiiYjCsOKImcK34oia4oG/wrLilqDCoFwiXG4gIH0sXG4gIFwiaWJtODYzXCI6IFwiY3A4NjNcIixcbiAgXCJjc2libTg2M1wiOiBcImNwODYzXCIsXG4gIFwiY3A4NjRcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIlxcdTAwMDBcXHUwMDAxXFx1MDAwMlxcdTAwMDNcXHUwMDA0XFx1MDAwNVxcdTAwMDZcXHUwMDA3XFxiXFx0XFxuXFx1MDAwYlxcZlxcclxcdTAwMGVcXHUwMDBmXFx1MDAxMFxcdTAwMTFcXHUwMDEyXFx1MDAxM1xcdTAwMTRcXHUwMDE1XFx1MDAxNlxcdTAwMTdcXHUwMDE4XFx1MDAxOVxcdTAwMWFcXHUwMDFiXFx1MDAxY1xcdTAwMWRcXHUwMDFlXFx1MDAxZiAhXFxcIiMk2aomJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXFxcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn/CsMK34oiZ4oia4paS4pSA4pSC4pS84pSk4pSs4pSc4pS04pSQ4pSM4pSU4pSYzrLiiJ7PhsKxwr3CvOKJiMKrwrvvu7fvu7jvv73vv73vu7vvu7zvv73CoMKt77qCwqPCpO+6hO+/ve+/ve+6ju+6j++6le+6mdiM77qd77qh77ql2aDZodmi2aPZpNml2abZp9mo2anvu5HYm++6se+6te+6udifwqLvuoDvuoHvuoPvuoXvu4rvuovvuo3vupHvupPvupfvupvvup/vuqPvuqfvuqnvuqvvuq3vuq/vurPvurfvurvvur/vu4Hvu4Xvu4vvu4/CpsKsw7fDl++7idmA77uT77uX77ub77uf77uj77un77ur77ut77uv77uz77q977uM77uO77uN77uh77m92ZHvu6Xvu6nvu6zvu7Dvu7Lvu5Dvu5Xvu7Xvu7bvu53vu5nvu7HilqDvv71cIlxuICB9LFxuICBcImlibTg2NFwiOiBcImNwODY0XCIsXG4gIFwiY3NpYm04NjRcIjogXCJjcDg2NFwiLFxuICBcImNwODY1XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLDh8O8w6nDosOkw6DDpcOnw6rDq8Oow6/DrsOsw4TDhcOJw6bDhsO0w7bDssO7w7nDv8OWw5zDuMKjw5jigqfGksOhw63Ds8O6w7HDkcKqwrrCv+KMkMKswr3CvMKhwqvCpOKWkeKWkuKWk+KUguKUpOKVoeKVouKVluKVleKVo+KVkeKVl+KVneKVnOKVm+KUkOKUlOKUtOKUrOKUnOKUgOKUvOKVnuKVn+KVmuKVlOKVqeKVpuKVoOKVkOKVrOKVp+KVqOKVpOKVpeKVmeKVmOKVkuKVk+KVq+KVquKUmOKUjOKWiOKWhOKWjOKWkOKWgM6xw5/Ok8+AzqPPg8K1z4TOps6YzqnOtOKIns+GzrXiiKniiaHCseKJpeKJpOKMoOKMocO34omIwrDiiJnCt+KImuKBv8Ky4pagwqBcIlxuICB9LFxuICBcImlibTg2NVwiOiBcImNwODY1XCIsXG4gIFwiY3NpYm04NjVcIjogXCJjcDg2NVwiLFxuICBcImNwODY2XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLQkNCR0JLQk9CU0JXQltCX0JjQmdCa0JvQnNCd0J7Qn9Cg0KHQotCj0KTQpdCm0KfQqNCp0KrQq9Cs0K3QrtCv0LDQsdCy0LPQtNC10LbQt9C40LnQutC70LzQvdC+0L/ilpHilpLilpPilILilKTilaHilaLilZbilZXilaPilZHilZfilZ3ilZzilZvilJDilJTilLTilKzilJzilIDilLzilZ7ilZ/ilZrilZTilanilabilaDilZDilazilafilajilaTilaXilZnilZjilZLilZPilavilarilJjilIzilojiloTilozilpDiloDRgNGB0YLRg9GE0YXRhtGH0YjRidGK0YvRjNGN0Y7Rj9CB0ZHQhNGU0IfRl9CO0Z7CsOKImcK34oia4oSWwqTilqDCoFwiXG4gIH0sXG4gIFwiaWJtODY2XCI6IFwiY3A4NjZcIixcbiAgXCJjc2libTg2NlwiOiBcImNwODY2XCIsXG4gIFwiY3A4NjlcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIu+/ve+/ve+/ve+/ve+/ve+/vc6G77+9wrfCrMKm4oCY4oCZzojigJXOic6KzqrOjO+/ve+/vc6OzqvCqc6PwrLCs86swqPOrc6uzq/Pis6Qz4zPjc6RzpLOk86UzpXOls6Xwr3OmM6ZwqvCu+KWkeKWkuKWk+KUguKUpM6azpvOnM6d4pWj4pWR4pWX4pWdzp7On+KUkOKUlOKUtOKUrOKUnOKUgOKUvM6gzqHilZrilZTilanilabilaDilZDilazOo86kzqXOps6nzqjOqc6xzrLOs+KUmOKUjOKWiOKWhM60zrXiloDOts63zrjOuc66zrvOvM69zr7Ov8+Az4HPg8+Cz4TOhMKtwrHPhc+Gz4fCp8+IzoXCsMKoz4nPi86wz47ilqDCoFwiXG4gIH0sXG4gIFwiaWJtODY5XCI6IFwiY3A4NjlcIixcbiAgXCJjc2libTg2OVwiOiBcImNwODY5XCIsXG4gIFwiY3A5MjJcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp/CoMKhwqLCo8KkwqXCpsKnwqjCqcKqwqvCrMKtwq7igL7CsMKxwrLCs8K0wrXCtsK3wrjCucK6wrvCvMK9wr7Cv8OAw4HDgsODw4TDhcOGw4fDiMOJw4rDi8OMw43DjsOPxaDDkcOSw5PDlMOVw5bDl8OYw5nDmsObw5zDncW9w5/DoMOhw6LDo8Okw6XDpsOnw6jDqcOqw6vDrMOtw67Dr8Whw7HDssOzw7TDtcO2w7fDuMO5w7rDu8O8w73FvsO/XCJcbiAgfSxcbiAgXCJpYm05MjJcIjogXCJjcDkyMlwiLFxuICBcImNzaWJtOTIyXCI6IFwiY3A5MjJcIixcbiAgXCJjcDEwNDZcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIu+6iMOXw7fvo7bvo7Xvo7Tvo7fvubHCiOKWoOKUguKUgOKUkOKUjOKUlOKUmO+5ue+5u++5ve+5v++5t++6iu+7sO+7s++7su+7ju+7j++7kO+7tu+7uO+7uu+7vMKg76O676O576O4wqTvo7vvuovvupHvupfvupvvup/vuqPYjMKt77qn77qz2aDZodmi2aPZpNml2abZp9mo2anvurfYm++6u++6v++7itif77uL2KHYotij2KTYpdim2KfYqNip2KrYq9is2K3Yrtiv2LDYsdiy2LPYtNi12LbYt++7h9i52Lrvu4zvuoLvuoTvuo7vu5PZgNmB2YLZg9mE2YXZhtmH2YjZidmK2YvZjNmN2Y7Zj9mQ2ZHZku+7l++7m++7n++jvO+7te+7t++7ue+7u++7o++7p++7rO+7qe+/vVwiXG4gIH0sXG4gIFwiaWJtMTA0NlwiOiBcImNwMTA0NlwiLFxuICBcImNzaWJtMTA0NlwiOiBcImNwMTA0NlwiLFxuICBcImNwMTEyNFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiwoDCgcKCwoPChMKFwobCh8KIwonCisKLwozCjcKOwo/CkMKRwpLCk8KUwpXClsKXwpjCmcKawpvCnMKdwp7Cn8Kg0IHQgtKQ0ITQhdCG0IfQiNCJ0IrQi9CMwq3QjtCP0JDQkdCS0JPQlNCV0JbQl9CY0JnQmtCb0JzQndCe0J/QoNCh0KLQo9Ck0KXQptCn0KjQqdCq0KvQrNCt0K7Qr9Cw0LHQstCz0LTQtdC20LfQuNC50LrQu9C80L3QvtC/0YDRgdGC0YPRhNGF0YbRh9GI0YnRitGL0YzRjdGO0Y/ihJbRkdGS0pHRlNGV0ZbRl9GY0ZnRmtGb0ZzCp9Ge0Z9cIlxuICB9LFxuICBcImlibTExMjRcIjogXCJjcDExMjRcIixcbiAgXCJjc2libTExMjRcIjogXCJjcDExMjRcIixcbiAgXCJjcDExMjVcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcItCQ0JHQktCT0JTQldCW0JfQmNCZ0JrQm9Cc0J3QntCf0KDQodCi0KPQpNCl0KbQp9Co0KnQqtCr0KzQrdCu0K/QsNCx0LLQs9C00LXQttC30LjQudC60LvQvNC90L7Qv+KWkeKWkuKWk+KUguKUpOKVoeKVouKVluKVleKVo+KVkeKVl+KVneKVnOKVm+KUkOKUlOKUtOKUrOKUnOKUgOKUvOKVnuKVn+KVmuKVlOKVqeKVpuKVoOKVkOKVrOKVp+KVqOKVpOKVpeKVmeKVmOKVkuKVk+KVq+KVquKUmOKUjOKWiOKWhOKWjOKWkOKWgNGA0YHRgtGD0YTRhdGG0YfRiNGJ0YrRi9GM0Y3RjtGP0IHRkdKQ0pHQhNGU0IbRltCH0ZfCt+KImuKElsKk4pagwqBcIlxuICB9LFxuICBcImlibTExMjVcIjogXCJjcDExMjVcIixcbiAgXCJjc2libTExMjVcIjogXCJjcDExMjVcIixcbiAgXCJjcDExMjlcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp/CoMKhwqLCo8KkwqXCpsKnxZPCqcKqwqvCrMKtwq7Cr8KwwrHCssKzxbjCtcK2wrfFksK5wrrCu8K8wr3CvsK/w4DDgcOCxILDhMOFw4bDh8OIw4nDisOLzIDDjcOOw4/EkMORzInDk8OUxqDDlsOXw5jDmcOaw5vDnMavzIPDn8Ogw6HDosSDw6TDpcOmw6fDqMOpw6rDq8yBw63DrsOvxJHDscyjw7PDtMahw7bDt8O4w7nDusO7w7zGsOKCq8O/XCJcbiAgfSxcbiAgXCJpYm0xMTI5XCI6IFwiY3AxMTI5XCIsXG4gIFwiY3NpYm0xMTI5XCI6IFwiY3AxMTI5XCIsXG4gIFwiY3AxMTMzXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfwqDguoHguoLguoTguofguojguqrguorguo3gupTgupXgupbgupfgupnguprgupvgupzgup3gup7gup/guqHguqLguqPguqXguqfguqvguq3guq7vv73vv73vv73guq/gurDgurLgurPgurTgurXgurbgurfgurjgurngurzgurHgurvgur3vv73vv73vv73gu4Dgu4Hgu4Lgu4Pgu4Tgu4jgu4ngu4rgu4vgu4zgu43gu4bvv73gu5zgu53igq3vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73gu5Dgu5Hgu5Lgu5Pgu5Tgu5Xgu5bgu5fgu5jgu5nvv73vv73CosKswqbvv71cIlxuICB9LFxuICBcImlibTExMzNcIjogXCJjcDExMzNcIixcbiAgXCJjc2libTExMzNcIjogXCJjcDExMzNcIixcbiAgXCJjcDExNjFcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIu+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/veC5iOC4geC4guC4g+C4hOC4heC4huC4h+C4iOC4ieC4iuC4i+C4jOC4jeC4juC4j+C4kOC4keC4kuC4k+C4lOC4leC4luC4l+C4mOC4meC4muC4m+C4nOC4neC4nuC4n+C4oOC4oeC4ouC4o+C4pOC4peC4puC4p+C4qOC4qeC4quC4q+C4rOC4reC4ruC4r+C4sOC4seC4suC4s+C4tOC4teC4tuC4t+C4uOC4ueC4uuC5ieC5iuC5i+KCrOC4v+C5gOC5geC5guC5g+C5hOC5heC5huC5h+C5iOC5ieC5iuC5i+C5jOC5jeC5juC5j+C5kOC5keC5kuC5k+C5lOC5leC5luC5l+C5mOC5meC5muC5m8KiwqzCpsKgXCJcbiAgfSxcbiAgXCJpYm0xMTYxXCI6IFwiY3AxMTYxXCIsXG4gIFwiY3NpYm0xMTYxXCI6IFwiY3AxMTYxXCIsXG4gIFwiY3AxMTYyXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLigqzCgcKCwoPChOKApsKGwofCiMKJworCi8KMwo3CjsKPwpDigJjigJnigJzigJ3igKLigJPigJTCmMKZwprCm8Kcwp3CnsKfwqDguIHguILguIPguITguIXguIbguIfguIjguInguIrguIvguIzguI3guI7guI/guJDguJHguJLguJPguJTguJXguJbguJfguJjguJnguJrguJvguJzguJ3guJ7guJ/guKDguKHguKLguKPguKTguKXguKbguKfguKjguKnguKrguKvguKzguK3guK7guK/guLDguLHguLLguLPguLTguLXguLbguLfguLjguLnguLrvv73vv73vv73vv73guL/guYDguYHguYLguYPguYTguYXguYbguYfguYjguYnguYrguYvguYzguY3guY7guY/guZDguZHguZLguZPguZTguZXguZbguZfguZjguZnguZrguZvvv73vv73vv73vv71cIlxuICB9LFxuICBcImlibTExNjJcIjogXCJjcDExNjJcIixcbiAgXCJjc2libTExNjJcIjogXCJjcDExNjJcIixcbiAgXCJjcDExNjNcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp/CoMKhwqLCo+KCrMKlwqbCp8WTwqnCqsKrwqzCrcKuwq/CsMKxwrLCs8W4wrXCtsK3xZLCucK6wrvCvMK9wr7Cv8OAw4HDgsSCw4TDhcOGw4fDiMOJw4rDi8yAw43DjsOPxJDDkcyJw5PDlMagw5bDl8OYw5nDmsObw5zGr8yDw5/DoMOhw6LEg8Okw6XDpsOnw6jDqcOqw6vMgcOtw67Dr8SRw7HMo8Ozw7TGocO2w7fDuMO5w7rDu8O8xrDigqvDv1wiXG4gIH0sXG4gIFwiaWJtMTE2M1wiOiBcImNwMTE2M1wiLFxuICBcImNzaWJtMTE2M1wiOiBcImNwMTE2M1wiLFxuICBcIm1hY2Nyb2F0aWFuXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7FoOKEosK0wqjiiaDFvcOY4oiewrHiiaTiiaXiiIbCteKIguKIkeKIj8Wh4oirwqrCuuKEpsW+w7jCv8KhwqziiJrGkuKJiMSGwqvEjOKApsKgw4DDg8OVxZLFk8SQ4oCU4oCc4oCd4oCY4oCZw7fil4rvv73CqeKBhMKk4oC54oC6w4bCu+KAk8K34oCa4oCe4oCww4LEh8OBxI3DiMONw47Dj8OMw5PDlMSRw5LDmsObw5nEscuGy5zCr8+Aw4vLmsK4w4rDpsuHXCJcbiAgfSxcbiAgXCJtYWNjeXJpbGxpY1wiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwi0JDQkdCS0JPQlNCV0JbQl9CY0JnQmtCb0JzQndCe0J/QoNCh0KLQo9Ck0KXQptCn0KjQqdCq0KvQrNCt0K7Qr+KAoMKwwqLCo8Kn4oCiwrbQhsKuwqnihKLQgtGS4omg0IPRk+KInsKx4omk4oml0ZbCteKIgtCI0ITRlNCH0ZfQidGZ0IrRmtGY0IXCrOKImsaS4omI4oiGwqvCu+KApsKg0IvRm9CM0ZzRleKAk+KAlOKAnOKAneKAmOKAmcO34oCe0I7RntCP0Z/ihJbQgdGR0Y/QsNCx0LLQs9C00LXQttC30LjQudC60LvQvNC90L7Qv9GA0YHRgtGD0YTRhdGG0YfRiNGJ0YrRi9GM0Y3RjsKkXCJcbiAgfSxcbiAgXCJtYWNncmVla1wiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiw4TCucKyw4nCs8OWw5zOhcOgw6LDpM6EwqjDp8Opw6jDqsOrwqPihKLDrsOv4oCiwr3igLDDtMO2wqbCrcO5w7vDvOKAoM6TzpTOmM6bzp7OoMOfwq7Cqc6jzqrCp+KJoMKwzofOkcKx4omk4omlwqXOks6VzpbOl86ZzprOnM6mzqvOqM6pzqzOncKszp/OoeKJiM6kwqvCu+KApsKgzqXOp86GzojFk+KAk+KAleKAnOKAneKAmOKAmcO3zonOis6Mzo7Orc6uzq/PjM6Pz43Osc6yz4jOtM61z4bOs863zrnOvs66zrvOvM69zr/PgM+Oz4HPg8+EzrjPic+Cz4fPhc62z4rPi86QzrDvv71cIlxuICB9LFxuICBcIm1hY2ljZWxhbmRcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsOEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zDncKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCuuKEpsOmw7jCv8KhwqziiJrGkuKJiOKIhsKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnDt+KXisO/xbjigYTCpMOQw7DDnsO+w73Ct+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvv73DksOaw5vDmcSxy4bLnMKvy5jLmcuawrjLncuby4dcIlxuICB9LFxuICBcIm1hY3JvbWFuXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7CqeKEosK0wqjiiaDDhsOY4oiewrHiiaTiiaXCpcK14oiC4oiR4oiPz4DiiKvCqsK64oSmw6bDuMK/wqHCrOKImsaS4omI4oiGwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmcO34peKw7/FuOKBhMKk4oC54oC676yB76yC4oChwrfigJrigJ7igLDDgsOKw4HDi8OIw43DjsOPw4zDk8OU77+9w5LDmsObw5nEscuGy5zCr8uYy5nLmsK4y53Lm8uHXCJcbiAgfSxcbiAgXCJtYWNyb21hbmlhXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7CqeKEosK0wqjiiaDEgsWe4oiewrHiiaTiiaXCpcK14oiC4oiR4oiPz4DiiKvCqsK64oSmxIPFn8K/wqHCrOKImsaS4omI4oiGwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmcO34peKw7/FuOKBhMKk4oC54oC6xaLFo+KAocK34oCa4oCe4oCww4LDisOBw4vDiMONw47Dj8OMw5PDlO+/vcOSw5rDm8OZxLHLhsucwq/LmMuZy5rCuMudy5vLh1wiXG4gIH0sXG4gIFwibWFjdGhhaVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiwqvCu+KApu+ijO+ij++iku+ile+imO+ii++iju+ike+ilO+il+KAnOKAne+ime+/veKAou+ihO+iie+ihe+ihu+ih++iiO+iiu+ije+ikO+ik++iluKAmOKAme+/vcKg4LiB4LiC4LiD4LiE4LiF4LiG4LiH4LiI4LiJ4LiK4LiL4LiM4LiN4LiO4LiP4LiQ4LiR4LiS4LiT4LiU4LiV4LiW4LiX4LiY4LiZ4Lia4Lib4Lic4Lid4Lie4Lif4Lig4Lih4Lii4Lij4Lik4Lil4Lim4Lin4Lio4Lip4Liq4Lir4Lis4Lit4Liu4Liv4Liw4Lix4Liy4Liz4Li04Li14Li24Li34Li44Li54Li677u/4oCL4oCT4oCU4Li/4LmA4LmB4LmC4LmD4LmE4LmF4LmG4LmH4LmI4LmJ4LmK4LmL4LmM4LmN4oSi4LmP4LmQ4LmR4LmS4LmT4LmU4LmV4LmW4LmX4LmY4LmZwq7Cqe+/ve+/ve+/ve+/vVwiXG4gIH0sXG4gIFwibWFjdHVya2lzaFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCuuKEpsOmw7jCv8KhwqziiJrGkuKJiOKIhsKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnDt+KXisO/xbjEnsSfxLDEscWexZ/igKHCt+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvv73DksOaw5vDme+/vcuGy5zCr8uYy5nLmsK4y53Lm8uHXCJcbiAgfSxcbiAgXCJtYWN1a3JhaW5lXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLQkNCR0JLQk9CU0JXQltCX0JjQmdCa0JvQnNCd0J7Qn9Cg0KHQotCj0KTQpdCm0KfQqNCp0KrQq9Cs0K3QrtCv4oCgwrDSkMKjwqfigKLCttCGwq7CqeKEotCC0ZLiiaDQg9GT4oiewrHiiaTiiaXRlsK10pHQiNCE0ZTQh9GX0InRmdCK0ZrRmNCFwqziiJrGkuKJiOKIhsKrwrvigKbCoNCL0ZvQjNGc0ZXigJPigJTigJzigJ3igJjigJnDt+KAntCO0Z7Qj9Gf4oSW0IHRkdGP0LDQsdCy0LPQtNC10LbQt9C40LnQutC70LzQvdC+0L/RgNGB0YLRg9GE0YXRhtGH0YjRidGK0YvRjNGN0Y7CpFwiXG4gIH0sXG4gIFwia29pOHJcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIuKUgOKUguKUjOKUkOKUlOKUmOKUnOKUpOKUrOKUtOKUvOKWgOKWhOKWiOKWjOKWkOKWkeKWkuKWk+KMoOKWoOKImeKImuKJiOKJpOKJpcKg4oyhwrDCssK3w7filZDilZHilZLRkeKVk+KVlOKVleKVluKVl+KVmOKVmeKVmuKVm+KVnOKVneKVnuKVn+KVoOKVodCB4pWi4pWj4pWk4pWl4pWm4pWn4pWo4pWp4pWq4pWr4pWswqnRjtCw0LHRhtC00LXRhNCz0YXQuNC50LrQu9C80L3QvtC/0Y/RgNGB0YLRg9C20LLRjNGL0LfRiNGN0YnRh9GK0K7QkNCR0KbQlNCV0KTQk9Cl0JjQmdCa0JvQnNCd0J7Qn9Cv0KDQodCi0KPQltCS0KzQq9CX0KjQrdCp0KfQqlwiXG4gIH0sXG4gIFwia29pOHVcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIuKUgOKUguKUjOKUkOKUlOKUmOKUnOKUpOKUrOKUtOKUvOKWgOKWhOKWiOKWjOKWkOKWkeKWkuKWk+KMoOKWoOKImeKImuKJiOKJpOKJpcKg4oyhwrDCssK3w7filZDilZHilZLRkdGU4pWU0ZbRl+KVl+KVmOKVmeKVmuKVm9KR4pWd4pWe4pWf4pWg4pWh0IHQhOKVo9CG0IfilabilafilajilanilarSkOKVrMKp0Y7QsNCx0YbQtNC10YTQs9GF0LjQudC60LvQvNC90L7Qv9GP0YDRgdGC0YPQttCy0YzRi9C30YjRjdGJ0YfRitCu0JDQkdCm0JTQldCk0JPQpdCY0JnQmtCb0JzQndCe0J/Qr9Cg0KHQotCj0JbQktCs0KvQl9Co0K3QqdCn0KpcIlxuICB9LFxuICBcImtvaThydVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwi4pSA4pSC4pSM4pSQ4pSU4pSY4pSc4pSk4pSs4pS04pS84paA4paE4paI4paM4paQ4paR4paS4paT4oyg4pag4oiZ4oia4omI4omk4omlwqDijKHCsMKywrfDt+KVkOKVkeKVktGR0ZTilZTRltGX4pWX4pWY4pWZ4pWa4pWb0pHRnuKVnuKVn+KVoOKVodCB0ITilaPQhtCH4pWm4pWn4pWo4pWp4pWq0pDQjsKp0Y7QsNCx0YbQtNC10YTQs9GF0LjQudC60LvQvNC90L7Qv9GP0YDRgdGC0YPQttCy0YzRi9C30YjRjdGJ0YfRitCu0JDQkdCm0JTQldCk0JPQpdCY0JnQmtCb0JzQndCe0J/Qr9Cg0KHQotCj0JbQktCs0KvQl9Co0K3QqdCn0KpcIlxuICB9LFxuICBcImtvaTh0XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLSm9KT4oCa0pLigJ7igKbigKDigKHvv73igLDSs+KAudKy0rfStu+/vdKa4oCY4oCZ4oCc4oCd4oCi4oCT4oCU77+94oSi77+94oC677+977+977+977+977+906/TrtGRwqTTo8Kmwqfvv73vv73vv73Cq8Kswq3Cru+/vcKwwrHCstCB77+906LCtsK377+94oSW77+9wrvvv73vv73vv73CqdGO0LDQsdGG0LTQtdGE0LPRhdC40LnQutC70LzQvdC+0L/Rj9GA0YHRgtGD0LbQstGM0YvQt9GI0Y3RidGH0YrQrtCQ0JHQptCU0JXQpNCT0KXQmNCZ0JrQm9Cc0J3QntCf0K/QoNCh0KLQo9CW0JLQrNCr0JfQqNCt0KnQp9CqXCJcbiAgfSxcbiAgXCJhcm1zY2lpOFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiwoDCgcKCwoPChMKFwobCh8KIwonCisKLwozCjcKOwo/CkMKRwpLCk8KUwpXClsKXwpjCmcKawpvCnMKdwp7Cn8Kg77+91ofWiSkowrvCq+KAlC7VnSwt1origKbVnNWb1Z7UsdWh1LLVotSz1aPUtNWk1LXVpdS21abUt9Wn1LjVqNS51anUutWq1LvVq9S81azUvdWt1L7VrtS/1a/VgNWw1YHVsdWC1bLVg9Wz1YTVtNWF1bXVhtW21YfVt9WI1bjVidW51YrVutWL1bvVjNW81Y3VvdWO1b7Vj9W/1ZDWgNWR1oHVktaC1ZPWg9WU1oTVldaF1ZbWhtWa77+9XCJcbiAgfSxcbiAgXCJyazEwNDhcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcItCC0IPigJrRk+KAnuKApuKAoOKAoeKCrOKAsNCJ4oC50IrSmtK60I/RkuKAmOKAmeKAnOKAneKAouKAk+KAlO+/veKEotGZ4oC60ZrSm9K70Z/CoNKw0rHTmMKk06jCpsKn0IHCqdKSwqvCrMKtwq7SrsKwwrHQhtGW06nCtcK2wrfRkeKEltKTwrvTmdKi0qPSr9CQ0JHQktCT0JTQldCW0JfQmNCZ0JrQm9Cc0J3QntCf0KDQodCi0KPQpNCl0KbQp9Co0KnQqtCr0KzQrdCu0K/QsNCx0LLQs9C00LXQttC30LjQudC60LvQvNC90L7Qv9GA0YHRgtGD0YTRhdGG0YfRiNGJ0YrRi9GM0Y3RjtGPXCJcbiAgfSxcbiAgXCJ0Y3ZuXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCJcXHUwMDAww5rhu6RcXHUwMDAz4buq4bus4buuXFx1MDAwN1xcYlxcdFxcblxcdTAwMGJcXGZcXHJcXHUwMDBlXFx1MDAwZlxcdTAwMTDhu6jhu7Dhu7Lhu7bhu7jDneG7tFxcdTAwMThcXHUwMDE5XFx1MDAxYVxcdTAwMWJcXHUwMDFjXFx1MDAxZFxcdTAwMWVcXHUwMDFmICFcXFwiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXFxcXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/w4DhuqLDg8OB4bqg4bq24bqsw4jhurrhurzDieG6uOG7hsOM4buIxKjDjeG7isOS4buOw5XDk+G7jOG7mOG7nOG7nuG7oOG7muG7osOZ4bumxajCoMSCw4LDisOUxqDGr8SQxIPDosOqw7TGocawxJHhurDMgMyJzIPMgcyjw6DhuqPDo8Oh4bqh4bqy4bqx4bqz4bq14bqv4bq04bqu4bqm4bqo4bqq4bqk4buA4bq34bqn4bqp4bqr4bql4bqtw6jhu4Lhurvhur3DqeG6ueG7geG7g+G7heG6v+G7h8Os4buJ4buE4bq+4buSxKnDreG7i8Oy4buU4buPw7XDs+G7jeG7k+G7leG7l+G7keG7meG7neG7n+G7oeG7m+G7o8O54buW4bunxanDuuG7peG7q+G7reG7r+G7qeG7seG7s+G7t+G7ucO94bu14buQXCJcbiAgfSxcbiAgXCJnZW9yZ2lhbmFjYWRlbXlcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKAwoHigJrGkuKAnuKApuKAoOKAocuG4oCwxaDigLnFksKNwo7Cj8KQ4oCY4oCZ4oCc4oCd4oCi4oCT4oCUy5zihKLFoeKAusWTwp3CnsW4wqDCocKiwqPCpMKlwqbCp8KowqnCqsKrwqzCrcKuwq/CsMKxwrLCs8K0wrXCtsK3wrjCucK6wrvCvMK9wr7Cv+GDkOGDkeGDkuGDk+GDlOGDleGDluGDl+GDmOGDmeGDmuGDm+GDnOGDneGDnuGDn+GDoOGDoeGDouGDo+GDpOGDpeGDpuGDp+GDqOGDqeGDquGDq+GDrOGDreGDruGDr+GDsOGDseGDsuGDs+GDtOGDteGDtsOnw6jDqcOqw6vDrMOtw67Dr8Oww7HDssOzw7TDtcO2w7fDuMO5w7rDu8O8w73DvsO/XCJcbiAgfSxcbiAgXCJnZW9yZ2lhbnBzXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKB4oCaxpLigJ7igKbigKDigKHLhuKAsMWg4oC5xZLCjcKOwo/CkOKAmOKAmeKAnOKAneKAouKAk+KAlMuc4oSixaHigLrFk8Kdwp7FuMKgwqHCosKjwqTCpcKmwqfCqMKpwqrCq8Kswq3CrsKvwrDCscKywrPCtMK1wrbCt8K4wrnCusK7wrzCvcK+wr/hg5Dhg5Hhg5Lhg5Phg5Thg5Xhg5bhg7Hhg5fhg5jhg5nhg5rhg5vhg5zhg7Lhg53hg57hg5/hg6Dhg6Hhg6Lhg7Phg6Phg6Thg6Xhg6bhg6fhg6jhg6nhg6rhg6vhg6zhg63hg67hg7Thg6/hg7Dhg7XDpsOnw6jDqcOqw6vDrMOtw67Dr8Oww7HDssOzw7TDtcO2w7fDuMO5w7rDu8O8w73DvsO/XCJcbiAgfSxcbiAgXCJwdDE1NFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwi0pbSktOu0pPigJ7igKbSttKu0rLSr9Kg06LSotKa0rrSuNKX4oCY4oCZ4oCc4oCd4oCi4oCT4oCU0rPSt9Kh06PSo9Kb0rvSucKg0I7RntCI06jSmNKwwqfQgcKp05jCq8Ks06/CrtKcwrDSsdCG0ZbSmdOpwrbCt9GR4oSW05nCu9GY0qrSq9Kd0JDQkdCS0JPQlNCV0JbQl9CY0JnQmtCb0JzQndCe0J/QoNCh0KLQo9Ck0KXQptCn0KjQqdCq0KvQrNCt0K7Qr9Cw0LHQstCz0LTQtdC20LfQuNC50LrQu9C80L3QvtC/0YDRgdGC0YPRhNGF0YbRh9GI0YnRitGL0YzRjdGO0Y9cIlxuICB9LFxuICBcInZpc2NpaVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiXFx1MDAwMFxcdTAwMDHhurJcXHUwMDAzXFx1MDAwNOG6tOG6qlxcdTAwMDdcXGJcXHRcXG5cXHUwMDBiXFxmXFxyXFx1MDAwZVxcdTAwMGZcXHUwMDEwXFx1MDAxMVxcdTAwMTJcXHUwMDEz4bu2XFx1MDAxNVxcdTAwMTZcXHUwMDE3XFx1MDAxOOG7uFxcdTAwMWFcXHUwMDFiXFx1MDAxY1xcdTAwMWThu7RcXHUwMDFmICFcXFwiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXFxcXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/4bqg4bqu4bqw4bq24bqk4bqm4bqo4bqs4bq84bq44bq+4buA4buC4buE4buG4buQ4buS4buU4buW4buY4bui4bua4buc4bue4buK4buO4buM4buI4bumxajhu6Thu7LDleG6r+G6seG6t+G6peG6p+G6qeG6reG6veG6ueG6v+G7geG7g+G7heG7h+G7keG7k+G7leG7l+G7oMag4buZ4bud4buf4buL4buw4buo4buq4busxqHhu5vGr8OAw4HDgsOD4bqixILhurPhurXDiMOJw4rhurrDjMONxKjhu7PEkOG7qcOSw5PDlOG6oeG7t+G7q+G7rcOZw5rhu7nhu7XDneG7ocaww6DDocOiw6PhuqPEg+G7r+G6q8Oow6nDquG6u8Osw63EqeG7icSR4buxw7LDs8O0w7Xhu4/hu43hu6XDucO6xanhu6fDveG7o+G7rlwiXG4gIH0sXG4gIFwiaXNvNjQ2Y25cIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIlxcdTAwMDBcXHUwMDAxXFx1MDAwMlxcdTAwMDNcXHUwMDA0XFx1MDAwNVxcdTAwMDZcXHUwMDA3XFxiXFx0XFxuXFx1MDAwYlxcZlxcclxcdTAwMGVcXHUwMDBmXFx1MDAxMFxcdTAwMTFcXHUwMDEyXFx1MDAxM1xcdTAwMTRcXHUwMDE1XFx1MDAxNlxcdTAwMTdcXHUwMDE4XFx1MDAxOVxcdTAwMWFcXHUwMDFiXFx1MDAxY1xcdTAwMWRcXHUwMDFlXFx1MDAxZiAhXFxcIiPCpSUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXFxcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x94oC+f++/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/vVwiXG4gIH0sXG4gIFwiaXNvNjQ2anBcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIlxcdTAwMDBcXHUwMDAxXFx1MDAwMlxcdTAwMDNcXHUwMDA0XFx1MDAwNVxcdTAwMDZcXHUwMDA3XFxiXFx0XFxuXFx1MDAwYlxcZlxcclxcdTAwMGVcXHUwMDBmXFx1MDAxMFxcdTAwMTFcXHUwMDEyXFx1MDAxM1xcdTAwMTRcXHUwMDE1XFx1MDAxNlxcdTAwMTdcXHUwMDE4XFx1MDAxOVxcdTAwMWFcXHUwMDFiXFx1MDAxY1xcdTAwMWRcXHUwMDFlXFx1MDAxZiAhXFxcIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW8KlXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x94oC+f++/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/vVwiXG4gIH0sXG4gIFwiaHByb21hbjhcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp/CoMOAw4LDiMOKw4vDjsOPwrTLi8uGwqjLnMOZw5vigqTCr8Odw73CsMOHw6fDkcOxwqHCv8KkwqPCpcKnxpLCosOiw6rDtMO7w6HDqcOzw7rDoMOow7LDucOkw6vDtsO8w4XDrsOYw4bDpcOtw7jDpsOEw6zDlsOcw4nDr8Ofw5TDgcODw6PDkMOww43DjMOTw5LDlcO1xaDFocOaxbjDv8Oew77Ct8K1wrbCvuKAlMK8wr3CqsK6wqvilqDCu8Kx77+9XCJcbiAgfSxcbiAgXCJtYWNpbnRvc2hcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsOEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zigKDCsMKiwqPCp+KAosK2w5/CrsKp4oSiwrTCqOKJoMOGw5jiiJ7CseKJpOKJpcKlwrXiiILiiJHiiI/PgOKIq8KqwrrihKbDpsO4wr/CocKs4oiaxpLiiYjiiIbCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rDv8W44oGEwqTigLnigLrvrIHvrILigKHCt+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvv73DksOaw5vDmcSxy4bLnMKvy5jLmcuawrjLncuby4dcIlxuICB9LFxuICBcImFzY2lpXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLvv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv71cIlxuICB9LFxuICBcInRpczYyMFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwi77+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+94LiB4LiC4LiD4LiE4LiF4LiG4LiH4LiI4LiJ4LiK4LiL4LiM4LiN4LiO4LiP4LiQ4LiR4LiS4LiT4LiU4LiV4LiW4LiX4LiY4LiZ4Lia4Lib4Lic4Lid4Lie4Lif4Lig4Lih4Lii4Lij4Lik4Lil4Lim4Lin4Lio4Lip4Liq4Lir4Lis4Lit4Liu4Liv4Liw4Lix4Liy4Liz4Li04Li14Li24Li34Li44Li54Li677+977+977+977+94Li/4LmA4LmB4LmC4LmD4LmE4LmF4LmG4LmH4LmI4LmJ4LmK4LmL4LmM4LmN4LmO4LmP4LmQ4LmR4LmS4LmT4LmU4LmV4LmW4LmX4LmY4LmZ4Lma4Lmb77+977+977+977+9XCJcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL3NiY3MtZGF0YS1nZW5lcmF0ZWQuanNcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBCdWZmZXIgPSByZXF1aXJlKFwic2FmZXItYnVmZmVyXCIpLkJ1ZmZlcjtcblxuLy8gTXVsdGlieXRlIGNvZGVjLiBJbiB0aGlzIHNjaGVtZSwgYSBjaGFyYWN0ZXIgaXMgcmVwcmVzZW50ZWQgYnkgMSBvciBtb3JlIGJ5dGVzLlxuLy8gT3VyIGNvZGVjIHN1cHBvcnRzIFVURi0xNiBzdXJyb2dhdGVzLCBleHRlbnNpb25zIGZvciBHQjE4MDMwIGFuZCB1bmljb2RlIHNlcXVlbmNlcy5cbi8vIFRvIHNhdmUgbWVtb3J5IGFuZCBsb2FkaW5nIHRpbWUsIHdlIHJlYWQgdGFibGUgZmlsZXMgb25seSB3aGVuIHJlcXVlc3RlZC5cblxuZXhwb3J0cy5fZGJjcyA9IERCQ1NDb2RlYztcblxudmFyIFVOQVNTSUdORUQgPSAtMSxcbiAgICBHQjE4MDMwX0NPREUgPSAtMixcbiAgICBTRVFfU1RBUlQgID0gLTEwLFxuICAgIE5PREVfU1RBUlQgPSAtMTAwMCxcbiAgICBVTkFTU0lHTkVEX05PREUgPSBuZXcgQXJyYXkoMHgxMDApLFxuICAgIERFRl9DSEFSID0gLTE7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMHgxMDA7IGkrKylcbiAgICBVTkFTU0lHTkVEX05PREVbaV0gPSBVTkFTU0lHTkVEO1xuXG5cbi8vIENsYXNzIERCQ1NDb2RlYyByZWFkcyBhbmQgaW5pdGlhbGl6ZXMgbWFwcGluZyB0YWJsZXMuXG5mdW5jdGlvbiBEQkNTQ29kZWMoY29kZWNPcHRpb25zLCBpY29udikge1xuICAgIHRoaXMuZW5jb2RpbmdOYW1lID0gY29kZWNPcHRpb25zLmVuY29kaW5nTmFtZTtcbiAgICBpZiAoIWNvZGVjT3B0aW9ucylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiREJDUyBjb2RlYyBpcyBjYWxsZWQgd2l0aG91dCB0aGUgZGF0YS5cIilcbiAgICBpZiAoIWNvZGVjT3B0aW9ucy50YWJsZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jb2RpbmcgJ1wiICsgdGhpcy5lbmNvZGluZ05hbWUgKyBcIicgaGFzIG5vIGRhdGEuXCIpO1xuXG4gICAgLy8gTG9hZCB0YWJsZXMuXG4gICAgdmFyIG1hcHBpbmdUYWJsZSA9IGNvZGVjT3B0aW9ucy50YWJsZSgpO1xuXG5cbiAgICAvLyBEZWNvZGUgdGFibGVzOiBNQkNTIC0+IFVuaWNvZGUuXG5cbiAgICAvLyBkZWNvZGVUYWJsZXMgaXMgYSB0cmllLCBlbmNvZGVkIGFzIGFuIGFycmF5IG9mIGFycmF5cyBvZiBpbnRlZ2Vycy4gSW50ZXJuYWwgYXJyYXlzIGFyZSB0cmllIG5vZGVzIGFuZCBhbGwgaGF2ZSBsZW4gPSAyNTYuXG4gICAgLy8gVHJpZSByb290IGlzIGRlY29kZVRhYmxlc1swXS5cbiAgICAvLyBWYWx1ZXM6ID49ICAwIC0+IHVuaWNvZGUgY2hhcmFjdGVyIGNvZGUuIGNhbiBiZSA+IDB4RkZGRlxuICAgIC8vICAgICAgICAgPT0gVU5BU1NJR05FRCAtPiB1bmtub3duL3VuYXNzaWduZWQgc2VxdWVuY2UuXG4gICAgLy8gICAgICAgICA9PSBHQjE4MDMwX0NPREUgLT4gdGhpcyBpcyB0aGUgZW5kIG9mIGEgR0IxODAzMCA0LWJ5dGUgc2VxdWVuY2UuXG4gICAgLy8gICAgICAgICA8PSBOT0RFX1NUQVJUIC0+IGluZGV4IG9mIHRoZSBuZXh0IG5vZGUgaW4gb3VyIHRyaWUgdG8gcHJvY2VzcyBuZXh0IGJ5dGUuXG4gICAgLy8gICAgICAgICA8PSBTRVFfU1RBUlQgIC0+IGluZGV4IG9mIHRoZSBzdGFydCBvZiBhIGNoYXJhY3RlciBjb2RlIHNlcXVlbmNlLCBpbiBkZWNvZGVUYWJsZVNlcS5cbiAgICB0aGlzLmRlY29kZVRhYmxlcyA9IFtdO1xuICAgIHRoaXMuZGVjb2RlVGFibGVzWzBdID0gVU5BU1NJR05FRF9OT0RFLnNsaWNlKDApOyAvLyBDcmVhdGUgcm9vdCBub2RlLlxuXG4gICAgLy8gU29tZXRpbWVzIGEgTUJDUyBjaGFyIGNvcnJlc3BvbmRzIHRvIGEgc2VxdWVuY2Ugb2YgdW5pY29kZSBjaGFycy4gV2Ugc3RvcmUgdGhlbSBhcyBhcnJheXMgb2YgaW50ZWdlcnMgaGVyZS4gXG4gICAgdGhpcy5kZWNvZGVUYWJsZVNlcSA9IFtdO1xuXG4gICAgLy8gQWN0dWFsIG1hcHBpbmcgdGFibGVzIGNvbnNpc3Qgb2YgY2h1bmtzLiBVc2UgdGhlbSB0byBmaWxsIHVwIGRlY29kZSB0YWJsZXMuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXBwaW5nVGFibGUubGVuZ3RoOyBpKyspXG4gICAgICAgIHRoaXMuX2FkZERlY29kZUNodW5rKG1hcHBpbmdUYWJsZVtpXSk7XG5cbiAgICB0aGlzLmRlZmF1bHRDaGFyVW5pY29kZSA9IGljb252LmRlZmF1bHRDaGFyVW5pY29kZTtcblxuICAgIFxuICAgIC8vIEVuY29kZSB0YWJsZXM6IFVuaWNvZGUgLT4gREJDUy5cblxuICAgIC8vIGBlbmNvZGVUYWJsZWAgaXMgYXJyYXkgbWFwcGluZyBmcm9tIHVuaWNvZGUgY2hhciB0byBlbmNvZGVkIGNoYXIuIEFsbCBpdHMgdmFsdWVzIGFyZSBpbnRlZ2VycyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgLy8gQmVjYXVzZSBpdCBjYW4gYmUgc3BhcnNlLCBpdCBpcyByZXByZXNlbnRlZCBhcyBhcnJheSBvZiBidWNrZXRzIGJ5IDI1NiBjaGFycyBlYWNoLiBCdWNrZXQgY2FuIGJlIG51bGwuXG4gICAgLy8gVmFsdWVzOiA+PSAgMCAtPiBpdCBpcyBhIG5vcm1hbCBjaGFyLiBXcml0ZSB0aGUgdmFsdWUgKGlmIDw9MjU2IHRoZW4gMSBieXRlLCBpZiA8PTY1NTM2IHRoZW4gMiBieXRlcywgZXRjLikuXG4gICAgLy8gICAgICAgICA9PSBVTkFTU0lHTkVEIC0+IG5vIGNvbnZlcnNpb24gZm91bmQuIE91dHB1dCBhIGRlZmF1bHQgY2hhci5cbiAgICAvLyAgICAgICAgIDw9IFNFUV9TVEFSVCAgLT4gaXQncyBhbiBpbmRleCBpbiBlbmNvZGVUYWJsZVNlcSwgc2VlIGJlbG93LiBUaGUgY2hhcmFjdGVyIHN0YXJ0cyBhIHNlcXVlbmNlLlxuICAgIHRoaXMuZW5jb2RlVGFibGUgPSBbXTtcbiAgICBcbiAgICAvLyBgZW5jb2RlVGFibGVTZXFgIGlzIHVzZWQgd2hlbiBhIHNlcXVlbmNlIG9mIHVuaWNvZGUgY2hhcmFjdGVycyBpcyBlbmNvZGVkIGFzIGEgc2luZ2xlIGNvZGUuIFdlIHVzZSBhIHRyZWUgb2ZcbiAgICAvLyBvYmplY3RzIHdoZXJlIGtleXMgY29ycmVzcG9uZCB0byBjaGFyYWN0ZXJzIGluIHNlcXVlbmNlIGFuZCBsZWFmcyBhcmUgdGhlIGVuY29kZWQgZGJjcyB2YWx1ZXMuIEEgc3BlY2lhbCBERUZfQ0hBUiBrZXlcbiAgICAvLyBtZWFucyBlbmQgb2Ygc2VxdWVuY2UgKG5lZWRlZCB3aGVuIG9uZSBzZXF1ZW5jZSBpcyBhIHN0cmljdCBzdWJzZXF1ZW5jZSBvZiBhbm90aGVyKS5cbiAgICAvLyBPYmplY3RzIGFyZSBrZXB0IHNlcGFyYXRlbHkgZnJvbSBlbmNvZGVUYWJsZSB0byBpbmNyZWFzZSBwZXJmb3JtYW5jZS5cbiAgICB0aGlzLmVuY29kZVRhYmxlU2VxID0gW107XG5cbiAgICAvLyBTb21lIGNoYXJzIGNhbiBiZSBkZWNvZGVkLCBidXQgbmVlZCBub3QgYmUgZW5jb2RlZC5cbiAgICB2YXIgc2tpcEVuY29kZUNoYXJzID0ge307XG4gICAgaWYgKGNvZGVjT3B0aW9ucy5lbmNvZGVTa2lwVmFscylcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2RlY09wdGlvbnMuZW5jb2RlU2tpcFZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBjb2RlY09wdGlvbnMuZW5jb2RlU2tpcFZhbHNbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgc2tpcEVuY29kZUNoYXJzW3ZhbF0gPSB0cnVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSB2YWwuZnJvbTsgaiA8PSB2YWwudG87IGorKylcbiAgICAgICAgICAgICAgICAgICAgc2tpcEVuY29kZUNoYXJzW2pdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAvLyBVc2UgZGVjb2RlIHRyaWUgdG8gcmVjdXJzaXZlbHkgZmlsbCBvdXQgZW5jb2RlIHRhYmxlcy5cbiAgICB0aGlzLl9maWxsRW5jb2RlVGFibGUoMCwgMCwgc2tpcEVuY29kZUNoYXJzKTtcblxuICAgIC8vIEFkZCBtb3JlIGVuY29kaW5nIHBhaXJzIHdoZW4gbmVlZGVkLlxuICAgIGlmIChjb2RlY09wdGlvbnMuZW5jb2RlQWRkKSB7XG4gICAgICAgIGZvciAodmFyIHVDaGFyIGluIGNvZGVjT3B0aW9ucy5lbmNvZGVBZGQpXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvZGVjT3B0aW9ucy5lbmNvZGVBZGQsIHVDaGFyKSlcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRFbmNvZGVDaGFyKHVDaGFyLmNoYXJDb2RlQXQoMCksIGNvZGVjT3B0aW9ucy5lbmNvZGVBZGRbdUNoYXJdKTtcbiAgICB9XG5cbiAgICB0aGlzLmRlZkNoYXJTQiAgPSB0aGlzLmVuY29kZVRhYmxlWzBdW2ljb252LmRlZmF1bHRDaGFyU2luZ2xlQnl0ZS5jaGFyQ29kZUF0KDApXTtcbiAgICBpZiAodGhpcy5kZWZDaGFyU0IgPT09IFVOQVNTSUdORUQpIHRoaXMuZGVmQ2hhclNCID0gdGhpcy5lbmNvZGVUYWJsZVswXVsnPyddO1xuICAgIGlmICh0aGlzLmRlZkNoYXJTQiA9PT0gVU5BU1NJR05FRCkgdGhpcy5kZWZDaGFyU0IgPSBcIj9cIi5jaGFyQ29kZUF0KDApO1xuXG5cbiAgICAvLyBMb2FkICYgY3JlYXRlIEdCMTgwMzAgdGFibGVzIHdoZW4gbmVlZGVkLlxuICAgIGlmICh0eXBlb2YgY29kZWNPcHRpb25zLmdiMTgwMzAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5nYjE4MDMwID0gY29kZWNPcHRpb25zLmdiMTgwMzAoKTsgLy8gTG9hZCBHQjE4MDMwIHJhbmdlcy5cblxuICAgICAgICAvLyBBZGQgR0IxODAzMCBkZWNvZGUgdGFibGVzLlxuICAgICAgICB2YXIgdGhpcmRCeXRlTm9kZUlkeCA9IHRoaXMuZGVjb2RlVGFibGVzLmxlbmd0aDtcbiAgICAgICAgdmFyIHRoaXJkQnl0ZU5vZGUgPSB0aGlzLmRlY29kZVRhYmxlc1t0aGlyZEJ5dGVOb2RlSWR4XSA9IFVOQVNTSUdORURfTk9ERS5zbGljZSgwKTtcblxuICAgICAgICB2YXIgZm91cnRoQnl0ZU5vZGVJZHggPSB0aGlzLmRlY29kZVRhYmxlcy5sZW5ndGg7XG4gICAgICAgIHZhciBmb3VydGhCeXRlTm9kZSA9IHRoaXMuZGVjb2RlVGFibGVzW2ZvdXJ0aEJ5dGVOb2RlSWR4XSA9IFVOQVNTSUdORURfTk9ERS5zbGljZSgwKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMHg4MTsgaSA8PSAweEZFOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzZWNvbmRCeXRlTm9kZUlkeCA9IE5PREVfU1RBUlQgLSB0aGlzLmRlY29kZVRhYmxlc1swXVtpXTtcbiAgICAgICAgICAgIHZhciBzZWNvbmRCeXRlTm9kZSA9IHRoaXMuZGVjb2RlVGFibGVzW3NlY29uZEJ5dGVOb2RlSWR4XTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAweDMwOyBqIDw9IDB4Mzk7IGorKylcbiAgICAgICAgICAgICAgICBzZWNvbmRCeXRlTm9kZVtqXSA9IE5PREVfU1RBUlQgLSB0aGlyZEJ5dGVOb2RlSWR4O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAweDgxOyBpIDw9IDB4RkU7IGkrKylcbiAgICAgICAgICAgIHRoaXJkQnl0ZU5vZGVbaV0gPSBOT0RFX1NUQVJUIC0gZm91cnRoQnl0ZU5vZGVJZHg7XG4gICAgICAgIGZvciAodmFyIGkgPSAweDMwOyBpIDw9IDB4Mzk7IGkrKylcbiAgICAgICAgICAgIGZvdXJ0aEJ5dGVOb2RlW2ldID0gR0IxODAzMF9DT0RFXG4gICAgfSAgICAgICAgXG59XG5cbkRCQ1NDb2RlYy5wcm90b3R5cGUuZW5jb2RlciA9IERCQ1NFbmNvZGVyO1xuREJDU0NvZGVjLnByb3RvdHlwZS5kZWNvZGVyID0gREJDU0RlY29kZXI7XG5cbi8vIERlY29kZXIgaGVscGVyc1xuREJDU0NvZGVjLnByb3RvdHlwZS5fZ2V0RGVjb2RlVHJpZU5vZGUgPSBmdW5jdGlvbihhZGRyKSB7XG4gICAgdmFyIGJ5dGVzID0gW107XG4gICAgZm9yICg7IGFkZHIgPiAwOyBhZGRyID4+PSA4KVxuICAgICAgICBieXRlcy5wdXNoKGFkZHIgJiAweEZGKTtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoID09IDApXG4gICAgICAgIGJ5dGVzLnB1c2goMCk7XG5cbiAgICB2YXIgbm9kZSA9IHRoaXMuZGVjb2RlVGFibGVzWzBdO1xuICAgIGZvciAodmFyIGkgPSBieXRlcy5sZW5ndGgtMTsgaSA+IDA7IGktLSkgeyAvLyBUcmF2ZXJzZSBub2RlcyBkZWVwZXIgaW50byB0aGUgdHJpZS5cbiAgICAgICAgdmFyIHZhbCA9IG5vZGVbYnl0ZXNbaV1dO1xuXG4gICAgICAgIGlmICh2YWwgPT0gVU5BU1NJR05FRCkgeyAvLyBDcmVhdGUgbmV3IG5vZGUuXG4gICAgICAgICAgICBub2RlW2J5dGVzW2ldXSA9IE5PREVfU1RBUlQgLSB0aGlzLmRlY29kZVRhYmxlcy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmRlY29kZVRhYmxlcy5wdXNoKG5vZGUgPSBVTkFTU0lHTkVEX05PREUuc2xpY2UoMCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbCA8PSBOT0RFX1NUQVJUKSB7IC8vIEV4aXN0aW5nIG5vZGUuXG4gICAgICAgICAgICBub2RlID0gdGhpcy5kZWNvZGVUYWJsZXNbTk9ERV9TVEFSVCAtIHZhbF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3ZlcndyaXRlIGJ5dGUgaW4gXCIgKyB0aGlzLmVuY29kaW5nTmFtZSArIFwiLCBhZGRyOiBcIiArIGFkZHIudG9TdHJpbmcoMTYpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5cblxuREJDU0NvZGVjLnByb3RvdHlwZS5fYWRkRGVjb2RlQ2h1bmsgPSBmdW5jdGlvbihjaHVuaykge1xuICAgIC8vIEZpcnN0IGVsZW1lbnQgb2YgY2h1bmsgaXMgdGhlIGhleCBtYmNzIGNvZGUgd2hlcmUgd2Ugc3RhcnQuXG4gICAgdmFyIGN1ckFkZHIgPSBwYXJzZUludChjaHVua1swXSwgMTYpO1xuXG4gICAgLy8gQ2hvb3NlIHRoZSBkZWNvZGluZyBub2RlIHdoZXJlIHdlJ2xsIHdyaXRlIG91ciBjaGFycy5cbiAgICB2YXIgd3JpdGVUYWJsZSA9IHRoaXMuX2dldERlY29kZVRyaWVOb2RlKGN1ckFkZHIpO1xuICAgIGN1ckFkZHIgPSBjdXJBZGRyICYgMHhGRjtcblxuICAgIC8vIFdyaXRlIGFsbCBvdGhlciBlbGVtZW50cyBvZiB0aGUgY2h1bmsgdG8gdGhlIHRhYmxlLlxuICAgIGZvciAodmFyIGsgPSAxOyBrIDwgY2h1bmsubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBjaHVua1trXTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ID09PSBcInN0cmluZ1wiKSB7IC8vIFN0cmluZywgd3JpdGUgYXMtaXMuXG4gICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHBhcnQubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gcGFydC5jaGFyQ29kZUF0KGwrKyk7XG4gICAgICAgICAgICAgICAgaWYgKDB4RDgwMCA8PSBjb2RlICYmIGNvZGUgPCAweERDMDApIHsgLy8gRGVjb2RlIHN1cnJvZ2F0ZVxuICAgICAgICAgICAgICAgICAgICB2YXIgY29kZVRyYWlsID0gcGFydC5jaGFyQ29kZUF0KGwrKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgweERDMDAgPD0gY29kZVRyYWlsICYmIGNvZGVUcmFpbCA8IDB4RTAwMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlVGFibGVbY3VyQWRkcisrXSA9IDB4MTAwMDAgKyAoY29kZSAtIDB4RDgwMCkgKiAweDQwMCArIChjb2RlVHJhaWwgLSAweERDMDApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvcnJlY3Qgc3Vycm9nYXRlIHBhaXIgaW4gXCIgICsgdGhpcy5lbmNvZGluZ05hbWUgKyBcIiBhdCBjaHVuayBcIiArIGNodW5rWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoMHgwRkYwIDwgY29kZSAmJiBjb2RlIDw9IDB4MEZGRikgeyAvLyBDaGFyYWN0ZXIgc2VxdWVuY2UgKG91ciBvd24gZW5jb2RpbmcgdXNlZClcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IDB4RkZGIC0gY29kZSArIDI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBsZW47IG0rKylcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcS5wdXNoKHBhcnQuY2hhckNvZGVBdChsKyspKTsgLy8gU2ltcGxlIHZhcmlhdGlvbjogZG9uJ3Qgc3VwcG9ydCBzdXJyb2dhdGVzIG9yIHN1YnNlcXVlbmNlcyBpbiBzZXEuXG5cbiAgICAgICAgICAgICAgICAgICAgd3JpdGVUYWJsZVtjdXJBZGRyKytdID0gU0VRX1NUQVJUIC0gdGhpcy5kZWNvZGVUYWJsZVNlcS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlVGFibGVTZXEucHVzaChzZXEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVGFibGVbY3VyQWRkcisrXSA9IGNvZGU7IC8vIEJhc2ljIGNoYXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBhcnQgPT09IFwibnVtYmVyXCIpIHsgLy8gSW50ZWdlciwgbWVhbmluZyBpbmNyZWFzaW5nIHNlcXVlbmNlIHN0YXJ0aW5nIHdpdGggcHJldiBjaGFyYWN0ZXIuXG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB3cml0ZVRhYmxlW2N1ckFkZHIgLSAxXSArIDE7XG4gICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHBhcnQ7IGwrKylcbiAgICAgICAgICAgICAgICB3cml0ZVRhYmxlW2N1ckFkZHIrK10gPSBjaGFyQ29kZSsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29ycmVjdCB0eXBlICdcIiArIHR5cGVvZiBwYXJ0ICsgXCInIGdpdmVuIGluIFwiICArIHRoaXMuZW5jb2RpbmdOYW1lICsgXCIgYXQgY2h1bmsgXCIgKyBjaHVua1swXSk7XG4gICAgfVxuICAgIGlmIChjdXJBZGRyID4gMHhGRilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5jb3JyZWN0IGNodW5rIGluIFwiICArIHRoaXMuZW5jb2RpbmdOYW1lICsgXCIgYXQgYWRkciBcIiArIGNodW5rWzBdICsgXCI6IHRvbyBsb25nXCIgKyBjdXJBZGRyKTtcbn1cblxuLy8gRW5jb2RlciBoZWxwZXJzXG5EQkNTQ29kZWMucHJvdG90eXBlLl9nZXRFbmNvZGVCdWNrZXQgPSBmdW5jdGlvbih1Q29kZSkge1xuICAgIHZhciBoaWdoID0gdUNvZGUgPj4gODsgLy8gVGhpcyBjb3VsZCBiZSA+IDB4RkYgYmVjYXVzZSBvZiBhc3RyYWwgY2hhcmFjdGVycy5cbiAgICBpZiAodGhpcy5lbmNvZGVUYWJsZVtoaWdoXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aGlzLmVuY29kZVRhYmxlW2hpZ2hdID0gVU5BU1NJR05FRF9OT0RFLnNsaWNlKDApOyAvLyBDcmVhdGUgYnVja2V0IG9uIGRlbWFuZC5cbiAgICByZXR1cm4gdGhpcy5lbmNvZGVUYWJsZVtoaWdoXTtcbn1cblxuREJDU0NvZGVjLnByb3RvdHlwZS5fc2V0RW5jb2RlQ2hhciA9IGZ1bmN0aW9uKHVDb2RlLCBkYmNzQ29kZSkge1xuICAgIHZhciBidWNrZXQgPSB0aGlzLl9nZXRFbmNvZGVCdWNrZXQodUNvZGUpO1xuICAgIHZhciBsb3cgPSB1Q29kZSAmIDB4RkY7XG4gICAgaWYgKGJ1Y2tldFtsb3ddIDw9IFNFUV9TVEFSVClcbiAgICAgICAgdGhpcy5lbmNvZGVUYWJsZVNlcVtTRVFfU1RBUlQtYnVja2V0W2xvd11dW0RFRl9DSEFSXSA9IGRiY3NDb2RlOyAvLyBUaGVyZSdzIGFscmVhZHkgYSBzZXF1ZW5jZSwgc2V0IGEgc2luZ2xlLWNoYXIgc3Vic2VxdWVuY2Ugb2YgaXQuXG4gICAgZWxzZSBpZiAoYnVja2V0W2xvd10gPT0gVU5BU1NJR05FRClcbiAgICAgICAgYnVja2V0W2xvd10gPSBkYmNzQ29kZTtcbn1cblxuREJDU0NvZGVjLnByb3RvdHlwZS5fc2V0RW5jb2RlU2VxdWVuY2UgPSBmdW5jdGlvbihzZXEsIGRiY3NDb2RlKSB7XG4gICAgXG4gICAgLy8gR2V0IHRoZSByb290IG9mIGNoYXJhY3RlciB0cmVlIGFjY29yZGluZyB0byBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIHNlcXVlbmNlLlxuICAgIHZhciB1Q29kZSA9IHNlcVswXTtcbiAgICB2YXIgYnVja2V0ID0gdGhpcy5fZ2V0RW5jb2RlQnVja2V0KHVDb2RlKTtcbiAgICB2YXIgbG93ID0gdUNvZGUgJiAweEZGO1xuXG4gICAgdmFyIG5vZGU7XG4gICAgaWYgKGJ1Y2tldFtsb3ddIDw9IFNFUV9TVEFSVCkge1xuICAgICAgICAvLyBUaGVyZSdzIGFscmVhZHkgYSBzZXF1ZW5jZSB3aXRoICAtIHVzZSBpdC5cbiAgICAgICAgbm9kZSA9IHRoaXMuZW5jb2RlVGFibGVTZXFbU0VRX1NUQVJULWJ1Y2tldFtsb3ddXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRoZXJlIHdhcyBubyBzZXF1ZW5jZSBvYmplY3QgLSBhbGxvY2F0ZSBhIG5ldyBvbmUuXG4gICAgICAgIG5vZGUgPSB7fTtcbiAgICAgICAgaWYgKGJ1Y2tldFtsb3ddICE9PSBVTkFTU0lHTkVEKSBub2RlW0RFRl9DSEFSXSA9IGJ1Y2tldFtsb3ddOyAvLyBJZiBhIGNoYXIgd2FzIHNldCBiZWZvcmUgLSBtYWtlIGl0IGEgc2luZ2xlLWNoYXIgc3Vic2VxdWVuY2UuXG4gICAgICAgIGJ1Y2tldFtsb3ddID0gU0VRX1NUQVJUIC0gdGhpcy5lbmNvZGVUYWJsZVNlcS5sZW5ndGg7XG4gICAgICAgIHRoaXMuZW5jb2RlVGFibGVTZXEucHVzaChub2RlKTtcbiAgICB9XG5cbiAgICAvLyBUcmF2ZXJzZSB0aGUgY2hhcmFjdGVyIHRyZWUsIGFsbG9jYXRpbmcgbmV3IG5vZGVzIGFzIG5lZWRlZC5cbiAgICBmb3IgKHZhciBqID0gMTsgaiA8IHNlcS5sZW5ndGgtMTsgaisrKSB7XG4gICAgICAgIHZhciBvbGRWYWwgPSBub2RlW3VDb2RlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBvbGRWYWwgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgbm9kZSA9IG9sZFZhbDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZVt1Q29kZV0gPSB7fVxuICAgICAgICAgICAgaWYgKG9sZFZhbCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIG5vZGVbREVGX0NIQVJdID0gb2xkVmFsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIGxlYWYgdG8gZ2l2ZW4gZGJjc0NvZGUuXG4gICAgdUNvZGUgPSBzZXFbc2VxLmxlbmd0aC0xXTtcbiAgICBub2RlW3VDb2RlXSA9IGRiY3NDb2RlO1xufVxuXG5EQkNTQ29kZWMucHJvdG90eXBlLl9maWxsRW5jb2RlVGFibGUgPSBmdW5jdGlvbihub2RlSWR4LCBwcmVmaXgsIHNraXBFbmNvZGVDaGFycykge1xuICAgIHZhciBub2RlID0gdGhpcy5kZWNvZGVUYWJsZXNbbm9kZUlkeF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAweDEwMDsgaSsrKSB7XG4gICAgICAgIHZhciB1Q29kZSA9IG5vZGVbaV07XG4gICAgICAgIHZhciBtYkNvZGUgPSBwcmVmaXggKyBpO1xuICAgICAgICBpZiAoc2tpcEVuY29kZUNoYXJzW21iQ29kZV0pXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBpZiAodUNvZGUgPj0gMClcbiAgICAgICAgICAgIHRoaXMuX3NldEVuY29kZUNoYXIodUNvZGUsIG1iQ29kZSk7XG4gICAgICAgIGVsc2UgaWYgKHVDb2RlIDw9IE5PREVfU1RBUlQpXG4gICAgICAgICAgICB0aGlzLl9maWxsRW5jb2RlVGFibGUoTk9ERV9TVEFSVCAtIHVDb2RlLCBtYkNvZGUgPDwgOCwgc2tpcEVuY29kZUNoYXJzKTtcbiAgICAgICAgZWxzZSBpZiAodUNvZGUgPD0gU0VRX1NUQVJUKVxuICAgICAgICAgICAgdGhpcy5fc2V0RW5jb2RlU2VxdWVuY2UodGhpcy5kZWNvZGVUYWJsZVNlcVtTRVFfU1RBUlQgLSB1Q29kZV0sIG1iQ29kZSk7XG4gICAgfVxufVxuXG5cblxuLy8gPT0gRW5jb2RlciA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gREJDU0VuY29kZXIob3B0aW9ucywgY29kZWMpIHtcbiAgICAvLyBFbmNvZGVyIHN0YXRlXG4gICAgdGhpcy5sZWFkU3Vycm9nYXRlID0gLTE7XG4gICAgdGhpcy5zZXFPYmogPSB1bmRlZmluZWQ7XG4gICAgXG4gICAgLy8gU3RhdGljIGRhdGFcbiAgICB0aGlzLmVuY29kZVRhYmxlID0gY29kZWMuZW5jb2RlVGFibGU7XG4gICAgdGhpcy5lbmNvZGVUYWJsZVNlcSA9IGNvZGVjLmVuY29kZVRhYmxlU2VxO1xuICAgIHRoaXMuZGVmYXVsdENoYXJTaW5nbGVCeXRlID0gY29kZWMuZGVmQ2hhclNCO1xuICAgIHRoaXMuZ2IxODAzMCA9IGNvZGVjLmdiMTgwMzA7XG59XG5cbkRCQ1NFbmNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciBuZXdCdWYgPSBCdWZmZXIuYWxsb2Moc3RyLmxlbmd0aCAqICh0aGlzLmdiMTgwMzAgPyA0IDogMykpLFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gdGhpcy5sZWFkU3Vycm9nYXRlLFxuICAgICAgICBzZXFPYmogPSB0aGlzLnNlcU9iaiwgbmV4dENoYXIgPSAtMSxcbiAgICAgICAgaSA9IDAsIGogPSAwO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgLy8gMC4gR2V0IG5leHQgY2hhcmFjdGVyLlxuICAgICAgICBpZiAobmV4dENoYXIgPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgIHZhciB1Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdUNvZGUgPSBuZXh0Q2hhcjtcbiAgICAgICAgICAgIG5leHRDaGFyID0gLTE7ICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMS4gSGFuZGxlIHN1cnJvZ2F0ZXMuXG4gICAgICAgIGlmICgweEQ4MDAgPD0gdUNvZGUgJiYgdUNvZGUgPCAweEUwMDApIHsgLy8gQ2hhciBpcyBvbmUgb2Ygc3Vycm9nYXRlcy5cbiAgICAgICAgICAgIGlmICh1Q29kZSA8IDB4REMwMCkgeyAvLyBXZSd2ZSBnb3QgbGVhZCBzdXJyb2dhdGUuXG4gICAgICAgICAgICAgICAgaWYgKGxlYWRTdXJyb2dhdGUgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSB1Q29kZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IHVDb2RlO1xuICAgICAgICAgICAgICAgICAgICAvLyBEb3VibGUgbGVhZCBzdXJyb2dhdGUgZm91bmQuXG4gICAgICAgICAgICAgICAgICAgIHVDb2RlID0gVU5BU1NJR05FRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBXZSd2ZSBnb3QgdHJhaWwgc3Vycm9nYXRlLlxuICAgICAgICAgICAgICAgIGlmIChsZWFkU3Vycm9nYXRlICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB1Q29kZSA9IDB4MTAwMDAgKyAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCkgKiAweDQwMCArICh1Q29kZSAtIDB4REMwMCk7XG4gICAgICAgICAgICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSAtMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbmNvbXBsZXRlIHN1cnJvZ2F0ZSBwYWlyIC0gb25seSB0cmFpbCBzdXJyb2dhdGUgZm91bmQuXG4gICAgICAgICAgICAgICAgICAgIHVDb2RlID0gVU5BU1NJR05FRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIEluY29tcGxldGUgc3Vycm9nYXRlIHBhaXIgLSBvbmx5IGxlYWQgc3Vycm9nYXRlIGZvdW5kLlxuICAgICAgICAgICAgbmV4dENoYXIgPSB1Q29kZTsgdUNvZGUgPSBVTkFTU0lHTkVEOyAvLyBXcml0ZSBhbiBlcnJvciwgdGhlbiBjdXJyZW50IGNoYXIuXG4gICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAyLiBDb252ZXJ0IHVDb2RlIGNoYXJhY3Rlci5cbiAgICAgICAgdmFyIGRiY3NDb2RlID0gVU5BU1NJR05FRDtcbiAgICAgICAgaWYgKHNlcU9iaiAhPT0gdW5kZWZpbmVkICYmIHVDb2RlICE9IFVOQVNTSUdORUQpIHsgLy8gV2UgYXJlIGluIHRoZSBtaWRkbGUgb2YgdGhlIHNlcXVlbmNlXG4gICAgICAgICAgICB2YXIgcmVzQ29kZSA9IHNlcU9ialt1Q29kZV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc0NvZGUgPT09ICdvYmplY3QnKSB7IC8vIFNlcXVlbmNlIGNvbnRpbnVlcy5cbiAgICAgICAgICAgICAgICBzZXFPYmogPSByZXNDb2RlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXNDb2RlID09ICdudW1iZXInKSB7IC8vIFNlcXVlbmNlIGZpbmlzaGVkLiBXcml0ZSBpdC5cbiAgICAgICAgICAgICAgICBkYmNzQ29kZSA9IHJlc0NvZGU7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzQ29kZSA9PSB1bmRlZmluZWQpIHsgLy8gQ3VycmVudCBjaGFyYWN0ZXIgaXMgbm90IHBhcnQgb2YgdGhlIHNlcXVlbmNlLlxuXG4gICAgICAgICAgICAgICAgLy8gVHJ5IGRlZmF1bHQgY2hhcmFjdGVyIGZvciB0aGlzIHNlcXVlbmNlXG4gICAgICAgICAgICAgICAgcmVzQ29kZSA9IHNlcU9ialtERUZfQ0hBUl07XG4gICAgICAgICAgICAgICAgaWYgKHJlc0NvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkYmNzQ29kZSA9IHJlc0NvZGU7IC8vIEZvdW5kLiBXcml0ZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgbmV4dENoYXIgPSB1Q29kZTsgLy8gQ3VycmVudCBjaGFyYWN0ZXIgd2lsbCBiZSB3cml0dGVuIHRvbyBpbiB0aGUgbmV4dCBpdGVyYXRpb24uXG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBXaGF0IGlmIHdlIGhhdmUgbm8gZGVmYXVsdD8gKHJlc0NvZGUgPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVuLCB3ZSBzaG91bGQgd3JpdGUgZmlyc3QgY2hhciBvZiB0aGUgc2VxdWVuY2UgYXMtaXMgYW5kIHRyeSB0aGUgcmVzdCByZWN1cnNpdmVseS5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGlkbid0IGRvIGl0IGZvciBub3cgYmVjYXVzZSBubyBlbmNvZGluZyBoYXMgdGhpcyBzaXR1YXRpb24geWV0LlxuICAgICAgICAgICAgICAgICAgICAvLyBDdXJyZW50bHksIGp1c3Qgc2tpcCB0aGUgc2VxdWVuY2UgYW5kIHdyaXRlIGN1cnJlbnQgY2hhci5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXFPYmogPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodUNvZGUgPj0gMCkgeyAgLy8gUmVndWxhciBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHZhciBzdWJ0YWJsZSA9IHRoaXMuZW5jb2RlVGFibGVbdUNvZGUgPj4gOF07XG4gICAgICAgICAgICBpZiAoc3VidGFibGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBkYmNzQ29kZSA9IHN1YnRhYmxlW3VDb2RlICYgMHhGRl07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChkYmNzQ29kZSA8PSBTRVFfU1RBUlQpIHsgLy8gU2VxdWVuY2Ugc3RhcnRcbiAgICAgICAgICAgICAgICBzZXFPYmogPSB0aGlzLmVuY29kZVRhYmxlU2VxW1NFUV9TVEFSVC1kYmNzQ29kZV07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYmNzQ29kZSA9PSBVTkFTU0lHTkVEICYmIHRoaXMuZ2IxODAzMCkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSBHQjE4MDMwIGFsZ29yaXRobSB0byBmaW5kIGNoYXJhY3RlcihzKSB0byB3cml0ZS5cbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gZmluZElkeCh0aGlzLmdiMTgwMzAudUNoYXJzLCB1Q29kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlkeCAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGJjc0NvZGUgPSB0aGlzLmdiMTgwMzAuZ2JDaGFyc1tpZHhdICsgKHVDb2RlIC0gdGhpcy5nYjE4MDMwLnVDaGFyc1tpZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3QnVmW2orK10gPSAweDgxICsgTWF0aC5mbG9vcihkYmNzQ29kZSAvIDEyNjAwKTsgZGJjc0NvZGUgPSBkYmNzQ29kZSAlIDEyNjAwO1xuICAgICAgICAgICAgICAgICAgICBuZXdCdWZbaisrXSA9IDB4MzAgKyBNYXRoLmZsb29yKGRiY3NDb2RlIC8gMTI2MCk7IGRiY3NDb2RlID0gZGJjc0NvZGUgJSAxMjYwO1xuICAgICAgICAgICAgICAgICAgICBuZXdCdWZbaisrXSA9IDB4ODEgKyBNYXRoLmZsb29yKGRiY3NDb2RlIC8gMTApOyBkYmNzQ29kZSA9IGRiY3NDb2RlICUgMTA7XG4gICAgICAgICAgICAgICAgICAgIG5ld0J1ZltqKytdID0gMHgzMCArIGRiY3NDb2RlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBXcml0ZSBkYmNzQ29kZSBjaGFyYWN0ZXIuXG4gICAgICAgIGlmIChkYmNzQ29kZSA9PT0gVU5BU1NJR05FRClcbiAgICAgICAgICAgIGRiY3NDb2RlID0gdGhpcy5kZWZhdWx0Q2hhclNpbmdsZUJ5dGU7XG4gICAgICAgIFxuICAgICAgICBpZiAoZGJjc0NvZGUgPCAweDEwMCkge1xuICAgICAgICAgICAgbmV3QnVmW2orK10gPSBkYmNzQ29kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYmNzQ29kZSA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIG5ld0J1ZltqKytdID0gZGJjc0NvZGUgPj4gODsgICAvLyBoaWdoIGJ5dGVcbiAgICAgICAgICAgIG5ld0J1ZltqKytdID0gZGJjc0NvZGUgJiAweEZGOyAvLyBsb3cgYnl0ZVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3QnVmW2orK10gPSBkYmNzQ29kZSA+PiAxNjtcbiAgICAgICAgICAgIG5ld0J1ZltqKytdID0gKGRiY3NDb2RlID4+IDgpICYgMHhGRjtcbiAgICAgICAgICAgIG5ld0J1ZltqKytdID0gZGJjc0NvZGUgJiAweEZGO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXFPYmogPSBzZXFPYmo7XG4gICAgdGhpcy5sZWFkU3Vycm9nYXRlID0gbGVhZFN1cnJvZ2F0ZTtcbiAgICByZXR1cm4gbmV3QnVmLnNsaWNlKDAsIGopO1xufVxuXG5EQkNTRW5jb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMubGVhZFN1cnJvZ2F0ZSA9PT0gLTEgJiYgdGhpcy5zZXFPYmogPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuOyAvLyBBbGwgY2xlYW4uIE1vc3Qgb2Z0ZW4gY2FzZS5cblxuICAgIHZhciBuZXdCdWYgPSBCdWZmZXIuYWxsb2MoMTApLCBqID0gMDtcblxuICAgIGlmICh0aGlzLnNlcU9iaikgeyAvLyBXZSdyZSBpbiB0aGUgc2VxdWVuY2UuXG4gICAgICAgIHZhciBkYmNzQ29kZSA9IHRoaXMuc2VxT2JqW0RFRl9DSEFSXTtcbiAgICAgICAgaWYgKGRiY3NDb2RlICE9PSB1bmRlZmluZWQpIHsgLy8gV3JpdGUgYmVnaW5uaW5nIG9mIHRoZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgIGlmIChkYmNzQ29kZSA8IDB4MTAwKSB7XG4gICAgICAgICAgICAgICAgbmV3QnVmW2orK10gPSBkYmNzQ29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0J1ZltqKytdID0gZGJjc0NvZGUgPj4gODsgICAvLyBoaWdoIGJ5dGVcbiAgICAgICAgICAgICAgICBuZXdCdWZbaisrXSA9IGRiY3NDb2RlICYgMHhGRjsgLy8gbG93IGJ5dGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNlZSB0b2RvIGFib3ZlLlxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VxT2JqID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlYWRTdXJyb2dhdGUgIT09IC0xKSB7XG4gICAgICAgIC8vIEluY29tcGxldGUgc3Vycm9nYXRlIHBhaXIgLSBvbmx5IGxlYWQgc3Vycm9nYXRlIGZvdW5kLlxuICAgICAgICBuZXdCdWZbaisrXSA9IHRoaXMuZGVmYXVsdENoYXJTaW5nbGVCeXRlO1xuICAgICAgICB0aGlzLmxlYWRTdXJyb2dhdGUgPSAtMTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG5ld0J1Zi5zbGljZSgwLCBqKTtcbn1cblxuLy8gRXhwb3J0IGZvciB0ZXN0aW5nXG5EQkNTRW5jb2Rlci5wcm90b3R5cGUuZmluZElkeCA9IGZpbmRJZHg7XG5cblxuLy8gPT0gRGVjb2RlciA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gREJDU0RlY29kZXIob3B0aW9ucywgY29kZWMpIHtcbiAgICAvLyBEZWNvZGVyIHN0YXRlXG4gICAgdGhpcy5ub2RlSWR4ID0gMDtcbiAgICB0aGlzLnByZXZCdWYgPSBCdWZmZXIuYWxsb2MoMCk7XG5cbiAgICAvLyBTdGF0aWMgZGF0YVxuICAgIHRoaXMuZGVjb2RlVGFibGVzID0gY29kZWMuZGVjb2RlVGFibGVzO1xuICAgIHRoaXMuZGVjb2RlVGFibGVTZXEgPSBjb2RlYy5kZWNvZGVUYWJsZVNlcTtcbiAgICB0aGlzLmRlZmF1bHRDaGFyVW5pY29kZSA9IGNvZGVjLmRlZmF1bHRDaGFyVW5pY29kZTtcbiAgICB0aGlzLmdiMTgwMzAgPSBjb2RlYy5nYjE4MDMwO1xufVxuXG5EQkNTRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWYpIHtcbiAgICB2YXIgbmV3QnVmID0gQnVmZmVyLmFsbG9jKGJ1Zi5sZW5ndGgqMiksXG4gICAgICAgIG5vZGVJZHggPSB0aGlzLm5vZGVJZHgsIFxuICAgICAgICBwcmV2QnVmID0gdGhpcy5wcmV2QnVmLCBwcmV2QnVmT2Zmc2V0ID0gdGhpcy5wcmV2QnVmLmxlbmd0aCxcbiAgICAgICAgc2VxU3RhcnQgPSAtdGhpcy5wcmV2QnVmLmxlbmd0aCwgLy8gaWR4IG9mIHRoZSBzdGFydCBvZiBjdXJyZW50IHBhcnNlZCBzZXF1ZW5jZS5cbiAgICAgICAgdUNvZGU7XG5cbiAgICBpZiAocHJldkJ1Zk9mZnNldCA+IDApIC8vIE1ha2UgcHJldiBidWYgb3ZlcmxhcCBhIGxpdHRsZSB0byBtYWtlIGl0IGVhc2llciB0byBzbGljZSBsYXRlci5cbiAgICAgICAgcHJldkJ1ZiA9IEJ1ZmZlci5jb25jYXQoW3ByZXZCdWYsIGJ1Zi5zbGljZSgwLCAxMCldKTtcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGN1ckJ5dGUgPSAoaSA+PSAwKSA/IGJ1ZltpXSA6IHByZXZCdWZbaSArIHByZXZCdWZPZmZzZXRdO1xuXG4gICAgICAgIC8vIExvb2t1cCBpbiBjdXJyZW50IHRyaWUgbm9kZS5cbiAgICAgICAgdmFyIHVDb2RlID0gdGhpcy5kZWNvZGVUYWJsZXNbbm9kZUlkeF1bY3VyQnl0ZV07XG5cbiAgICAgICAgaWYgKHVDb2RlID49IDApIHsgXG4gICAgICAgICAgICAvLyBOb3JtYWwgY2hhcmFjdGVyLCBqdXN0IHVzZSBpdC5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1Q29kZSA9PT0gVU5BU1NJR05FRCkgeyAvLyBVbmtub3duIGNoYXIuXG4gICAgICAgICAgICAvLyBUT0RPOiBDYWxsYmFjayB3aXRoIHNlcS5cbiAgICAgICAgICAgIC8vdmFyIGN1clNlcSA9IChzZXFTdGFydCA+PSAwKSA/IGJ1Zi5zbGljZShzZXFTdGFydCwgaSsxKSA6IHByZXZCdWYuc2xpY2Uoc2VxU3RhcnQgKyBwcmV2QnVmT2Zmc2V0LCBpKzEgKyBwcmV2QnVmT2Zmc2V0KTtcbiAgICAgICAgICAgIGkgPSBzZXFTdGFydDsgLy8gVHJ5IHRvIHBhcnNlIGFnYWluLCBhZnRlciBza2lwcGluZyBmaXJzdCBieXRlIG9mIHRoZSBzZXF1ZW5jZSAoJ2knIHdpbGwgYmUgaW5jcmVtZW50ZWQgYnkgJ2ZvcicgY3ljbGUpLlxuICAgICAgICAgICAgdUNvZGUgPSB0aGlzLmRlZmF1bHRDaGFyVW5pY29kZS5jaGFyQ29kZUF0KDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVDb2RlID09PSBHQjE4MDMwX0NPREUpIHtcbiAgICAgICAgICAgIHZhciBjdXJTZXEgPSAoc2VxU3RhcnQgPj0gMCkgPyBidWYuc2xpY2Uoc2VxU3RhcnQsIGkrMSkgOiBwcmV2QnVmLnNsaWNlKHNlcVN0YXJ0ICsgcHJldkJ1Zk9mZnNldCwgaSsxICsgcHJldkJ1Zk9mZnNldCk7XG4gICAgICAgICAgICB2YXIgcHRyID0gKGN1clNlcVswXS0weDgxKSoxMjYwMCArIChjdXJTZXFbMV0tMHgzMCkqMTI2MCArIChjdXJTZXFbMl0tMHg4MSkqMTAgKyAoY3VyU2VxWzNdLTB4MzApO1xuICAgICAgICAgICAgdmFyIGlkeCA9IGZpbmRJZHgodGhpcy5nYjE4MDMwLmdiQ2hhcnMsIHB0cik7XG4gICAgICAgICAgICB1Q29kZSA9IHRoaXMuZ2IxODAzMC51Q2hhcnNbaWR4XSArIHB0ciAtIHRoaXMuZ2IxODAzMC5nYkNoYXJzW2lkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodUNvZGUgPD0gTk9ERV9TVEFSVCkgeyAvLyBHbyB0byBuZXh0IHRyaWUgbm9kZS5cbiAgICAgICAgICAgIG5vZGVJZHggPSBOT0RFX1NUQVJUIC0gdUNvZGU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1Q29kZSA8PSBTRVFfU1RBUlQpIHsgLy8gT3V0cHV0IGEgc2VxdWVuY2Ugb2YgY2hhcnMuXG4gICAgICAgICAgICB2YXIgc2VxID0gdGhpcy5kZWNvZGVUYWJsZVNlcVtTRVFfU1RBUlQgLSB1Q29kZV07XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNlcS5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAgICAgICAgICAgICB1Q29kZSA9IHNlcVtrXTtcbiAgICAgICAgICAgICAgICBuZXdCdWZbaisrXSA9IHVDb2RlICYgMHhGRjtcbiAgICAgICAgICAgICAgICBuZXdCdWZbaisrXSA9IHVDb2RlID4+IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1Q29kZSA9IHNlcVtzZXEubGVuZ3RoLTFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImljb252LWxpdGUgaW50ZXJuYWwgZXJyb3I6IGludmFsaWQgZGVjb2RpbmcgdGFibGUgdmFsdWUgXCIgKyB1Q29kZSArIFwiIGF0IFwiICsgbm9kZUlkeCArIFwiL1wiICsgY3VyQnl0ZSk7XG5cbiAgICAgICAgLy8gV3JpdGUgdGhlIGNoYXJhY3RlciB0byBidWZmZXIsIGhhbmRsaW5nIGhpZ2hlciBwbGFuZXMgdXNpbmcgc3Vycm9nYXRlIHBhaXIuXG4gICAgICAgIGlmICh1Q29kZSA+IDB4RkZGRikgeyBcbiAgICAgICAgICAgIHVDb2RlIC09IDB4MTAwMDA7XG4gICAgICAgICAgICB2YXIgdUNvZGVMZWFkID0gMHhEODAwICsgTWF0aC5mbG9vcih1Q29kZSAvIDB4NDAwKTtcbiAgICAgICAgICAgIG5ld0J1ZltqKytdID0gdUNvZGVMZWFkICYgMHhGRjtcbiAgICAgICAgICAgIG5ld0J1ZltqKytdID0gdUNvZGVMZWFkID4+IDg7XG5cbiAgICAgICAgICAgIHVDb2RlID0gMHhEQzAwICsgdUNvZGUgJSAweDQwMDtcbiAgICAgICAgfVxuICAgICAgICBuZXdCdWZbaisrXSA9IHVDb2RlICYgMHhGRjtcbiAgICAgICAgbmV3QnVmW2orK10gPSB1Q29kZSA+PiA4O1xuXG4gICAgICAgIC8vIFJlc2V0IHRyaWUgbm9kZS5cbiAgICAgICAgbm9kZUlkeCA9IDA7IHNlcVN0YXJ0ID0gaSsxO1xuICAgIH1cblxuICAgIHRoaXMubm9kZUlkeCA9IG5vZGVJZHg7XG4gICAgdGhpcy5wcmV2QnVmID0gKHNlcVN0YXJ0ID49IDApID8gYnVmLnNsaWNlKHNlcVN0YXJ0KSA6IHByZXZCdWYuc2xpY2Uoc2VxU3RhcnQgKyBwcmV2QnVmT2Zmc2V0KTtcbiAgICByZXR1cm4gbmV3QnVmLnNsaWNlKDAsIGopLnRvU3RyaW5nKCd1Y3MyJyk7XG59XG5cbkRCQ1NEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmV0ID0gJyc7XG5cbiAgICAvLyBUcnkgdG8gcGFyc2UgYWxsIHJlbWFpbmluZyBjaGFycy5cbiAgICB3aGlsZSAodGhpcy5wcmV2QnVmLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gU2tpcCAxIGNoYXJhY3RlciBpbiB0aGUgYnVmZmVyLlxuICAgICAgICByZXQgKz0gdGhpcy5kZWZhdWx0Q2hhclVuaWNvZGU7XG4gICAgICAgIHZhciBidWYgPSB0aGlzLnByZXZCdWYuc2xpY2UoMSk7XG5cbiAgICAgICAgLy8gUGFyc2UgcmVtYWluaW5nIGFzIHVzdWFsLlxuICAgICAgICB0aGlzLnByZXZCdWYgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgIHRoaXMubm9kZUlkeCA9IDA7XG4gICAgICAgIGlmIChidWYubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHJldCArPSB0aGlzLndyaXRlKGJ1Zik7XG4gICAgfVxuXG4gICAgdGhpcy5ub2RlSWR4ID0gMDtcbiAgICByZXR1cm4gcmV0O1xufVxuXG4vLyBCaW5hcnkgc2VhcmNoIGZvciBHQjE4MDMwLiBSZXR1cm5zIGxhcmdlc3QgaSBzdWNoIHRoYXQgdGFibGVbaV0gPD0gdmFsLlxuZnVuY3Rpb24gZmluZElkeCh0YWJsZSwgdmFsKSB7XG4gICAgaWYgKHRhYmxlWzBdID4gdmFsKVxuICAgICAgICByZXR1cm4gLTE7XG5cbiAgICB2YXIgbCA9IDAsIHIgPSB0YWJsZS5sZW5ndGg7XG4gICAgd2hpbGUgKGwgPCByLTEpIHsgLy8gYWx3YXlzIHRhYmxlW2xdIDw9IHZhbCA8IHRhYmxlW3JdXG4gICAgICAgIHZhciBtaWQgPSBsICsgTWF0aC5mbG9vcigoci1sKzEpLzIpO1xuICAgICAgICBpZiAodGFibGVbbWlkXSA8PSB2YWwpXG4gICAgICAgICAgICBsID0gbWlkO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbDtcbn1cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaWNvbnYtbGl0ZS9lbmNvZGluZ3MvZGJjcy1jb2RlYy5qc1xuLy8gbW9kdWxlIGlkID0gMTAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBEZXNjcmlwdGlvbiBvZiBzdXBwb3J0ZWQgZG91YmxlIGJ5dGUgZW5jb2RpbmdzIGFuZCBhbGlhc2VzLlxuLy8gVGFibGVzIGFyZSBub3QgcmVxdWlyZSgpLWQgdW50aWwgdGhleSBhcmUgbmVlZGVkIHRvIHNwZWVkIHVwIGxpYnJhcnkgbG9hZC5cbi8vIHJlcXVpcmUoKS1zIGFyZSBkaXJlY3QgdG8gc3VwcG9ydCBCcm93c2VyaWZ5LlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBcbiAgICAvLyA9PSBKYXBhbmVzZS9TaGlmdEpJUyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gQWxsIGphcGFuZXNlIGVuY29kaW5ncyBhcmUgYmFzZWQgb24gSklTIFggc2V0IG9mIHN0YW5kYXJkczpcbiAgICAvLyBKSVMgWCAwMjAxIC0gU2luZ2xlLWJ5dGUgZW5jb2Rpbmcgb2YgQVNDSUkgKyDCpSArIEthbmEgY2hhcnMgYXQgMHhBMS0weERGLlxuICAgIC8vIEpJUyBYIDAyMDggLSBNYWluIHNldCBvZiA2ODc5IGNoYXJhY3RlcnMsIHBsYWNlZCBpbiA5NHg5NCBwbGFuZSwgdG8gYmUgZW5jb2RlZCBieSAyIGJ5dGVzLiBcbiAgICAvLyAgICAgICAgICAgICAgSGFzIHNldmVyYWwgdmFyaWF0aW9ucyBpbiAxOTc4LCAxOTgzLCAxOTkwIGFuZCAxOTk3LlxuICAgIC8vIEpJUyBYIDAyMTIgLSBTdXBwbGVtZW50YXJ5IHBsYW5lIG9mIDYwNjcgY2hhcnMgaW4gOTR4OTQgcGxhbmUuIDE5OTAuIEVmZmVjdGl2ZWx5IGRlYWQuXG4gICAgLy8gSklTIFggMDIxMyAtIEV4dGVuc2lvbiBhbmQgbW9kZXJuIHJlcGxhY2VtZW50IG9mIDAyMDggYW5kIDAyMTIuIFRvdGFsIGNoYXJzOiAxMTIzMy5cbiAgICAvLyAgICAgICAgICAgICAgMiBwbGFuZXMsIGZpcnN0IGlzIHN1cGVyc2V0IG9mIDAyMDgsIHNlY29uZCAtIHJldmlzZWQgMDIxMi5cbiAgICAvLyAgICAgICAgICAgICAgSW50cm9kdWNlZCBpbiAyMDAwLCByZXZpc2VkIDIwMDQuIFNvbWUgY2hhcmFjdGVycyBhcmUgaW4gVW5pY29kZSBQbGFuZSAyICgweDJ4eHh4KVxuXG4gICAgLy8gQnl0ZSBlbmNvZGluZ3MgYXJlOlxuICAgIC8vICAqIFNoaWZ0X0pJUzogQ29tcGF0aWJsZSB3aXRoIDAyMDEsIHVzZXMgbm90IGRlZmluZWQgY2hhcnMgaW4gdG9wIGhhbGYgYXMgbGVhZCBieXRlcyBmb3IgZG91YmxlLWJ5dGVcbiAgICAvLyAgICAgICAgICAgICAgIGVuY29kaW5nIG9mIDAyMDguIExlYWQgYnl0ZSByYW5nZXM6IDB4ODEtMHg5RiwgMHhFMC0weEVGOyBUcmFpbCBieXRlIHJhbmdlczogMHg0MC0weDdFLCAweDgwLTB4OUUsIDB4OUYtMHhGQy5cbiAgICAvLyAgICAgICAgICAgICAgIFdpbmRvd3MgQ1A5MzIgaXMgYSBzdXBlcnNldCBvZiBTaGlmdF9KSVMuIFNvbWUgY29tcGFuaWVzIGFkZGVkIG1vcmUgY2hhcnMsIG5vdGFibHkgS0RESS5cbiAgICAvLyAgKiBFVUMtSlA6ICAgIFVwIHRvIDMgYnl0ZXMgcGVyIGNoYXJhY3Rlci4gVXNlZCBtb3N0bHkgb24gKm5peGVzLlxuICAgIC8vICAgICAgICAgICAgICAgMHgwMC0weDdGICAgICAgIC0gbG93ZXIgcGFydCBvZiAwMjAxXG4gICAgLy8gICAgICAgICAgICAgICAweDhFLCAweEExLTB4REYgLSB1cHBlciBwYXJ0IG9mIDAyMDFcbiAgICAvLyAgICAgICAgICAgICAgICgweEExLTB4RkUpeDIgICAtIDAyMDggcGxhbmUgKDk0eDk0KS5cbiAgICAvLyAgICAgICAgICAgICAgIDB4OEYsICgweEExLTB4RkUpeDIgLSAwMjEyIHBsYW5lICg5NHg5NCkuXG4gICAgLy8gICogSklTIFggMjA4OiA3LWJpdCwgZGlyZWN0IGVuY29kaW5nIG9mIDAyMDguIEJ5dGUgcmFuZ2VzOiAweDIxLTB4N0UgKDk0IHZhbHVlcykuIFVuY29tbW9uLlxuICAgIC8vICAgICAgICAgICAgICAgVXNlZCBhcy1pcyBpbiBJU08yMDIyIGZhbWlseS5cbiAgICAvLyAgKiBJU08yMDIyLUpQOiBTdGF0ZWZ1bCBlbmNvZGluZywgd2l0aCBlc2NhcGUgc2VxdWVuY2VzIHRvIHN3aXRjaCBiZXR3ZWVuIEFTQ0lJLCBcbiAgICAvLyAgICAgICAgICAgICAgICAwMjAxLTE5NzYgUm9tYW4sIDAyMDgtMTk3OCwgMDIwOC0xOTgzLlxuICAgIC8vICAqIElTTzIwMjItSlAtMTogQWRkcyBlc2Mgc2VxIGZvciAwMjEyLTE5OTAuXG4gICAgLy8gICogSVNPMjAyMi1KUC0yOiBBZGRzIGVzYyBzZXEgZm9yIEdCMjMxMy0xOTgwLCBLU1gxMDAxLTE5OTIsIElTTzg4NTktMSwgSVNPODg1OS03LlxuICAgIC8vICAqIElTTzIwMjItSlAtMzogQWRkcyBlc2Mgc2VxIGZvciAwMjAxLTE5NzYgS2FuYSBzZXQsIDAyMTMtMjAwMCBQbGFuZXMgMSwgMi5cbiAgICAvLyAgKiBJU08yMDIyLUpQLTIwMDQ6IEFkZHMgMDIxMy0yMDA0IFBsYW5lIDEuXG4gICAgLy9cbiAgICAvLyBBZnRlciBKSVMgWCAwMjEzIGFwcGVhcmVkLCBTaGlmdF9KSVMtMjAwNCwgRVVDLUpJU1gwMjEzIGFuZCBJU08yMDIyLUpQLTIwMDQgZm9sbG93ZWQsIHdpdGgganVzdCBjaGFuZ2luZyB0aGUgcGxhbmVzLlxuICAgIC8vXG4gICAgLy8gT3ZlcmFsbCwgaXQgc2VlbXMgdGhhdCBpdCdzIGEgbWVzcyA6KCBodHRwOi8vd3d3OC5wbGFsYS5vci5qcC90a3Vib3RhMS91bmljb2RlLXN5bWJvbHMtbWFwMi5odG1sXG5cbiAgICAnc2hpZnRqaXMnOiB7XG4gICAgICAgIHR5cGU6ICdfZGJjcycsXG4gICAgICAgIHRhYmxlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHJlcXVpcmUoJy4vdGFibGVzL3NoaWZ0amlzLmpzb24nKSB9LFxuICAgICAgICBlbmNvZGVBZGQ6IHsnXFx1MDBhNSc6IDB4NUMsICdcXHUyMDNFJzogMHg3RX0sXG4gICAgICAgIGVuY29kZVNraXBWYWxzOiBbe2Zyb206IDB4RUQ0MCwgdG86IDB4Rjk0MH1dLFxuICAgIH0sXG4gICAgJ2Nzc2hpZnRqaXMnOiAnc2hpZnRqaXMnLFxuICAgICdtc2thbmppJzogJ3NoaWZ0amlzJyxcbiAgICAnc2ppcyc6ICdzaGlmdGppcycsXG4gICAgJ3dpbmRvd3MzMWonOiAnc2hpZnRqaXMnLFxuICAgICdtczMxaic6ICdzaGlmdGppcycsXG4gICAgJ3hzamlzJzogJ3NoaWZ0amlzJyxcbiAgICAnd2luZG93czkzMic6ICdzaGlmdGppcycsXG4gICAgJ21zOTMyJzogJ3NoaWZ0amlzJyxcbiAgICAnOTMyJzogJ3NoaWZ0amlzJyxcbiAgICAnY3A5MzInOiAnc2hpZnRqaXMnLFxuXG4gICAgJ2V1Y2pwJzoge1xuICAgICAgICB0eXBlOiAnX2RiY3MnLFxuICAgICAgICB0YWJsZTogZnVuY3Rpb24oKSB7IHJldHVybiByZXF1aXJlKCcuL3RhYmxlcy9ldWNqcC5qc29uJykgfSxcbiAgICAgICAgZW5jb2RlQWRkOiB7J1xcdTAwYTUnOiAweDVDLCAnXFx1MjAzRSc6IDB4N0V9LFxuICAgIH0sXG5cbiAgICAvLyBUT0RPOiBLRERJIGV4dGVuc2lvbiB0byBTaGlmdF9KSVNcbiAgICAvLyBUT0RPOiBJQk0gQ0NTSUQgOTQyID0gQ1A5MzIsIGJ1dCBGMC1GOSBjdXN0b20gY2hhcnMgYW5kIG90aGVyIGNoYXIgY2hhbmdlcy5cbiAgICAvLyBUT0RPOiBJQk0gQ0NTSUQgOTQzID0gU2hpZnRfSklTID0gQ1A5MzIgd2l0aCBvcmlnaW5hbCBTaGlmdF9KSVMgbG93ZXIgMTI4IGNoYXJzLlxuXG5cbiAgICAvLyA9PSBDaGluZXNlL0dCSyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HQktcbiAgICAvLyBXZSBtb3N0bHkgaW1wbGVtZW50IFczQyByZWNvbW1lbmRhdGlvbjogaHR0cHM6Ly93d3cudzMub3JnL1RSL2VuY29kaW5nLyNnYmstZW5jb2RlclxuXG4gICAgLy8gT2xkZXN0IEdCMjMxMiAoMTk4MSwgfjc2MDAgY2hhcnMpIGlzIGEgc3Vic2V0IG9mIENQOTM2XG4gICAgJ2diMjMxMic6ICdjcDkzNicsXG4gICAgJ2diMjMxMjgwJzogJ2NwOTM2JyxcbiAgICAnZ2IyMzEyMTk4MCc6ICdjcDkzNicsXG4gICAgJ2NzZ2IyMzEyJzogJ2NwOTM2JyxcbiAgICAnY3Npc281OGdiMjMxMjgwJzogJ2NwOTM2JyxcbiAgICAnZXVjY24nOiAnY3A5MzYnLFxuXG4gICAgLy8gTWljcm9zb2Z0J3MgQ1A5MzYgaXMgYSBzdWJzZXQgYW5kIGFwcHJveGltYXRpb24gb2YgR0JLLlxuICAgICd3aW5kb3dzOTM2JzogJ2NwOTM2JyxcbiAgICAnbXM5MzYnOiAnY3A5MzYnLFxuICAgICc5MzYnOiAnY3A5MzYnLFxuICAgICdjcDkzNic6IHtcbiAgICAgICAgdHlwZTogJ19kYmNzJyxcbiAgICAgICAgdGFibGU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVxdWlyZSgnLi90YWJsZXMvY3A5MzYuanNvbicpIH0sXG4gICAgfSxcblxuICAgIC8vIEdCSyAofjIyMDAwIGNoYXJzKSBpcyBhbiBleHRlbnNpb24gb2YgQ1A5MzYgdGhhdCBhZGRlZCB1c2VyLW1hcHBlZCBjaGFycyBhbmQgc29tZSBvdGhlci5cbiAgICAnZ2JrJzoge1xuICAgICAgICB0eXBlOiAnX2RiY3MnLFxuICAgICAgICB0YWJsZTogZnVuY3Rpb24oKSB7IHJldHVybiByZXF1aXJlKCcuL3RhYmxlcy9jcDkzNi5qc29uJykuY29uY2F0KHJlcXVpcmUoJy4vdGFibGVzL2diay1hZGRlZC5qc29uJykpIH0sXG4gICAgfSxcbiAgICAneGdiayc6ICdnYmsnLFxuICAgICdpc29pcjU4JzogJ2diaycsXG5cbiAgICAvLyBHQjE4MDMwIGlzIGFuIGFsZ29yaXRobWljIGV4dGVuc2lvbiBvZiBHQksuXG4gICAgLy8gTWFpbiBzb3VyY2U6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9lbmNvZGluZy8jZ2JrLWVuY29kZXJcbiAgICAvLyBodHRwOi8vaWN1LXByb2plY3Qub3JnL2RvY3MvcGFwZXJzL2diMTgwMzAuaHRtbFxuICAgIC8vIGh0dHA6Ly9zb3VyY2UuaWN1LXByb2plY3Qub3JnL3JlcG9zL2ljdS9kYXRhL3RydW5rL2NoYXJzZXQvZGF0YS94bWwvZ2ItMTgwMzAtMjAwMC54bWxcbiAgICAvLyBodHRwOi8vd3d3LmtobmdhaS5jb20vY2hpbmVzZS9jaGFybWFwL3RibGdiay5waHA/cGFnZT0wXG4gICAgJ2diMTgwMzAnOiB7XG4gICAgICAgIHR5cGU6ICdfZGJjcycsXG4gICAgICAgIHRhYmxlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHJlcXVpcmUoJy4vdGFibGVzL2NwOTM2Lmpzb24nKS5jb25jYXQocmVxdWlyZSgnLi90YWJsZXMvZ2JrLWFkZGVkLmpzb24nKSkgfSxcbiAgICAgICAgZ2IxODAzMDogZnVuY3Rpb24oKSB7IHJldHVybiByZXF1aXJlKCcuL3RhYmxlcy9nYjE4MDMwLXJhbmdlcy5qc29uJykgfSxcbiAgICAgICAgZW5jb2RlU2tpcFZhbHM6IFsweDgwXSxcbiAgICAgICAgZW5jb2RlQWRkOiB7J+KCrCc6IDB4QTJFM30sXG4gICAgfSxcblxuICAgICdjaGluZXNlJzogJ2diMTgwMzAnLFxuXG5cbiAgICAvLyA9PSBLb3JlYW4gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRVVDLUtSLCBLU19DXzU2MDEgYW5kIEtTIFggMTAwMSBhcmUgZXhhY3RseSB0aGUgc2FtZS5cbiAgICAnd2luZG93czk0OSc6ICdjcDk0OScsXG4gICAgJ21zOTQ5JzogJ2NwOTQ5JyxcbiAgICAnOTQ5JzogJ2NwOTQ5JyxcbiAgICAnY3A5NDknOiB7XG4gICAgICAgIHR5cGU6ICdfZGJjcycsXG4gICAgICAgIHRhYmxlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHJlcXVpcmUoJy4vdGFibGVzL2NwOTQ5Lmpzb24nKSB9LFxuICAgIH0sXG5cbiAgICAnY3NldWNrcic6ICdjcDk0OScsXG4gICAgJ2Nza3NjNTYwMTE5ODcnOiAnY3A5NDknLFxuICAgICdldWNrcic6ICdjcDk0OScsXG4gICAgJ2lzb2lyMTQ5JzogJ2NwOTQ5JyxcbiAgICAna29yZWFuJzogJ2NwOTQ5JyxcbiAgICAna3NjNTYwMTE5ODcnOiAnY3A5NDknLFxuICAgICdrc2M1NjAxMTk4OSc6ICdjcDk0OScsXG4gICAgJ2tzYzU2MDEnOiAnY3A5NDknLFxuXG5cbiAgICAvLyA9PSBCaWc1L1RhaXdhbi9Ib25nIEtvbmcgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gVGhlcmUgYXJlIGxvdHMgb2YgdGFibGVzIGZvciBCaWc1IGFuZCBjcDk1MC4gUGxlYXNlIHNlZSB0aGUgZm9sbG93aW5nIGxpbmtzIGZvciBoaXN0b3J5OlxuICAgIC8vIGh0dHA6Ly9tb3p0dy5vcmcvZG9jcy9iaWc1LyAgaHR0cDovL3d3dy5oYWlibGUuZGUvYnJ1bm8vY2hhcnNldHMvY29udmVyc2lvbi10YWJsZXMvQmlnNS5odG1sXG4gICAgLy8gVmFyaWF0aW9ucywgaW4gcm91Z2hseSBudW1iZXIgb2YgZGVmaW5lZCBjaGFyczpcbiAgICAvLyAgKiBXaW5kb3dzIENQIDk1MDogTWljcm9zb2Z0IHZhcmlhbnQgb2YgQmlnNS4gQ2Fub25pY2FsOiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9NQVBQSU5HUy9WRU5ET1JTL01JQ1NGVC9XSU5ET1dTL0NQOTUwLlRYVFxuICAgIC8vICAqIFdpbmRvd3MgQ1AgOTUxOiBNaWNyb3NvZnQgdmFyaWFudCBvZiBCaWc1LUhLU0NTLTIwMDEuIFNlZW1zIHRvIGJlIG5ldmVyIHB1YmxpYy4gaHR0cDovL21lLmFiZWxjaGV1bmcub3JnL2FydGljbGVzL3Jlc2VhcmNoL3doYXQtaXMtY3A5NTEvXG4gICAgLy8gICogQmlnNS0yMDAzIChUYWl3YW4gc3RhbmRhcmQpIGFsbW9zdCBzdXBlcnNldCBvZiBjcDk1MC5cbiAgICAvLyAgKiBVbmljb2RlLWF0LW9uIChVQU8pIC8gTW96aWxsYSAxLjguIEZhbGxpbmcgb3V0IG9mIHVzZSBvbiB0aGUgV2ViLiBOb3Qgc3VwcG9ydGVkIGJ5IG90aGVyIGJyb3dzZXJzLlxuICAgIC8vICAqIEJpZzUtSEtTQ1MgKC0yMDAxLCAtMjAwNCwgLTIwMDgpLiBIb25nIEtvbmcgc3RhbmRhcmQuIFxuICAgIC8vICAgIG1hbnkgdW5pY29kZSBjb2RlIHBvaW50cyBtb3ZlZCBmcm9tIFBVQSB0byBTdXBwbGVtZW50YXJ5IHBsYW5lIChVKzJYWFhYKSBvdmVyIHRoZSB5ZWFycy5cbiAgICAvLyAgICBQbHVzLCBpdCBoYXMgNCBjb21iaW5pbmcgc2VxdWVuY2VzLlxuICAgIC8vICAgIFNlZW1zIHRoYXQgTW96aWxsYSByZWZ1c2VkIHRvIHN1cHBvcnQgaXQgZm9yIDEwIHlycy4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTYyNDMxIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTMxMDI5OVxuICAgIC8vICAgIGJlY2F1c2UgYmlnNS1oa3NjcyBpcyB0aGUgb25seSBlbmNvZGluZyB0byBpbmNsdWRlIGFzdHJhbCBjaGFyYWN0ZXJzIGluIG5vbi1hbGdvcml0aG1pYyB3YXkuXG4gICAgLy8gICAgSW1wbGVtZW50YXRpb25zIGFyZSBub3QgY29uc2lzdGVudCB3aXRoaW4gYnJvd3NlcnM7IHNvbWV0aW1lcyBsYWJlbGVkIGFzIGp1c3QgYmlnNS5cbiAgICAvLyAgICBNUyBJbnRlcm5ldCBFeHBsb3JlciBzd2l0Y2hlcyBmcm9tIGJpZzUgdG8gYmlnNS1oa3NjcyB3aGVuIGEgcGF0Y2ggYXBwbGllZC5cbiAgICAvLyAgICBHcmVhdCBkaXNjdXNzaW9uICYgcmVjYXAgb2Ygd2hhdCdzIGdvaW5nIG9uIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTkxMjQ3MCNjMzFcbiAgICAvLyAgICBJbiB0aGUgZW5jb2RlciwgaXQgbWlnaHQgbWFrZSBzZW5zZSB0byBzdXBwb3J0IGVuY29kaW5nIG9sZCBQVUEgbWFwcGluZ3MgdG8gQmlnNSBieXRlcyBzZXEtcy5cbiAgICAvLyAgICBPZmZpY2lhbCBzcGVjOiBodHRwOi8vd3d3Lm9nY2lvLmdvdi5oay9lbi9idXNpbmVzcy90ZWNoX3Byb21vdGlvbi9jY2xpL3Rlcm1zL2RvYy8yMDAzY21wXzIwMDgudHh0XG4gICAgLy8gICAgICAgICAgICAgICAgICAgaHR0cDovL3d3dy5vZ2Npby5nb3YuaGsvdGMvYnVzaW5lc3MvdGVjaF9wcm9tb3Rpb24vY2NsaS90ZXJtcy9kb2MvaGtzY3MtMjAwOC1iaWc1LWlzby50eHRcbiAgICAvLyBcbiAgICAvLyBDdXJyZW50IHVuZGVyc3RhbmRpbmcgb2YgaG93IHRvIGRlYWwgd2l0aCBCaWc1KC1IS1NDUykgaXMgaW4gdGhlIEVuY29kaW5nIFN0YW5kYXJkLCBodHRwOi8vZW5jb2Rpbmcuc3BlYy53aGF0d2cub3JnLyNiaWc1LWVuY29kZXJcbiAgICAvLyBVbmljb2RlIG1hcHBpbmcgKGh0dHA6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL01BUFBJTkdTL09CU09MRVRFL0VBU1RBU0lBL09USEVSL0JJRzUuVFhUKSBpcyBzYWlkIHRvIGJlIHdyb25nLlxuXG4gICAgJ3dpbmRvd3M5NTAnOiAnY3A5NTAnLFxuICAgICdtczk1MCc6ICdjcDk1MCcsXG4gICAgJzk1MCc6ICdjcDk1MCcsXG4gICAgJ2NwOTUwJzoge1xuICAgICAgICB0eXBlOiAnX2RiY3MnLFxuICAgICAgICB0YWJsZTogZnVuY3Rpb24oKSB7IHJldHVybiByZXF1aXJlKCcuL3RhYmxlcy9jcDk1MC5qc29uJykgfSxcbiAgICB9LFxuXG4gICAgLy8gQmlnNSBoYXMgbWFueSB2YXJpYXRpb25zIGFuZCBpcyBhbiBleHRlbnNpb24gb2YgY3A5NTAuIFdlIHVzZSBFbmNvZGluZyBTdGFuZGFyZCdzIGFzIGEgY29uc2Vuc3VzLlxuICAgICdiaWc1JzogJ2JpZzVoa3NjcycsXG4gICAgJ2JpZzVoa3Njcyc6IHtcbiAgICAgICAgdHlwZTogJ19kYmNzJyxcbiAgICAgICAgdGFibGU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVxdWlyZSgnLi90YWJsZXMvY3A5NTAuanNvbicpLmNvbmNhdChyZXF1aXJlKCcuL3RhYmxlcy9iaWc1LWFkZGVkLmpzb24nKSkgfSxcbiAgICAgICAgZW5jb2RlU2tpcFZhbHM6IFsweGEyY2NdLFxuICAgIH0sXG5cbiAgICAnY25iaWc1JzogJ2JpZzVoa3NjcycsXG4gICAgJ2NzYmlnNSc6ICdiaWc1aGtzY3MnLFxuICAgICd4eGJpZzUnOiAnYmlnNWhrc2NzJyxcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9pY29udi1saXRlL2VuY29kaW5ncy9kYmNzLWRhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFtbXCIwXCIsXCJcXHUwMDAwXCIsMTI4XSxbXCJhMVwiLFwi772hXCIsNjJdLFtcIjgxNDBcIixcIuOAgOOAgeOAgu+8jO+8juODu++8mu+8m++8n++8geOCm+OCnMK0772AwqjvvL7vv6PvvL/jg73jg77jgp3jgp7jgIPku53jgIXjgIbjgIfjg7zigJXigJDvvI/vvLzvvZ7iiKXvvZzigKbigKXigJjigJnigJzigJ3vvIjvvInjgJTjgJXvvLvvvL3vvZvvvZ3jgIhcIiw5LFwi77yL77yNwrHDl1wiXSxbXCI4MTgwXCIsXCLDt++8neKJoO+8nO+8nuKJpuKJp+KInuKItOKZguKZgMKw4oCy4oCz4oSD77+l77yE77+g77+h77yF77yD77yG77yK77ygwqfimIbimIXil4vil4/il47il4fil4bilqHilqDilrPilrLilr3ilrzigLvjgJLihpLihpDihpHihpPjgJNcIl0sW1wiODFiOFwiLFwi4oiI4oiL4oqG4oqH4oqC4oqD4oiq4oipXCJdLFtcIjgxYzhcIixcIuKIp+KIqO+/ouKHkuKHlOKIgOKIg1wiXSxbXCI4MWRhXCIsXCLiiKDiiqXijJLiiILiiIfiiaHiiZLiiariiaviiJriiL3iiJ3iiLXiiKviiKxcIl0sW1wiODFmMFwiLFwi4oSr4oCw4pmv4pmt4pmq4oCg4oChwrZcIl0sW1wiODFmY1wiLFwi4pevXCJdLFtcIjgyNGZcIixcIu+8kFwiLDldLFtcIjgyNjBcIixcIu+8oVwiLDI1XSxbXCI4MjgxXCIsXCLvvYFcIiwyNV0sW1wiODI5ZlwiLFwi44GBXCIsODJdLFtcIjgzNDBcIixcIuOCoVwiLDYyXSxbXCI4MzgwXCIsXCLjg6BcIiwyMl0sW1wiODM5ZlwiLFwizpFcIiwxNixcIs6jXCIsNl0sW1wiODNiZlwiLFwizrFcIiwxNixcIs+DXCIsNl0sW1wiODQ0MFwiLFwi0JBcIiw1LFwi0IHQllwiLDI1XSxbXCI4NDcwXCIsXCLQsFwiLDUsXCLRkdC2XCIsN10sW1wiODQ4MFwiLFwi0L5cIiwxN10sW1wiODQ5ZlwiLFwi4pSA4pSC4pSM4pSQ4pSY4pSU4pSc4pSs4pSk4pS04pS84pSB4pSD4pSP4pST4pSb4pSX4pSj4pSz4pSr4pS74pWL4pSg4pSv4pSo4pS34pS/4pSd4pSw4pSl4pS44pWCXCJdLFtcIjg3NDBcIixcIuKRoFwiLDE5LFwi4oWgXCIsOV0sW1wiODc1ZlwiLFwi442J44yU44yi442N44yY44yn44yD44y2442R442X44yN44ym44yj44yr442K44y7446c446d446e446O446P44+E446hXCJdLFtcIjg3N2VcIixcIuONu1wiXSxbXCI4NzgwXCIsXCLjgJ3jgJ/ihJbjj43ihKHjiqRcIiw0LFwi44ix44iy44i5442+442944284omS4omh4oir4oiu4oiR4oia4oql4oig4oif4oq/4oi14oip4oiqXCJdLFtcIjg4OWZcIixcIuS6nOWUluWog+mYv+WTgOaEm+aMqOWntumAouiRteiMnOepkOaCquaPoea4peaXreiRpuiKpumvteaik+Wcp+aWoeaJseWum+WnkOiZu+mjtOe1oue2vumujuaIlueyn+iit+WuieW6teaMieaal+ahiOmXh+mejeadj+S7peS8iuS9jeS+neWBieWbsuWkt+WnlOWogeWwieaDn+aEj+aFsOaYk+akheeCuueVj+eVsOenu+e2ree3r+iDg+iQjuiho+isgumBlemBuuWMu+S6leS6peWfn+iCsumDgeejr+S4gOWjsea6oumAuOeosuiMqOiKi+mwr+WFgeWNsOWSveWToeWboOWnu+W8lemjsua3q+iDpOiUrVwiXSxbXCI4OTQwXCIsXCLpmaLpmbDpmqDpn7vlkIvlj7Plrofng4/nvr3ov4Lpm6jlja/ptZznqrrkuJHnopPoh7zmuKblmJjllITmrJ3olJrpsLvlp6Xljqnmtabnk5zplo/lmYLkupHpgYvpm7LojY/ppIzlj6HllrblrLDlvbHmmKDmm7PmoITmsLjms7PmtKnnkZvnm4jnqY7poLToi7HooZvoqaDpi63mtrLnlqvnm4rpp4XmgqborIHotorplrLmpo7ljq3lhoZcIl0sW1wiODk4MFwiLFwi5ZyS5aCw5aWE5a605bu25oCo5o6p5o+05rK/5ryU54KO54SU54WZ54eV54y/57iB6Im26IuR6JaX6YGg6Ymb6bSb5aGp5pa85rGa55Sl5Ye55aSu5aWl5b6A5b+c5oq85pe65qiq5qyn5q60546L57+B6KWW6bSs6bSO6buE5bKh5rKW6I275YSE5bGL5oa26IeG5qG254mh5LmZ5L+65Y245oGp5rip56mP6Z+z5LiL5YyW5Luu5L2V5Ly95L6h5L2z5Yqg5Y+v5ZiJ5aSP5auB5a625a+h56eR5pqH5p6c5p625q2M5rKz54Gr54+C56aN56a+56i8566H6Iqx6Iub6IyE6I236I+v6I+T6J2m6Kqy5Zip6LKo6L+m6YGO6Zye6JqK5L+E5bOo5oiR54mZ55S76Iel6Iq96Ju+6LOA6ZuF6aST6aeV5LuL5Lya6Kej5Zue5aGK5aOK5bu75b+r5oCq5oKU5oGi5oeQ5oiS5ouQ5pS5XCJdLFtcIjhhNDBcIixcIumtgeaZpuaisOa1t+eBsOeVjOeahue1teiKpeifuemWi+majuiyneWHseWKvuWkluWSs+Wus+W0luaFqOamgua2r+eijeiTi+ihl+ipsumOp+mquOa1rOmmqOibmeWeo+afv+ibjumIjuWKg+Wah+WQhOW7k+aLoeaSueagvOaguOauu+eNsueiuuepq+immuinkui1q+i8g+mDremWo+malOmdqeWtpuWys+alvemhjemhjuaOm+esoOaoq1wiXSxbXCI4YTgwXCIsXCLmqb/morbpsI3mvZ/libLllp3mgbDmi6zmtLvmuIfmu5HokZvopJDovYTkuJTpsLnlj7bmpJvmqLrpnoTmoKrlhZznq4PokrLph5zpjozlmZvptKjmoKLojIXokLHnsqXliIjoi4Xnk6bkub7kvoPlhqDlr5LliIrli5jli6flt7vllprloKrlp6blrozlrpjlr5vlubLlubnmgqPmhJ/mhaPmhr7mj5vmlaLmn5HmoZPmo7rmrL7mrZPmsZfmvKLmvpfmvYXnkrDnlJjnm6PnnIvnq7/nrqHnsKHnt6nnvLbnv7Dogp3oiabojp7oprPoq4zosqvpgoTpkZHplpPplpHplqLpmaXpn5PppKjoiJjkuLjlkKvlsrjlt4znjqnnmYznnLzlsqnnv6votIvpm4HpoJHpoZTpoZjkvIHkvI7ljbHllpzlmajln7rlpYflrInlr4TlspDluIzlub7lv4zmj67mnLrml5fml6LmnJ/mo4vmo4RcIl0sW1wiOGI0MFwiLFwi5qmf5biw5q+F5rCX5rG955W/56WI5a2j56iA57SA5b696KaP6KiY6LK06LW36LuM6Lyd6aOi6aiO6ay85LqA5YG95YSA5aaT5a6c5oiv5oqA5pOs5qy654qg55aR56WH576p6J+76Kq86K2w5o6s6I+K6Z6g5ZCJ5ZCD5Zar5qGU5qmY6Kmw56Cn5p216buN5Y205a6i6ISa6JmQ6YCG5LiY5LmF5LuH5LyR5Y+K5ZC45a6u5byT5oCl5pWRXCJdLFtcIjhiODBcIixcIuacveaxguaxsuazo+eBuOeQg+eptueqruesiOe0muezvue1puaXp+eJm+WOu+WxheW3qOaLkuaLoOaMmea4oOiZmuiosei3nemLuOa8geempumtmuS6qOS6q+S6rOS+m+S+oOWDkeWFh+ertuWFseWHtuWNlOWMoeWNv+WPq+WWrOWig+WzoeW8t+W9iuaAr+aBkOaBreaMn+aVmeapi+azgeeLgueLreefr+iDuOiEheiIiOiVjumDt+mPoemfv+mll+mpmuS7sOWHneWwreaagealreWxgOabsualteeOieahkOeygeWDheWLpOWdh+W3vumMpuaWpOaso+asveeQtOemgeemveeti+e3iuiKueiPjOihv+iln+isuei/kemHkeWQn+mKgOS5neWAtuWPpeWMuueLl+eOluefqeiLpui6r+mnhumniOmnkuWFt+aEmuiZnuWWsOepuuWBtuWvk+mBh+maheS4suarm+mHp+WxkeWxiFwiXSxbXCI4YzQwXCIsXCLmjpjnqp/mspPpnbTovaHnqqrnhorpmojnsoLmoJfnubDmoZHpjazli7LlkJvolqvoqJPnvqTou43pg6HljabooojnpYHkv4Llgr7liJHlhYTllZPlnK3nj6rlnovlpZHlvaLlvoTmgbXmhbbmhafmhqnmjrLmkLrmlazmma/moYLmuJPnlabnqL3ns7vntYzntpnnuYvnvavojI7ojYrom43oqIjoqaPorabou73poJrpto/oirjov47pr6hcIl0sW1wiOGM4MFwiLFwi5YqH5oif5pKD5r+A6ZqZ5qGB5YKR5qyg5rG65r2U56m057WQ6KGA6Kij5pyI5Lu25YC55YCm5YGl5YW85Yi45Ymj5Zan5ZyP5aCF5auM5bu65oay5oe45ouz5o2y5qSc5qip54m954qs54yu56CU56Gv57W555yM6IKp6KaL6KyZ6LOi6LuS6YGj6Y216Zm66aGV6aiT6bm45YWD5Y6f5Y6z5bm75bym5rib5rqQ546E54++57WD6Ii36KiA6Ku66ZmQ5LmO5YCL5Y+k5ZG85Zu65aeR5a2k5bex5bqr5byn5oi45pWF5p6v5rmW54uQ57OK6KK06IKh6IOh6I+w6JmO6KqH6Leo6Yi36ZuH6aGn6byT5LqU5LqS5LyN5Y2I5ZGJ5ZC+5aiv5b6M5b6h5oKf5qKn5qqO55Ga56KB6Kqe6Kqk6K236YaQ5Lme6a+J5Lqk5L285L6v5YCZ5YCW5YWJ5YWs5Yqf5Yq55Yu+5Y6a5Y+j5ZCRXCJdLFtcIjhkNDBcIixcIuWQjuWWieWdkeWeouWlveWtlOWtneWuj+W3peW3p+W3t+W5uOW6g+W6muW6t+W8mOaBkuaFjOaKl+aLmOaOp+aUu+aYguaZg+abtOadreagoeail+ani+axn+a0qua1qea4r+a6neeUsueah+ehrOeov+ezoOe0hee0mOe1nue2seiAleiAg+iCr+iCseiFlOiGj+iIquiNkuihjOihoeism+iyouizvOmDiumFtemJseegv+mLvOmWpOmZjVwiXSxbXCI4ZDgwXCIsXCLpoIXpppnpq5jptLvliZvliqvlj7flkIjlo5Xmi7fmv6DosarovZ/purnlhYvliLvlkYrlm73nqYDphbfptaDpu5LnjYTmvInohbDnlJHlv73mg5rpqqjni5vovrzmraTpoIPku4rlm7DlnaTlor7lqZrmgajmh4fmmI/mmIbmoLnmorHmt7fnl5XntLroia7prYLkupvkvZDlj4nllIblta/lt6blt67mn7vmspnnkbPnoILoqZDpjpboo5/lnZDluqfmjKvlgrXlgqzlho3mnIDlk4nloZ7lprvlrrDlvanmiY3mjqHmoL3mrbPmuIjngb3ph4fnioDnoJXnoKbnpa3mlo7ntLDoj5zoo4HovInpmpvliaTlnKjmnZDnvarosqHlhrTlnYLpmKrloLrmporogrTlkrLltI7ln7znopXpt7rkvZzliYrlkovmkL7mmKjmnJTmn7XnqoTnrZbntKLpjK/moZzprq3nrLnljJnlhorliLdcIl0sW1wiOGU0MFwiLFwi5a+f5ou25pKu5pOm5pyt5q666Jap6ZuR55qQ6a+W5o2M6YyG6a6r55q/5pmS5LiJ5YKY5Y+C5bGx5oOo5pKS5pWj5qGf54em54+K55Sj566X57qC6JqV6K6D6LOb6YW46aSQ5pas5pqr5q6L5LuV5LuU5Ly65L2/5Yi65Y+45Y+y5Zej5Zub5aOr5aeL5aeJ5ae/5a2Q5bGN5biC5bir5b+X5oCd5oyH5pSv5a2c5pav5pa95peo5p6d5q2iXCJdLFtcIjhlODBcIixcIuatu+awj+eNheelieengeezuOe0mee0q+iCouiEguiHs+imluipnuipqeippuiqjOirruizh+iznOmbjOmjvOatr+S6i+S8vOS+jeWFkOWtl+WvuuaFiOaMgeaZguasoea7i+ayu+eIvueSveeXlOejgeekuuiAjOiAs+iHquiSlOi+nuaxkOm5v+W8j+itmOm0q+eruui7uOWujembq+S4g+WPseWft+WkseWrieWupOaCiea5v+a8hueWvuizquWun+iUgOevoOWBsuaftOiKneWxoeiViue4nuiIjuWGmeWwhOaNqOi1puaWnOeFruekvue0l+iAheisnei7iumBruibh+mCquWAn+WLuuWwuuadk+eBvOeItemFjOmHiOmMq+iLpeWvguW8seaDueS4u+WPluWuiOaJi+acseauiueLqeePoOeoruiFq+i2o+mFkummluWEkuWPl+WRquWvv+aOiOaouee2rOmcgOWbmuWPjuWRqFwiXSxbXCI4ZjQwXCIsXCLlrpflsLHlt57kv67mhIHmi77mtLLnp4Dnp4vntYLnuY3nv5Loh63oiJ/okpDooYbopbLorpDoubTovK/pgLHphYvphazpm4bphpzku4DkvY/lhYXljYHlvpPmiI7mn5TmsYHmuIvnjaPnuKbph43pioPlj5TlpJnlrr/mt5HnpZ3nuK7nspvlob7nhp/lh7rooZPov7Dkv4rls7vmmKXnnqznq6PoiJzpp7/lh4blvqrml6zmpa/mronmt7NcIl0sW1wiOGY4MFwiLFwi5rqW5r2k55u+57SU5beh6YG16YaH6aCG5Yem5Yid5omA5pqR5puZ5ria5bq257eS572y5pu46Jav6Je36Ku45Yqp5Y+Z5aWz5bqP5b6Q5oGV6Yuk6Zmk5YK35YSf5Yud5Yyg5Y2H5Y+s5ZOo5ZWG5ZSx5ZiX5aWo5aa+5ai85a615bCG5bCP5bCR5bCa5bqE5bqK5bug5b2w5om/5oqE5oub5o6M5o235piH5piM5pit5pm25p2+5qKi5qif5qi15rK85raI5riJ5rmY54S854Sm54Wn55eH55yB56Gd56SB56Wl56ew56ug56yR57Kn57S56IKW6I+W6JKL6JWJ6KGd6KOz6Kif6Ki86KmU6Kmz6LGh6LOe6Yak6Ymm6Y2+6ZCY6Zqc6Z6Y5LiK5LiI5Lie5LmX5YaX5Ymw5Z+O5aC05aOM5ayi5bi45oOF5pO+5p2h5p2W5rWE54q255Wz56mj6JK46K2y6Ya46Yyg5Zix5Z+06aO+XCJdLFtcIjkwNDBcIixcIuaLreakjeaulueHree5lOiBt+iJsuinpumjn+idlei+seWwu+S8uOS/oeS+teWUh+WooOWvneWvqeW/g+aFjuaMr+aWsOaZi+ajruamm+a1uOa3seeUs+eWueecn+elnuenpue0s+iHo+iKr+iWquimquiouui6q+i+m+mAsumHnemch+S6uuS7geWIg+WhteWjrOWwi+eUmuWwveiFjuioiui/hemZo+mdreespeirj+mgiOmFouWbs+WOqFwiXSxbXCI5MDgwXCIsXCLpgJflkLnlnoLluKXmjqjmsLTngornnaHnsovnv6DoobDpgYLphZTpjJDpjJjpmo/nkZ7pq4TltIfltanmlbDmnqLotqjpm5vmja7mnYnmpJnoj4XpoJfpm4Doo77mvoTmkbrlr7jkuJbngKznlZ3mmK/lh4TliLbli6Llp5PlvoHmgKfmiJDmlL/mlbTmmJ/mmbTmo7LmoJbmraPmuIXnibLnlJ/nm5vnsr7ogZblo7Doo73opb/oqqDoqpPoq4vpgJ3phpLpnZLpnZnmlonnqI7ohIbpmrvluK3mg5zmiJrmlqXmmJTmnpDnn7PnqY3nsY3nuL7ohIrosqzotaTot6HouZ/noqnliIfmi5nmjqXmkYLmipjoqK3nqoPnr4Doqqzpm6rntbboiIzonYnku5nlhYjljYPljaDlrqPlsILlsJblt53miKbmiYfmkrDmoJPmoLTms4nmtYXmtJfmn5PmvZznhY7nhb3ml4vnqb/nrq3nt5pcIl0sW1wiOTE0MFwiLFwi57mK576o6IW66Iib6Ii56Jam6Kmu6LOO6Le16YG46YG36Yqt6YqR6ZaD6a6u5YmN5ZaE5ry454S25YWo56aF57mV6Iaz57OO5ZmM5aGR5bKo5o6q5pu+5pu95qWa54uZ55aP55aO56SO56WW56ef57KX57Sg57WE6JiH6Ki06Zi76YGh6byg5YOn5Ym15Y+M5Y+i5YCJ5Zaq5aOu5aWP54i95a6L5bGk5Yyd5oOj5oOz5o2c5o6D5oy/5o67XCJdLFtcIjkxODBcIixcIuaTjeaXqeabueW3o+anjeanvea8leeHpeS6ieeXqeebuOeqk+ezn+e3j+e2nOiBoeiNieiNmOiRrOiSvOiXu+ijhei1sOmAgemBremOl+mcnOmokuWDj+Wil+aGjuiHk+iUtei0iOmAoOS/g+WBtOWJh+WNs+aBr+aNieadn+a4rOi2s+mAn+S/l+WxnuiziuaXj+e2muWNkuiiluWFtuaPg+WtmOWtq+WwiuaQjeadkemBnOS7luWkmuWkquaxsOipkeWUvuWgleWmpeaDsOaJk+afgeiIteallemZgOmnhOmoqOS9k+WghuWvvuiAkOWyseW4r+W+heaAoOaFi+aItOabv+azsOa7nuiDjuiFv+iLlOiii+iyuOmAgOmArumaium7m+mvm+S7o+WPsOWkp+esrOmGjemhjOm3uea7neeAp+WNk+WVhOWuheaJmOaKnuaLk+ayoua/r+eQouiol+mQuOa/geirvuiMuOWHp+ibuOWPqlwiXSxbXCI5MjQwXCIsXCLlj6nkvYbpgZTovrDlparohLHlt73nq6rovr/mo5rosLfni7jpsYjmqL3oqrDkuLnljZjlmIblnabmi4XmjqLml6bmrY7mt6HmuZvngq3nn63nq6/nrqrntrvogL3og4bom4voqpXpjZvlm6Plo4flvL7mlq3mmpbmqoDmrrXnlLfoq4flgKTnn6XlnLDlvJvmgaXmmbrmsaDnl7TnqJrnva7oh7TonJjpgYXpprPnr4nnlZznq7nnrZHok4RcIl0sW1wiOTI4MFwiLFwi6YCQ56ep56qS6Iy25auh552A5Lit5Luy5a6Z5b+g5oq95pi85p+x5rOo6Jmr6KG36Ki76YWO6Yuz6aeQ5qiX54Cm54yq6Iun6JGX6LKv5LiB5YWG5YeL5ZaL5a+15biW5biz5bqB5byU5by15b2r5b605oey5oyR5pqi5pyd5r2u54mS55S655y66IG06IS56IW46J226Kq/6Kuc6LaF6Lez6Yqa6ZW36aCC6bOl5YuF5o2X55u05pyV5rKI54+N6LOD6Y6u6Zmz5rSl5aKc5qSO5qeM6L+96Y6a55eb6YCa5aGa5qCC5o605qe75L2D5rys5p+Y6L676JSm57a06Y2U5qS/5r2w5Z2q5aO35ays57Ss54iq5ZCK6Yej6ba05Lqt5L2O5YGc5YG15YmD6LKe5ZGI5aCk5a6a5bid5bqV5bqt5bu35byf5oKM5oq15oy65o+Q5qKv5rGA56KH56aO56iL57eg6ImH6KiC6Kum6LmE6YCTXCJdLFtcIjkzNDBcIixcIumCuOmEremHmOm8juazpeaRmOaTouaVtea7tOeahOesm+mBqemPkea6uuWTsuW+ueaSpOi9jei/remJhOWFuOWhq+WkqeWxleW6l+a3u+e6j+eUnOiyvOi7oumhm+eCueS8neauv+a+seeUsOmbu+WFjuWQkOWgteWhl+WmrOWxoOW+kuaWl+adnOa4oeeZu+iPn+izremAlOmDvemNjeegpeeguuWKquW6puWcn+WltOaAkuWAkuWFmuWGrFwiXSxbXCI5MzgwXCIsXCLlh43liIDllJDloZTloZjlpZflrpXls7bltovmgrzmipXmkK3mnbHmoYPmorzmo5/nm5fmt5jmua/mtpvnga/nh4jlvZPnl5jnpbfnrYnnrZTnrZLns5bntbHliLDokaPolanol6ToqI7orITosYbouI/pgIPpgI/pkJnpmbbpoK3pqLDpl5jlg43li5XlkIzloILlsI7mhqfmkp7mtJ7nnrPnq6Xog7TokITpgZPpioXls6DptIfljL/lvpflvrPmtpznibnnnaPnpr/nr6Tmr5Lni6zoqq3moIPmqaHlh7jnqoHmpLTlsYrps7boi6vlr4XphYnngJ7lmbjlsa/mg4fmlabmsozosZrpgYHpoJPlkZHmm4fpiI3lpYjpgqPlhoXkuY3lh6rolpnorI7ngZjmjbrpjYvmpaLpprTnuITnlbfljZfmpaDou5/pm6PmsZ3kuozlsLzlvJDov6nljILos5Hogonombnlu7/ml6XkubPlhaVcIl0sW1wiOTQ0MFwiLFwi5aaC5bC/6Z+u5Lu75aaK5b+N6KqN5r+h56aw56Wi5a+n6JGx54yr54ax5bm05b+15o275pKa54eD57KY5LmD5bu85LmL5Z+c5Zqi5oKp5r+D57SN6IO96ISz6Ia/6L6y6KaX6Jqk5be05oqK5pKt6KaH5p235rOi5rS+55C256C05amG57216Iqt6aas5L+z5buD5oud5o6S5pWX5p2v55uD54mM6IOM6IK66Lyp6YWN5YCN5Z+55aqS5qKFXCJdLFtcIjk0ODBcIixcIuals+eFpOeLveiyt+WjsuizoOmZqumAmeidv+enpOefp+iQqeS8r+WJpeWNmuaLjeafj+aziueZveeulOeyleiItuiWhOi/q+abnea8oOeIhue4m+iOq+mngem6puWHveeuseehsueuuOiCh+etiOarqOW5oeiCjOeVkeeVoOWFq+mJoua6jOeZuumGl+mrquS8kOe9sOaKnOetj+mWpemzqeWZuuWhmeibpOmavOS8tOWIpOWNiuWPjeWPm+W4huaQrOaWkeadv+awvuaxjueJiOeKr+ePreeVlOe5geiIrOiXqeiyqeevhOmHhueFqemgkumjr+aMveaZqeeVquebpOejkOiVg+ibruWMquWNkeWQpuWmg+W6h+W9vOaCsuaJieaJueaKq+aWkOavlOazjOeWsuearueikeenmOe3i+e9t+iCpeiiq+iqueiyu+mBv+mdnumjm+aoi+ewuOWCmeWwvuW+ruaeh+avmOeQteeciee+jlwiXSxbXCI5NTQwXCIsXCLpvLvmn4rnqJfljLnnlovpq63lvabohp3oj7HogpjlvLzlv4XnlaLnrYbpgLzmoaflp6vlqpvntJDnmb7orKzkv7XlvarmqJnmsLfmvILnk6LnpajooajoqZXosbnlu5/mj4/nl4Xnp5Loi5fpjKjpi7Lokpzom63psK3lk4HlvazmlozmtZzngJXosqfos5PpoLvmlY/nk7bkuI3ku5jln6DlpKvlqablr4zlhqjluIPlupzmgJbmibbmlbdcIl0sW1wiOTU4MFwiLFwi5pan5pmu5rWu54i256ym6IWQ6Iaa6IqZ6K2c6LKg6LOm6LW06Zic6ZmE5L6u5pKr5q2m6Iie6JGh6JWq6YOo5bCB5qWT6aKo6JG66JWX5LyP5Ymv5b6p5bmF5pyN56aP6IW56KSH6KaG5re15byX5omV5rK45LuP54mp6a6S5YiG5ZC75Zm05aKz5oak5omu54Sa5aWu57KJ57Oe57Sb6Zuw5paH6IGe5LiZ5L215YW15aGA5bmj5bmz5byK5p+E5Lim6JS96ZaJ6Zmb57Gz6aCB5YO75aOB55mW56Kn5Yil556l6JSR566G5YGP5aSJ54mH56+H57eo6L666L+U6YGN5L6/5YuJ5aip5byB6Z6t5L+d6IiX6Yuq5ZyD5o2V5q2p55Sr6KOc6LyU56mC5Yuf5aKT5oWV5oiK5pqu5q+N57C/6I+p5YCj5L+45YyF5ZGG5aCx5aWJ5a6d5bOw5bOv5bSp5bqW5oqx5o2n5pS+5pa55pyLXCJdLFtcIjk2NDBcIixcIuazleazoeeDueegsue4q+iDnuiKs+iQjOiTrOicguikkuioquixiumCpumLkumjvemzs+m1rOS5j+S6oeWCjeWJluWdiuWmqOW4veW/mOW/meaIv+aatOacm+afkOajkuWGkue0oeiCquiGqOisgOiyjOiyv+mJvumYsuWQoOmgrOWMl+WDleWNnOWiqOaSsuactOeJp+edpuephumHpuWLg+ayoeauhuWggOW5jOWllOacrOe/u+WHoeebhlwiXSxbXCI5NjgwXCIsXCLmkanno6jprZTpurvln4vlprnmmKfmnprmr47lk6nmp5nluZXohpzmnpXprqrmn77psZLmoZ3kuqbkv6Plj4jmirnmnKvmsqvov4Tkvq3nua3pur/kuIfmhaLmuoDmvKvolJPlkbPmnKrprYXlt7PnrpXlsqzlr4bonJzmuYrok5HnqJTohIjlppnnso3msJHnnKDli5nlpKLnhKHniZ/nn5vpnKfptaHmpIvlqb/lqJjlhqXlkI3lkb3mmI7nm5/ov7fpipjps7Tlp6rniZ3mu4XlhY3mo4nntr/nt6zpnaLpurrmkbjmqKHojILlpoTlrZ/mr5vnjJvnm7LntrLogJfokpnlhLLmnKjpu5nnm67mnaLli7/ppIXlsKTmiLvnsb7osrDllY/mgrbntIvploDljIHkuZ/lhrblpJzniLrogLbph47lvKXnn6LljoTlvbnntITolqzoqLPouo3pnZbmn7Polq7pkZPmhInmhIjmsrnnmZJcIl0sW1wiOTc0MFwiLFwi6Kut6Ly45ZSv5L2R5YSq5YuH5Y+L5a6l5bm95oKg5oaC5o+W5pyJ5p+a5rmn5raM54y254y355Sx56WQ6KOV6KqY6YGK6YKR6YO16ZuE6J6N5aSV5LqI5L2Z5LiO6KqJ6Ly/6aCQ5YKt5bm85aaW5a655bq45o+a5o+65pOB5puc5qWK5qeY5rSL5rq254aU55So56qv576K6ICA6JGJ6JOJ6KaB6Kyh6LiK6YGl6Zm96aSK5oW+5oqR5qyyXCJdLFtcIjk3ODBcIixcIuayg+a1tOe/jOe/vOa3gOe+heieuuijuOadpeiOsemgvOmbt+a0m+e1oeiQvemFquS5seWNteW1kOashOa/q+iXjeiYreimp+WIqeWQj+WxpeadjuaiqOeQhueSg+eXouijj+ijoemHjOmboumZuOW+i+eOh+eri+iRjuaOoOeVpeWKiea1gea6nOeQieeVmeehq+eykumahuernOm+jeS+tuaFruaXheiZnOS6huS6ruWDmuS4oeWHjOWvruaWmeaigea2vOeMn+eZgueereeonOezp+iJr+irkumBvOmHj+mZtemgmOWKm+e3keWAq+WOmOael+a3i+eHkOeQs+iHqOi8qumao+mxl+m6n+eRoOWhgea2mee0r+mhnuS7pOS8tuS+i+WGt+WKseW2uuaAnOeOsuekvOiLk+mItOmat+mbtumcium6l+m9ouaapuattOWIl+WKo+eDiOijguW7ieaBi+aGkOa8o+eFieewvue3tOiBr1wiXSxbXCI5ODQwXCIsXCLok67pgKPpjKzlkYLpra/mq5Pngonos4Lot6/pnLLlirTlqYHlu4rlvITmnJfmpbzmppTmtarmvI/niaLni7znr63ogIHogb7onYvpg47lha3pupPnpoTogovpjLLoq5blgK3lkozoqbHmraros4TohIfmg5HmnqDpt7LkupnkupjpsJDoqavol4HolajmpIDmub7nopfohZVcIl0sW1wiOTg5ZlwiLFwi5byM5LiQ5LiV5Liq5Lix5Li25Li85Li/5LmC5LmW5LmY5LqC5LqF6LGr5LqK6IiS5byN5LqO5Lqe5Lqf5Lqg5Lqi5Lqw5Lqz5Lq25LuO5LuN5LuE5LuG5LuC5LuX5Lue5Lut5Luf5Lu35LyJ5L2a5Lyw5L2b5L2d5L2X5L2H5L225L6I5L6P5L6Y5L275L2p5L2w5L6R5L2v5L6G5L6W5YSY5L+U5L+f5L+O5L+Y5L+b5L+R5L+a5L+Q5L+k5L+l5YCa5YCo5YCU5YCq5YCl5YCF5Lyc5L+25YCh5YCp5YCs5L++5L+v5YCR5YCG5YGD5YGH5pyD5YGV5YGQ5YGI5YGa5YGW5YGs5YG45YKA5YKa5YKF5YK05YKyXCJdLFtcIjk5NDBcIixcIuWDieWDiuWCs+WDguWDluWDnuWDpeWDreWDo+WDruWDueWDteWEieWEgeWEguWEluWEleWElOWEmuWEoeWEuuWEt+WEvOWEu+WEv+WFgOWFkuWFjOWFlOWFoueruOWFqeWFquWFruWGgOWGguWbmOWGjOWGieWGj+WGkeWGk+WGleWGluWGpOWGpuWGouWGqeWGquWGq+WGs+WGseWGsuWGsOWGteWGveWHheWHieWHm+WHoOiZleWHqeWHrVwiXSxbXCI5OTgwXCIsXCLlh7Dlh7Xlh77liITliIvliJTliI7liKfliKrliK7liLPliLnliY/liYTliYvliYzliZ7liZTliarlibTlianlibPlib/lib3lio3lipTlipLlibHliojlipHovqjovqfliqzliq3lirzlirXli4Hli43li5fli57li6Pli6bpo63li6Dli7Pli7Xli7jli7nljIbljIjnlLjljI3ljJDljI/ljJXljJrljKPljK/ljLHljLPljLjljYDljYbljYXkuJfljYnljY3lh5bljZ7ljanlja7lpJjljbvljbfljoLljpbljqDljqbljqXljq7ljrDljrblj4PnsJLpm5nlj5/mm7znh67lj67lj6jlj63lj7rlkIHlkL3lkYDlkKzlkK3lkLzlkK7lkLblkKnlkJ3lkY7lko/lkbXlko7lkZ/lkbHlkbflkbDlkpLlkbvlkoDlkbblkoTlkpDlkoblk4flkqLlkrjlkqXlkqzlk4Tlk4jlkqhcIl0sW1wiOWE0MFwiLFwi5ZKr5ZOC5ZKk5ZK+5ZK85ZOY5ZOl5ZOm5ZSP5ZSU5ZO95ZOu5ZOt5ZO65ZOi5ZS55ZWA5ZWj5ZWM5ZSu5ZWc5ZWF5ZWW5ZWX5ZS45ZSz5ZWd5ZaZ5ZaA5ZKv5ZaK5Zaf5ZW75ZW+5ZaY5Zae5Zau5ZW85ZaD5Zap5ZaH5Zao5Zea5ZeF5Zef5ZeE5Zec5Zek5ZeU5ZiU5Ze35ZiW5Ze+5Ze95Zib5Ze55ZmO5ZmQ54ef5Zi05Zi25Ziy5Zi4XCJdLFtcIjlhODBcIixcIuWZq+WZpOWYr+WZrOWZquWahuWagOWaiuWaoOWalOWaj+WapeWaruWatuWatOWbguWavOWbgeWbg+WbgOWbiOWbjuWbkeWbk+Wbl+WbruWbueWcgOWbv+WchOWcieWciOWci+WcjeWck+WcmOWcluWXh+WcnOWcpuWct+WcuOWdjuWcu+WdgOWdj+WdqeWfgOWeiOWdoeWdv+WeieWek+WeoOWes+WepOWequWesOWfg+WfhuWflOWfkuWfk+WgiuWfluWfo+Wgi+WgmeWgneWhsuWgoeWhouWhi+WhsOavgOWhkuWgveWhueWiheWiueWin+Wiq+WiuuWjnuWiu+WiuOWiruWjheWjk+WjkeWjl+WjmeWjmOWjpeWjnOWjpOWjn+Wjr+WjuuWjueWju+WjvOWjveWkguWkiuWkkOWkm+aipuWkpeWkrOWkreWksuWkuOWkvuerkuWlleWlkOWljuWlmuWlmOWlouWloOWlp+WlrOWlqVwiXSxbXCI5YjQwXCIsXCLlpbjlpoHlpp3kvZ7kvqvlpqPlprLlp4blp6jlp5zlpo3lp5nlp5rlqKXlqJ/lqJHlqJzlqInlqJrlqYDlqazlqYnlqLXlqLblqaLlqarlqprlqrzlqr7lq4vlq4Llqr3lq6Plq5flq6blq6nlq5blq7rlq7vlrIzlrIvlrJblrLLlq5DlrKrlrLblrL7lrYPlrYXlrYDlrZHlrZXlrZrlrZvlraXlranlrbDlrbPlrbXlrbjmlojlrbrlroBcIl0sW1wiOWI4MFwiLFwi5a6D5a6m5a645a+D5a+H5a+J5a+U5a+Q5a+k5a+m5a+i5a+e5a+l5a+r5a+w5a+25a+z5bCF5bCH5bCI5bCN5bCT5bCg5bCi5bCo5bC45bC55bGB5bGG5bGO5bGT5bGQ5bGP5a2x5bGs5bGu5Lmi5bG25bG55bKM5bKR5bKU5aab5bKr5bK75bK25bK85bK35bOF5bK+5bOH5bOZ5bOp5bO95bO65bOt5baM5bOq5bSL5bSV5bSX5bWc5bSf5bSb5bSR5bSU5bSi5bSa5bSZ5bSY5bWM5bWS5bWO5bWL5bWs5bWz5bW25baH5baE5baC5bai5bad5bas5bau5ba95baQ5ba35ba85beJ5beN5beT5beS5beW5beb5ber5bey5be15biL5bia5biZ5biR5bib5bi25bi35bmE5bmD5bmA5bmO5bmX5bmU5bmf5bmi5bmk5bmH5bm15bm25bm66bq85bm/5bqg5buB5buC5buI5buQ5buPXCJdLFtcIjljNDBcIixcIuW7luW7o+W7neW7muW7m+W7ouW7oeW7qOW7qeW7rOW7seW7s+W7sOW7tOW7uOW7vuW8g+W8ieW9neW9nOW8i+W8keW8luW8qeW8reW8uOW9geW9iOW9jOW9juW8r+W9keW9luW9l+W9meW9oeW9reW9s+W9t+W+g+W+guW9v+W+iuW+iOW+keW+h+W+nuW+meW+mOW+oOW+qOW+reW+vOW/luW/u+W/pOW/uOW/seW/neaCs+W/v+aAoeaBoFwiXSxbXCI5YzgwXCIsXCLmgJnmgJDmgKnmgI7mgLHmgJvmgJXmgKvmgKbmgI/mgLrmgZrmgYHmgarmgbfmgZ/mgYrmgYbmgY3mgaPmgYPmgaTmgYLmgazmgavmgZnmgoHmgo3mg6fmgoPmgprmgoTmgpvmgpbmgpfmgpLmgqfmgovmg6Hmgrjmg6Dmg5PmgrTlv7Dmgr3mg4bmgrXmg5jmhY3mhJXmhIbmg7bmg7fmhIDmg7Tmg7rmhIPmhKHmg7vmg7HmhI3mhI7mhYfmhL7mhKjmhKfmhYrmhL/mhLzmhKzmhLTmhL3mhYLmhYTmhbPmhbfmhZjmhZnmhZrmhavmhbTmha/mhaXmhbHmhZ/mhZ3mhZPmhbXmhpnmhpbmhofmhqzmhpTmhprmhormhpHmhqvmhq7mh4zmh4rmh4nmh7fmh4jmh4Pmh4bmhrrmh4vnvbnmh43mh6bmh6Pmh7bmh7rmh7Tmh7/mh73mh7zmh77miIDmiIjmiInmiI3miIzmiJTmiJtcIl0sW1wiOWQ0MFwiLFwi5oie5oih5oiq5oiu5oiw5oiy5oiz5omB5omO5ome5omj5omb5omg5omo5om85oqC5oqJ5om+5oqS5oqT5oqW5ouU5oqD5oqU5ouX5ouR5oq75ouP5ou/5ouG5pOU5ouI5ouc5ouM5ouK5ouC5ouH5oqb5ouJ5oyM5ouu5oux5oyn5oyC5oyI5ouv5ou15o2Q5oy+5o2N5pCc5o2P5o6W5o6O5o6A5o6r5o225o6j5o6P5o6J5o6f5o615o2rXCJdLFtcIjlkODBcIixcIuaNqeaOvuaPqeaPgOaPhuaPo+aPieaPkuaPtuaPhOaQluaQtOaQhuaQk+aQpuaQtuaUneaQl+aQqOaQj+aRp+aRr+aRtuaRjuaUquaSleaSk+aSpeaSqeaSiOaSvOaTmuaTkuaTheaTh+aSu+aTmOaTguaTseaTp+iIieaToOaToeaKrOaTo+aTr+aUrOaTtuaTtOaTsuaTuuaUgOaTveaUmOaUnOaUheaUpOaUo+aUq+aUtOaUteaUt+aUtuaUuOeVi+aViOaVluaVleaVjeaVmOaVnuaVneaVsuaVuOaWguaWg+iuiuaWm+aWn+aWq+aWt+aXg+aXhuaXgeaXhOaXjOaXkuaXm+aXmeaXoOaXoeaXseadsuaYiuaYg+aXu+ads+aYteaYtuaYtOaYnOaZj+aZhOaZieaZgeaZnuaZneaZpOaZp+aZqOaZn+aZouaZsOaag+aaiOaajuaaieaahOaamOaaneabgeaaueabieaavuaavFwiXSxbXCI5ZTQwXCIsXCLmm4Tmmrjmm5bmm5rmm6DmmL/mm6bmm6nmm7Dmm7Xmm7fmnI/mnJbmnJ7mnKbmnKfpnLjmnK7mnL/mnLbmnYHmnLjmnLfmnYbmnZ7mnaDmnZnmnaPmnaTmnonmnbDmnqnmnbzmnarmnozmnovmnqbmnqHmnoXmnrfmn6/mnrTmn6zmnrPmn6nmnrjmn6Tmn57mn53mn6Lmn67mnrnmn47mn4bmn6fmqpzmoJ7moYbmoKnmoYDmoY3moLLmoY5cIl0sW1wiOWU4MFwiLFwi5qKz5qCr5qGZ5qGj5qG35qG/5qKf5qKP5qKt5qKU5qKd5qKb5qKD5qqu5qK55qG05qK15qKg5qK65qSP5qKN5qG+5qSB5qOK5qSI5qOY5qSi5qSm5qOh5qSM5qON5qOU5qOn5qOV5qS25qSS5qSE5qOX5qOj5qSl5qO55qOg5qOv5qSo5qSq5qSa5qSj5qSh5qOG5qW55qW35qWc5qW45qWr5qWU5qW+5qWu5qS55qW05qS95qWZ5qSw5qWh5qWe5qWd5qaB5qWq5qay5qau5qeQ5qa/5qeB5qeT5qa+5qeO5a+o5qeK5qed5qa75qeD5qan5qiu5qaR5qag5qac5qaV5qa05qee5qeo5qiC5qib5qe/5qyK5qe55qey5qen5qiF5qax5qie5qet5qiU5qer5qiK5qiS5quB5qij5qiT5qmE5qiM5qmy5qi25qm45qmH5qmi5qmZ5qmm5qmI5qi45qii5qqQ5qqN5qqg5qqE5qqi5qqjXCJdLFtcIjlmNDBcIixcIuaql+iYl+aqu+arg+arguaquOaqs+aqrOarnuarkearn+aqquarmuarquaru+asheiYluaruuaskuaslumsseasn+asuOast+ebnOasuemjruath+atg+atieatkOatmeatlOatm+atn+atoeatuOatueatv+augOauhOaug+aujeaumOauleaunuaupOauquauq+aur+ausuauseaus+aut+auvOavhuavi+avk+avn+avrOavq+avs+avr1wiXSxbXCI5ZjgwXCIsXCLpur7msIjmsJPmsJTmsJvmsKTmsKPmsZ7msZXmsaLmsarmsoLmso3msprmsoHmspvmsb7msajmsbPmspLmspDms4Tms7Hms5Pmsr3ms5fms4Xms53msq7msrHmsr7msrrms5vms6/ms5nms6rmtJ/ooY3mtLbmtKvmtL3mtLjmtJnmtLXmtLPmtJLmtIzmtaPmtpPmtaTmtZrmtbnmtZnmto7mtpXmv6TmtoXmt7nmuJXmuIrmtrXmt4fmt6bmtrjmt4bmt6zmt57mt4zmt6jmt5Lmt4Xmt7rmt5nmt6Tmt5Xmt6rmt67muK3mua7muK7muJnmubLmuZ/muL7muKPmuavmuKvmubbmuY3muJ/muYPmuLrmuY7muKTmu7/muJ3muLjmuoLmuqrmupjmu4nmurfmu5Pmur3muq/mu4TmurLmu5Tmu5Xmuo/muqXmu4Lmup/mvYHmvJHngYzmu6zmu7jmu77mvL/mu7LmvLHmu6/mvLLmu4xcIl0sW1wiZTA0MFwiLFwi5ry+5ryT5ru35r6G5r265r245r6B5r6A5r2v5r2b5r+z5r2t5r6C5r285r2Y5r6O5r6R5r+C5r2m5r6z5r6j5r6h5r6k5r655r+G5r6q5r+f5r+V5r+s5r+U5r+Y5r+x5r+u5r+b54CJ54CL5r+654CR54CB54CP5r++54Cb54Ca5r2054Cd54CY54Cf54Cw54C+54Cy54GR54Gj54KZ54KS54Kv54Ox54Ks54K454Kz54Ku54Of54OL54OdXCJdLFtcImUwODBcIixcIueDmeeEieeDveeEnOeEmeeFpeeFleeGiOeFpueFoueFjOeFlueFrOeGj+eHu+eGhOeGleeGqOeGrOeHl+eGueeGvueHkueHieeHlOeHjueHoOeHrOeHp+eHteeHvOeHueeHv+eIjeeIkOeIm+eIqOeIreeIrOeIsOeIsueIu+eIvOeIv+eJgOeJhueJi+eJmOeJtOeJvueKgueKgeeKh+eKkueKlueKoueKp+eKueeKsueLg+eLhueLhOeLjueLkueLoueLoOeLoeeLueeLt+WAj+eMl+eMiueMnOeMlueMneeMtOeMr+eMqeeMpeeMvueNjueNj+m7mOeNl+eNqueNqOeNsOeNuOeNteeNu+eNuuePiOeOs+ePjueOu+ePgOePpeePruePnueSoueQheeRr+eQpeePuOeQsueQuueRleeQv+eRn+eRmeeRgeeRnOeRqeeRsOeRo+eRqueRtueRvueSi+eSnueSp+eTiueTj+eTlOePsVwiXSxbXCJlMTQwXCIsXCLnk6Dnk6Pnk6fnk6nnk67nk7Lnk7Dnk7Hnk7jnk7fnlITnlIPnlIXnlIznlI7nlI3nlJXnlJPnlJ7nlKbnlKznlLznlYTnlY3nlYrnlYnnlZvnlYbnlZrnlannlaTnlafnlavnla3nlbjnlbbnlobnlofnlbTnlornlonnloLnlpTnlprnlp3nlqXnlqPnl4LnlrPnl4PnlrXnlr3nlrjnlrznlrHnl43nl4rnl5Lnl5nnl6Pnl57nl77nl79cIl0sW1wiZTE4MFwiLFwi55e855iB55ew55e655ey55ez55iL55iN55iJ55if55in55ig55ih55ii55ik55i055iw55i755mH55mI55mG55mc55mY55mh55mi55mo55mp55mq55mn55ms55mw55my55m255m455m855qA55qD55qI55qL55qO55qW55qT55qZ55qa55qw55q055q455q555q655uC55uN55uW55uS55ue55uh55ul55un55uq6Jiv55u755yI55yH55yE55yp55yk55ye55yl55ym55yb55y355y4552H552a552o552r552b552l552/552+5525556O556L556R556g556e556w55625565556/55685569556755+H55+N55+X55+a55+c55+j55+u55+856CM56CS56Sm56Cg56Sq56GF56KO56G056KG56G856Ka56KM56Kj56K156Kq56Kv56OR56OG56OL56OU56K+56K856OF56OK56OsXCJdLFtcImUyNDBcIixcIuejp+ejmuejveejtOekh+ekkuekkeekmeekrOekq+elgOeloOell+eln+elmuelleelk+eluuelv+emiuemneemp+m9i+emquemruems+emueemuuenieenleenp+enrOenoeeno+eoiOeojeeomOeomeeooOeon+emgOeoseeou+eovueot+epg+epl+epieepoeepouepqem+neepsOepueepveeqiOeql+eqleeqmOeqlueqqeeriOeqsFwiXSxbXCJlMjgwXCIsXCLnqrbnq4Xnq4Tnqr/pgoPnq4fnq4rnq43nq4/nq5Xnq5Pnq5nnq5rnq53nq6Hnq6Lnq6bnq63nq7DnrILnrI/nrIrnrIbnrLPnrJjnrJnnrJ7nrLXnrKjnrLbnrZDnrbrnrITnrY3nrIvnrYznrYXnrbXnraXnrbTnrafnrbDnrbHnraznra7nrp3nrpjnrp/nro3nrpznrprnrovnrpLnro/nrZ3nrpnnr4vnr4Hnr4znr4/nrrTnr4bnr53nr6nnsJHnsJTnr6bnr6XnsaDnsIDnsIfnsJPnr7Pnr7fnsJfnsI3nr7bnsKPnsKfnsKrnsJ/nsLfnsKvnsL3nsYznsYPnsZTnsY/nsYDnsZDnsZjnsZ/nsaTnsZbnsaXnsaznsbXnsoPnspDnsqTnsq3nsqLnsqvnsqHnsqjnsrPnsrLnsrHnsq7nsrnnsr3ns4Dns4Xns4Lns5jns5Lns5zns6LprLvns6/ns7Lns7Tns7bns7rntIZcIl0sW1wiZTM0MFwiLFwi57SC57Sc57SV57SK57WF57WL57Su57Sy57S/57S157WG57Wz57WW57WO57Wy57Wo57Wu57WP57Wj57aT57aJ57Wb57aP57W957ab57a657au57aj57a157eH57a957ar57i957ai57av57ec57a457af57aw57eY57ed57ek57ee57e757ey57eh57iF57iK57ij57ih57iS57ix57if57iJ57iL57ii57mG57mm57i757i157i557mD57i3XCJdLFtcImUzODBcIixcIue4sue4uue5p+e5nee5lue5nue5mee5mue5uee5que5qee5vOe5u+e6g+e3lee5vei+rue5v+e6iOe6iee6jOe6kue6kOe6k+e6lOe6lue6jue6m+e6nOe8uOe8uue9hee9jOe9jee9jue9kOe9kee9lee9lOe9mOe9n+e9oOe9qOe9qee9p+e9uOe+gue+hue+g+e+iOe+h+e+jOe+lOe+nue+nee+mue+o+e+r+e+sue+uee+rue+tue+uOitsee/hee/hue/iue/lee/lOe/oee/pue/qee/s+e/uemjnOiAhuiAhOiAi+iAkuiAmOiAmeiAnOiAoeiAqOiAv+iAu+iBiuiBhuiBkuiBmOiBmuiBn+iBouiBqOiBs+iBsuiBsOiBtuiBueiBveiBv+iChOiChuiCheiCm+iCk+iCmuiCreWGkOiCrOiDm+iDpeiDmeiDneiDhOiDmuiDluiEieiDr+iDseiEm+iEqeiEo+iEr+iFi1wiXSxbXCJlNDQwXCIsXCLpmovohYbohL7ohZPohZHog7zohbHoha7ohaXohabohbTohoPohojohorohoDohoLohqDohpXohqTohqPohZ/ohpPohqnohrDohrXohr7ohrjohr3oh4Doh4Lohrroh4noh43oh5Hoh5noh5joh4joh5roh5/oh6Doh6foh7roh7voh77oiIHoiILoiIXoiIfoiIroiI3oiJDoiJboiKnoiKvoiLjoiLPoiYDoiZnoiZjoiZ3oiZroiZ/oiaRcIl0sW1wiZTQ4MFwiLFwi6Imi6Imo6Imq6Imr6Iiu6Imx6Im36Im46Im+6IqN6IqS6Iqr6Iqf6Iq76Iqs6Iuh6Iuj6Iuf6IuS6Iu06Iuz6Iu66I6T6IyD6Iu76Iu56Iue6IyG6Iuc6IyJ6IuZ6Iy16Iy06IyW6Iyy6Iyx6I2A6Iy56I2Q6I2F6Iyv6Iyr6IyX6IyY6I6F6I6a6I6q6I6f6I6i6I6W6Iyj6I6O6I6H6I6K6I286I616I2z6I216I6g6I6J6I6o6I+06JCT6I+r6I+O6I+96JCD6I+Y6JCL6I+B6I+36JCH6I+g6I+y6JCN6JCi6JCg6I696JC46JSG6I+76JGt6JCq6JC86JWa6JKE6JG36JGr6JKt6JGu6JKC6JGp6JGG6JCs6JGv6JG56JC16JOK6JGi6JK56JK/6JKf6JOZ6JON6JK76JOa6JOQ6JOB6JOG6JOW6JKh6JSh6JO/6JO06JSX6JSY6JSs6JSf6JSV6JSU6JO86JWA6JWj6JWY6JWIXCJdLFtcImU1NDBcIixcIuiVgeiYguiVi+iVleiWgOiWpOiWiOiWkeiWiuiWqOiVreiWlOiWm+iXquiWh+iWnOiVt+iVvuiWkOiXieiWuuiXj+iWueiXkOiXleiXneiXpeiXnOiXueiYiuiYk+iYi+iXvuiXuuiYhuiYouiYmuiYsOiYv+iZjeS5leiZlOiZn+iZp+iZseiak+iao+iaqeiaquiai+iajOiatuiar+ibhOibhuiasOibieigo+iaq+iblOibnuibqeibrFwiXSxbXCJlNTgwXCIsXCLom5/om5vom6/onJLonIbonIjonIDonIPom7vonJHonInonI3om7nonIronLTonL/onLfonLvonKXonKnonJronaDonZ/onbjonYzonY7onbTonZfonajona7onZnonZPonaPonarooIXonqLonp/onoLonq/on4vonr3on4Don5Dpm5bonqvon4TonrPon4fon4bonrvon6/on7Lon6DooI/ooI3on77on7bon7fooI7on5LooJHooJbooJXooKLooKHooLHooLbooLnooKfooLvooYTooYLooZLooZnooZ7ooaLooavoooHoob7oop7oobXoob3oorXoobLoooLoopfoopLooq7oopnooqLooo3ooqToorDoor/oorHoo4Poo4Too5Too5joo5noo53oo7nopILoo7zoo7Too6joo7LopITopIzopIropJPopYPopJ7opKXopKropKvopYHopYTopLvopLbopLjopYzopJ3opaDopZ5cIl0sW1wiZTY0MFwiLFwi6KWm6KWk6KWt6KWq6KWv6KW06KW36KW+6KaD6KaI6KaK6KaT6KaY6Kah6Kap6Kam6Kas6Kav6Kay6Ka66Ka96Ka/6KeA6Kea6Kec6Ked6Ken6Ke06Ke46KiD6KiW6KiQ6KiM6Kib6Kid6Kil6Ki26KmB6Kmb6KmS6KmG6KmI6Km86Kmt6Kms6Kmi6KqF6KqC6KqE6Kqo6Kqh6KqR6Kql6Kqm6Kqa6Kqj6KuE6KuN6KuC6Kua6Kur6Kuz6KunXCJdLFtcImU2ODBcIixcIuirpOirseislOiroOirouirt+irnuirm+isjOish+ismuiroeisluiskOisl+isoOiss+meq+ispuisq+isvuisqOitgeitjOitj+itjuitieitluitm+itmuitq+itn+itrOitr+ittOitveiugOiujOiujuiukuiuk+iuluiumeiumuiwuuixgeiwv+ixiOixjOixjuixkOixleixouixrOixuOixuuiyguiyieiyheiyiuiyjeiyjuiylOixvOiymOaIneiyreiyquiyveiysuiys+iyruiytuiziOizgeizpOizo+izmuizveizuuizu+i0hOi0hei0iui0h+i0j+i0jei0kOm9jui0k+izjei0lOi0lui1p+i1rei1sei1s+i2gei2mei3gui2vui2uui3j+i3mui3lui3jOi3m+i3i+i3qui3q+i3n+i3o+i3vOi4iOi4iei3v+i4nei4nui4kOi4n+i5gui4tei4sOi4tOi5ilwiXSxbXCJlNzQwXCIsXCLouYfouYnouYzouZDouYjouZnouaTouaDouKrouaPouZXoubboubLoubzouoHouofouoXouoTouovouoroupPoupHoupToupnouqrouqHouqzourDou4bourHour7ou4Xou4jou4vou5vou6Pou7zou7vou6vou77ovIrovIXovJXovJLovJnovJPovJzovJ/ovJvovIzovKbovLPovLvovLnovYXovYLovL7ovYzovYnovYbovY7ovZfovZxcIl0sW1wiZTc4MFwiLFwi6L2i6L2j6L2k6L6c6L6f6L6j6L6t6L6v6L636L+a6L+l6L+i6L+q6L+v6YKH6L+06YCF6L+56L+66YCR6YCV6YCh6YCN6YCe6YCW6YCL6YCn6YC26YC16YC56L+46YGP6YGQ6YGR6YGS6YCO6YGJ6YC+6YGW6YGY6YGe6YGo6YGv6YG26Zqo6YGy6YKC6YG96YKB6YKA6YKK6YKJ6YKP6YKo6YKv6YKx6YK16YOi6YOk5omI6YOb6YSC6YSS6YSZ6YSy6YSw6YWK6YWW6YWY6YWj6YWl6YWp6YWz6YWy6YaL6YaJ6YaC6Yai6Yar6Yav6Yaq6Ya16Ya06Ya66YeA6YeB6YeJ6YeL6YeQ6YeW6Yef6Yeh6Yeb6Ye86Ye16Ye26Yie6Ye/6YiU6Yis6YiV6YiR6Yme6YmX6YmF6YmJ6Ymk6YmI6YqV6Yi/6YmL6YmQ6Yqc6YqW6YqT6Yqb6Yma6YuP6Yq56Yq36Yup6YyP6Yu66Y2E6YyuXCJdLFtcImU4NDBcIixcIumMmemMoumMmumMo+mMuumMtemMu+mNnOmNoOmNvOmNrumNlumOsOmOrOmOremOlOmOuemPlumPl+mPqOmPpemPmOmPg+mPnemPkOmPiOmPpOmQmumQlOmQk+mQg+mQh+mQkOmQtumQq+mQtemQoemQuumRgemRkumRhOmRm+mRoOmRoumRnumRqumIqemRsOmRtemRt+mRvemRmumRvOmRvumSgemRv+mWgumWh+mWiumWlOmWlumWmOmWmVwiXSxbXCJlODgwXCIsXCLplqDplqjplqfplq3plrzplrvplrnplr7pl4rmv7bpl4Ppl43pl4zpl5Xpl5Tpl5bpl5zpl6Hpl6Xpl6LpmKHpmKjpmK7pmK/pmYLpmYzpmY/pmYvpmbfpmZzpmZ7pmZ3pmZ/pmabpmbLpmazpmo3pmpjpmpXpmpfpmqrpmqfpmrHpmrLpmrDpmrTpmrbpmrjpmrnpm47pm4vpm4npm43opY3pm5zpnI3pm5Xpm7npnITpnIbpnIjpnJPpnI7pnJHpnI/pnJbpnJnpnKTpnKrpnLDpnLnpnL3pnL7pnYTpnYbpnYjpnYLpnYnpnZzpnaDpnaTpnabpnajli5LpnavpnbHpnbnpnoXpnbzpnoHpnbrpnobpnovpno/pnpDpnpzpnqjpnqbpnqPpnrPpnrTpn4Ppn4bpn4jpn4vpn5zpn63pvY/pn7Lnq5/pn7bpn7XpoI/poIzpoLjpoKTpoKHpoLfpoL3poYbpoY/poYvpoavpoa/pobBcIl0sW1wiZTk0MFwiLFwi6aGx6aG06aGz6aKq6aKv6aKx6aK26aOE6aOD6aOG6aOp6aOr6aSD6aSJ6aSS6aSU6aSY6aSh6aSd6aSe6aSk6aSg6aSs6aSu6aS96aS+6aWC6aWJ6aWF6aWQ6aWL6aWR6aWS6aWM6aWV6aaX6aaY6aal6aat6aau6aa86aef6aeb6aed6aeY6aeR6aet6aeu6aex6aey6ae76ae46aiB6aiP6aiF6aei6aiZ6air6ai36amF6amC6amA6amDXCJdLFtcImU5ODBcIixcIumovumplempjempm+mpl+mpn+mpoumppemppOmpqempq+mpqumqremqsOmqvOmrgOmrj+mrkemrk+mrlOmrnumrn+mroumro+mrpumrr+mrq+mrrumrtOmrsemrt+mru+mshumsmOmsmumsn+msoumso+mspemsp+msqOmsqemsqumsrumsr+mssumthOmtg+mtj+mtjemtjumtkemtmOmttOmuk+mug+mukemulumul+mun+muoOmuqOmutOmvgOmviumuuemvhumvj+mvkemvkumvo+mvoumvpOmvlOmvoemwuumvsumvsemvsOmwlemwlOmwiemwk+mwjOmwhumwiOmwkumwiumwhOmwrumwm+mwpemwpOmwoemwsOmxh+mwsumxhumwvumxmumxoOmxp+mxtumxuOmzp+mzrOmzsOm0iem0iOmzq+m0g+m0hum0qum0pum2r+m0o+m0n+m1hOm0lem0kum1gem0v+m0vum1hum1iFwiXSxbXCJlYTQwXCIsXCLptZ3ptZ7ptaTptZHptZDptZnptbLptonptofptqvpta/ptbrptprptqTptqnptrLpt4Tpt4Hptrvptrjptrrpt4bpt4/pt4Lpt5npt5Ppt7jpt6bpt63pt6/pt73puJrpuJvpuJ7pubXpubnpub3puoHpuojpuovpuozpupLpupXpupHpup3puqXpuqnpurjpuqrpuq3pnaHpu4zpu47pu4/pu5Dpu5Tpu5zpu57pu53pu6Dpu6Xpu6jpu69cIl0sW1wiZWE4MFwiLFwi6bu06bu26bu36bu56bu76bu86bu96byH6byI55q36byV6byh6bys6by+6b2K6b2S6b2U6b2j6b2f6b2g6b2h6b2m6b2n6b2s6b2q6b236b2y6b226b6V6b6c6b6g5aCv5qeH6YGZ55Gk5Yec54aZXCJdLFtcImVkNDBcIixcIue6iuiknOmNiOmKiOiTnOS/ieeCu+aYseajiOmLueabu+W9heS4qOS7oeS7vOS8gOS8g+S8ueS9luS+kuS+iuS+muS+lOS/jeWBgOWAouS/v+WAnuWBhuWBsOWBguWClOWDtOWDmOWFiuWFpOWGneWGvuWHrOWIleWKnOWKpuWLgOWLm+WMgOWMh+WMpOWNsuWOk+WOsuWPne+ojuWSnOWSiuWSqeWTv+WWhuWdmeWdpeWerOWfiOWfh++oj1wiXSxbXCJlZDgwXCIsXCLvqJDlop7lorLlpIvlpZPlpZvlpZ3lpaPlpqTlprrlrZblr4DnlK/lr5jlr6zlsJ7lsqblsrrls7XltKfltZPvqJHltYLlta3ltrjltrnlt5DlvKHlvLTlvaflvrflv57mgZ3mgoXmgormg57mg5XmhKDmg7LmhJHmhLfmhLDmhpjmiJPmiqbmj7XmkaDmkp3mk47mlY7mmIDmmJXmmLvmmInmmK7mmJ7mmKTmmaXmmZfmmZnvqJLmmbPmmpnmmqDmmrLmmr/mm7rmnI7vpKnmnabmnrvmoZLmn4DmoIHmoYTmo4/vqJPmpajvqJTmppjmp6LmqLDmqavmqYbmqbPmqb7mq6Lmq6Tmr5bmsL/msZzmsobmsa/ms5rmtITmtofmta/mtpbmtqzmt4/mt7jmt7Lmt7zmuLnmuZzmuKfmuLzmur/mvojmvrXmv7XngIXngIfngKjngoXngqvnhI/nhITnhZznhYbnhYfvqJXnh4Hnh77nirFcIl0sW1wiZWU0MFwiLFwi54q+54yk76iW5423546954+J54+W54+j54+S55CH54+155Cm55Cq55Cp55Cu55Gi55KJ55Kf55SB55Wv55qC55qc55qe55qb55qm76iX552G5Yqv56Ch56GO56Gk56G656Sw76iY76iZ76ia56aU76ib56ab56uR56un76ic56ur566e76id57WI57Wc57a357ag57eW57mS572H576h76ie6IyB6I2i6I2/6I+H6I+26JGI6JK06JWT6JWZXCJdLFtcImVlODBcIixcIuiVq++on+iWsO+ooO+ooeigh+ijteiokuiot+ipueiqp+iqvuirn++oouirtuitk+itv+izsOiztOi0kui1tu+oo+i7j++opO+opemBp+mDnu+opumElemEp+mHmumHl+mHnumHremHrumHpOmHpemIhumIkOmIiumIuumJgOmIvOmJjumJmemJkemIuemJp+mKp+mJt+mJuOmLp+mLl+mLmemLkO+op+mLlemLoOmLk+mMpemMoemLu++oqOmMnumLv+mMnemMgumNsOmNl+mOpOmPhumPnumPuOmQsemRhemRiOmWku+nnO+oqemanemar+mcs+mcu+mdg+mdjemdj+mdkemdlemhl+mhpe+oqu+oq+mkp++orOmmnumpjumrmemrnOmttemtsumuj+musemuu+mwgOm1sOm1q++orem4mem7kVwiXSxbXCJlZWVmXCIsXCLihbBcIiw5LFwi77+i77+k77yH77yCXCJdLFtcImYwNDBcIixcIu6AgFwiLDYyXSxbXCJmMDgwXCIsXCLugL9cIiwxMjRdLFtcImYxNDBcIixcIu6CvFwiLDYyXSxbXCJmMTgwXCIsXCLug7tcIiwxMjRdLFtcImYyNDBcIixcIu6FuFwiLDYyXSxbXCJmMjgwXCIsXCLuhrdcIiwxMjRdLFtcImYzNDBcIixcIu6ItFwiLDYyXSxbXCJmMzgwXCIsXCLuibNcIiwxMjRdLFtcImY0NDBcIixcIu6LsFwiLDYyXSxbXCJmNDgwXCIsXCLujK9cIiwxMjRdLFtcImY1NDBcIixcIu6OrFwiLDYyXSxbXCJmNTgwXCIsXCLuj6tcIiwxMjRdLFtcImY2NDBcIixcIu6RqFwiLDYyXSxbXCJmNjgwXCIsXCLukqdcIiwxMjRdLFtcImY3NDBcIixcIu6UpFwiLDYyXSxbXCJmNzgwXCIsXCLulaNcIiwxMjRdLFtcImY4NDBcIixcIu6XoFwiLDYyXSxbXCJmODgwXCIsXCLumJ9cIiwxMjRdLFtcImY5NDBcIixcIu6anFwiXSxbXCJmYTQwXCIsXCLihbBcIiw5LFwi4oWgXCIsOSxcIu+/ou+/pO+8h++8guOIseKEluKEoeKItee6iuiknOmNiOmKiOiTnOS/ieeCu+aYseajiOmLueabu+W9heS4qOS7oeS7vOS8gOS8g+S8ueS9luS+kuS+iuS+muS+lOS/jeWBgOWAouS/v+WAnuWBhuWBsOWBguWClOWDtOWDmOWFilwiXSxbXCJmYTgwXCIsXCLlhaTlhp3lhr7lh6zliJXlipzliqbli4Dli5vljIDljIfljKTljbLljpPljrLlj53vqI7lkpzlkorlkqnlk7/lloblnZnlnaXlnqzln4jln4fvqI/vqJDlop7lorLlpIvlpZPlpZvlpZ3lpaPlpqTlprrlrZblr4DnlK/lr5jlr6zlsJ7lsqblsrrls7XltKfltZPvqJHltYLlta3ltrjltrnlt5DlvKHlvLTlvaflvrflv57mgZ3mgoXmgormg57mg5XmhKDmg7LmhJHmhLfmhLDmhpjmiJPmiqbmj7XmkaDmkp3mk47mlY7mmIDmmJXmmLvmmInmmK7mmJ7mmKTmmaXmmZfmmZnvqJLmmbPmmpnmmqDmmrLmmr/mm7rmnI7vpKnmnabmnrvmoZLmn4DmoIHmoYTmo4/vqJPmpajvqJTmppjmp6LmqLDmqavmqYbmqbPmqb7mq6Lmq6Tmr5bmsL/msZzmsobmsa/ms5rmtITmtofmta9cIl0sW1wiZmI0MFwiLFwi5raW5ras5reP5re45rey5re85ri55rmc5rin5ri85rq/5r6I5r615r+154CF54CH54Co54KF54Kr54SP54SE54Wc54WG54WH76iV54eB54e+54qx54q+54yk76iW5423546954+J54+W54+j54+S55CH54+155Cm55Cq55Cp55Cu55Gi55KJ55Kf55SB55Wv55qC55qc55qe55qb55qm76iX552G5Yqv56Ch56GO56Gk56G656Sw76iY76iZXCJdLFtcImZiODBcIixcIu+omuemlO+om+emm+erkeerp++onOerq+eunu+onee1iOe1nOe2t+e2oOe3lue5kue9h+e+oe+onuiMgeiNouiNv+iPh+iPtuiRiOiStOiVk+iVmeiVq++on+iWsO+ooO+ooeigh+ijteiokuiot+ipueiqp+iqvuirn++oouirtuitk+itv+izsOiztOi0kui1tu+oo+i7j++opO+opemBp+mDnu+opumElemEp+mHmumHl+mHnumHremHrumHpOmHpemIhumIkOmIiumIuumJgOmIvOmJjumJmemJkemIuemJp+mKp+mJt+mJuOmLp+mLl+mLmemLkO+op+mLlemLoOmLk+mMpemMoemLu++oqOmMnumLv+mMnemMgumNsOmNl+mOpOmPhumPnumPuOmQsemRhemRiOmWku+nnO+oqemanemar+mcs+mcu+mdg+mdjemdj+mdkemdlemhl+mhpe+oqu+oq+mkp++orOmmnumpjumrmVwiXSxbXCJmYzQwXCIsXCLpq5zprbXprbLpro/prrHprrvpsIDptbDptavvqK3puJnpu5FcIl1dXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaWNvbnYtbGl0ZS9lbmNvZGluZ3MvdGFibGVzL3NoaWZ0amlzLmpzb25cbi8vIG1vZHVsZSBpZCA9IDEwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFtbXCIwXCIsXCJcXHUwMDAwXCIsMTI3XSxbXCI4ZWExXCIsXCLvvaFcIiw2Ml0sW1wiYTFhMVwiLFwi44CA44CB44CC77yM77yO44O777ya77yb77yf77yB44Kb44KcwrTvvYDCqO+8vu+/o++8v+ODveODvuOCneOCnuOAg+S7neOAheOAhuOAh+ODvOKAleKAkO+8j++8vO+9nuKIpe+9nOKApuKApeKAmOKAmeKAnOKAne+8iO+8ieOAlOOAle+8u++8ve+9m++9neOAiFwiLDksXCLvvIvvvI3CscOXw7fvvJ3iiaDvvJzvvJ7iiabiiafiiJ7iiLTimYLimYDCsOKAsuKAs+KEg++/pe+8hO+/oO+/oe+8he+8g++8hu+8iu+8oMKn4piG4piF4peL4peP4peO4peHXCJdLFtcImEyYTFcIixcIuKXhuKWoeKWoOKWs+KWsuKWveKWvOKAu+OAkuKGkuKGkOKGkeKGk+OAk1wiXSxbXCJhMmJhXCIsXCLiiIjiiIviiobiiofiioLiioPiiKriiKlcIl0sW1wiYTJjYVwiLFwi4oin4oio77+i4oeS4oeU4oiA4oiDXCJdLFtcImEyZGNcIixcIuKIoOKKpeKMkuKIguKIh+KJoeKJkuKJquKJq+KImuKIveKIneKIteKIq+KIrFwiXSxbXCJhMmYyXCIsXCLihKvigLDima/ima3imarigKDigKHCtlwiXSxbXCJhMmZlXCIsXCLil69cIl0sW1wiYTNiMFwiLFwi77yQXCIsOV0sW1wiYTNjMVwiLFwi77yhXCIsMjVdLFtcImEzZTFcIixcIu+9gVwiLDI1XSxbXCJhNGExXCIsXCLjgYFcIiw4Ml0sW1wiYTVhMVwiLFwi44KhXCIsODVdLFtcImE2YTFcIixcIs6RXCIsMTYsXCLOo1wiLDZdLFtcImE2YzFcIixcIs6xXCIsMTYsXCLPg1wiLDZdLFtcImE3YTFcIixcItCQXCIsNSxcItCB0JZcIiwyNV0sW1wiYTdkMVwiLFwi0LBcIiw1LFwi0ZHQtlwiLDI1XSxbXCJhOGExXCIsXCLilIDilILilIzilJDilJjilJTilJzilKzilKTilLTilLzilIHilIPilI/ilJPilJvilJfilKPilLPilKvilLvilYvilKDilK/ilKjilLfilL/ilJ3ilLDilKXilLjilYJcIl0sW1wiYWRhMVwiLFwi4pGgXCIsMTksXCLihaBcIiw5XSxbXCJhZGMwXCIsXCLjjYnjjJTjjKLjjY3jjJjjjKfjjIPjjLbjjZHjjZfjjI3jjKbjjKPjjKvjjYrjjLvjjpzjjp3jjp7jjo7jjo/jj4TjjqFcIl0sW1wiYWRkZlwiLFwi442744Cd44Cf4oSW44+N4oSh44qkXCIsNCxcIuOIseOIsuOIueONvuONveONvOKJkuKJoeKIq+KIruKIkeKImuKKpeKIoOKIn+KKv+KIteKIqeKIqlwiXSxbXCJiMGExXCIsXCLkupzllJblqIPpmL/lk4DmhJvmjKjlp7bpgKLokbXojJznqZDmgqrmj6HmuKXml63okaboiqbpr7XmopPlnKfmlqHmibHlrpvlp5Dombvpo7TntaLntr7pro7miJbnsp/oorflronlurXmjInmmpfmoYjpl4fpno3mnY/ku6XkvIrkvY3kvp3lgYnlm7LlpLflp5TlqIHlsInmg5/mhI/mhbDmmJPmpIXngrrnlY/nlbDnp7vntq3nt6/og4PokI7ooaPorILpgZXpgbrljLvkupXkuqXln5/ogrLpg4Hno6/kuIDlo7HmuqLpgLjnqLLojKjoiovpsK/lhYHljbDlkr3lk6Hlm6Dlp7vlvJXpo7Lmt6vog6TolK1cIl0sW1wiYjFhMVwiLFwi6Zmi6Zmw6Zqg6Z+75ZCL5Y+z5a6H54OP57696L+C6Zuo5Y2v6bWc56q65LiR56KT6Ie85rim5ZiY5ZSE5qyd6JSa6bC75ael5Y6p5rWm55Oc6ZaP5ZmC5LqR6YGL6Zuy6I2P6aSM5Y+h5Za25ayw5b2x5pig5puz5qCE5rC45rOz5rSp55Gb55uI56mO6aC06Iux6KGb6Kmg6Yut5ray55ar55uK6aeF5oKm6KyB6LaK6Zay5qaO5Y6t5YaG5ZyS5aCw5aWE5a605bu25oCo5o6p5o+05rK/5ryU54KO54SU54WZ54eV54y/57iB6Im26IuR6JaX6YGg6Ymb6bSb5aGp5pa85rGa55Sl5Ye55aSu5aWl5b6A5b+cXCJdLFtcImIyYTFcIixcIuaKvOaXuuaoquasp+autOeOi+e/geillum0rOm0jum7hOWyoeayluiNu+WEhOWxi+aGtuiHhuahtueJoeS5meS/uuWNuOaBqea4qeepj+mfs+S4i+WMluS7ruS9leS8veS+oeS9s+WKoOWPr+WYieWkj+WrgeWutuWvoeenkeaah+aenOaetuatjOays+eBq+ePguemjeemvueovOeuh+iKseiLm+iMhOiNt+iPr+iPk+idpuiqsuWYqeiyqOi/pumBjumcnuiaiuS/hOWzqOaIkeeJmeeUu+iHpeiKveibvuizgOmbhemkk+mnleS7i+S8muino+WbnuWhiuWjiuW7u+W/q+aAquaClOaBouaHkOaIkuaLkOaUuVwiXSxbXCJiM2ExXCIsXCLprYHmmabmorDmtbfngbDnlYznmobntbXoiqXon7nplovpmo7osp3lh7Hlir7lpJblkrPlrrPltJbmhajmpoLmtq/noo3ok4vooZfoqbLpjqfpqrjmtazppqjom5nlnqPmn7/om47piI7lioPlmoflkITlu5Pmi6HmkrnmoLzmoLjmrrvnjbLnorrnqavopprop5LotavovIPpg63plqPpmpTpnanlrablsrPmpb3poY3poY7mjpvnrKDmqKvmqb/morbpsI3mvZ/libLllp3mgbDmi6zmtLvmuIfmu5HokZvopJDovYTkuJTpsLnlj7bmpJvmqLrpnoTmoKrlhZznq4PokrLph5zpjozlmZvptKjmoKLojIXokLFcIl0sW1wiYjRhMVwiLFwi57Kl5YiI6IuF55Om5Lm+5L6D5Yag5a+S5YiK5YuY5Yun5be75Zaa5aCq5aem5a6M5a6Y5a+b5bmy5bm55oKj5oSf5oWj5oa+5o+b5pWi5p+R5qGT5qO65qy+5q2T5rGX5ryi5r6X5r2F55Kw55SY55uj55yL56u/566h57Ch57ep57y257+w6IKd6Imm6I6e6Kaz6KuM6LKr6YKE6ZGR6ZaT6ZaR6Zai6Zml6Z+T6aSo6IiY5Li45ZCr5bK45beM546p55mM55y85bKp57+r6LSL6ZuB6aCR6aGU6aGY5LyB5LyO5Y2x5Zac5Zmo5Z+65aWH5ayJ5a+E5bKQ5biM5bm+5b+M5o+u5py65peX5pei5pyf5qOL5qOEXCJdLFtcImI1YTFcIixcIuapn+W4sOavheawl+axveeVv+eliOWto+eogOe0gOW+veimj+iomOiytOi1t+i7jOi8nemjoumojumsvOS6gOWBveWEgOWmk+WunOaIr+aKgOaTrOasuueKoOeWkeelh+e+qeifu+iqvOitsOaOrOiPiumeoOWQieWQg+WWq+ahlOapmOipsOegp+adtem7jeWNtOWuouiEmuiZkOmAhuS4mOS5heS7h+S8keWPiuWQuOWuruW8k+aApeaVkeacveaxguaxsuazo+eBuOeQg+eptueqruesiOe0muezvue1puaXp+eJm+WOu+WxheW3qOaLkuaLoOaMmea4oOiZmuiosei3nemLuOa8geempumtmuS6qOS6q+S6rFwiXSxbXCJiNmExXCIsXCLkvpvkvqDlg5HlhYfnq7blhbHlh7bljZTljKHljb/lj6vllqzlooPls6HlvLflvYrmgK/mgZDmga3mjJ/mlZnmqYvms4Hni4Lni63nn6/og7johIXoiIjolY7pg7fpj6Hpn7/ppZfpqZrku7Dlh53lsK3mmoHmpa3lsYDmm7LmpbXnjonmoZDnsoHlg4Xli6TlnYflt77pjKbmlqTmrKPmrL3nkLTnpoHnpr3nrYvnt4roirnoj4zoob/opZ/orLnov5Hph5HlkJ/pioDkuZ3lgLblj6XljLrni5fnjpbnn6noi6bouq/pp4bpp4jpp5LlhbfmhJromZ7llrDnqbrlgbblr5PpgYfpmoXkuLLmq5vph6flsZHlsYhcIl0sW1wiYjdhMVwiLFwi5o6Y56qf5rKT6Z206L2h56qq54aK6ZqI57KC5qCX57mw5qGR6Y2s5Yuy5ZCb6Jar6KiT576k6LuN6YOh5Y2m6KKI56WB5L+C5YK+5YiR5YWE5ZWT5Zyt54+q5Z6L5aWR5b2i5b6E5oG15oW25oWn5oap5o6y5pC65pWs5pmv5qGC5riT55Wm56i957O757WM57aZ57mL572r6IyO6I2K6JuN6KiI6Kmj6K2m6Lu96aCa6baP6Iq46L+O6a+o5YqH5oif5pKD5r+A6ZqZ5qGB5YKR5qyg5rG65r2U56m057WQ6KGA6Kij5pyI5Lu25YC55YCm5YGl5YW85Yi45Ymj5Zan5ZyP5aCF5auM5bu65oay5oe45ouz5o2yXCJdLFtcImI4YTFcIixcIuaknOaoqeeJveeKrOeMrueglOehr+e1ueecjOiCqeimi+ismeizoui7kumBo+mNtemZuumhlemok+m5uOWFg+WOn+WOs+W5u+W8pua4m+a6kOeOhOePvue1g+iIt+iogOiruumZkOS5juWAi+WPpOWRvOWbuuWnkeWtpOW3seW6q+W8p+aIuOaVheaer+a5lueLkOeziuiitOiCoeiDoeiPsOiZjuiqh+i3qOmIt+mbh+mhp+m8k+S6lOS6kuS8jeWNiOWRieWQvuWor+W+jOW+oeaCn+aip+aqjueRmueigeiqnuiqpOitt+mGkOS5numvieS6pOS9vOS+r+WAmeWAluWFieWFrOWKn+WKueWLvuWOmuWPo+WQkVwiXSxbXCJiOWExXCIsXCLlkI7llonlnZHlnqLlpb3lrZTlrZ3lro/lt6Xlt6flt7flubjluoPluprlurflvJjmgZLmhYzmipfmi5jmjqfmlLvmmILmmYPmm7Tmna3moKHmopfmp4vmsZ/mtKrmtanmuK/mup3nlLLnmofnoaznqL/ns6DntIXntJjntZ7ntrHogJXogIPogq/ogrHohZToho/oiKrojZLooYzooaHorJvosqLos7zpg4rphbXpibHnoL/pi7zplqTpmY3poIXpppnpq5jptLvliZvliqvlj7flkIjlo5Xmi7fmv6DosarovZ/purnlhYvliLvlkYrlm73nqYDphbfptaDpu5LnjYTmvInohbDnlJHlv73mg5rpqqjni5vovrxcIl0sW1wiYmFhMVwiLFwi5q2k6aCD5LuK5Zuw5Z2k5aK+5ama5oGo5oeH5piP5piG5qC55qKx5re355eV57S66Imu6a2C5Lqb5L2Q5Y+J5ZSG5bWv5bem5beu5p+75rKZ55Gz56CC6KmQ6Y6W6KOf5Z2Q5bqn5oyr5YK15YKs5YaN5pyA5ZOJ5aGe5aa75a6w5b2p5omN5o6h5qC95q2z5riI54G96YeH54qA56CV56Cm56Wt5paO57Sw6I+c6KOB6LyJ6Zqb5Ymk5Zyo5p2Q572q6LKh5Ya05Z2C6Ziq5aC65qaK6IK05ZKy5bSO5Z+856KV6be65L2c5YmK5ZKL5pC+5pio5pyU5p+156qE562W57Si6Yyv5qGc6a6t56y55YyZ5YaK5Yi3XCJdLFtcImJiYTFcIixcIuWvn+aLtuaSruaTpuacreauuuiWqembkeeakOmvluaNjOmMhumuq+eav+aZkuS4ieWCmOWPguWxseaDqOaSkuaVo+ahn+eHpuePiueUo+eul+e6guialeiug+izm+mFuOmkkOaWrOaaq+aui+S7leS7lOS8uuS9v+WIuuWPuOWPsuWXo+Wbm+Wjq+Wni+WnieWnv+WtkOWxjeW4guW4q+W/l+aAneaMh+aUr+WtnOaWr+aWveaXqOaeneatouatu+awj+eNheelieengeezuOe0mee0q+iCouiEguiHs+imluipnuipqeippuiqjOirruizh+iznOmbjOmjvOatr+S6i+S8vOS+jeWFkOWtl+WvuuaFiOaMgeaZglwiXSxbXCJiY2ExXCIsXCLmrKHmu4vmsrvniL7nkr3nl5Tno4HnpLrogIzogLPoh6rokpTovp7msZDpub/lvI/orZjptKvnq7rou7jlro3pm6vkuIPlj7Hln7flpLHlq4nlrqTmgonmub/mvIbnlr7os6rlrp/olIDnr6DlgbLmn7Toip3lsaHolYrnuJ7oiI7lhpnlsITmjajotabmlpznha7npL7ntJfogIXorJ3ou4rpga7om4fpgqrlgJ/li7rlsLrmnZPngbzniLXphYzph4jpjKvoi6Xlr4LlvLHmg7nkuLvlj5blrojmiYvmnLHmrorni6nnj6DnqK7ohavotqPphZLpppblhJLlj5flkarlr7/mjojmqLnntqzpnIDlm5rlj47lkahcIl0sW1wiYmRhMVwiLFwi5a6X5bCx5bee5L+u5oSB5ou+5rSy56eA56eL57WC57mN57+S6Iet6Iif6JKQ6KGG6KWy6K6Q6Lm06Lyv6YCx6YWL6YWs6ZuG6Yac5LuA5L2P5YWF5Y2B5b6T5oiO5p+U5rGB5riL542j57im6YeN6YqD5Y+U5aSZ5a6/5reR56Wd57iu57Kb5aG+54af5Ye66KGT6L+w5L+K5bO75pil556s56uj6Iic6ae/5YeG5b6q5pes5qWv5q6J5rez5rqW5r2k55u+57SU5beh6YG16YaH6aCG5Yem5Yid5omA5pqR5puZ5ria5bq257eS572y5pu46Jav6Je36Ku45Yqp5Y+Z5aWz5bqP5b6Q5oGV6Yuk6Zmk5YK35YSfXCJdLFtcImJlYTFcIixcIuWLneWMoOWNh+WPrOWTqOWVhuWUseWYl+WlqOWmvuWovOWuteWwhuWwj+WwkeWwmuW6hOW6iuW7oOW9sOaJv+aKhOaLm+aOjOaNt+aYh+aYjOaYreaZtuadvuaiouaon+aoteayvOa2iOa4iea5mOeEvOeEpueFp+eXh+ecgeehneekgeelpeensOeroOeskeeyp+e0ueiCluiPluiSi+iVieihneijs+ion+iovOiplOips+ixoeiznumGpOmJpumNvumQmOmanOmemOS4iuS4iOS4nuS5l+WGl+WJsOWfjuWgtOWjjOWsouW4uOaDheaTvuadoeadlua1hOeKtueVs+epo+iSuOitsumGuOmMoOWYseWftOmjvlwiXSxbXCJiZmExXCIsXCLmi63mpI3mrpbnh63nuZTogbfoibLop6bpo5/onZXovrHlsLvkvLjkv6HkvrXllIflqKDlr53lr6nlv4PmhY7mjK/mlrDmmYvmo67mppvmtbjmt7HnlLPnlrnnnJ/npZ7np6bntLPoh6Poiq/olqropqroqLrouqvovpvpgLLph53pnIfkurrku4HliIPlobXlo6zlsIvnlJrlsL3ohY7oqIrov4XpmaPpna3nrKXoq4/poIjphaLlm7PljqjpgJflkLnlnoLluKXmjqjmsLTngornnaHnsovnv6DoobDpgYLphZTpjJDpjJjpmo/nkZ7pq4TltIfltanmlbDmnqLotqjpm5vmja7mnYnmpJnoj4XpoJfpm4Doo75cIl0sW1wiYzBhMVwiLFwi5r6E5pG65a+45LiW54Cs55Wd5piv5YeE5Yi25Yui5aeT5b6B5oCn5oiQ5pS/5pW05pif5pm05qOy5qCW5q2j5riF54my55Sf55ub57K+6IGW5aOw6KO96KW/6Kqg6KqT6KuL6YCd6YaS6Z2S6Z2Z5paJ56iO6ISG6Zq75bit5oOc5oia5pal5piU5p6Q55+z56mN57GN57i+6ISK6LKs6LWk6Leh6Lmf56Kp5YiH5ouZ5o6l5pGC5oqY6Kit56qD56+A6Kqs6Zuq57W26IiM6J2J5LuZ5YWI5Y2D5Y2g5a6j5bCC5bCW5bed5oim5omH5pKw5qCT5qC05rOJ5rWF5rSX5p+T5r2c54WO54W95peL56m/566t57eaXCJdLFtcImMxYTFcIixcIue5iue+qOiFuuiIm+iIueiWpuipruizjui3temBuOmBt+mKremKkemWg+muruWJjeWWhOa8uOeEtuWFqOemhee5leiGs+ezjuWZjOWhkeWyqOaOquabvuabvealmueLmeeWj+eWjuekjuelluenn+eyl+e0oOe1hOiYh+iotOmYu+mBoem8oOWDp+WJteWPjOWPouWAieWWquWjruWlj+eIveWui+WxpOWMneaDo+aDs+aNnOaOg+aMv+aOu+aTjeaXqeabueW3o+anjeanvea8leeHpeS6ieeXqeebuOeqk+ezn+e3j+e2nOiBoeiNieiNmOiRrOiSvOiXu+ijhei1sOmAgemBremOl+mcnOmokuWDj+Wil+aGjlwiXSxbXCJjMmExXCIsXCLoh5PolLXotIjpgKDkv4PlgbTliYfljbPmga/mjYnmnZ/muKzotrPpgJ/kv5flsZ7os4rml4/ntprljZLoopblhbbmj4PlrZjlravlsIrmkI3mnZHpgZzku5blpJrlpKrmsbDoqZHllL7loJXlpqXmg7DmiZPmn4HoiLXmpZXpmYDpp4TpqKjkvZPloIblr77ogJDlsrHluK/lvoXmgKDmhYvmiLTmm7/ms7Dmu57og47ohb/oi5TooovosrjpgIDpgK7pmorpu5vpr5vku6Plj7DlpKfnrKzpho3poYzpt7nmu53ngKfljZPllYTlroXmiZjmip7mi5PmsqLmv6/nkKLoqJfpkLjmv4Hoq77ojLjlh6fom7jlj6pcIl0sW1wiYzNhMVwiLFwi5Y+p5L2G6YGU6L6w5aWq6ISx5be956uq6L6/5qOa6LC354u46bGI5qi96Kqw5Li55Y2Y5ZiG5Z2m5ouF5o6i5pem5q2O5reh5rmb54Kt55+t56uv566q57a76IC96IOG6JuL6KqV6Y2b5Zuj5aOH5by+5pat5pqW5qqA5q6155S36KuH5YCk55+l5Zyw5byb5oGl5pm65rGg55e056ia572u6Ie06JyY6YGF6aaz56+J55Wc56u5562R6JOE6YCQ56ep56qS6Iy25auh552A5Lit5Luy5a6Z5b+g5oq95pi85p+x5rOo6Jmr6KG36Ki76YWO6Yuz6aeQ5qiX54Cm54yq6Iun6JGX6LKv5LiB5YWG5YeL5ZaL5a+1XCJdLFtcImM0YTFcIixcIuW4luW4s+W6geW8lOW8teW9q+W+tOaHsuaMkeaaouacnea9rueJkueUuuecuuiBtOiEueiFuOidtuiqv+irnOi2hei3s+mKmumVt+mggumzpeWLheaNl+ebtOacleayiOePjeizg+mOrumZs+a0peWinOakjuanjOi/vemOmueXm+mAmuWhmuagguaOtOanu+S9g+a8rOafmOi+u+iUpue2tOmNlOakv+a9sOWdquWjt+WsrOe0rOeIquWQiumHo+m2tOS6reS9juWBnOWBteWJg+iynuWRiOWgpOWumuW4neW6leW6reW7t+W8n+aCjOaKteaMuuaPkOair+axgOeih+emjueoi+e3oOiJh+ioguirpui5hOmAk1wiXSxbXCJjNWExXCIsXCLpgrjphK3ph5jpvI7ms6XmkZjmk6LmlbXmu7TnmoTnrJvpganpj5Hmurrlk7LlvrnmkqTovY3ov63piYTlhbjloavlpKnlsZXlupfmt7vnuo/nlJzosrzou6LpoZvngrnkvJ3mrr/mvrHnlLDpm7vlhY7lkJDloLXloZflpqzlsaDlvpLmlpfmnZzmuKHnmbvoj5/os63pgJTpg73pjY3noKXnoLrliqrluqblnJ/lpbTmgJLlgJLlhZrlhqzlh43liIDllJDloZTloZjlpZflrpXls7bltovmgrzmipXmkK3mnbHmoYPmorzmo5/nm5fmt5jmua/mtpvnga/nh4jlvZPnl5jnpbfnrYnnrZTnrZLns5bntbHliLBcIl0sW1wiYzZhMVwiLFwi6JGj6JWp6Jek6KiO6KyE6LGG6LiP6YCD6YCP6ZCZ6Zm26aCt6aiw6ZeY5YON5YuV5ZCM5aCC5bCO5oan5pKe5rSe556z56ul6IO06JCE6YGT6YqF5bOg6bSH5Yy/5b6X5b6z5rac54m5552j56a/56+k5q+S54us6Kqt5qCD5qmh5Ye456qB5qS05bGK6bO26Iur5a+F6YWJ54Ce5Zm45bGv5oOH5pWm5rKM6LGa6YGB6aCT5ZGR5puH6YiN5aWI6YKj5YaF5LmN5Yeq6JaZ6KyO54GY5o266Y2L5qWi6aa057iE55W35Y2X5qWg6Luf6Zuj5rGd5LqM5bC85byQ6L+p5YyC6LOR6IKJ6Jm55bu/5pel5Lmz5YWlXCJdLFtcImM3YTFcIixcIuWmguWwv+mfruS7u+WmiuW/jeiqjea/oeemsOelouWvp+iRseeMq+eGseW5tOW/teaNu+aSmueHg+eymOS5g+W7vOS5i+WfnOWaouaCqea/g+e0jeiDveiEs+iGv+i+suiml+iapOW3tOaKiuaSreimh+adt+azoua0vueQtuegtOWphue9teiKremmrOS/s+W7g+aLneaOkuaVl+adr+ebg+eJjOiDjOiCuui8qemFjeWAjeWfueWqkuaiheals+eFpOeLveiyt+WjsuizoOmZqumAmeidv+enpOefp+iQqeS8r+WJpeWNmuaLjeafj+aziueZveeulOeyleiItuiWhOi/q+abnea8oOeIhue4m+iOq+mngem6plwiXSxbXCJjOGExXCIsXCLlh73nrrHnobLnrrjogofnrYjmq6jluaHogoznlZHnlaDlhavpiaLmuoznmbrphpfpq6rkvJDnvbDmipznrY/plqXps6nlmbrloZnom6TpmrzkvLTliKTljYrlj43lj5vluIbmkKzmlpHmnb/msL7msY7niYjniq/nj63nlZTnuYHoiKzol6nosqnnr4Tph4bnhanpoJLpo6/mjL3mmannlarnm6Tno5DolYPom67ljKrljZHlkKblpoPluoflvbzmgrLmiYnmibnmiqvmlpDmr5Tms4znlrLnmq7nopHnp5jnt4vnvbfogqXooqvoqrnosrvpgb/pnZ7po5vmqIvnsLjlgpnlsL7lvq7mnofmr5jnkLXnnInnvo5cIl0sW1wiYzlhMVwiLFwi6by75p+K56iX5Yy555aL6aut5b2m6Iad6I+x6IKY5by85b+F55Wi562G6YC85qGn5aer5aqb57SQ55m+6Kys5L+15b2q5qiZ5rC35ryC55Oi56Wo6KGo6KmV6LG55buf5o+P55eF56eS6IuX6Yyo6Yuy6JKc6Jut6bCt5ZOB5b2s5paM5rWc54CV6LKn6LOT6aC75pWP55O25LiN5LuY5Z+g5aSr5amm5a+M5Yao5biD5bqc5oCW5om25pW35pan5pmu5rWu54i256ym6IWQ6Iaa6IqZ6K2c6LKg6LOm6LW06Zic6ZmE5L6u5pKr5q2m6Iie6JGh6JWq6YOo5bCB5qWT6aKo6JG66JWX5LyP5Ymv5b6p5bmF5pyNXCJdLFtcImNhYTFcIixcIuemj+iFueikh+imhua3teW8l+aJleayuOS7j+eJqemukuWIhuWQu+WZtOWis+aGpOaJrueEmuWlrueyieeznue0m+mbsOaWh+iBnuS4meS9teWFteWhgOW5o+W5s+W8iuafhOS4puiUvemWiemZm+exs+mggeWDu+WjgeeZlueip+WIpeeepeiUkeeuhuWBj+WkieeJh+evh+e3qOi+uui/lOmBjeS+v+WLieWoqeW8gemereS/neiIl+mLquWcg+aNleatqeeUq+ijnOi8lOepguWLn+Wik+aFleaIiuaaruavjeewv+iPqeWAo+S/uOWMheWRhuWgseWlieWuneWzsOWzr+W0qeW6luaKseaNp+aUvuaWueaci1wiXSxbXCJjYmExXCIsXCLms5Xms6Hng7nnoLLnuKvog57oirPokIzok6zonILopJLoqKrosYrpgqbpi5Lpo73ps7PptazkuY/kuqHlgo3liZblnYrlpqjluL3lv5jlv5nmiL/mmrTmnJvmn5Dmo5LlhpLntKHogqrohqjorIDosozosr/pib7pmLLlkKDpoKzljJflg5XljZzloqjmkrLmnLTniafnnabnqYbph6bli4PmsqHmrobloIDluYzlpZTmnKznv7vlh6Hnm4bmkanno6jprZTpurvln4vlprnmmKfmnprmr47lk6nmp5nluZXohpzmnpXprqrmn77psZLmoZ3kuqbkv6Plj4jmirnmnKvmsqvov4Tkvq3nua3pur/kuIfmhaLmuoBcIl0sW1wiY2NhMVwiLFwi5ryr6JST5ZGz5pyq6a2F5bez566V5bKs5a+G6Jyc5rmK6JOR56iU6ISI5aaZ57KN5rCR55yg5YuZ5aSi54Sh54mf55+b6Zyn6bWh5qSL5am/5aiY5Yal5ZCN5ZG95piO55uf6L+36YqY6bO05aeq54md5ruF5YWN5qOJ57a/57es6Z2i6bq65pG45qih6IyC5aaE5a2f5q+b54yb55uy57ay6ICX6JKZ5YSy5pyo6buZ55uu5p2i5Yu/6aSF5bCk5oi757G+6LKw5ZWP5oK257SL6ZaA5YyB5Lmf5Ya25aSc54i66IC26YeO5byl55+i5Y6E5b2557SE6Jas6Kiz6LqN6Z2W5p+z6Jau6ZGT5oSJ5oSI5rK555mSXCJdLFtcImNkYTFcIixcIuirrei8uOWUr+S9keWEquWLh+WPi+WupeW5veaCoOaGguaPluacieafmua5p+a2jOeMtueMt+eUseelkOijleiqmOmBiumCkemDtembhOiejeWkleS6iOS9meS4juiqiei8v+mgkOWCreW5vOWmluWuueW6uOaPmuaPuuaTgeabnOaliuanmOa0i+a6tueGlOeUqOeqr+e+iuiAgOiRieiTieimgeisoei4iumBpemZvemkiuaFvuaKkeassuayg+a1tOe/jOe/vOa3gOe+heieuuijuOadpeiOsemgvOmbt+a0m+e1oeiQvemFquS5seWNteW1kOashOa/q+iXjeiYreimp+WIqeWQj+WxpeadjuaiqOeQhueSg1wiXSxbXCJjZWExXCIsXCLnl6Loo4/oo6Hph4zpm6Lpmbjlvovnjofnq4vokY7mjqDnlaXlionmtYHmupznkInnlZnnoavnspLpmobnq5zpvo3kvrbmha7ml4XomZzkuobkuq7lg5rkuKHlh4zlr67mlpnmooHmtrznjJ/nmYLnnq3nqJzns6foia/oq5Lpgbzph4/pmbXpoJjlipvnt5HlgKvljpjmnpfmt4vnh5DnkLPoh6jovKrpmqPpsZfpup/nkaDloYHmtpnntK/poZ7ku6TkvLbkvovlhrflirHltrrmgJznjrLnpLzoi5PpiLTpmrfpm7bpnIrpupfpvaLmmqbmrbTliJfliqPng4joo4Llu4nmgYvmhpDmvKPnhYnnsL7nt7Toga9cIl0sW1wiY2ZhMVwiLFwi6JOu6YCj6Yys5ZGC6a2v5quT54KJ6LOC6Lev6Zyy5Yq05amB5buK5byE5pyX5qW85qaU5rWq5ryP54mi54u856+t6ICB6IG+6J2L6YOO5YWt6bqT56aE6IKL6Yyy6KuW5YCt5ZKM6Kmx5q2q6LOE6ISH5oOR5p6g6bey5LqZ5LqY6bCQ6Kmr6JeB6JWo5qSA5rm+56KX6IWVXCJdLFtcImQwYTFcIixcIuW8jOS4kOS4leS4quS4seS4tuS4vOS4v+S5guS5luS5mOS6guS6heixq+S6iuiIkuW8jeS6juS6nuS6n+S6oOS6ouS6sOS6s+S6tuS7juS7jeS7hOS7huS7guS7l+S7nuS7reS7n+S7t+S8ieS9muS8sOS9m+S9neS9l+S9h+S9tuS+iOS+j+S+mOS9u+S9qeS9sOS+keS9r+S+huS+luWEmOS/lOS/n+S/juS/mOS/m+S/keS/muS/kOS/pOS/peWAmuWAqOWAlOWAquWApeWAheS8nOS/tuWAoeWAqeWArOS/vuS/r+WAkeWAhuWBg+WBh+acg+WBleWBkOWBiOWBmuWBluWBrOWBuOWCgOWCmuWCheWCtOWCslwiXSxbXCJkMWExXCIsXCLlg4nlg4rlgrPlg4Llg5blg57lg6Xlg63lg6Plg67lg7nlg7XlhInlhIHlhILlhJblhJXlhJTlhJrlhKHlhLrlhLflhLzlhLvlhL/lhYDlhZLlhYzlhZTlhaLnq7jlhanlharlha7lhoDlhoLlm5jlhozlhonlho/lhpHlhpPlhpXlhpblhqTlhqblhqLlhqnlhqrlhqvlhrPlhrHlhrLlhrDlhrXlhr3lh4Xlh4nlh5vlh6DomZXlh6nlh63lh7Dlh7Xlh77liITliIvliJTliI7liKfliKrliK7liLPliLnliY/liYTliYvliYzliZ7liZTliarlibTlianlibPlib/lib3lio3lipTlipLlibHliojlipHovqhcIl0sW1wiZDJhMVwiLFwi6L6n5Yqs5Yqt5Yq85Yq15YuB5YuN5YuX5Yue5Yuj5Yum6aOt5Yug5Yuz5Yu15Yu45Yu55YyG5YyI55S45YyN5YyQ5YyP5YyV5Yya5Yyj5Yyv5Yyx5Yyz5Yy45Y2A5Y2G5Y2F5LiX5Y2J5Y2N5YeW5Y2e5Y2p5Y2u5aSY5Y275Y235Y6C5Y6W5Y6g5Y6m5Y6l5Y6u5Y6w5Y625Y+D57CS6ZuZ5Y+f5pu854eu5Y+u5Y+o5Y+t5Y+65ZCB5ZC95ZGA5ZCs5ZCt5ZC85ZCu5ZC25ZCp5ZCd5ZGO5ZKP5ZG15ZKO5ZGf5ZGx5ZG35ZGw5ZKS5ZG75ZKA5ZG25ZKE5ZKQ5ZKG5ZOH5ZKi5ZK45ZKl5ZKs5ZOE5ZOI5ZKoXCJdLFtcImQzYTFcIixcIuWSq+WTguWSpOWSvuWSvOWTmOWTpeWTpuWUj+WUlOWTveWTruWTreWTuuWTouWUueWVgOWVo+WVjOWUruWVnOWVheWVluWVl+WUuOWUs+WVneWWmeWWgOWSr+WWiuWWn+WVu+WVvuWWmOWWnuWWruWVvOWWg+WWqeWWh+WWqOWXmuWXheWXn+WXhOWXnOWXpOWXlOWYlOWXt+WYluWXvuWXveWYm+WXueWZjuWZkOeHn+WYtOWYtuWYsuWYuOWZq+WZpOWYr+WZrOWZquWahuWagOWaiuWaoOWalOWaj+WapeWaruWatuWatOWbguWavOWbgeWbg+WbgOWbiOWbjuWbkeWbk+Wbl+WbruWbueWcgOWbv+WchOWciVwiXSxbXCJkNGExXCIsXCLlnIjlnIvlnI3lnJPlnJjlnJbll4flnJzlnKblnLflnLjlnY7lnLvlnYDlnY/lnanln4DlnojlnaHlnb/lnonlnpPlnqDlnrPlnqTlnqrlnrDln4Pln4bln5Tln5Lln5PloIrln5bln6PloIvloJnloJ3lobLloKHloaLloYvlobDmr4DloZLloL3lobnlooXlornlop/loqvlorrlo57lorvlorjloq7lo4Xlo5Plo5Hlo5flo5nlo5jlo6Xlo5zlo6Tlo5/lo6/lo7rlo7nlo7vlo7zlo73lpILlpIrlpJDlpJvmoqblpKXlpKzlpK3lpLLlpLjlpL7nq5LlpZXlpZDlpY7lpZrlpZjlpaLlpaDlpaflpazlpalcIl0sW1wiZDVhMVwiLFwi5aW45aaB5aad5L2e5L6r5aaj5aay5aeG5aeo5aec5aaN5aeZ5aea5ail5aif5aiR5aic5aiJ5aia5amA5ams5amJ5ai15ai25ami5amq5aqa5aq85aq+5auL5auC5aq95auj5auX5aum5aup5auW5au65au75ayM5ayL5ayW5ayy5auQ5ayq5ay25ay+5a2D5a2F5a2A5a2R5a2V5a2a5a2b5a2l5a2p5a2w5a2z5a215a245paI5a265a6A5a6D5a6m5a645a+D5a+H5a+J5a+U5a+Q5a+k5a+m5a+i5a+e5a+l5a+r5a+w5a+25a+z5bCF5bCH5bCI5bCN5bCT5bCg5bCi5bCo5bC45bC55bGB5bGG5bGO5bGTXCJdLFtcImQ2YTFcIixcIuWxkOWxj+WtseWxrOWxruS5ouWxtuWxueWyjOWykeWylOWmm+Wyq+Wyu+WytuWyvOWyt+WzheWyvuWzh+WzmeWzqeWzveWzuuWzreW2jOWzquW0i+W0leW0l+W1nOW0n+W0m+W0keW0lOW0ouW0muW0meW0mOW1jOW1kuW1juW1i+W1rOW1s+W1tuW2h+W2hOW2guW2ouW2neW2rOW2ruW2veW2kOW2t+W2vOW3ieW3jeW3k+W3kuW3luW3m+W3q+W3suW3teW4i+W4muW4meW4keW4m+W4tuW4t+W5hOW5g+W5gOW5juW5l+W5lOW5n+W5ouW5pOW5h+W5teW5tuW5uum6vOW5v+W6oOW7geW7guW7iOW7kOW7j1wiXSxbXCJkN2ExXCIsXCLlu5blu6Plu53lu5rlu5vlu6Llu6Hlu6jlu6nlu6zlu7Hlu7Plu7Dlu7Tlu7jlu77lvIPlvInlvZ3lvZzlvIvlvJHlvJblvKnlvK3lvLjlvYHlvYjlvYzlvY7lvK/lvZHlvZblvZflvZnlvaHlva3lvbPlvbflvoPlvoLlvb/lvorlvojlvpHlvoflvp7lvpnlvpjlvqDlvqjlvq3lvrzlv5blv7vlv6Tlv7jlv7Hlv53mgrPlv7/mgKHmgaDmgJnmgJDmgKnmgI7mgLHmgJvmgJXmgKvmgKbmgI/mgLrmgZrmgYHmgarmgbfmgZ/mgYrmgYbmgY3mgaPmgYPmgaTmgYLmgazmgavmgZnmgoHmgo3mg6fmgoPmgppcIl0sW1wiZDhhMVwiLFwi5oKE5oKb5oKW5oKX5oKS5oKn5oKL5oOh5oK45oOg5oOT5oK05b+w5oK95oOG5oK15oOY5oWN5oSV5oSG5oO25oO35oSA5oO05oO65oSD5oSh5oO75oOx5oSN5oSO5oWH5oS+5oSo5oSn5oWK5oS/5oS85oSs5oS05oS95oWC5oWE5oWz5oW35oWY5oWZ5oWa5oWr5oW05oWv5oWl5oWx5oWf5oWd5oWT5oW15oaZ5oaW5oaH5oas5oaU5oaa5oaK5oaR5oar5oau5oeM5oeK5oeJ5oe35oeI5oeD5oeG5oa65oeL57255oeN5oem5oej5oe25oe65oe05oe/5oe95oe85oe+5oiA5oiI5oiJ5oiN5oiM5oiU5oibXCJdLFtcImQ5YTFcIixcIuaInuaIoeaIquaIruaIsOaIsuaIs+aJgeaJjuaJnuaJo+aJm+aJoOaJqOaJvOaKguaKieaJvuaKkuaKk+aKluaLlOaKg+aKlOaLl+aLkeaKu+aLj+aLv+aLhuaTlOaLiOaLnOaLjOaLiuaLguaLh+aKm+aLieaMjOaLruaLseaMp+aMguaMiOaLr+aLteaNkOaMvuaNjeaQnOaNj+aOluaOjuaOgOaOq+aNtuaOo+aOj+aOieaOn+aOteaNq+aNqeaOvuaPqeaPgOaPhuaPo+aPieaPkuaPtuaPhOaQluaQtOaQhuaQk+aQpuaQtuaUneaQl+aQqOaQj+aRp+aRr+aRtuaRjuaUquaSleaSk+aSpeaSqeaSiOaSvFwiXSxbXCJkYWExXCIsXCLmk5rmk5Lmk4Xmk4fmkrvmk5jmk4Lmk7Hmk6foiInmk6Dmk6Hmiqzmk6Pmk6/mlKzmk7bmk7Tmk7Lmk7rmlIDmk73mlJjmlJzmlIXmlKTmlKPmlKvmlLTmlLXmlLfmlLbmlLjnlYvmlYjmlZbmlZXmlY3mlZjmlZ7mlZ3mlbLmlbjmloLmloPorormlpvmlp/mlqvmlrfml4Pml4bml4Hml4Tml4zml5Lml5vml5nml6Dml6Hml7HmnbLmmIrmmIPml7vmnbPmmLXmmLbmmLTmmJzmmY/mmYTmmYnmmYHmmZ7mmZ3mmaTmmafmmajmmZ/mmaLmmbDmmoPmmojmmo7mmonmmoTmmpjmmp3mm4Hmmrnmm4nmmr7mmrxcIl0sW1wiZGJhMVwiLFwi5puE5pq45puW5pua5pug5pi/5pum5pup5puw5pu15pu35pyP5pyW5pye5pym5pyn6Zy45pyu5py/5py25p2B5py45py35p2G5p2e5p2g5p2Z5p2j5p2k5p6J5p2w5p6p5p285p2q5p6M5p6L5p6m5p6h5p6F5p635p+v5p605p+s5p6z5p+p5p645p+k5p+e5p+d5p+i5p+u5p655p+O5p+G5p+n5qqc5qCe5qGG5qCp5qGA5qGN5qCy5qGO5qKz5qCr5qGZ5qGj5qG35qG/5qKf5qKP5qKt5qKU5qKd5qKb5qKD5qqu5qK55qG05qK15qKg5qK65qSP5qKN5qG+5qSB5qOK5qSI5qOY5qSi5qSm5qOh5qSM5qONXCJdLFtcImRjYTFcIixcIuajlOajp+ajleaktuakkuakhOajl+ajo+akpeajueajoOajr+akqOakquakmuako+akoeajhualuealt+alnOaluOalq+allOalvualruakuealtOakvealmeaksOaloealnualneamgealquamsuamruankOamv+angeank+amvuanjuWvqOaniuanneamu+ang+amp+aoruamkeamoOamnOamleamtOannuanqOaoguaom+anv+asiuanueansuanp+aoheamseaonuanreaolOanq+aoiuaokuargeaoo+aok+aphOaojOapsuaotuapuOaph+apouapmeappuapiOaouOaoouaqkOaqjeaqoOaqhOaqouaqo1wiXSxbXCJkZGExXCIsXCLmqpfomJfmqrvmq4Pmq4LmqrjmqrPmqqzmq57mq5Hmq5/mqqrmq5rmq6rmq7vmrIXomJbmq7rmrJLmrJbprLHmrJ/mrLjmrLfnm5zmrLnpo67mrYfmrYPmrYnmrZDmrZnmrZTmrZvmrZ/mraHmrbjmrbnmrb/mroDmroTmroPmro3mrpjmrpXmrp7mrqTmrqrmrqvmrq/mrrLmrrHmrrPmrrfmrrzmr4bmr4vmr5Pmr5/mr6zmr6vmr7Pmr6/pur7msIjmsJPmsJTmsJvmsKTmsKPmsZ7msZXmsaLmsarmsoLmso3msprmsoHmspvmsb7msajmsbPmspLmspDms4Tms7Hms5Pmsr3ms5fms4Xms53msq7msrHmsr5cIl0sW1wiZGVhMVwiLFwi5rK65rOb5rOv5rOZ5rOq5rSf6KGN5rS25rSr5rS95rS45rSZ5rS15rSz5rSS5rSM5rWj5raT5rWk5rWa5rW55rWZ5raO5raV5r+k5raF5re55riV5riK5ra15reH5rem5ra45reG5res5ree5reM5reo5reS5reF5re65reZ5rek5reV5req5reu5rit5rmu5riu5riZ5rmy5rmf5ri+5rij5rmr5rir5rm25rmN5rif5rmD5ri65rmO5rik5ru/5rid5ri45rqC5rqq5rqY5ruJ5rq35ruT5rq95rqv5ruE5rqy5ruU5ruV5rqP5rql5ruC5rqf5r2B5ryR54GM5rus5ru45ru+5ry/5ruy5ryx5ruv5ryy5ruMXCJdLFtcImRmYTFcIixcIua8vua8k+a7t+a+hua9uua9uOa+gea+gOa9r+a9m+a/s+a9rea+gua9vOa9mOa+jua+kea/gua9pua+s+a+o+a+oea+pOa+uea/hua+qua/n+a/lea/rOa/lOa/mOa/sea/rua/m+eAieeAi+a/uueAkeeAgeeAj+a/vueAm+eAmua9tOeAneeAmOeAn+eAsOeAvueAsueBkeeBo+eCmeeCkueCr+eDseeCrOeCuOeCs+eCrueDn+eDi+eDneeDmeeEieeDveeEnOeEmeeFpeeFleeGiOeFpueFoueFjOeFlueFrOeGj+eHu+eGhOeGleeGqOeGrOeHl+eGueeGvueHkueHieeHlOeHjueHoOeHrOeHp+eHteeHvFwiXSxbXCJlMGExXCIsXCLnh7nnh7/niI3niJDniJvniKjniK3niKzniLDniLLniLvniLzniL/niYDniYbniYvniZjnibTnib7nioLnioHniofnipLnipbniqLniqfnirnnirLni4Pni4bni4Tni47ni5Lni6Lni6Dni6Hni7nni7flgI/njJfnjIrnjJznjJbnjJ3njLTnjK/njKnnjKXnjL7njY7njY/pu5jnjZfnjarnjajnjbDnjbjnjbXnjbvnjbrnj4jnjrPnj47njrvnj4Dnj6Xnj67nj57nkqLnkIXnka/nkKXnj7jnkLLnkLrnkZXnkL/nkZ/nkZnnkYHnkZznkannkbDnkaPnkarnkbbnkb7nkovnkp7nkqfnk4rnk4/nk5Tnj7FcIl0sW1wiZTFhMVwiLFwi55Og55Oj55On55Op55Ou55Oy55Ow55Ox55O455O355SE55SD55SF55SM55SO55SN55SV55ST55Se55Sm55Ss55S855WE55WN55WK55WJ55Wb55WG55Wa55Wp55Wk55Wn55Wr55Wt55W455W255aG55aH55W055aK55aJ55aC55aU55aa55ad55al55aj55eC55az55eD55a155a955a455a855ax55eN55eK55eS55eZ55ej55ee55e+55e/55e855iB55ew55e655ey55ez55iL55iN55iJ55if55in55ig55ih55ii55ik55i055iw55i755mH55mI55mG55mc55mY55mh55mi55mo55mp55mq55mn55ms55mwXCJdLFtcImUyYTFcIixcIueZsueZtueZuOeZvOeagOeag+eaiOeai+eajuealueak+eameeamueasOeatOeauOeaueeauuebguebjeebluebkuebnueboeebpeebp+ebquiYr+ebu+eciOech+echOecqeecpOecnuecpeecpuecm+ect+ecuOedh+edmuedqOedq+edm+edpeedv+edvuedueeejueei+eekeeeoOeenueesOeetueeueeev+eevOeeveeeu+efh+efjeefl+efmuefnOefo+efruefvOegjOegkuekpuegoOekquehheeijuehtOeihuehvOeimueijOeio+eiteeiqueir+ejkeejhueji+ejlOeivueivOejheejiuejrFwiXSxbXCJlM2ExXCIsXCLno6fno5rno73no7TnpIfnpJLnpJHnpJnnpKznpKvnpYDnpaDnpZfnpZ/npZrnpZXnpZPnpbrnpb/npornpp3npqfpvYvnpqrnpq7nprPnprnnprrnp4nnp5Xnp6fnp6znp6Hnp6PnqIjnqI3nqJjnqJnnqKDnqJ/npoDnqLHnqLvnqL7nqLfnqYPnqZfnqYnnqaHnqaLnqanpvp3nqbDnqbnnqb3nqojnqpfnqpXnqpjnqpbnqqnnq4jnqrDnqrbnq4Xnq4Tnqr/pgoPnq4fnq4rnq43nq4/nq5Xnq5Pnq5nnq5rnq53nq6Hnq6Lnq6bnq63nq7DnrILnrI/nrIrnrIbnrLPnrJjnrJnnrJ7nrLXnrKjnrLbnrZBcIl0sW1wiZTRhMVwiLFwi562656yE562N56yL562M562F5621562l5620562n562w562x562s562u566d566Y566f566N566c566a566L566S566P562d566Z56+L56+B56+M56+P566056+G56+d56+p57CR57CU56+m56+l57Gg57CA57CH57CT56+z56+357CX57CN56+257Cj57Cn57Cq57Cf57C357Cr57C957GM57GD57GU57GP57GA57GQ57GY57Gf57Gk57GW57Gl57Gs57G157KD57KQ57Kk57Kt57Ki57Kr57Kh57Ko57Kz57Ky57Kx57Ku57K557K957OA57OF57OC57OY57OS57Oc57Oi6ay757Ov57Oy57O057O257O657SGXCJdLFtcImU1YTFcIixcIue0gue0nOe0lee0iue1hee1i+e0rue0sue0v+e0tee1hue1s+e1lue1jue1sue1qOe1rue1j+e1o+e2k+e2iee1m+e2j+e1vee2m+e2uue2rue2o+e2tee3h+e2vee2q+e4vee2oue2r+e3nOe2uOe2n+e2sOe3mOe3nee3pOe3nue3u+e3sue3oee4hee4iue4o+e4oee4kue4see4n+e4iee4i+e4oue5hue5pue4u+e4tee4uee5g+e4t+e4sue4uue5p+e5nee5lue5nue5mee5mue5uee5que5qee5vOe5u+e6g+e3lee5vei+rue5v+e6iOe6iee6jOe6kue6kOe6k+e6lOe6lue6jue6m+e6nOe8uOe8ulwiXSxbXCJlNmExXCIsXCLnvYXnvYznvY3nvY7nvZDnvZHnvZXnvZTnvZjnvZ/nvaDnvajnvannvafnvbjnvoLnvobnvoPnvojnvofnvoznvpTnvp7nvp3nvprnvqPnvq/nvrLnvrnnvq7nvrbnvrjorbHnv4Xnv4bnv4rnv5Xnv5Tnv6Hnv6bnv6nnv7Pnv7npo5zogIbogITogIvogJLogJjogJnogJzogKHogKjogL/ogLvogYrogYbogZLogZjogZrogZ/ogaLogajogbPogbLogbDogbbogbnogb3ogb/ogoTogobogoXogpvogpPogprogq3lhpDogqzog5vog6Xog5nog53og4Tog5rog5bohInog6/og7HohJvohKnohKPohK/ohYtcIl0sW1wiZTdhMVwiLFwi6ZqL6IWG6IS+6IWT6IWR6IO86IWx6IWu6IWl6IWm6IW06IaD6IaI6IaK6IaA6IaC6Iag6IaV6Iak6Iaj6IWf6IaT6Iap6Iaw6Ia16Ia+6Ia46Ia96IeA6IeC6Ia66IeJ6IeN6IeR6IeZ6IeY6IeI6Iea6Ief6Ieg6Ien6Ie66Ie76Ie+6IiB6IiC6IiF6IiH6IiK6IiN6IiQ6IiW6Iip6Iir6Ii46Iiz6ImA6ImZ6ImY6Imd6Ima6Imf6Imk6Imi6Imo6Imq6Imr6Iiu6Imx6Im36Im46Im+6IqN6IqS6Iqr6Iqf6Iq76Iqs6Iuh6Iuj6Iuf6IuS6Iu06Iuz6Iu66I6T6IyD6Iu76Iu56Iue6IyG6Iuc6IyJ6IuZXCJdLFtcImU4YTFcIixcIuiMteiMtOiMluiMsuiMseiNgOiMueiNkOiNheiMr+iMq+iMl+iMmOiOheiOmuiOquiOn+iOouiOluiMo+iOjuiOh+iOiuiNvOiOteiNs+iNteiOoOiOieiOqOiPtOiQk+iPq+iPjuiPveiQg+iPmOiQi+iPgeiPt+iQh+iPoOiPsuiQjeiQouiQoOiOveiQuOiUhuiPu+iRreiQquiQvOiVmuiShOiRt+iRq+iSreiRruiSguiRqeiRhuiQrOiRr+iRueiQteiTiuiRouiSueiSv+iSn+iTmeiTjeiSu+iTmuiTkOiTgeiThuiTluiSoeiUoeiTv+iTtOiUl+iUmOiUrOiUn+iUleiUlOiTvOiVgOiVo+iVmOiViFwiXSxbXCJlOWExXCIsXCLolYHomILolYvolZXoloDolqTolojolpHolorolqjola3olpTolpvol6rolofolpzolbfolb7olpDol4nolrrol4/olrnol5Dol5Xol53ol6Xol5zol7nomIromJPomIvol77ol7romIbomKLomJromLDomL/omY3kuZXomZTomZ/omafombHompPomqPomqnomqromovomozomrbomq/om4Tom4bomrDom4nooKPomqvom5Tom57om6nom6zom5/om5vom6/onJLonIbonIjonIDonIPom7vonJHonInonI3om7nonIronLTonL/onLfonLvonKXonKnonJronaDonZ/onbjonYzonY7onbTonZfonajona7onZlcIl0sW1wiZWFhMVwiLFwi6J2T6J2j6J2q6KCF6J6i6J6f6J6C6J6v6J+L6J696J+A6J+Q6ZuW6J6r6J+E6J6z6J+H6J+G6J676J+v6J+y6J+g6KCP6KCN6J++6J+26J+36KCO6J+S6KCR6KCW6KCV6KCi6KCh6KCx6KC26KC56KCn6KC76KGE6KGC6KGS6KGZ6KGe6KGi6KGr6KKB6KG+6KKe6KG16KG96KK16KGy6KKC6KKX6KKS6KKu6KKZ6KKi6KKN6KKk6KKw6KK/6KKx6KOD6KOE6KOU6KOY6KOZ6KOd6KO56KSC6KO86KO06KOo6KOy6KSE6KSM6KSK6KST6KWD6KSe6KSl6KSq6KSr6KWB6KWE6KS76KS26KS46KWM6KSd6KWg6KWeXCJdLFtcImViYTFcIixcIuilpuilpOilreilquilr+iltOilt+ilvuimg+imiOimiuimk+immOimoeimqeimpuimrOimr+imsuimuuimveimv+ingOinmuinnOinneinp+intOinuOiog+ioluiokOiojOiom+ioneiopeiotuipgeipm+ipkuiphuipiOipvOipreiprOipouiqheiqguiqhOiqqOiqoeiqkeiqpeiqpuiqmuiqo+irhOirjeirguirmuirq+irs+irp+irpOirseislOiroOirouirt+irnuirm+isjOish+ismuiroeisluiskOisl+isoOiss+meq+ispuisq+isvuisqOitgeitjOitj+itjuitieitluitm+itmuitq1wiXSxbXCJlY2ExXCIsXCLorZ/orazora/orbTorb3oroDorozoro7orpLorpPorpborpnorprosLrosYHosL/osYjosYzosY7osZDosZXosaLosazosbjosbrosoLosonosoXosoroso3oso7ospTosbzospjmiJ3osq3osqrosr3osrLosrPosq7osrbos4jos4Hos6Tos6Pos5ros73os7ros7votITotIXotIrotIfotI/otI3otJDpvY7otJPos43otJTotJbotafota3otbHotbPotoHotpnot4Lotr7otrrot4/ot5rot5bot4zot5vot4vot6rot6vot5/ot6Pot7zouIjouInot7/ouJ3ouJ7ouJDouJ/ouYLouLXouLDouLTouYpcIl0sW1wiZWRhMVwiLFwi6LmH6LmJ6LmM6LmQ6LmI6LmZ6Lmk6Lmg6Liq6Lmj6LmV6Lm26Lmy6Lm86LqB6LqH6LqF6LqE6LqL6LqK6LqT6LqR6LqU6LqZ6Lqq6Lqh6Lqs6Lqw6LuG6Lqx6Lq+6LuF6LuI6LuL6Lub6Luj6Lu86Lu76Lur6Lu+6LyK6LyF6LyV6LyS6LyZ6LyT6Lyc6Lyf6Lyb6LyM6Lym6Lyz6Ly76Ly56L2F6L2C6Ly+6L2M6L2J6L2G6L2O6L2X6L2c6L2i6L2j6L2k6L6c6L6f6L6j6L6t6L6v6L636L+a6L+l6L+i6L+q6L+v6YKH6L+06YCF6L+56L+66YCR6YCV6YCh6YCN6YCe6YCW6YCL6YCn6YC26YC16YC56L+4XCJdLFtcImVlYTFcIixcIumBj+mBkOmBkemBkumAjumBiemAvumBlumBmOmBnumBqOmBr+mBtumaqOmBsumCgumBvemCgemCgOmCiumCiemCj+mCqOmCr+mCsemCtemDoumDpOaJiOmDm+mEgumEkumEmemEsumEsOmFiumFlumFmOmFo+mFpemFqemFs+mFsumGi+mGiemGgumGoumGq+mGr+mGqumGtemGtOmGuumHgOmHgemHiemHi+mHkOmHlumHn+mHoemHm+mHvOmHtemHtumInumHv+mIlOmIrOmIlemIkemJnumJl+mJhemJiemJpOmJiOmKlemIv+mJi+mJkOmKnOmKlumKk+mKm+mJmumLj+mKuemKt+mLqemMj+mLuumNhOmMrlwiXSxbXCJlZmExXCIsXCLpjJnpjKLpjJrpjKPpjLrpjLXpjLvpjZzpjaDpjbzpja7pjZbpjrDpjqzpjq3pjpTpjrnpj5bpj5fpj6jpj6Xpj5jpj4Ppj53pj5Dpj4jpj6TpkJrpkJTpkJPpkIPpkIfpkJDpkLbpkKvpkLXpkKHpkLrpkYHpkZLpkYTpkZvpkaDpkaLpkZ7pkarpiKnpkbDpkbXpkbfpkb3pkZrpkbzpkb7pkoHpkb/ploLplofplorplpTplpbplpjplpnplqDplqjplqfplq3plrzplrvplrnplr7pl4rmv7bpl4Ppl43pl4zpl5Xpl5Tpl5bpl5zpl6Hpl6Xpl6LpmKHpmKjpmK7pmK/pmYLpmYzpmY/pmYvpmbfpmZzpmZ5cIl0sW1wiZjBhMVwiLFwi6Zmd6Zmf6Zmm6Zmy6Zms6ZqN6ZqY6ZqV6ZqX6Zqq6Zqn6Zqx6Zqy6Zqw6Zq06Zq26Zq46Zq56ZuO6ZuL6ZuJ6ZuN6KWN6Zuc6ZyN6ZuV6Zu56ZyE6ZyG6ZyI6ZyT6ZyO6ZyR6ZyP6ZyW6ZyZ6Zyk6Zyq6Zyw6Zy56Zy96Zy+6Z2E6Z2G6Z2I6Z2C6Z2J6Z2c6Z2g6Z2k6Z2m6Z2o5YuS6Z2r6Z2x6Z256Z6F6Z286Z6B6Z266Z6G6Z6L6Z6P6Z6Q6Z6c6Z6o6Z6m6Z6j6Z6z6Z606Z+D6Z+G6Z+I6Z+L6Z+c6Z+t6b2P6Z+y56uf6Z+26Z+16aCP6aCM6aC46aCk6aCh6aC36aC96aGG6aGP6aGL6aGr6aGv6aGwXCJdLFtcImYxYTFcIixcIumhsemhtOmhs+miqumir+misemitumjhOmjg+mjhumjqemjq+mkg+mkiemkkumklOmkmOmkoemknemknumkpOmkoOmkrOmkrumkvemkvumlgumliemlhemlkOmli+mlkemlkumljOmllemml+mmmOmmpemmremmrummvOmnn+mnm+mnnemnmOmnkemnremnrumnsemnsumnu+mnuOmogemoj+mohemnoumomemoq+mot+mphempgumpgOmpg+movumplempjempm+mpl+mpn+mpoumppemppOmpqempq+mpqumqremqsOmqvOmrgOmrj+mrkemrk+mrlOmrnumrn+mroumro+mrpumrr+mrq+mrrumrtOmrsemrt1wiXSxbXCJmMmExXCIsXCLpq7vprIbprJjprJrprJ/prKLprKPprKXprKfprKjprKnprKrprK7prK/prLLprYTprYPprY/prY3prY7prZHprZjprbTprpPproPprpHprpbprpfprp/prqDprqjprrTpr4Dpr4rprrnpr4bpr4/pr5Hpr5Lpr6Ppr6Lpr6Tpr5Tpr6HpsLrpr7Lpr7Hpr7DpsJXpsJTpsInpsJPpsIzpsIbpsIjpsJLpsIrpsITpsK7psJvpsKXpsKTpsKHpsLDpsYfpsLLpsYbpsL7psZrpsaDpsafpsbbpsbjps6fps6zps7DptInptIjps6vptIPptIbptKrptKbptq/ptKPptJ/ptYTptJXptJLptYHptL/ptL7ptYbptYhcIl0sW1wiZjNhMVwiLFwi6bWd6bWe6bWk6bWR6bWQ6bWZ6bWy6baJ6baH6bar6bWv6bW66baa6bak6bap6bay6beE6beB6ba76ba46ba66beG6beP6beC6beZ6beT6be46bem6bet6bev6be96bia6bib6bie6bm16bm56bm96bqB6bqI6bqL6bqM6bqS6bqV6bqR6bqd6bql6bqp6bq46bqq6bqt6Z2h6buM6buO6buP6buQ6buU6buc6bue6bud6bug6bul6buo6buv6bu06bu26bu36bu56bu76bu86bu96byH6byI55q36byV6byh6bys6by+6b2K6b2S6b2U6b2j6b2f6b2g6b2h6b2m6b2n6b2s6b2q6b236b2y6b226b6V6b6c6b6gXCJdLFtcImY0YTFcIixcIuWgr+anh+mBmeeRpOWHnOeGmVwiXSxbXCJmOWExXCIsXCLnuoropJzpjYjpiojok5zkv4nngrvmmLHmo4jpi7nmm7vlvYXkuKjku6Hku7zkvIDkvIPkvLnkvZbkvpLkvorkvprkvpTkv43lgYDlgKLkv7/lgJ7lgYblgbDlgYLlgpTlg7Tlg5jlhYrlhaTlhp3lhr7lh6zliJXlipzliqbli4Dli5vljIDljIfljKTljbLljpPljrLlj53vqI7lkpzlkorlkqnlk7/lloblnZnlnaXlnqzln4jln4fvqI/vqJDlop7lorLlpIvlpZPlpZvlpZ3lpaPlpqTlprrlrZblr4DnlK/lr5jlr6zlsJ7lsqblsrrls7XltKfltZPvqJHltYLlta3ltrjltrnlt5DlvKHlvLTlvaflvrdcIl0sW1wiZmFhMVwiLFwi5b+e5oGd5oKF5oKK5oOe5oOV5oSg5oOy5oSR5oS35oSw5oaY5oiT5oqm5o+15pGg5pKd5pOO5pWO5piA5piV5pi75piJ5piu5pie5pik5pml5pmX5pmZ76iS5pmz5pqZ5pqg5pqy5pq/5pu65pyO76Sp5p2m5p675qGS5p+A5qCB5qGE5qOP76iT5qWo76iU5qaY5qei5qiw5qmr5qmG5qmz5qm+5qui5quk5q+W5rC/5rGc5rKG5rGv5rOa5rSE5raH5rWv5raW5ras5reP5re45rey5re85ri55rmc5rin5ri85rq/5r6I5r615r+154CF54CH54Co54KF54Kr54SP54SE54Wc54WG54WH76iV54eB54e+54qxXCJdLFtcImZiYTFcIixcIueKvueMpO+olueNt+eOveePieePluePo+ePkueQh+ePteeQpueQqueQqeeQrueRoueSieeSn+eUgeeVr+eagueanOeanueam+eapu+ol+edhuWKr+egoeehjuehpOehuueksO+omO+ome+omuemlO+om+emm+erkeerp++onOerq+eunu+onee1iOe1nOe2t+e2oOe3lue5kue9h+e+oe+onuiMgeiNouiNv+iPh+iPtuiRiOiStOiVk+iVmeiVq++on+iWsO+ooO+ooeigh+ijteiokuiot+ipueiqp+iqvuirn++oouirtuitk+itv+izsOiztOi0kui1tu+oo+i7j++opO+opemBp+mDnu+opumElemEp+mHmlwiXSxbXCJmY2ExXCIsXCLph5fph57ph63ph67ph6Tph6XpiIbpiJDpiIrpiLrpiYDpiLzpiY7piZnpiZHpiLnpiafpiqfpibfpibjpi6fpi5fpi5npi5DvqKfpi5Xpi6Dpi5PpjKXpjKHpi7vvqKjpjJ7pi7/pjJ3pjILpjbDpjZfpjqTpj4bpj57pj7jpkLHpkYXpkYjplpLvp5zvqKnpmp3pmq/pnLPpnLvpnYPpnY3pnY/pnZHpnZXpoZfpoaXvqKrvqKvppKfvqKzppp7pqY7pq5npq5zprbXprbLpro/prrHprrvpsIDptbDptavvqK3puJnpu5FcIl0sW1wiZmNmMVwiLFwi4oWwXCIsOSxcIu+/ou+/pO+8h++8glwiXSxbXCI4ZmEyYWZcIixcIsuYy4fCuMuZy53Cr8uby5rvvZ7OhM6FXCJdLFtcIjhmYTJjMlwiLFwiwqHCpsK/XCJdLFtcIjhmYTJlYlwiLFwiwrrCqsKpwq7ihKLCpOKEllwiXSxbXCI4ZmE2ZTFcIixcIs6GzojOic6KzqpcIl0sW1wiOGZhNmU3XCIsXCLOjFwiXSxbXCI4ZmE2ZTlcIixcIs6OzqtcIl0sW1wiOGZhNmVjXCIsXCLOj1wiXSxbXCI4ZmE2ZjFcIixcIs6szq3Ors6vz4rOkM+Mz4LPjc+LzrDPjlwiXSxbXCI4ZmE3YzJcIixcItCCXCIsMTAsXCLQjtCPXCJdLFtcIjhmYTdmMlwiLFwi0ZJcIiwxMCxcItGe0Z9cIl0sW1wiOGZhOWExXCIsXCLDhsSQXCJdLFtcIjhmYTlhNFwiLFwixKZcIl0sW1wiOGZhOWE2XCIsXCLEslwiXSxbXCI4ZmE5YThcIixcIsWBxL9cIl0sW1wiOGZhOWFiXCIsXCLFisOYxZJcIl0sW1wiOGZhOWFmXCIsXCLFpsOeXCJdLFtcIjhmYTljMVwiLFwiw6bEkcOwxKfEscSzxLjFgsWAxYnFi8O4xZPDn8Wnw75cIl0sW1wiOGZhYWExXCIsXCLDgcOAw4TDgsSCx43EgMSEw4XDg8SGxIjEjMOHxIrEjsOJw4jDi8OKxJrElsSSxJhcIl0sW1wiOGZhYWJhXCIsXCLEnMSexKLEoMSkw43DjMOPw47Hj8SwxKrErsSoxLTEtsS5xL3Eu8WDxYfFhcORw5PDksOWw5THkcWQxYzDlcWUxZjFlsWaxZzFoMWexaTFosOaw5nDnMObxazHk8WwxarFssWuxajHl8ebx5nHlcW0w53FuMW2xbnFvcW7XCJdLFtcIjhmYWJhMVwiLFwiw6HDoMOkw6LEg8eOxIHEhcOlw6PEh8SJxI3Dp8SLxI/DqcOow6vDqsSbxJfEk8SZx7XEncSfXCJdLFtcIjhmYWJiZFwiLFwixKHEpcOtw6zDr8Oux5BcIl0sW1wiOGZhYmM1XCIsXCLEq8SvxKnEtcS3xLrEvsS8xYTFiMWGw7HDs8Oyw7bDtMeSxZHFjcO1xZXFmcWXxZvFncWhxZ/FpcWjw7rDucO8w7vFrceUxbHFq8Wzxa/FqceYx5zHmseWxbXDvcO/xbfFusW+xbxcIl0sW1wiOGZiMGExXCIsXCLkuILkuITkuIXkuIzkuJLkuJ/kuKPkuKTkuKjkuKvkuK7kuK/kuLDkuLXkuYDkuYHkuYTkuYfkuZHkuZrkuZzkuaPkuajkuankubTkubXkubnkub/kuo3kupbkupfkup3kuq/kurnku4Pku5Dku5rku5vku6Dku6Hku6Lku6jku6/ku7Hku7Pku7Xku73ku77ku7/kvIDkvILkvIPkvIjkvIvkvIzkvJLkvJXkvJbkvJfkvJnkvK7kvLHkvaDkvLPkvLXkvLfkvLnkvLvkvL7kvYDkvYLkvYjkvYnkvYvkvYzkvZLkvZTkvZbkvZjkvZ/kvaPkvarkvazkva7kvbHkvbfkvbjkvbnkvbrkvb3kvb7kvoHkvoLkvoRcIl0sW1wiOGZiMWExXCIsXCLkvoXkvonkvorkvozkvo7kvpDkvpLkvpPkvpTkvpfkvpnkvprkvp7kvp/kvrLkvrfkvrnkvrvkvrzkvr3kvr7kv4Dkv4Hkv4Xkv4bkv4jkv4nkv4vkv4zkv43kv4/kv5Lkv5zkv6Dkv6Lkv7Dkv7Lkv7zkv73kv7/lgIDlgIHlgITlgIflgIrlgIzlgI7lgJDlgJPlgJflgJjlgJvlgJzlgJ3lgJ7lgKLlgKflgK7lgLDlgLLlgLPlgLXlgYDlgYHlgYLlgYXlgYblgYrlgYzlgY7lgZHlgZLlgZPlgZflgZnlgZ/lgaDlgaLlgaPlgablgaflgarlga3lgbDlgbHlgLvlgoHlgoPlgoTlgoblgorlgo7lgo/lgpBcIl0sW1wiOGZiMmExXCIsXCLlgpLlgpPlgpTlgpblgpvlgpzlgp5cIiw0LFwi5YKq5YKv5YKw5YK55YK65YK95YOA5YOD5YOE5YOH5YOM5YOO5YOQ5YOT5YOU5YOY5YOc5YOd5YOf5YOi5YOk5YOm5YOo5YOp5YOv5YOx5YO25YO65YO+5YSD5YSG5YSH5YSI5YSL5YSM5YSN5YSO5YOy5YSQ5YSX5YSZ5YSb5YSc5YSd5YSe5YSj5YSn5YSo5YSs5YSt5YSv5YSx5YSz5YS05YS15YS45YS55YWC5YWK5YWP5YWT5YWV5YWX5YWY5YWf5YWk5YWm5YW+5YaD5YaE5YaL5YaO5YaY5Yad5Yah5Yaj5Yat5Ya45Ya65Ya85Ya+5Ya/5YeCXCJdLFtcIjhmYjNhMVwiLFwi5YeI5YeP5YeR5YeS5YeT5YeV5YeY5Yee5Yei5Yel5Yeu5Yey5Yez5Ye05Ye35YiB5YiC5YiF5YiS5YiT5YiV5YiW5YiY5Yii5Yio5Yix5Yiy5Yi15Yi85YmF5YmJ5YmV5YmX5YmY5Yma5Ymc5Ymf5Ymg5Ymh5Ymm5Ymu5Ym35Ym45Ym55YqA5YqC5YqF5YqK5YqM5YqT5YqV5YqW5YqX5YqY5Yqa5Yqc5Yqk5Yql5Yqm5Yqn5Yqv5Yqw5Yq25Yq35Yq45Yq65Yq75Yq95YuA5YuE5YuG5YuI5YuM5YuP5YuR5YuU5YuW5Yub5Yuc5Yuh5Yul5Yuo5Yup5Yuq5Yus5Yuw5Yux5Yu05Yu25Yu35YyA5YyD5YyK5YyLXCJdLFtcIjhmYjRhMVwiLFwi5YyM5YyR5YyT5YyY5Yyb5Yyc5Yye5Yyf5Yyl5Yyn5Yyo5Yyp5Yyr5Yys5Yyt5Yyw5Yyy5Yy15Yy85Yy95Yy+5Y2C5Y2M5Y2L5Y2Z5Y2b5Y2h5Y2j5Y2l5Y2s5Y2t5Y2y5Y255Y2+5Y6D5Y6H5Y6I5Y6O5Y6T5Y6U5Y6Z5Y6d5Y6h5Y6k5Y6q5Y6r5Y6v5Y6y5Y605Y615Y635Y645Y665Y695Y+A5Y+F5Y+P5Y+S5Y+T5Y+V5Y+a5Y+d5Y+e5Y+g5Y+m5Y+n5Y+15ZCC5ZCT5ZCa5ZCh5ZCn5ZCo5ZCq5ZCv5ZCx5ZC05ZC15ZGD5ZGE5ZGH5ZGN5ZGP5ZGe5ZGi5ZGk5ZGm5ZGn5ZGp5ZGr5ZGt5ZGu5ZG05ZG/XCJdLFtcIjhmYjVhMVwiLFwi5ZKB5ZKD5ZKF5ZKI5ZKJ5ZKN5ZKR5ZKV5ZKW5ZKc5ZKf5ZKh5ZKm5ZKn5ZKp5ZKq5ZKt5ZKu5ZKx5ZK35ZK55ZK65ZK75ZK/5ZOG5ZOK5ZON5ZOO5ZOg5ZOq5ZOs5ZOv5ZO25ZO85ZO+5ZO/5ZSA5ZSB5ZSF5ZSI5ZSJ5ZSM5ZSN5ZSO5ZSV5ZSq5ZSr5ZSy5ZS15ZS25ZS75ZS85ZS95ZWB5ZWH5ZWJ5ZWK5ZWN5ZWQ5ZWR5ZWY5ZWa5ZWb5ZWe5ZWg5ZWh5ZWk5ZWm5ZW/5ZaB5ZaC5ZaG5ZaI5ZaO5ZaP5ZaR5ZaS5ZaT5ZaU5ZaX5Zaj5Zak5Zat5Zay5Za/5ZeB5ZeD5ZeG5ZeJ5ZeL5ZeM5ZeO5ZeR5ZeSXCJdLFtcIjhmYjZhMVwiLFwi5ZeT5ZeX5ZeY5Zeb5Zee5Zei5Zep5Ze25Ze/5ZiF5ZiI5ZiK5ZiNXCIsNSxcIuWYmeWYrOWYsOWYs+WYteWYt+WYueWYu+WYvOWYveWYv+WZgOWZgeWZg+WZhOWZhuWZieWZi+WZjeWZj+WZlOWZnuWZoOWZoeWZouWZo+WZpuWZqeWZreWZr+WZseWZsuWZteWahOWaheWaiOWai+WajOWaleWameWamuWaneWanuWan+WapuWap+WaqOWaqeWaq+WarOWareWaseWas+Wat+WavuWbheWbieWbiuWbi+Wbj+WbkOWbjOWbjeWbmeWbnOWbneWbn+WboeWbpFwiLDQsXCLlm7Hlm6vlm61cIl0sW1wiOGZiN2ExXCIsXCLlm7blm7flnIHlnILlnIflnIrlnIzlnJHlnJXlnJrlnJvlnJ3lnKDlnKLlnKPlnKTlnKXlnKnlnKrlnKzlnK7lnK/lnLPlnLTlnL3lnL7lnL/lnYXlnYblnYzlnY3lnZLlnaLlnaXlnaflnajlnavlna1cIiw0LFwi5Z2z5Z205Z215Z235Z255Z265Z275Z285Z2+5Z6B5Z6D5Z6M5Z6U5Z6X5Z6Z5Z6a5Z6c5Z6d5Z6e5Z6f5Z6h5Z6V5Z6n5Z6o5Z6p5Z6s5Z645Z695Z+H5Z+I5Z+M5Z+P5Z+V5Z+d5Z+e5Z+k5Z+m5Z+n5Z+p5Z+t5Z+w5Z+15Z+25Z+45Z+95Z++5Z+/5aCD5aCE5aCI5aCJ5Z+hXCJdLFtcIjhmYjhhMVwiLFwi5aCM5aCN5aCb5aCe5aCf5aCg5aCm5aCn5aCt5aCy5aC55aC/5aGJ5aGM5aGN5aGP5aGQ5aGV5aGf5aGh5aGk5aGn5aGo5aG45aG85aG/5aKA5aKB5aKH5aKI5aKJ5aKK5aKM5aKN5aKP5aKQ5aKU5aKW5aKd5aKg5aKh5aKi5aKm5aKp5aKx5aKy5aOE5aK85aOC5aOI5aON5aOO5aOQ5aOS5aOU5aOW5aOa5aOd5aOh5aOi5aOp5aOz5aSF5aSG5aSL5aSM5aSS5aST5aSU6JmB5aSd5aSh5aSj5aSk5aSo5aSv5aSw5aSz5aS15aS25aS/5aWD5aWG5aWS5aWT5aWZ5aWb5aWd5aWe5aWf5aWh5aWj5aWr5aWtXCJdLFtcIjhmYjlhMVwiLFwi5aWv5aWy5aW15aW25aW55aW75aW85aaL5aaM5aaO5aaS5aaV5aaX5aaf5aak5aan5aat5aau5aav5aaw5aaz5aa35aa65aa85aeB5aeD5aeE5aeI5aeK5aeN5aeS5aed5aee5aef5aej5aek5aen5aeu5aev5aex5aey5ae05ae35aiA5aiE5aiM5aiN5aiO5aiS5aiT5aie5aij5aik5ain5aio5aiq5ait5aiw5amE5amF5amH5amI5amM5amQ5amV5ame5amj5aml5amn5amt5am35am65am75am+5aqL5aqQ5aqT5aqW5aqZ5aqc5aqe5aqf5aqg5aqi5aqn5aqs5aqx5aqy5aqz5aq15aq45aq65aq75aq/XCJdLFtcIjhmYmFhMVwiLFwi5auE5auG5auI5auP5aua5auc5aug5aul5auq5auu5au15au25au95ayA5ayB5ayI5ayX5ay05ayZ5ayb5ayd5ayh5ayl5ayt5ay45a2B5a2L5a2M5a2S5a2W5a2e5a2o5a2u5a2v5a285a295a2+5a2/5a6B5a6E5a6G5a6K5a6O5a6Q5a6R5a6T5a6U5a6W5a6o5a6p5a6s5a6t5a6v5a6x5a6y5a635a665a685a+A5a+B5a+N5a+P5a+WXCIsNCxcIuWvoOWvr+WvseWvtOWvveWwjOWwl+WwnuWwn+Wwo+WwpuWwqeWwq+WwrOWwruWwsOWwsuWwteWwtuWxmeWxmuWxnOWxouWxo+Wxp+WxqOWxqVwiXSxbXCI4ZmJiYTFcIixcIuWxreWxsOWxtOWxteWxuuWxu+WxvOWxveWyh+WyiOWyiuWyj+WykuWyneWyn+WyoOWyouWyo+WypuWyquWysuWytOWyteWyuuWzieWzi+WzkuWzneWzl+WzruWzseWzsuWztOW0geW0huW0jeW0kuW0q+W0o+W0pOW0puW0p+W0seW0tOW0ueW0veW0v+W1guW1g+W1huW1iOW1leW1keW1meW1iuW1n+W1oOW1oeW1ouW1pOW1quW1reW1sOW1ueW1uuW1vuW1v+W2geW2g+W2iOW2iuW2kuW2k+W2lOW2leW2meW2m+W2n+W2oOW2p+W2q+W2sOW2tOW2uOW2ueW3g+W3h+W3i+W3kOW3juW3mOW3meW3oOW3pFwiXSxbXCI4ZmJjYTFcIixcIuW3qeW3uOW3ueW4gOW4h+W4jeW4kuW4lOW4leW4mOW4n+W4oOW4ruW4qOW4suW4teW4vuW5i+W5kOW5ieW5keW5luW5mOW5m+W5nOW5nuW5qOW5qlwiLDQsXCLlubDluoDluovluo7luqLluqTluqXluqjluqrluqzlurHlurPlur3lur7lur/lu4blu4zlu4vlu47lu5Hlu5Llu5Tlu5Xlu5zlu57lu6Xlu6vlvILlvIblvIflvIjlvI7lvJnlvJzlvJ3lvKHlvKLlvKPlvKTlvKjlvKvlvKzlvK7lvLDlvLTlvLblvLvlvL3lvL/lvYDlvYTlvYXlvYflvY3lvZDlvZTlvZjlvZvlvaDlvaPlvaTlvadcIl0sW1wiOGZiZGExXCIsXCLlva/lvbLlvbTlvbXlvbjlvbrlvb3lvb7lvonlvo3lvo/lvpblvpzlvp3lvqLlvqflvqvlvqTlvqzlvq/lvrDlvrHlvrjlv4Tlv4flv4jlv4nlv4vlv5BcIiw0LFwi5b+e5b+h5b+i5b+o5b+p5b+q5b+s5b+t5b+u5b+v5b+y5b+z5b+25b+65b+85oCH5oCK5oCN5oCT5oCU5oCX5oCY5oCa5oCf5oCk5oCt5oCz5oC15oGA5oGH5oGI5oGJ5oGM5oGR5oGU5oGW5oGX5oGd5oGh5oGn5oGx5oG+5oG/5oKC5oKG5oKI5oKK5oKO5oKR5oKT5oKV5oKY5oKd5oKe5oKi5oKk5oKl5oKo5oKw5oKx5oK3XCJdLFtcIjhmYmVhMVwiLFwi5oK75oK+5oOC5oOE5oOI5oOJ5oOK5oOL5oOO5oOP5oOU5oOV5oOZ5oOb5oOd5oOe5oOi5oOl5oOy5oO15oO45oO85oO95oSC5oSH5oSK5oSM5oSQXCIsNCxcIuaEluaEl+aEmeaEnOaEnuaEouaEquaEq+aEsOaEseaEteaEtuaEt+aEueaFgeaFheaFhuaFieaFnuaFoOaFrOaFsuaFuOaFu+aFvOaFv+aGgOaGgeaGg+aGhOaGi+aGjeaGkuaGk+aGl+aGmOaGnOaGneaGn+aGoOaGpeaGqOaGquaGreaGuOaGueaGvOaHgOaHgeaHguaHjuaHj+aHleaHnOaHneaHnuaHn+aHoeaHouaHp+aHqeaHpVwiXSxbXCI4ZmJmYTFcIixcIuaHrOaHreaHr+aIgeaIg+aIhOaIh+aIk+aIleaInOaIoOaIouaIo+aIp+aIqeaIq+aIueaIveaJguaJg+aJhOaJhuaJjOaJkOaJkeaJkuaJlOaJluaJmuaJnOaJpOaJreaJr+aJs+aJuuaJveaKjeaKjuaKj+aKkOaKpuaKqOaKs+aKtuaKt+aKuuaKvuaKv+aLhOaLjuaLleaLluaLmuaLquaLsuaLtOaLvOaLveaMg+aMhOaMiuaMi+aMjeaMkOaMk+aMluaMmOaMqeaMquaMreaMteaMtuaMueaMvOaNgeaNguaNg+aNhOaNhuaNiuaNi+aNjuaNkuaNk+aNlOaNmOaNm+aNpeaNpuaNrOaNreaNseaNtOaNtVwiXSxbXCI4ZmMwYTFcIixcIuaNuOaNvOaNveaNv+aOguaOhOaOh+aOiuaOkOaOlOaOleaOmeaOmuaOnuaOpOaOpuaOreaOruaOr+aOveaPgeaPheaPiOaPjuaPkeaPk+aPlOaPleaPnOaPoOaPpeaPquaPrOaPsuaPs+aPteaPuOaPueaQieaQiuaQkOaQkuaQlOaQmOaQnuaQoOaQouaQpOaQpeaQqeaQquaQr+aQsOaQteaQveaQv+aRi+aRj+aRkeaRkuaRk+aRlOaRmuaRm+aRnOaRneaRn+aRoOaRoeaRo+aRreaRs+aRtOaRu+aRveaSheaSh+aSj+aSkOaSkeaSmOaSmeaSm+aSneaSn+aSoeaSo+aSpuaSqOaSrOaSs+aSveaSvuaSv1wiXSxbXCI4ZmMxYTFcIixcIuaThOaTieaTiuaTi+aTjOaTjuaTkOaTkeaTleaTl+aTpOaTpeaTqeaTquaTreaTsOaTteaTt+aTu+aTv+aUgeaUhOaUiOaUieaUiuaUj+aUk+aUlOaUluaUmeaUm+aUnuaUn+aUouaUpuaUqeaUruaUseaUuuaUvOaUveaVg+aVh+aVieaVkOaVkuaVlOaVn+aVoOaVp+aVq+aVuuaVveaWgeaWheaWiuaWkuaWleaWmOaWneaWoOaWo+aWpuaWruaWsuaWs+aWtOaWv+aXguaXiOaXieaXjuaXkOaXlOaXluaXmOaXn+aXsOaXsuaXtOaXteaXueaXvuaXv+aYgOaYhOaYiOaYieaYjeaYkeaYkuaYleaYluaYnVwiXSxbXCI4ZmMyYTFcIixcIuaYnuaYoeaYouaYo+aYpOaYpuaYqeaYquaYq+aYrOaYruaYsOaYseaYs+aYueaYt+aZgOaZheaZhuaZiuaZjOaZkeaZjuaZl+aZmOaZmeaZm+aZnOaZoOaZoeabu+aZquaZq+aZrOaZvuaZs+aZteaZv+aZt+aZuOaZueaZu+aagOaZvOaai+aajOaajeaakOaakuaameaamuaam+aanOaan+aaoOaapOaareaaseaasuaateaau+aav+abgOabguabg+abiOabjOabjuabj+ablOabm+abn+abqOabq+abrOabruabuuacheach+acjuack+acmeacnOacoOacouacs+acvuadheadh+adiOadjOadlOadleadnVwiXSxbXCI4ZmMzYTFcIixcIuadpuadrOadruadtOadtuadu+aegeaehOaejuaej+aekeaek+aeluaemOaemeaem+aesOaeseaesuaeteaeu+aevOaeveafueafgOafguafg+afheafiOafieafkuafl+afmeafnOafoeafpuafsOafsuaftuaft+ahkuaglOagmeagneagn+agqOagp+agrOagreagr+agsOagseags+agu+agv+ahhOahheahiuahjOahleahl+ahmOahm+ahq+ahrlwiLDQsXCLmobXmobnmobrmobvmobzmooLmooTmoobmoojmopbmopjmoprmopzmoqHmoqPmoqXmoqnmoqrmoq7morLmorvmo4Xmo4jmo4zmo49cIl0sW1wiOGZjNGExXCIsXCLmo5Dmo5Hmo5Pmo5bmo5nmo5zmo53mo6Xmo6jmo6rmo6vmo6zmo63mo7Dmo7Hmo7Xmo7bmo7vmo7zmo73mpIbmpInmpIrmpJDmpJHmpJPmpJbmpJfmpLHmpLPmpLXmpLjmpLvmpYLmpYXmpYnmpY7mpZfmpZvmpaPmpaTmpaXmpabmpajmpanmpazmpbDmpbHmpbLmpbrmpbvmpb/mpoDmpo3mppLmppbmppjmpqHmpqXmpqbmpqjmpqvmpq3mpq/mprfmprjmprrmprzmp4Xmp4jmp5Hmp5bmp5fmp6Lmp6Xmp67mp6/mp7Hmp7Pmp7Xmp77mqIDmqIHmqIPmqI/mqJHmqJXmqJrmqJ3mqKDmqKTmqKjmqLDmqLJcIl0sW1wiOGZjNWExXCIsXCLmqLTmqLfmqLvmqL7mqL/mqYXmqYbmqYnmqYrmqY7mqZDmqZHmqZLmqZXmqZbmqZvmqaTmqafmqarmqbHmqbPmqb7mqoHmqoPmqobmqofmqonmqovmqpHmqpvmqp3mqp7mqp/mqqXmqqvmqq/mqrDmqrHmqrTmqr3mqr7mqr/mq4bmq4nmq4jmq4zmq5Dmq5Tmq5Xmq5bmq5zmq53mq6Tmq6fmq6zmq7Dmq7Hmq7Lmq7zmq73mrILmrIPmrIbmrIfmrInmrI/mrJDmrJHmrJfmrJvmrJ7mrKTmrKjmrKvmrKzmrK/mrLXmrLbmrLvmrL/mrYbmrYrmrY3mrZLmrZbmrZjmrZ3mraDmrafmravmra7mrbDmrbXmrb1cIl0sW1wiOGZjNmExXCIsXCLmrb7mroLmroXmrpfmrpvmrp/mrqDmrqLmrqPmrqjmrqnmrqzmrq3mrq7mrrDmrrjmrrnmrr3mrr7mr4Pmr4Tmr4nmr4zmr5bmr5rmr6Hmr6Pmr6bmr6fmr67mr7Hmr7fmr7nmr7/msILmsITmsIXmsInmsI3msI7msJDmsJLmsJnmsJ/msKbmsKfmsKjmsKzmsK7msLPmsLXmsLbmsLrmsLvmsL/msYrmsYvmsY3msY/msZLmsZTmsZnmsZvmsZzmsavmsa3msa/msbTmsbbmsbjmsbnmsbvmsoXmsobmsofmsonmspTmspXmspfmspjmspzmsp/msrDmsrLmsrTms4Lms4bms43ms4/ms5Dms5Hms5Lms5Tms5ZcIl0sW1wiOGZjN2ExXCIsXCLms5rms5zms6Dms6fms6nms6vms6zms67ms7Lms7TmtITmtIfmtIrmtI7mtI/mtJHmtJPmtJrmtKbmtKfmtKjmsafmtK7mtK/mtLHmtLnmtLzmtL/mtZfmtZ7mtZ/mtaHmtaXmtafmta/mtbDmtbzmtoLmtofmtpHmtpLmtpTmtpbmtpfmtpjmtqrmtqzmtrTmtrfmtrnmtr3mtr/mt4Tmt4jmt4rmt47mt4/mt5bmt5vmt53mt5/mt6Dmt6Lmt6Xmt6nmt6/mt7Dmt7Tmt7bmt7zmuIDmuITmuJ7muKLmuKfmuLLmuLbmuLnmuLvmuLzmuYTmuYXmuYjmuYnmuYvmuY/muZHmuZLmuZPmuZTmuZfmuZzmuZ3muZ5cIl0sW1wiOGZjOGExXCIsXCLmuaLmuaPmuajmubPmubvmub3muo3mupPmupnmuqDmuqfmuq3muq7murHmurPmurvmur/mu4Dmu4Hmu4Pmu4fmu4jmu4rmu43mu47mu4/mu6vmu63mu67mu7nmu7vmu73mvITmvIjmvIrmvIzmvI3mvJbmvJjmvJrmvJvmvKbmvKnmvKrmvK/mvLDmvLPmvLbmvLvmvLzmvK3mvY/mvZHmvZLmvZPmvZfmvZnmvZrmvZ3mvZ7mvaHmvaLmvajmvazmvb3mvb7mvoPmvofmvojmvovmvozmvo3mvpDmvpLmvpPmvpTmvpbmvprmvp/mvqDmvqXmvqbmvqfmvqjmvq7mvq/mvrDmvrXmvrbmvrzmv4Xmv4fmv4jmv4pcIl0sW1wiOGZjOWExXCIsXCLmv5rmv57mv6jmv6nmv7Dmv7Xmv7nmv7zmv73ngIDngIXngIbngIfngI3ngJfngKDngKPngK/ngLTngLfngLnngLzngYPngYTngYjngYnngYrngYvngZTngZXngZ3ngZ7ngY7ngaTngaXngaznga7ngbXngbbngb7ngoHngoXngobngpRcIiw0LFwi54Kb54Kk54Kr54Kw54Kx54K054K354OK54OR54OT54OU54OV54OW54OY54Oc54Ok54O654SDXCIsNCxcIueEi+eEjOeEj+eEnueEoOeEq+eEreeEr+eEsOeEseeEuOeFgeeFheeFhueFh+eFiueFi+eFkOeFkueFl+eFmueFnOeFnueFoFwiXSxbXCI4ZmNhYTFcIixcIueFqOeFueeGgOeGheeGh+eGjOeGkueGmueGm+eGoOeGoueGr+eGsOeGsueGs+eGuueGv+eHgOeHgeeHhOeHi+eHjOeHk+eHlueHmeeHmueHnOeHuOeHvueIgOeIh+eIiOeIieeIk+eIl+eImueIneeIn+eIpOeIq+eIr+eItOeIuOeIueeJgeeJgueJg+eJheeJjueJj+eJkOeJk+eJleeJlueJmueJnOeJnueJoOeJo+eJqOeJq+eJrueJr+eJseeJt+eJuOeJu+eJvOeJv+eKhOeKieeKjeeKjueKk+eKm+eKqOeKreeKrueKseeKtOeKvueLgeeLh+eLieeLjOeLleeLlueLmOeLn+eLpeeLs+eLtOeLuueLu1wiXSxbXCI4ZmNiYTFcIixcIueLvueMgueMhOeMheeMh+eMi+eMjeeMkueMk+eMmOeMmeeMnueMoueMpOeMp+eMqOeMrOeMseeMsueMteeMuueMu+eMveeNg+eNjeeNkOeNkueNlueNmOeNneeNnueNn+eNoOeNpueNp+eNqeeNq+eNrOeNrueNr+eNseeNt+eNueeNvOeOgOeOgeeOg+eOheeOhueOjueOkOeOk+eOleeOl+eOmOeOnOeOnueOn+eOoOeOoueOpeeOpueOqueOq+eOreeOteeOt+eOueeOvOeOveeOv+ePheePhuePieePi+ePjOePj+ePkuePk+ePluePmeePneePoeePo+ePpuePp+ePqeePtOePteePt+ePueePuuePu+ePvVwiXSxbXCI4ZmNjYTFcIixcIuePv+eQgOeQgeeQhOeQh+eQiueQkeeQmueQm+eQpOeQpueQqFwiLDksXCLnkLnnkYDnkYPnkYTnkYbnkYfnkYvnkY3nkZHnkZLnkZfnkZ3nkaLnkabnkafnkajnkavnka3nka7nkbHnkbLnkoDnkoHnkoXnkobnkofnkonnko/nkpDnkpHnkpLnkpjnkpnnkprnkpznkp/nkqDnkqHnkqPnkqbnkqjnkqnnkqrnkqvnkq7nkq/nkrHnkrLnkrXnkrnnkrvnkr/nk4jnk4nnk4znk5Dnk5Pnk5jnk5rnk5vnk57nk5/nk6Tnk6jnk6rnk6vnk6/nk7Tnk7rnk7vnk7znk7/nlIZcIl0sW1wiOGZjZGExXCIsXCLnlJLnlJbnlJfnlKDnlKHnlKTnlKfnlKnnlKrnlK/nlLbnlLnnlL3nlL7nlL/nlYDnlYPnlYfnlYjnlY7nlZDnlZLnlZfnlZ7nlZ/nlaHnla/nlbHnlblcIiw1LFwi55aB55aF55aQ55aS55aT55aV55aZ55ac55ai55ak55a055a655a/55eA55eB55eE55eG55eM55eO55eP55eX55ec55ef55eg55eh55ek55en55es55eu55ev55ex55e555iA55iC55iD55iE55iH55iI55iK55iM55iP55iS55iT55iV55iW55iZ55ib55ic55id55ie55ij55il55im55ip55it55iy55iz55i155i455i5XCJdLFtcIjhmY2VhMVwiLFwi55i655i855mK55mA55mB55mD55mE55mF55mJ55mL55mV55mZ55mf55mk55ml55mt55mu55mv55mx55m055qB55qF55qM55qN55qV55qb55qc55qd55qf55qg55qiXCIsNixcIueaqueareeaveebgeebheebieebi+ebjOebjueblOebmeeboOebpuebqOebrOebsOebseebtuebueebvOecgOechueciuecjueckueclOecleecl+ecmeecmuecnOecouecqOecreecruecr+ectOecteectuecueecveecvuedguedheedhuediuedjeedjuedj+edkuedluedl+ednOednuedn+edoOedolwiXSxbXCI4ZmNmYTFcIixcIuedpOedp+edquedrOedsOedsueds+edtOeduuedveeegOeehOeejOeejeeelOeeleeelueemueen+eeoueep+eequeerueer+eeseeeteeevuefg+efieefkeefkuefleefmeefnuefn+efoOefpOefpuefquefrOefsOefseeftOefuOefu+egheeghuegieegjeegjuegkeegneegoeegouego+egreegruegsOegteegt+ehg+ehhOehh+ehiOehjOehjuehkuehnOehnuehoOehoeeho+ehpOehqOehquehruehuuehvueiiueij+eilOeimOeioeeineeinuein+eipOeiqOeirOeireeisOeiseeisueis1wiXSxbXCI4ZmQwYTFcIixcIueiu+eiveeiv+ejh+ejiOejieejjOejjuejkuejk+ejleejluejpOejm+ejn+ejoOejoeejpuejquejsuejs+ekgOejtuejt+ejuueju+ejv+ekhuekjOekkOekmueknOeknuekn+ekoOekpeekp+ekqeekreekseektOekteeku+ekveekv+elhOelheelhueliueli+elj+elkeellOelmOelm+elnOelp+elqeelq+elsuelueelu+elvOelvuemi+emjOemkeemk+emlOemleemluemmOemm+emnOemoeemqOemqeemq+emr+emseemtOemuOemu+enguenhOenh+eniOeniuenj+enlOenluenmuenneennlwiXSxbXCI4ZmQxYTFcIixcIuenoOenouenpeenquenq+enreenseenuOenvOeogueog+eoh+eoieeoiueojOeokeeoleeom+eonueooeeop+eoq+eoreeor+eosOeotOeoteeouOeoueeouuephOepheeph+epiOepjOepleepluepmeepnOepneepn+epoOeppeepp+epquepreepteepuOepvueqgOeqgueqheeqhueqiueqi+eqkOeqkeeqlOeqnueqoOeqo+eqrOeqs+eqteequeequ+eqvOerhuerieerjOerjuerkeerm+erqOerqeerq+errOerseertOeru+erveervuesh+eslOesn+eso+esp+esqeesquesq+esreesruesr+essFwiXSxbXCI4ZmQyYTFcIixcIuesseestOesveesv+etgOetgeeth+etjuetleetoOetpOetpuetqeetquetreetr+etsuets+ett+euhOeuieeujueukOeukeeulueum+eunueuoOeupeeurOeur+eusOeusueuteeutueuuueuu+euvOeuveevguevheeviOeviuevlOevluevl+evmeevmuevm+evqOevquevsuevtOevteevuOevueevuuevvOevvuewgeewguewg+ewhOewhuewieewi+ewjOewjuewj+ewmeewm+ewoOewpeewpuewqOewrOewseews+ewtOewtuewueewuuexhuexiuexleexkeexkuexk+exmVwiLDVdLFtcIjhmZDNhMVwiLFwi57Gh57Gj57Gn57Gp57Gt57Gu57Gw57Gy57G557G857G957KG57KH57KP57KU57Ke57Kg57Km57Kw57K257K357K657K757K857K/57OE57OH57OI57OJ57ON57OP57OT57OU57OV57OX57OZ57Oa57Od57Om57Op57Or57O157SD57SH57SI57SJ57SP57SR57SS57ST57SW57Sd57Se57Sj57Sm57Sq57St57Sx57S857S957S+57WA57WB57WH57WI57WN57WR57WT57WX57WZ57Wa57Wc57Wd57Wl57Wn57Wq57Ww57W457W657W757W/57aB57aC57aD57aF57aG57aI57aL57aM57aN57aR57aW57aX57adXCJdLFtcIjhmZDRhMVwiLFwi57ae57am57an57aq57az57a257a357a557eCXCIsNCxcIue3jOe3jee3jue3l+e3mee4gOe3oue3pee3pue3que3q+e3ree3see3tee3tue3uee3uue4iOe4kOe4kee4lee4l+e4nOe4nee4oOe4p+e4qOe4rOe4ree4r+e4s+e4tue4v+e5hOe5hee5h+e5jue5kOe5kue5mOe5n+e5oee5oue5pee5q+e5rue5r+e5s+e5uOe5vue6gee6hue6h+e6iue6jee6kee6lee6mOe6mue6nee6nue8vOe8u+e8vee8vue8v+e9g+e9hOe9h+e9j+e9kue9k+e9m+e9nOe9nee9oee9o+e9pOe9pee9pue9rVwiXSxbXCI4ZmQ1YTFcIixcIue9see9vee9vue9v+e+gOe+i+e+jee+j+e+kOe+kee+lue+l+e+nOe+oee+oue+pue+que+ree+tOe+vOe+v+e/gOe/g+e/iOe/jue/j+e/m+e/n+e/o+e/pee/qOe/rOe/rue/r+e/sue/uue/vee/vue/v+iAh+iAiOiAiuiAjeiAjuiAj+iAkeiAk+iAlOiAluiAneiAnuiAn+iAoOiApOiApuiArOiAruiAsOiAtOiAteiAt+iAueiAuuiAvOiAvuiBgOiBhOiBoOiBpOiBpuiBreiBseiBteiCgeiCiOiCjuiCnOiCnuiCpuiCp+iCq+iCuOiCueiDiOiDjeiDj+iDkuiDlOiDleiDl+iDmOiDoOiDreiDrlwiXSxbXCI4ZmQ2YTFcIixcIuiDsOiDsuiDs+iDtuiDueiDuuiDvuiEg+iEi+iEluiEl+iEmOiEnOiEnuiEoOiEpOiEp+iErOiEsOiEteiEuuiEvOiFheiFh+iFiuiFjOiFkuiFl+iFoOiFoeiFp+iFqOiFqeiFreiFr+iFt+iGgeiGkOiGhOiGheiGhuiGi+iGjuiGluiGmOiGm+iGnuiGouiGruiGsuiGtOiGu+iHi+iHg+iHheiHiuiHjuiHj+iHleiHl+iHm+iHneiHnuiHoeiHpOiHq+iHrOiHsOiHseiHsuiHteiHtuiHuOiHueiHveiHv+iIgOiIg+iIj+iIk+iIlOiImeiImuiIneiIoeiIouiIqOiIsuiItOiIuuiJg+iJhOiJheiJhlwiXSxbXCI4ZmQ3YTFcIixcIuiJi+iJjuiJj+iJkeiJluiJnOiJoOiJo+iJp+iJreiJtOiJu+iJveiJv+iKgOiKgeiKg+iKhOiKh+iKieiKiuiKjuiKkeiKlOiKluiKmOiKmuiKm+iKoOiKoeiKo+iKpOiKp+iKqOiKqeiKquiKruiKsOiKsuiKtOiKt+iKuuiKvOiKvuiKv+iLhuiLkOiLleiLmuiLoOiLouiLpOiLqOiLquiLreiLr+iLtuiLt+iLveiLvuiMgOiMgeiMh+iMiOiMiuiMi+iNlOiMm+iMneiMnuiMn+iMoeiMouiMrOiMreiMruiMsOiMs+iMt+iMuuiMvOiMveiNguiNg+iNhOiNh+iNjeiNjuiNkeiNleiNluiNl+iNsOiNuFwiXSxbXCI4ZmQ4YTFcIixcIuiNveiNv+iOgOiOguiOhOiOhuiOjeiOkuiOlOiOleiOmOiOmeiOm+iOnOiOneiOpuiOp+iOqeiOrOiOvuiOv+iPgOiPh+iPieiPj+iPkOiPkeiPlOiPneiNk+iPqOiPquiPtuiPuOiPueiPvOiQgeiQhuiQiuiQj+iQkeiQleiQmeiOreiQr+iQueiRheiRh+iRiOiRiuiRjeiRj+iRkeiRkuiRluiRmOiRmeiRmuiRnOiRoOiRpOiRpeiRp+iRquiRsOiRs+iRtOiRtuiRuOiRvOiRveiSgeiSheiSkuiSk+iSleiSnuiSpuiSqOiSqeiSquiSr+iSseiStOiSuuiSveiSvuiTgOiTguiTh+iTiOiTjOiTj+iTk1wiXSxbXCI4ZmQ5YTFcIixcIuiTnOiTp+iTquiTr+iTsOiTseiTsuiTt+iUsuiTuuiTu+iTveiUguiUg+iUh+iUjOiUjuiUkOiUnOiUnuiUouiUo+iUpOiUpeiUp+iUquiUq+iUr+iUs+iUtOiUtuiUv+iVhuiVj1wiLDQsXCLolZbolZnolZxcIiw2LFwi6JWk6JWr6JWv6JW56JW66JW76JW96JW/6JaB6JaF6JaG6JaJ6JaL6JaM6JaP6JaT6JaY6Jad6Jaf6Jag6Jai6Jal6Jan6Ja06Ja26Ja36Ja46Ja86Ja96Ja+6Ja/6JeC6JeH6JeK6JeL6JeO6Jat6JeY6Jea6Jef6Jeg6Jem6Jeo6Jet6Jez6Je26Je8XCJdLFtcIjhmZGFhMVwiLFwi6Je/6JiA6JiE6JiF6JiN6JiO6JiQ6JiR6JiS6JiY6JiZ6Jib6Jie6Jih6Jin6Jip6Ji26Ji46Ji66Ji86Ji96JmA6JmC6JmG6JmS6JmT6JmW6JmX6JmY6JmZ6Jmd6JmgXCIsNCxcIuiZqeiZrOiZr+iZteiZtuiZt+iZuuiajeiakeialuiamOiamuianOiaoeiapuiap+iaqOiareiaseias+iatOiateiat+iauOiaueiav+ibgOibgeibg+ibheibkeibkuibleibl+ibmuibnOiboOibo+ibpeibp+iaiOibuuibvOibveichOicheich+ici+icjuicj+ickOick+iclOicmeicnuicn+icoeico1wiXSxbXCI4ZmRiYTFcIixcIuicqOicruicr+icseicsuicueicuuicvOicveicvuidgOidg+idheidjeidmOidneidoeidpOidpeidr+idseidsuidu+ieg1wiLDYsXCLonovonozonpDonpPonpXonpfonpjonpnonp7onqDonqPonqfonqzonq3onq7onrHonrXonr7onr/on4Hon4jon4non4ron47on5Xon5bon5non5ron5zon5/on6Lon6Pon6Ton6ron6von63on7Hon7Pon7jon7ron7/ooIHooIPooIbooInooIrooIvooJDooJnooJLooJPooJTooJjooJrooJvooJzooJ7ooJ/ooKjooK3ooK7ooLDooLLooLVcIl0sW1wiOGZkY2ExXCIsXCLooLrooLzooYHooYPooYXooYjooYnooYrooYvooY7ooZHooZXooZbooZjooZrooZzooZ/ooaDooaTooanoobHoobnoobvoooDoopjooproopvoopzoop/ooqDooqjooqroorroor3oor7oo4Doo4pcIiw0LFwi6KOR6KOS6KOT6KOb6KOe6KOn6KOv6KOw6KOx6KO16KO36KSB6KSG6KSN6KSO6KSP6KSV6KSW6KSY6KSZ6KSa6KSc6KSg6KSm6KSn6KSo6KSw6KSx6KSy6KS16KS56KS66KS+6KWA6KWC6KWF6KWG6KWJ6KWP6KWS6KWX6KWa6KWb6KWc6KWh6KWi6KWj6KWr6KWu6KWw6KWz6KW16KW6XCJdLFtcIjhmZGRhMVwiLFwi6KW76KW86KW96KaJ6KaN6KaQ6KaU6KaV6Kab6Kac6Kaf6Kag6Kal6Kaw6Ka06Ka16Ka26Ka36Ka86KeUXCIsNCxcIuinpeinqeinq+inreinseins+intuinueinveinv+iohOioheioh+ioj+iokeiokuiolOioleionuiooOioouiopOiopuioq+iorOior+ioteiot+ioveiovuipgOipg+ipheiph+ipieipjeipjuipk+ipluipl+ipmOipnOipneipoeippeipp+ipteiptuipt+ipueipuuipu+ipvuipv+iqgOiqg+iqhuiqi+iqj+iqkOiqkuiqluiql+iqmeiqn+iqp+iqqeiqruiqr+iqs1wiXSxbXCI4ZmRlYTFcIixcIuiqtuiqt+iqu+iqvuirg+irhuiriOirieiriuirkeirk+irlOirleirl+irneirn+irrOirsOirtOirteirtuirvOirv+isheishuisi+iskeisnOisnuisn+isiuisreissOist+isvOitglwiLDQsXCLorYjorZLorZPorZTorZnorY3orZ7oraPora3orbborbjorbnorbzorb7oroHoroToroXorovoro3oro/orpTorpXorpzorp7orp/osLjosLnosL3osL7osYXosYfosYnosYvosY/osZHosZPosZTosZfosZjosZvosZ3osZnosaPosaTosabosajosanosa3osbPosbXosbbosbvosb7osoZcIl0sW1wiOGZkZmExXCIsXCLosofosovospDospLospPospnospvospzosqTosrnosrros4Xos4bos4nos4vos4/os5bos5Xos5nos53os6Hos6jos6zos6/os7Dos7Los7Xos7fos7jos77os7/otIHotIPotInotJLotJfotJvotaXotanotazota7otb/otoLotoTotojoto3otpDotpHotpXotp7otp/otqDotqbotqvotqzotq/otrLotrXotrfotrnotrvot4Dot4Xot4bot4fot4jot4rot47ot5Hot5Tot5Xot5fot5not6Tot6Xot6fot6zot7Dotrzot7Hot7Lot7Tot73ouIHouITouIXouIbouIvouJHouJTouJbouKDouKHouKJcIl0sW1wiOGZlMGExXCIsXCLouKPouKbouKfouLHouLPouLbouLfouLjouLnouL3ouYDouYHouYvouY3ouY7ouY/ouZTouZvouZzouZ3ouZ7ouaHouaLouanouazoua3oua/oubDoubHoubnoubroubvouoLouoPouonoupDoupLoupXouproupvoup3oup7ouqLouqfouqnouq3ouq7ourPourXourrourvou4Dou4Hou4Pou4Tou4fou4/ou5Hou5Tou5zou6jou67ou7Dou7Hou7fou7nou7rou63ovIDovILovIfovIjovI/ovJDovJbovJfovJjovJ7ovKDovKHovKPovKXovKfovKjovKzovK3ovK7ovLTovLXovLbovLfovLrovYDovYFcIl0sW1wiOGZlMWExXCIsXCLovYPovYfovY/ovZFcIiw0LFwi6L2Y6L2d6L2e6L2l6L6d6L6g6L6h6L6k6L6l6L6m6L616L626L646L6+6L+A6L+B6L+G6L+K6L+L6L+N6L+Q6L+S6L+T6L+V6L+g6L+j6L+k6L+o6L+u6L+x6L+16L+26L+76L++6YCC6YCE6YCI6YCM6YCY6YCb6YCo6YCp6YCv6YCq6YCs6YCt6YCz6YC06YC36YC/6YGD6YGE6YGM6YGb6YGd6YGi6YGm6YGn6YGs6YGw6YG06YG56YKF6YKI6YKL6YKM6YKO6YKQ6YKV6YKX6YKY6YKZ6YKb6YKg6YKh6YKi6YKl6YKw6YKy6YKz6YK06YK26YK96YOM6YK+6YODXCJdLFtcIjhmZTJhMVwiLFwi6YOE6YOF6YOH6YOI6YOV6YOX6YOY6YOZ6YOc6YOd6YOf6YOl6YOS6YO26YOr6YOv6YOw6YO06YO+6YO/6YSA6YSE6YSF6YSG6YSI6YSN6YSQ6YSU6YSW6YSX6YSY6YSa6YSc6YSe6YSg6YSl6YSi6YSj6YSn6YSp6YSu6YSv6YSx6YS06YS26YS36YS56YS66YS86YS96YWD6YWH6YWI6YWP6YWT6YWX6YWZ6YWa6YWb6YWh6YWk6YWn6YWt6YW06YW56YW66YW76YaB6YaD6YaF6YaG6YaK6YaO6YaR6YaT6YaU6YaV6YaY6Yae6Yah6Yam6Yao6Yas6Yat6Yau6Yaw6Yax6Yay6Yaz6Ya26Ya76Ya86Ya96Ya/XCJdLFtcIjhmZTNhMVwiLFwi6YeC6YeD6YeF6YeT6YeU6YeX6YeZ6Yea6Yee6Yek6Yel6Yep6Yeq6YesXCIsNSxcIumHt+mHuemHu+mHvemIgOmIgemIhOmIhemIhumIh+mIiemIiumIjOmIkOmIkumIk+mIlumImOmInOmInemIo+mIpOmIpemIpumIqOmIrumIr+mIsOmIs+mItemItumIuOmIuemIuumIvOmIvumJgOmJgumJg+mJhumJh+mJiumJjemJjumJj+mJkemJmOmJmemJnOmJnemJoOmJoemJpemJp+mJqOmJqemJrumJr+mJsOmJtVwiLDQsXCLpibvpibzpib3pib/piojpionpiorpio3pio7pipLpipdcIl0sW1wiOGZlNGExXCIsXCLpipnpip/piqDpiqTpiqXpiqfpiqjpiqvpiq/pirLpirbpirjpirrpirvpirzpir3pir9cIiw0LFwi6YuF6YuG6YuH6YuI6YuL6YuM6YuN6YuO6YuQ6YuT6YuV6YuX6YuY6YuZ6Yuc6Yud6Yuf6Yug6Yuh6Yuj6Yul6Yun6Yuo6Yus6Yuu6Yuw6Yu56Yu76Yu/6YyA6YyC6YyI6YyN6YyR6YyU6YyV6Yyc6Yyd6Yye6Yyf6Yyh6Yyk6Yyl6Yyn6Yyp6Yyq6Yyz6Yy06Yy26Yy36Y2H6Y2I6Y2J6Y2Q6Y2R6Y2S6Y2V6Y2X6Y2Y6Y2a6Y2e6Y2k6Y2l6Y2n6Y2p6Y2q6Y2t6Y2v6Y2w6Y2x6Y2z6Y206Y22XCJdLFtcIjhmZTVhMVwiLFwi6Y266Y296Y2/6Y6A6Y6B6Y6C6Y6I6Y6K6Y6L6Y6N6Y6P6Y6S6Y6V6Y6Y6Y6b6Y6e6Y6h6Y6j6Y6k6Y6m6Y6o6Y6r6Y606Y616Y626Y666Y6p6Y+B6Y+E6Y+F6Y+G6Y+H6Y+JXCIsNCxcIumPk+mPmemPnOmPnumPn+mPoumPpumPp+mPuemPt+mPuOmPuumPu+mPvemQgemQgumQhOmQiOmQiemQjemQjumQj+mQlemQlumQl+mQn+mQrumQr+mQsemQsumQs+mQtOmQu+mQv+mQvemRg+mRhemRiOmRiumRjOmRlemRmemRnOmRn+mRoemRo+mRqOmRq+mRremRrumRr+mRsemRsumShOmSg+mVuOmVuVwiXSxbXCI4ZmU2YTFcIixcIumVvumWhOmWiOmWjOmWjemWjumWnemWnumWn+mWoemWpumWqemWq+mWrOmWtOmWtumWuumWvemWv+mXhumXiOmXiemXi+mXkOmXkemXkumXk+mXmemXmumXnemXnumXn+mXoOmXpOmXpumYnemYnumYoumYpOmYpemYpumYrOmYsemYs+mYt+mYuOmYuemYuumYvOmYvemZgemZkumZlOmZlumZl+mZmOmZoemZrumZtOmZu+mZvOmZvumZv+magemagumag+mahOmaiemakemalumamumaneman+mapOmapemapumaqemarumar+mas+mauumbiumbkuW2sumbmOmbmumbnembnumbn+mbqembr+mbsembuumcglwiXSxbXCI4ZmU3YTFcIixcIumcg+mchemciemcmumcm+mcnemcoemcoumco+mcqOmcsemcs+mdgemdg+mdiumdjumdj+mdlemdl+mdmOmdmumdm+mdo+mdp+mdqumdrumds+mdtumdt+mduOmdu+mdvemdv+megOmeiemelemelumel+memememumenumen+meoumerOmerumesemesumetemetumeuOmeuemeuumevOmevumev+mfgemfhOmfhemfh+mfiemfiumfjOmfjemfjumfkOmfkemflOmfl+mfmOmfmemfnemfnumfoOmfm+mfoemfpOmfr+mfsemftOmft+mfuOmfuumgh+mgiumgmemgjemgjumglOmglumgnOmgnumgoOmgo+mgplwiXSxbXCI4ZmU4YTFcIixcIumgq+mgrumgr+mgsOmgsumgs+mgtemgpemgvumhhOmhh+mhiumhkemhkumhk+mhlumhl+mhmemhmumhoumho+mhpemhpumhqumhrOmiq+miremirumisOmitOmit+miuOmiuumiu+miv+mjgumjhemjiOmjjOmjoemjo+mjpemjpumjp+mjqumjs+mjtumkgumkh+mkiOmkkemklemklumkl+mkmumkm+mknOmkn+mkoumkpumkp+mkq+mksVwiLDQsXCLppLnppLrppLvppLzppYDppYHppYbppYfppYjppY3ppY7ppZTppZjppZnppZvppZzppZ7ppZ/ppaDpppvppp3ppp/ppqbpprDpprHpprLpprVcIl0sW1wiOGZlOWExXCIsXCLpprnpprrppr3ppr/pp4Ppp4npp5Ppp5Tpp5npp5rpp5zpp57pp6fpp6rpp6vpp6zpp7Dpp7Tpp7Xpp7npp73pp77pqILpqIPpqITpqIvpqIzpqJDpqJHpqJbpqJ7pqKDpqKLpqKPpqKTpqKfpqK3pqK7pqLPpqLXpqLbpqLjpqYfpqYHpqYTpqYrpqYvpqYzpqY7pqZHpqZTpqZbpqZ3pqqrpqqzpqq7pqq/pqrLpqrTpqrXpqrbpqrnpqrvpqr7pqr/pq4Hpq4Ppq4bpq4jpq47pq5Dpq5Lpq5Xpq5bpq5fpq5vpq5zpq6Dpq6Tpq6Xpq6fpq6npq6zpq7Lpq7Ppq7Xpq7npq7rpq73pq79cIiw0XSxbXCI4ZmVhYTFcIixcIumshOmshemsiOmsiemsi+msjOmsjemsjumskOmskumslumsmemsm+msnOmsoOmspumsq+msremss+mstOmstemst+msuemsuumsvemtiOmti+mtjOmtlemtlumtl+mtm+mtnumtoemto+mtpemtpumtqOmtqlwiLDQsXCLprbPprbXprbfprbjprbnprb/proDproTproXprobprofpronprorprovpro3pro/prpDprpTprprprp3prp7prqbprqfprqnprqzprrDprrHprrLprrfprrjprrvprrzprr7prr/pr4Hpr4fpr4jpr47pr5Dpr5fpr5jpr53pr5/pr6Xpr6fpr6rpr6vpr6/pr7Ppr7fpr7hcIl0sW1wiOGZlYmExXCIsXCLpr7npr7rpr73pr7/psIDpsILpsIvpsI/psJHpsJbpsJjpsJnpsJrpsJzpsJ7psKLpsKPpsKZcIiw0LFwi6bCx6bC16bC26bC36bC96bGB6bGD6bGE6bGF6bGJ6bGK6bGO6bGP6bGQ6bGT6bGU6bGW6bGY6bGb6bGd6bGe6bGf6bGj6bGp6bGq6bGc6bGr6bGo6bGu6bGw6bGy6bG16bG36bG76bOm6bOy6bO36bO56bSL6bSC6bSR6bSX6bSY6bSc6bSd6bSe6bSv6bSw6bSy6bSz6bS06bS66bS86bWF6bS96bWC6bWD6bWH6bWK6bWT6bWU6bWf6bWj6bWi6bWl6bWp6bWq6bWr6bWw6bW26bW36bW7XCJdLFtcIjhmZWNhMVwiLFwi6bW86bW+6baD6baE6baG6baK6baN6baO6baS6baT6baV6baW6baX6baY6bah6baq6bas6bau6bax6ba16ba56ba86ba/6beD6beH6beJ6beK6beU6beV6beW6beX6bea6bee6bef6beg6bel6ben6bep6ber6beu6bew6bez6be06be+6biK6biC6biH6biO6biQ6biR6biS6biV6biW6biZ6bic6bid6bm66bm76bm86bqA6bqC6bqD6bqE6bqF6bqH6bqO6bqP6bqW6bqY6bqb6bqe6bqk6bqo6bqs6bqu6bqv6bqw6bqz6bq06bq16buG6buI6buL6buV6buf6buk6bun6bus6but6buu6buw6bux6buy6bu1XCJdLFtcIjhmZWRhMVwiLFwi6bu46bu/6byC6byD6byJ6byP6byQ6byR6byS6byU6byW6byX6byZ6bya6byb6byf6byi6bym6byq6byr6byv6byx6byy6by06by36by56by66by86by96by/6b2B6b2DXCIsNCxcIum9k+m9lem9lum9l+m9mOm9mum9nem9num9qOm9qem9rVwiLDQsXCLpvbPpvbXpvbrpvb3pvo/pvpDpvpHpvpLpvpTpvpbpvpfpvp7pvqHpvqLpvqPpvqVcIl1dXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaWNvbnYtbGl0ZS9lbmNvZGluZ3MvdGFibGVzL2V1Y2pwLmpzb25cbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcInVDaGFyc1wiOlsxMjgsMTY1LDE2OSwxNzgsMTg0LDIxNiwyMjYsMjM1LDIzOCwyNDQsMjQ4LDI1MSwyNTMsMjU4LDI3NiwyODQsMzAwLDMyNSwzMjksMzM0LDM2NCw0NjMsNDY1LDQ2Nyw0NjksNDcxLDQ3Myw0NzUsNDc3LDUwNiw1OTQsNjEwLDcxMiw3MTYsNzMwLDkzMCw5MzgsOTYyLDk3MCwxMDI2LDExMDQsMTEwNiw4MjA5LDgyMTUsODIxOCw4MjIyLDgyMzEsODI0MSw4MjQ0LDgyNDYsODI1Miw4MzY1LDg0NTIsODQ1NCw4NDU4LDg0NzEsODQ4Miw4NTU2LDg1NzAsODU5Niw4NjAyLDg3MTMsODcyMCw4NzIyLDg3MjYsODczMSw4NzM3LDg3NDAsODc0Miw4NzQ4LDg3NTEsODc2MCw4NzY2LDg3NzcsODc4MSw4Nzg3LDg4MDIsODgwOCw4ODE2LDg4NTQsODg1OCw4ODcwLDg4OTYsODk3OSw5MzIyLDkzNzIsOTU0OCw5NTg4LDk2MTYsOTYyMiw5NjM0LDk2NTIsOTY2Miw5NjcyLDk2NzYsOTY4MCw5NzAyLDk3MzUsOTczOCw5NzkzLDk3OTUsMTE5MDYsMTE5MDksMTE5MTMsMTE5MTcsMTE5MjgsMTE5NDQsMTE5NDcsMTE5NTEsMTE5NTYsMTE5NjAsMTE5NjQsMTE5NzksMTIyODQsMTIyOTIsMTIzMTIsMTIzMTksMTIzMzAsMTIzNTEsMTI0MzYsMTI0NDcsMTI1MzUsMTI1NDMsMTI1ODYsMTI4NDIsMTI4NTAsMTI5NjQsMTMyMDAsMTMyMTUsMTMyMTgsMTMyNTMsMTMyNjMsMTMyNjcsMTMyNzAsMTMzODQsMTM0MjgsMTM3MjcsMTM4MzksMTM4NTEsMTQ2MTcsMTQ3MDMsMTQ4MDEsMTQ4MTYsMTQ5NjQsMTUxODMsMTU0NzEsMTU1ODUsMTY0NzEsMTY3MzYsMTcyMDgsMTczMjUsMTczMzAsMTczNzQsMTc2MjMsMTc5OTcsMTgwMTgsMTgyMTIsMTgyMTgsMTgzMDEsMTgzMTgsMTg3NjAsMTg4MTEsMTg4MTQsMTg4MjAsMTg4MjMsMTg4NDQsMTg4NDgsMTg4NzIsMTk1NzYsMTk2MjAsMTk3MzgsMTk4ODcsNDA4NzAsNTkyNDQsNTkzMzYsNTkzNjcsNTk0MTMsNTk0MTcsNTk0MjMsNTk0MzEsNTk0MzcsNTk0NDMsNTk0NTIsNTk0NjAsNTk0NzgsNTk0OTMsNjM3ODksNjM4NjYsNjM4OTQsNjM5NzYsNjM5ODYsNjQwMTYsNjQwMTgsNjQwMjEsNjQwMjUsNjQwMzQsNjQwMzcsNjQwNDIsNjUwNzQsNjUwOTMsNjUxMDcsNjUxMTIsNjUxMjcsNjUxMzIsNjUzNzUsNjU1MTAsNjU1MzZdLFwiZ2JDaGFyc1wiOlswLDM2LDM4LDQ1LDUwLDgxLDg5LDk1LDk2LDEwMCwxMDMsMTA0LDEwNSwxMDksMTI2LDEzMywxNDgsMTcyLDE3NSwxNzksMjA4LDMwNiwzMDcsMzA4LDMwOSwzMTAsMzExLDMxMiwzMTMsMzQxLDQyOCw0NDMsNTQ0LDU0NSw1NTgsNzQxLDc0Miw3NDksNzUwLDgwNSw4MTksODIwLDc5MjIsNzkyNCw3OTI1LDc5MjcsNzkzNCw3OTQzLDc5NDQsNzk0NSw3OTUwLDgwNjIsODE0OCw4MTQ5LDgxNTIsODE2NCw4MTc0LDgyMzYsODI0MCw4MjYyLDgyNjQsODM3NCw4MzgwLDgzODEsODM4NCw4Mzg4LDgzOTAsODM5Miw4MzkzLDgzOTQsODM5Niw4NDAxLDg0MDYsODQxNiw4NDE5LDg0MjQsODQzNyw4NDM5LDg0NDUsODQ4Miw4NDg1LDg0OTYsODUyMSw4NjAzLDg5MzYsODk0Niw5MDQ2LDkwNTAsOTA2Myw5MDY2LDkwNzYsOTA5Miw5MTAwLDkxMDgsOTExMSw5MTEzLDkxMzEsOTE2Miw5MTY0LDkyMTgsOTIxOSwxMTMyOSwxMTMzMSwxMTMzNCwxMTMzNiwxMTM0NiwxMTM2MSwxMTM2MywxMTM2NiwxMTM3MCwxMTM3MiwxMTM3NSwxMTM4OSwxMTY4MiwxMTY4NiwxMTY4NywxMTY5MiwxMTY5NCwxMTcxNCwxMTcxNiwxMTcyMywxMTcyNSwxMTczMCwxMTczNiwxMTk4MiwxMTk4OSwxMjEwMiwxMjMzNiwxMjM0OCwxMjM1MCwxMjM4NCwxMjM5MywxMjM5NSwxMjM5NywxMjUxMCwxMjU1MywxMjg1MSwxMjk2MiwxMjk3MywxMzczOCwxMzgyMywxMzkxOSwxMzkzMywxNDA4MCwxNDI5OCwxNDU4NSwxNDY5OCwxNTU4MywxNTg0NywxNjMxOCwxNjQzNCwxNjQzOCwxNjQ4MSwxNjcyOSwxNzEwMiwxNzEyMiwxNzMxNSwxNzMyMCwxNzQwMiwxNzQxOCwxNzg1OSwxNzkwOSwxNzkxMSwxNzkxNSwxNzkxNiwxNzkzNiwxNzkzOSwxNzk2MSwxODY2NCwxODcwMywxODgxNCwxODk2MiwxOTA0MywzMzQ2OSwzMzQ3MCwzMzQ3MSwzMzQ4NCwzMzQ4NSwzMzQ5MCwzMzQ5NywzMzUwMSwzMzUwNSwzMzUxMywzMzUyMCwzMzUzNiwzMzU1MCwzNzg0NSwzNzkyMSwzNzk0OCwzODAyOSwzODAzOCwzODA2NCwzODA2NSwzODA2NiwzODA2OSwzODA3NSwzODA3NiwzODA3OCwzOTEwOCwzOTEwOSwzOTExMywzOTExNCwzOTExNSwzOTExNiwzOTI2NSwzOTM5NCwxODkwMDBdfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL3RhYmxlcy9nYjE4MDMwLXJhbmdlcy5qc29uXG4vLyBtb2R1bGUgaWQgPSAxMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBbW1wiMFwiLFwiXFx1MDAwMFwiLDEyN10sW1wiODE0MVwiLFwi6rCC6rCD6rCF6rCG6rCLXCIsNCxcIuqwmOqwnuqwn+qwoeqwouqwo+qwpVwiLDYsXCLqsK7qsLLqsLPqsLRcIl0sW1wiODE2MVwiLFwi6rC16rC26rC36rC66rC76rC96rC+6rC/6rGBXCIsOSxcIuqxjOqxjlwiLDUsXCLqsZVcIl0sW1wiODE4MVwiLFwi6rGW6rGX6rGZ6rGa6rGb6rGdXCIsMTgsXCLqsbLqsbPqsbXqsbbqsbnqsbtcIiw0LFwi6rKC6rKH6rKI6rKN6rKO6rKP6rKR6rKS6rKT6rKVXCIsNixcIuqynuqyolwiLDUsXCLqsqvqsq3qsq7qsrFcIiw2LFwi6rK66rK+6rK/6rOA6rOC6rOD6rOF6rOG6rOH6rOJ6rOK6rOL6rONXCIsNyxcIuqzluqzmFwiLDcsXCLqs6Lqs6Pqs6Xqs6bqs6nqs6vqs63qs67qs7Lqs7Tqs7dcIiw0LFwi6rO+6rO/6rSB6rSC6rSD6rSF6rSHXCIsNCxcIuq0juq0kOq0kuq0k1wiXSxbXCI4MjQxXCIsXCLqtJTqtJXqtJbqtJfqtJnqtJrqtJvqtJ3qtJ7qtJ/qtKFcIiw3LFwi6rSq6rSr6rSuXCIsNV0sW1wiODI2MVwiLFwi6rS26rS36rS56rS66rS76rS9XCIsNixcIuq1huq1iOq1ilwiLDUsXCLqtZHqtZLqtZPqtZXqtZbqtZdcIl0sW1wiODI4MVwiLFwi6rWZXCIsNyxcIuq1ouq1pFwiLDcsXCLqta7qta/qtbHqtbLqtbfqtbjqtbnqtbrqtb7qtoDqtoNcIiw0LFwi6raK6raL6raN6raO6raP6raRXCIsMTAsXCLqtp5cIiw1LFwi6ralXCIsMTcsXCLqtrhcIiw3LFwi6reC6reD6reF6reG6reH6reJXCIsNixcIuq3kuq3lFwiLDcsXCLqt53qt57qt5/qt6Hqt6Lqt6Pqt6VcIiwxOF0sW1wiODM0MVwiLFwi6re66re76re96re+6riCXCIsNSxcIuq4iuq4jOq4jlwiLDUsXCLquJVcIiw3XSxbXCI4MzYxXCIsXCLquJ1cIiwxOCxcIuq4suq4s+q4teq4tuq4ueq4u+q4vFwiXSxbXCI4MzgxXCIsXCLquL3quL7quL/quYLquYTquYfquYjquYnquYvquY/quZHquZLquZPquZXquZdcIiw0LFwi6rme6rmi6rmj6rmk6rmm6rmn6rmq6rmr6rmt6rmu6rmv6rmxXCIsNixcIuq5uuq5vlwiLDUsXCLquoZcIiw1LFwi6rqNXCIsNDYsXCLqur/qu4Hqu4Lqu4Pqu4VcIiw2LFwi6ruO6ruSXCIsNSxcIuq7muq7m+q7nVwiLDhdLFtcIjg0NDFcIixcIuq7puq7p+q7qeq7quq7rOq7rlwiLDUsXCLqu7Xqu7bqu7fqu7nqu7rqu7vqu71cIiw4XSxbXCI4NDYxXCIsXCLqvIbqvInqvIrqvIvqvIzqvI7qvI/qvJFcIiwxOF0sW1wiODQ4MVwiLFwi6rykXCIsNyxcIuq8ruq8r+q8seq8s+q8tVwiLDYsXCLqvL7qvYDqvYTqvYXqvYbqvYfqvYpcIiw1LFwi6r2RXCIsMTAsXCLqvZ5cIiw1LFwi6r2mXCIsMTgsXCLqvbpcIiw1LFwi6r6B6r6C6r6D6r6F6r6G6r6H6r6JXCIsNixcIuq+kuq+k+q+lOq+llwiLDUsXCLqvp1cIiwyNixcIuq+uuq+u+q+veq+vlwiXSxbXCI4NTQxXCIsXCLqvr/qv4FcIiw1LFwi6r+K6r+M6r+PXCIsNCxcIuq/lVwiLDYsXCLqv51cIiw0XSxbXCI4NTYxXCIsXCLqv6JcIiw1LFwi6r+qXCIsNSxcIuq/suq/s+q/teq/tuq/t+q/uVwiLDYsXCLrgILrgINcIl0sW1wiODU4MVwiLFwi64CFXCIsNixcIuuAjeuAjuuAj+uAkeuAkuuAk+uAlVwiLDYsXCLrgJ5cIiw5LFwi64CpXCIsMjYsXCLrgYbrgYfrgYnrgYvrgY3rgY/rgZDrgZHrgZLrgZbrgZjrgZrrgZvrgZzrgZ5cIiwyOSxcIuuBvuuBv+uCgeuCguuCg+uChVwiLDYsXCLrgo7rgpDrgpJcIiw1LFwi64Kb64Kd64Ke64Kj64KkXCJdLFtcIjg2NDFcIixcIuuCpeuCpuuCp+uCquuCsOuCsuuCtuuCt+uCueuCuuuCu+uCvVwiLDYsXCLrg4brg4pcIiw1LFwi64OSXCJdLFtcIjg2NjFcIixcIuuDk+uDleuDluuDl+uDmVwiLDYsXCLrg6Hrg6Lrg6Prg6Trg6ZcIiwxMF0sW1wiODY4MVwiLFwi64OxXCIsMjIsXCLrhIrrhI3rhI7rhI/rhJHrhJTrhJXrhJbrhJfrhJrrhJ5cIiw0LFwi64Sm64Sn64Sp64Sq64Sr64StXCIsNixcIuuEtuuEulwiLDUsXCLrhYLrhYPrhYXrhYbrhYfrhYlcIiw2LFwi64WS64WT64WW64WX64WZ64Wa64Wb64Wd64We64Wf64WhXCIsMjIsXCLrhbrrhbvrhb3rhb7rhb/rhoHrhoNcIiw0LFwi64aK64aM64aO64aP64aQ64aR64aV64aW64aX64aZ64aa64ab64adXCJdLFtcIjg3NDFcIixcIuuGnlwiLDksXCLrhqlcIiwxNV0sW1wiODc2MVwiLFwi64a5XCIsMTgsXCLrh43rh47rh4/rh5Hrh5Lrh5Prh5VcIl0sW1wiODc4MVwiLFwi64eWXCIsNSxcIuuHnuuHoFwiLDcsXCLrh6rrh6vrh63rh67rh6/rh7FcIiw3LFwi64e664e864e+XCIsNSxcIuuIhuuIh+uIieuIiuuIjVwiLDYsXCLriJbriJjriJpcIiw1LFwi64ihXCIsMTgsXCLriLVcIiw2LFwi64i9XCIsMjYsXCLriZnriZrriZvriZ3riZ7riZ/riaFcIiw2LFwi64mqXCIsNF0sW1wiODg0MVwiLFwi64mvXCIsNCxcIuuJtlwiLDUsXCLrib1cIiw2LFwi64qG64qH64qI64qKXCIsNF0sW1wiODg2MVwiLFwi64qP64qS64qT64qV64qW64qX64qbXCIsNCxcIuuKouuKpOuKp+uKqOuKqeuKq+uKreuKruuKr+uKseuKsuuKs+uKteuKtuuKt1wiXSxbXCI4ODgxXCIsXCLrirhcIiwxNSxcIuuLiuuLi+uLjeuLjuuLj+uLkeuLk1wiLDQsXCLri5rri5zri57ri5/ri6Dri6Hri6Pri6fri6nri6rri7Dri7Hri7Lri7bri7zri73ri77rjILrjIPrjIXrjIbrjIfrjIlcIiw2LFwi64yS64yWXCIsNSxcIuuMnVwiLDU0LFwi642X642Z642a642d642g642h642i642jXCJdLFtcIjg5NDFcIixcIuuNpuuNqOuNquuNrOuNreuNr+uNsuuNs+uNteuNtuuNt+uNuVwiLDYsXCLrjoLrjoZcIiw1LFwi646NXCJdLFtcIjg5NjFcIixcIuuOjuuOj+uOkeuOkuuOk+uOlVwiLDEwLFwi646iXCIsNSxcIuuOqeuOquuOq+uOrVwiXSxbXCI4OTgxXCIsXCLrjq5cIiwyMSxcIuuPhuuPh+uPieuPiuuPjeuPj+uPkeuPkuuPk+uPluuPmOuPmuuPnOuPnuuPn+uPoeuPouuPo+uPpeuPpuuPp+uPqVwiLDE4LFwi64+9XCIsMTgsXCLrkJFcIiw2LFwi65CZ65Ca65Cb65Cd65Ce65Cf65ChXCIsNixcIuuQquuQrFwiLDcsXCLrkLVcIiwxNV0sW1wiOGE0MVwiLFwi65GFXCIsMTAsXCLrkZLrkZPrkZXrkZbrkZfrkZlcIiw2LFwi65Gi65Gk65GmXCJdLFtcIjhhNjFcIixcIuuRp1wiLDQsXCLrka1cIiwxOCxcIuuSgeuSglwiXSxbXCI4YTgxXCIsXCLrkoNcIiw0LFwi65KJXCIsMTksXCLrkp5cIiw1LFwi65Kl65Km65Kn65Kp65Kq65Kr65KtXCIsNyxcIuuStuuSuOuSulwiLDUsXCLrk4Hrk4Lrk4Prk4Xrk4brk4frk4lcIiw2LFwi65OR65OS65OT65OU65OWXCIsNSxcIuuTnuuTn+uToeuTouuTpeuTp1wiLDQsXCLrk67rk7Drk7JcIiw1LFwi65O5XCIsMjYsXCLrlJbrlJfrlJnrlJrrlJ1cIl0sW1wiOGI0MVwiLFwi65SeXCIsNSxcIuuUpuuUq1wiLDQsXCLrlLLrlLPrlLXrlLbrlLfrlLlcIiw2LFwi65WC65WGXCJdLFtcIjhiNjFcIixcIuuVh+uViOuVieuViuuVjuuVj+uVkeuVkuuVk+uVlVwiLDYsXCLrlZ7rlaJcIiw4XSxbXCI4YjgxXCIsXCLrlatcIiw1MixcIuuWouuWo+uWpeuWpuuWp+uWqeuWrOuWreuWruuWr+uWsuuWtlwiLDQsXCLrlr7rlr/rl4Hrl4Lrl4Prl4VcIiw2LFwi65eO65eSXCIsNSxcIuuXmVwiLDE4LFwi65etXCIsMThdLFtcIjhjNDFcIixcIuuYgFwiLDE1LFwi65iS65iT65iV65iW65iX65iZXCIsNF0sW1wiOGM2MVwiLFwi65ieXCIsNixcIuuYplwiLDUsXCLrmK1cIiw2LFwi65i1XCIsNV0sW1wiOGM4MVwiLFwi65i7XCIsMTIsXCLrmYlcIiwyNixcIuuZpeuZpuuZp+uZqVwiLDUwLFwi65qe65qf65qh65qi65qj65qlXCIsNSxcIuuareuaruuar+uasOuaslwiLDE2XSxbXCI4ZDQxXCIsXCLrm4NcIiwxNixcIuublVwiLDhdLFtcIjhkNjFcIixcIuubnlwiLDE3LFwi65ux65uy65uz65u165u265u365u565u6XCJdLFtcIjhkODFcIixcIuubu1wiLDQsXCLrnILrnIPrnITrnIZcIiwzMyxcIuucquucq+ucreucruucsVwiLDYsXCLrnLrrnLxcIiw3LFwi652F652G652H652J652K652L652NXCIsNixcIuudllwiLDksXCLrnaHrnaLrnaPrnaXrnabrnafrnalcIiw2LFwi652y65206522XCIsNSxcIuudvuudv+uegeueguueg+uehVwiLDYsXCLrno7rnpPrnpTrnpXrnprrnpvrnp3rnp5cIl0sW1wiOGU0MVwiLFwi656f656hXCIsNixcIuuequuerlwiLDUsXCLrnrbrnrfrnrlcIiw4XSxbXCI4ZTYxXCIsXCLrn4JcIiw0LFwi65+I65+KXCIsMTldLFtcIjhlODFcIixcIuufnlwiLDEzLFwi65+u65+v65+x65+y65+z65+1XCIsNixcIuufvuugglwiLDQsXCLroIrroIvroI3roI7roI/roJFcIiw2LFwi66Ca66Cc66CeXCIsNSxcIuugpuugp+ugqeugquugq+ugrVwiLDYsXCLroLbroLpcIiw1LFwi66GB66GC66GD66GFXCIsMTEsXCLroZLroZRcIiw3LFwi66Ge66Gf66Gh66Gi66Gj66GlXCIsNixcIuuhruuhsOuhslwiLDUsXCLrobnrobrrobvrob1cIiw3XSxbXCI4ZjQxXCIsXCLrooVcIiw3LFwi66KOXCIsMTddLFtcIjhmNjFcIixcIuuioFwiLDcsXCLroqlcIiw2LFwi66Kx66Ky66Kz66K166K266K366K5XCIsNF0sW1wiOGY4MVwiLFwi66K+66K/66OC66OE66OGXCIsNSxcIuujjeujjuujj+ujkeujkuujk+ujlVwiLDcsXCLro57ro6Dro6JcIiw1LFwi66Oq66Or66Ot66Ou66Ov66OxXCIsNixcIuujuuujvOujvlwiLDUsXCLrpIVcIiwxOCxcIuukmVwiLDYsXCLrpKFcIiwyNixcIuukvuukv+ulgeulguulg+ulhVwiLDYsXCLrpY3rpY7rpZDrpZJcIiw1XSxbXCI5MDQxXCIsXCLrpZrrpZvrpZ3rpZ7rpZ/rpaFcIiw2LFwi66Wq66Ws66WuXCIsNSxcIuultuult+ulueuluuulu+ulvVwiXSxbXCI5MDYxXCIsXCLrpb5cIiw1LFwi66aG66aI66aL66aM66aPXCIsMTVdLFtcIjkwODFcIixcIuumn1wiLDEyLFwi66au66av66ax66ay66az66a1XCIsNixcIuumvuungOunglwiLDUsXCLrp4rrp4vrp43rp5NcIiw0LFwi66ea66ec66ef66eg66ei66em66en66ep66eq66er66etXCIsNixcIuuntuunu1wiLDQsXCLrqIJcIiw1LFwi66iJXCIsMTEsXCLrqJZcIiwzMyxcIuuouuuou+uoveuovuuov+upgeupg+uphOupheuphlwiXSxbXCI5MTQxXCIsXCLrqYfrqYrrqYzrqY/rqZDrqZHrqZLrqZbrqZfrqZnrqZrrqZvrqZ1cIiw2LFwi66mm66mqXCIsNV0sW1wiOTE2MVwiLFwi66my66mz66m166m266m366m5XCIsOSxcIuuqhuuqiOuqieuqiuuqi+uqjVwiLDVdLFtcIjkxODFcIixcIuuqk1wiLDIwLFwi66qq66qt66qu66qv66qx66qzXCIsNCxcIuuquuuqvOuqvlwiLDUsXCLrq4Xrq4brq4frq4lcIiwxNCxcIuurmlwiLDMzLFwi66u966u+66u/66yB66yC66yD66yFXCIsNyxcIuusjuuskOusklwiLDUsXCLrrJnrrJrrrJvrrJ3rrJ7rrJ/rrKFcIiw2XSxbXCI5MjQxXCIsXCLrrKjrrKrrrKxcIiw3LFwi66y366y566y666y/XCIsNCxcIuuthuutiOutiuuti+utjOutjuutkeutklwiXSxbXCI5MjYxXCIsXCLrrZPrrZXrrZbrrZfrrZlcIiw3LFwi662i662kXCIsNyxcIuutrVwiLDRdLFtcIjkyODFcIixcIuutslwiLDIxLFwi666J666K666L666N666O666P666RXCIsMTgsXCLrrqXrrqbrrqfrrqnrrqrrrqvrrq1cIiw2LFwi666166626664XCIsNyxcIuuvgeuvguuvg+uvheuvhuuvh+uviVwiLDYsXCLrr5Hrr5Lrr5RcIiwzNSxcIuuvuuuvu+uvveuvvuuwgVwiXSxbXCI5MzQxXCIsXCLrsINcIiw0LFwi67CK67CO67CQ67CS67CT67CZ67Ca67Cg67Ch67Ci67Cj67Cm67Co67Cq67Cr67Cs67Cu67Cv67Cy67Cz67C1XCJdLFtcIjkzNjFcIixcIuuwtuuwt+uwuVwiLDYsXCLrsYLrsYbrsYfrsYjrsYrrsYvrsY7rsY/rsZFcIiw4XSxbXCI5MzgxXCIsXCLrsZrrsZvrsZzrsZ5cIiwzNyxcIuuyhuuyh+uyieuyiuuyjeuyj1wiLDQsXCLrspbrspjrsptcIiw0LFwi67Ki67Kj67Kl67Km67KpXCIsNixcIuuysuuytlwiLDUsXCLrsr7rsr/rs4Hrs4Lrs4Prs4VcIiw3LFwi67OO67OS67OT67OU67OW67OX67OZ67Oa67Ob67OdXCIsMjIsXCLrs7frs7nrs7rrs7vrs71cIl0sW1wiOTQ0MVwiLFwi67O+XCIsNSxcIuu0huu0iOu0ilwiLDUsXCLrtJHrtJLrtJPrtJVcIiw4XSxbXCI5NDYxXCIsXCLrtJ5cIiw1LFwi67SlXCIsNixcIuu0rVwiLDEyXSxbXCI5NDgxXCIsXCLrtLpcIiw1LFwi67WBXCIsNixcIuu1iuu1i+u1jeu1juu1j+u1kVwiLDYsXCLrtZpcIiw5LFwi67Wl67Wm67Wn67WpXCIsMjIsXCLrtoLrtoPrtoXrtobrtotcIiw0LFwi67aS67aU67aW67aX67aY67ab67adXCIsNixcIuu2pVwiLDEwLFwi67axXCIsNixcIuu2uVwiLDI0XSxbXCI5NTQxXCIsXCLrt5Lrt5Prt5brt5frt5nrt5rrt5vrt51cIiwxMSxcIuu3qlwiLDUsXCLrt7FcIl0sW1wiOTU2MVwiLFwi67ey67ez67e167e267e367e5XCIsNixcIuu4geu4guu4hOu4hlwiLDUsXCLruI7ruI/ruJHruJLruJNcIl0sW1wiOTU4MVwiLFwi67iVXCIsNixcIuu4nuu4oFwiLDM1LFwi67mG67mH67mJ67mK67mL67mN67mPXCIsNCxcIuu5luu5mOu5nOu5neu5nuu5n+u5ouu5o+u5peu5puu5p+u5qeu5q1wiLDQsXCLrubLrubZcIiw0LFwi67m+67m/67qB67qC67qD67qFXCIsNixcIuu6juu6klwiLDUsXCLruppcIiwxMyxcIuu6qVwiLDE0XSxbXCI5NjQxXCIsXCLrurhcIiwyMyxcIuu7kuu7k1wiXSxbXCI5NjYxXCIsXCLru5Xru5bru5lcIiw2LFwi67uh67ui67umXCIsNSxcIuu7rVwiLDhdLFtcIjk2ODFcIixcIuu7tlwiLDEwLFwi67yCXCIsNSxcIuu8ilwiLDEzLFwi67ya67yeXCIsMzMsXCLrvYLrvYPrvYXrvYbrvYfrvYlcIiw2LFwi672S672T672U672WXCIsNDRdLFtcIjk3NDFcIixcIuu+g1wiLDE2LFwi676VXCIsOF0sW1wiOTc2MVwiLFwi676eXCIsMTcsXCLrvrFcIiw3XSxbXCI5NzgxXCIsXCLrvrlcIiwxMSxcIuu/hlwiLDUsXCLrv47rv4/rv5Hrv5Lrv5Prv5VcIiw2LFwi67+d67+e67+g67+iXCIsODksXCLsgL3sgL7sgL9cIl0sW1wiOTg0MVwiLFwi7IGAXCIsMTYsXCLsgZJcIiw1LFwi7IGZ7IGa7IGbXCJdLFtcIjk4NjFcIixcIuyBneyBnuyBn+yBoVwiLDYsXCLsgapcIiwxNV0sW1wiOTg4MVwiLFwi7IG6XCIsMjEsXCLsgpLsgpPsgpXsgpbsgpfsgplcIiw2LFwi7IKi7IKk7IKmXCIsNSxcIuyCruyCseyCsuyCt1wiLDQsXCLsgr7sg4Lsg4Psg4Tsg4bsg4fsg4rsg4vsg43sg47sg4/sg5FcIiw2LFwi7IOa7IOeXCIsNSxcIuyDpuyDp+yDqeyDquyDq+yDrVwiLDYsXCLsg7bsg7jsg7pcIiw1LFwi7ISB7ISC7ISD7ISF7ISG7ISH7ISJXCIsNixcIuyEkeyEkuyEk+yElOyEllwiLDUsXCLshKHshKLshKXshKjshKnshKrshKvshK5cIl0sW1wiOTk0MVwiLFwi7ISy7ISz7IS07IS17IS37IS67IS77IS97IS+7IS/7IWBXCIsNixcIuyFiuyFjlwiLDUsXCLshZbshZdcIl0sW1wiOTk2MVwiLFwi7IWZ7IWa7IWb7IWdXCIsNixcIuyFpuyFqlwiLDUsXCLshbHshbLshbPshbXshbbshbfshbnshbrshbtcIl0sW1wiOTk4MVwiLFwi7IW8XCIsOCxcIuyGhlwiLDUsXCLsho/shpHshpLshpPshpXshpdcIiw0LFwi7Iae7Iag7Iai7Iaj7Iak7Iam7Ian7Iaq7Iar7Iat7Iau7Iav7IaxXCIsMTEsXCLshr5cIiw1LFwi7IeF7IeG7IeH7IeJ7IeK7IeL7IeNXCIsNixcIuyHleyHluyHmVwiLDYsXCLsh6Hsh6Lsh6Psh6Xsh6bsh6fsh6lcIiw2LFwi7Iey7Ie0XCIsNyxcIuyHvuyHv+yIgeyIguyIg+yIhVwiLDYsXCLsiI7siJDsiJJcIiw1LFwi7Iia7Iib7Iid7Iie7Iih7Iii7IijXCJdLFtcIjlhNDFcIixcIuyIpOyIpeyIpuyIp+yIquyIrOyIruyIsOyIs+yItVwiLDE2XSxbXCI5YTYxXCIsXCLsiYbsiYfsiYlcIiw2LFwi7ImS7ImT7ImV7ImW7ImX7ImZXCIsNixcIuyJoeyJouyJo+yJpOyJplwiXSxbXCI5YTgxXCIsXCLsiadcIiw0LFwi7Imu7Imv7Imx7Imy7Imz7Im1XCIsNixcIuyJvuyKgOyKglwiLDUsXCLsiopcIiw1LFwi7IqRXCIsNixcIuyKmeyKmuyKnOyKnlwiLDUsXCLsiqbsiqfsiqnsiqrsiqvsiq5cIiw1LFwi7Iq27Iq47Iq6XCIsMzMsXCLsi57si5/si6Hsi6Lsi6VcIiw1LFwi7Iuu7Iuw7Iuy7Iuz7Iu07Iu17Iu37Iu67Iu97Iu+7Iu/7IyBXCIsNixcIuyMiuyMi+yMjuyMj1wiXSxbXCI5YjQxXCIsXCLsjJDsjJHsjJLsjJbsjJfsjJnsjJrsjJvsjJ1cIiw2LFwi7Iym7Iyn7IyqXCIsOF0sW1wiOWI2MVwiLFwi7IyzXCIsMTcsXCLsjYZcIiw3XSxbXCI5YjgxXCIsXCLsjY5cIiwyNSxcIuyNquyNq+yNreyNruyNr+yNseyNs1wiLDQsXCLsjbrsjbvsjb5cIiw1LFwi7I6F7I6G7I6H7I6J7I6K7I6L7I6NXCIsNTAsXCLsj4FcIiwyMixcIuyPmlwiXSxbXCI5YzQxXCIsXCLsj5vsj53sj57sj6Hsj6NcIiw0LFwi7I+q7I+r7I+s7I+uXCIsNSxcIuyPtuyPt+yPuVwiLDVdLFtcIjljNjFcIixcIuyPv1wiLDgsXCLskIlcIiw2LFwi7JCRXCIsOV0sW1wiOWM4MVwiLFwi7JCbXCIsOCxcIuyQpVwiLDYsXCLskK3skK7skK/skLHskLLskLPskLVcIiw2LFwi7JC+XCIsOSxcIuyRiVwiLDI2LFwi7JGm7JGn7JGp7JGq7JGr7JGtXCIsNixcIuyRtuyRt+yRuOyRulwiLDUsXCLskoFcIiwxOCxcIuySlVwiLDYsXCLskp1cIiwxMl0sW1wiOWQ0MVwiLFwi7JKqXCIsMTMsXCLskrnskrrskrvskr1cIiw4XSxbXCI5ZDYxXCIsXCLsk4ZcIiwyNV0sW1wiOWQ4MVwiLFwi7JOgXCIsOCxcIuyTqlwiLDUsXCLsk7Lsk7Psk7Xsk7bsk7fsk7nsk7vsk7zsk73sk77slIJcIiw5LFwi7JSN7JSO7JSP7JSR7JSS7JST7JSVXCIsNixcIuyUnVwiLDEwLFwi7JSq7JSr7JSt7JSu7JSv7JSxXCIsNixcIuyUuuyUvOyUvlwiLDUsXCLslYbslYfslYvslY/slZDslZHslZLslZbslZrslZvslZzslZ/slaLslaPslaXslabslafslalcIiw2LFwi7JWy7JW2XCIsNSxcIuyVvuyVv+yWgeyWguyWg+yWheyWhuyWiOyWieyWiuyWi+yWjuyWkOyWkuyWk+yWlFwiXSxbXCI5ZTQxXCIsXCLslpbslpnslprslpvslp3slp7slp/slqFcIiw3LFwi7JaqXCIsOSxcIuyWtlwiXSxbXCI5ZTYxXCIsXCLslrfslrrslr9cIiw0LFwi7JeL7JeN7JeP7JeS7JeT7JeV7JeW7JeX7JeZXCIsNixcIuyXouyXpOyXpuyXp1wiXSxbXCI5ZTgxXCIsXCLsl6jsl6nsl6rsl6vsl6/sl7Hsl7Lsl7Psl7Xsl7jsl7nsl7rsl7vsmILsmIPsmITsmInsmIrsmIvsmI3smI7smI/smJFcIiw2LFwi7Jia7JidXCIsNixcIuyYpuyYp+yYqeyYquyYq+yYr+yYseyYsuyYtuyYuOyYuuyYvOyYveyYvuyYv+yZguyZg+yZheyZhuyZh+yZiVwiLDYsXCLsmZLsmZZcIiw1LFwi7Jme7Jmf7JmhXCIsMTAsXCLsma3sma7smbDsmbJcIiw1LFwi7Jm67Jm77Jm97Jm+7Jm/7JqBXCIsNixcIuyaiuyajOyajlwiLDUsXCLsmpbsmpfsmpnsmprsmpvsmp1cIiw2LFwi7JqmXCJdLFtcIjlmNDFcIixcIuyaqOyaqlwiLDUsXCLsmrLsmrPsmrXsmrbsmrfsmrtcIiw0LFwi7JuC7JuE7JuGXCIsNSxcIuybjlwiXSxbXCI5ZjYxXCIsXCLsm4/sm5Hsm5Lsm5Psm5VcIiw2LFwi7Jue7Juf7JuiXCIsNSxcIuybquybq+ybreybruybr+ybseybslwiXSxbXCI5ZjgxXCIsXCLsm7NcIiw0LFwi7Ju67Ju77Ju87Ju+XCIsNSxcIuychuych+ycieyciuyci+ycjVwiLDYsXCLsnJbsnJjsnJpcIiw1LFwi7Jyi7Jyj7Jyl7Jym7Jyn7JypXCIsNixcIuycsuyctOyctuycuOycueycuuycu+ycvuycv+ydgeydguydg+ydhVwiLDQsXCLsnYvsnY7snZDsnZnsnZrsnZvsnZ3snZ7snZ/snaFcIiw2LFwi7J2p7J2q7J2sXCIsNyxcIuydtuydt+ydueyduuydu+ydv+yegOyegeyeguyehuyei+yejOyejeyej+yekuyek+yeleyemeyem1wiLDQsXCLsnqLsnqdcIiw0LFwi7J6u7J6v7J6x7J6y7J6z7J617J627J63XCJdLFtcImEwNDFcIixcIuyeuOyeueyeuuyeu+yevuyfglwiLDUsXCLsn4rsn4vsn43sn4/sn5FcIiw2LFwi7J+Z7J+a7J+b7J+cXCJdLFtcImEwNjFcIixcIuyfnlwiLDUsXCLsn6Xsn6bsn6fsn6nsn6rsn6vsn61cIiwxM10sW1wiYTA4MVwiLFwi7J+7XCIsNCxcIuygguygg+ygheyghuygh+ygieygi1wiLDQsXCLsoJLsoJTsoJdcIiw0LFwi7KCe7KCf7KCh7KCi7KCj7KClXCIsNixcIuygruygsOygslwiLDUsXCLsoLnsoLrsoLvsoL3soL7soL/soYFcIiw2LFwi7KGK7KGL7KGOXCIsNSxcIuyhlVwiLDI2LFwi7KGy7KGz7KG17KG27KG37KG57KG7XCIsNCxcIuyiguyihOyiiOyiieyiiuyijlwiLDUsXCLsopVcIiw3LFwi7KKe7KKg7KKi7KKj7KKkXCJdLFtcImExNDFcIixcIuyipeyipuyip+yiqVwiLDE4LFwi7KK+7KK/7KOA7KOBXCJdLFtcImExNjFcIixcIuyjguyjg+yjheyjhuyjh+yjieyjiuyji+yjjVwiLDYsXCLso5bso5jso5pcIiw1LFwi7KOi7KOj7KOlXCJdLFtcImExODFcIixcIuyjplwiLDE0LFwi7KO2XCIsNSxcIuyjvuyjv+ykgeykguykg+ykh1wiLDQsXCLspI7jgIDjgIHjgILCt+KApeKApsKo44CDwq3igJXiiKXvvLziiLzigJjigJnigJzigJ3jgJTjgJXjgIhcIiw5LFwiwrHDl8O34omg4omk4oml4oie4oi0wrDigLLigLPihIPihKvvv6Dvv6Hvv6XimYLimYDiiKDiiqXijJLiiILiiIfiiaHiiZLCp+KAu+KYhuKYheKXi+KXj+KXjuKXh+KXhuKWoeKWoOKWs+KWsuKWveKWvOKGkuKGkOKGkeKGk+KGlOOAk+KJquKJq+KImuKIveKIneKIteKIq+KIrOKIiOKIi+KKhuKKh+KKguKKg+KIquKIqeKIp+KIqO+/olwiXSxbXCJhMjQxXCIsXCLspJDspJJcIiw1LFwi7KSZXCIsMThdLFtcImEyNjFcIixcIuykrVwiLDYsXCLspLVcIiwxOF0sW1wiYTI4MVwiLFwi7KWIXCIsNyxcIuylkuylk+ylleylluyll+ylmVwiLDYsXCLspaLspaRcIiw3LFwi7KWt7KWu7KWv4oeS4oeU4oiA4oiDwrTvvZ7Lh8uYy53LmsuZwrjLm8Khwr/LkOKIruKIkeKIj8Kk4oSJ4oCw4peB4peA4pa34pa24pmk4pmg4pmh4pml4pmn4pmj4oqZ4peI4paj4peQ4peR4paS4pak4pal4pao4pan4pam4pap4pmo4piP4piO4pic4piewrbigKDigKHihpXihpfihpnihpbihpjima3imanimarimazjib/jiJzihJbjj4fihKLjj4Ljj5jihKHigqzCrlwiXSxbXCJhMzQxXCIsXCLspbHspbLspbPspbVcIiw2LFwi7KW9XCIsMTAsXCLsporspovspo3spo7spo9cIl0sW1wiYTM2MVwiLFwi7KaRXCIsNixcIuymmuymnOymnlwiLDE2XSxbXCJhMzgxXCIsXCLspq9cIiwxNixcIuynguyng+ynheynhuynieyni1wiLDQsXCLsp5Lsp5Tsp5fsp5jsp5vvvIFcIiw1OCxcIu+/pu+8vVwiLDMyLFwi77+jXCJdLFtcImE0NDFcIixcIuynnuynn+ynoeyno+ynpeynpuynqOynqeynquynq+ynruynslwiLDUsXCLsp7rsp7vsp73sp77sp7/sqIHsqILsqIPsqIRcIl0sW1wiYTQ2MVwiLFwi7KiF7KiG7KiH7KiK7KiOXCIsNSxcIuyoleyoluyol+yomVwiLDEyXSxbXCJhNDgxXCIsXCLsqKbsqKfsqKjsqKpcIiwyOCxcIuOEsVwiLDkzXSxbXCJhNTQxXCIsXCLsqYdcIiw0LFwi7KmO7KmP7KmR7KmS7KmT7KmVXCIsNixcIuypnuypolwiLDUsXCLsqansqapcIl0sW1wiYTU2MVwiLFwi7KmrXCIsMTcsXCLsqb5cIiw1LFwi7KqF7KqGXCJdLFtcImE1ODFcIixcIuyqh1wiLDE2LFwi7KqZXCIsMTQsXCLihbBcIiw5XSxbXCJhNWIwXCIsXCLihaBcIiw5XSxbXCJhNWMxXCIsXCLOkVwiLDE2LFwizqNcIiw2XSxbXCJhNWUxXCIsXCLOsVwiLDE2LFwiz4NcIiw2XSxbXCJhNjQxXCIsXCLsqqhcIiwxOSxcIuyqvuyqv+yrgeyrguyrg+yrhVwiXSxbXCJhNjYxXCIsXCLsq4ZcIiw1LFwi7KuO7KuQ7KuS7KuU7KuV7KuW7KuX7KuaXCIsNSxcIuyroVwiLDZdLFtcImE2ODFcIixcIuyrqOyrqeyrquyrq+yrrVwiLDYsXCLsq7VcIiwxOCxcIuysieysiuKUgOKUguKUjOKUkOKUmOKUlOKUnOKUrOKUpOKUtOKUvOKUgeKUg+KUj+KUk+KUm+KUl+KUo+KUs+KUq+KUu+KVi+KUoOKUr+KUqOKUt+KUv+KUneKUsOKUpeKUuOKVguKUkuKUkeKUmuKUmeKUluKUleKUjuKUjeKUnuKUn+KUoeKUouKUpuKUp+KUqeKUquKUreKUruKUseKUsuKUteKUtuKUueKUuuKUveKUvuKVgOKVgeKVg1wiLDddLFtcImE3NDFcIixcIuysi1wiLDQsXCLsrJHsrJLsrJPsrJXsrJbsrJfsrJlcIiw2LFwi7KyiXCIsN10sW1wiYTc2MVwiLFwi7KyqXCIsMjIsXCLsrYLsrYPsrYRcIl0sW1wiYTc4MVwiLFwi7K2F7K2G7K2H7K2K7K2L7K2N7K2O7K2P7K2RXCIsNixcIuytmuytm+ytnOytnlwiLDUsXCLsraVcIiw3LFwi446V446W446X4oST446Y44+E446j446k446l446m446ZXCIsOSxcIuOPiuOOjeOOjuOOj+OPj+OOiOOOieOPiOOOp+OOqOOOsFwiLDksXCLjjoBcIiw0LFwi4466XCIsNSxcIuOOkFwiLDQsXCLihKbjj4Djj4Hjjorjjovjjozjj5bjj4Xjjq3jjq7jjq/jj5vjjqnjjqrjjqvjjqzjj53jj5Djj5Pjj4Pjj4njj5zjj4ZcIl0sW1wiYTg0MVwiLFwi7K2tXCIsMTAsXCLsrbpcIiwxNF0sW1wiYTg2MVwiLFwi7K6JXCIsMTgsXCLsrp1cIiw2XSxbXCJhODgxXCIsXCLsrqRcIiwxOSxcIuyuuVwiLDExLFwiw4bDkMKqxKZcIl0sW1wiYThhNlwiLFwixLJcIl0sW1wiYThhOFwiLFwixL/FgcOYxZLCusOexabFilwiXSxbXCJhOGIxXCIsXCLjiaBcIiwyNyxcIuKTkFwiLDI1LFwi4pGgXCIsMTQsXCLCveKFk+KFlMK8wr7ihZvihZzihZ3ihZ5cIl0sW1wiYTk0MVwiLFwi7K+FXCIsMTQsXCLsr5VcIiwxMF0sW1wiYTk2MVwiLFwi7K+g7K+h7K+i7K+j7K+l7K+m7K+o7K+qXCIsMThdLFtcImE5ODFcIixcIuyvvVwiLDE0LFwi7LCO7LCP7LCR7LCS7LCT7LCVXCIsNixcIuywnuywn+ywoOywo+ywpMOmxJHDsMSnxLHEs8S4xYDFgsO4xZPDn8O+xafFi8WJ44iAXCIsMjcsXCLikpxcIiwyNSxcIuKRtFwiLDE0LFwiwrnCssKz4oG04oG/4oKB4oKC4oKD4oKEXCJdLFtcImFhNDFcIixcIuywpeywpuywquywq+ywreywr+ywsVwiLDYsXCLssLrssL9cIiw0LFwi7LGG7LGH7LGJ7LGK7LGL7LGN7LGOXCJdLFtcImFhNjFcIixcIuyxj1wiLDQsXCLssZbssZpcIiw1LFwi7LGh7LGi7LGj7LGl7LGn7LGpXCIsNixcIuyxseyxslwiXSxbXCJhYTgxXCIsXCLssbPssbTssbZcIiwyOSxcIuOBgVwiLDgyXSxbXCJhYjQxXCIsXCLsspTsspXsspbsspfssprsspvssp3ssp7ssp/ssqFcIiw2LFwi7LKq7LKuXCIsNSxcIuyytuyyt+yyuVwiXSxbXCJhYjYxXCIsXCLssrrssrvssr1cIiw2LFwi7LOG7LOI7LOKXCIsNSxcIuyzkeyzkuyzk+yzlVwiLDVdLFtcImFiODFcIixcIuyzm1wiLDgsXCLss6VcIiw2LFwi7LOt7LOu7LOv7LOxXCIsMTIsXCLjgqFcIiw4NV0sW1wiYWM0MVwiLFwi7LO+7LO/7LSA7LSCXCIsNSxcIuy0iuy0i+y0jey0juy0j+y0kVwiLDYsXCLstJrstJzstJ7stJ/stKBcIl0sW1wiYWM2MVwiLFwi7LSh7LSi7LSj7LSl7LSm7LSn7LSp7LSq7LSr7LStXCIsMTEsXCLstLpcIiw0XSxbXCJhYzgxXCIsXCLstL9cIiwyOCxcIuy1ney1nuy1n9CQXCIsNSxcItCB0JZcIiwyNV0sW1wiYWNkMVwiLFwi0LBcIiw1LFwi0ZHQtlwiLDI1XSxbXCJhZDQxXCIsXCLstaHstaLstaPstaVcIiw2LFwi7LWu7LWw7LWyXCIsNSxcIuy1uVwiLDddLFtcImFkNjFcIixcIuy2gVwiLDYsXCLstolcIiwxMCxcIuy2luy2l+y2mey2muy2m+y2ney2nuy2n1wiXSxbXCJhZDgxXCIsXCLstqDstqHstqLstqPstqbstqjstqpcIiw1LFwi7LaxXCIsMTgsXCLst4VcIl0sW1wiYWU0MVwiLFwi7LeGXCIsNSxcIuy3jey3juy3j+y3kVwiLDE2XSxbXCJhZTYxXCIsXCLst6JcIiw1LFwi7Lep7Leq7Ler7Let7Leu7Lev7LexXCIsNixcIuy3uuy3vOy3vlwiLDRdLFtcImFlODFcIixcIuy4g+y4hey4huy4h+y4iey4iuy4i+y4jVwiLDYsXCLsuJXsuJbsuJfsuJjsuJpcIiw1LFwi7Lii7Lij7Lil7Lim7Lin7Lip7Liq7LirXCJdLFtcImFmNDFcIixcIuy4rOy4rey4ruy4r+y4suy4tOy4tlwiLDE5XSxbXCJhZjYxXCIsXCLsuYpcIiwxMyxcIuy5muy5m+y5ney5nuy5olwiLDUsXCLsuarsuaxcIl0sW1wiYWY4MVwiLFwi7LmuXCIsNSxcIuy5tuy5t+y5uey5uuy5u+y5vVwiLDYsXCLsuobsuojsuopcIiw1LFwi7LqS7LqT7LqV7LqW7LqX7LqZXCJdLFtcImIwNDFcIixcIuy6mlwiLDUsXCLsuqLsuqZcIiw1LFwi7LquXCIsMTJdLFtcImIwNjFcIixcIuy6u1wiLDUsXCLsu4JcIiwxOV0sW1wiYjA4MVwiLFwi7LuWXCIsMTMsXCLsu6bsu6fsu6nsu6rsu61cIiw2LFwi7Lu27Lu6XCIsNSxcIuqwgOqwgeqwhOqwh+qwiOqwieqwiuqwkFwiLDcsXCLqsJlcIiw0LFwi6rCg6rCk6rCs6rCt6rCv6rCw6rCx6rC46rC56rC86rGA6rGL6rGN6rGU6rGY6rGc6rGw6rGx6rG06rG36rG46rG66rKA6rKB6rKD6rKE6rKF6rKG6rKJ6rKK6rKL6rKM6rKQ6rKU6rKc6rKd6rKf6rKg6rKh6rKo6rKp6rKq6rKs6rKv6rKw6rK46rK56rK76rK86rK96rOB6rOE6rOI6rOM6rOV6rOX6rOg6rOh6rOk6rOn6rOo6rOq6rOs6rOv6rOw6rOx6rOz6rO16rO26rO86rO96rSA6rSE6rSGXCJdLFtcImIxNDFcIixcIuy8guy8g+y8hey8huy8h+y8iVwiLDYsXCLsvJLsvJTsvJZcIiw1LFwi7Lyd7Lye7Lyf7Lyh7Lyi7LyjXCJdLFtcImIxNjFcIixcIuy8pVwiLDYsXCLsvK7svLJcIiw1LFwi7Ly5XCIsMTFdLFtcImIxODFcIixcIuy9hVwiLDE0LFwi7L2W7L2X7L2Z7L2a7L2b7L2dXCIsNixcIuy9puy9qOy9quy9q+y9rOq0jOq0jeq0j+q0keq0mOq0nOq0oOq0qeq0rOq0req0tOq0teq0uOq0vOq1hOq1heq1h+q1ieq1kOq1lOq1mOq1oeq1o+q1rOq1req1sOq1s+q1tOq1teq1tuq1u+q1vOq1veq1v+q2geq2guq2iOq2ieq2jOq2kOq2nOq2neq2pOq2t+q3gOq3geq3hOq3iOq3kOq3keq3k+q3nOq3oOq3pOq3uOq3ueq3vOq3v+q4gOq4geq4iOq4ieq4i+q4jeq4lOq4sOq4seq4tOq4t+q4uOq4uuq5gOq5geq5g+q5heq5huq5iuq5jOq5jeq5juq5kOq5lOq5luq5nOq5neq5n+q5oOq5oeq5peq5qOq5qeq5rOq5sOq5uFwiXSxbXCJiMjQxXCIsXCLsva3sva7sva/svbLsvbPsvbXsvbbsvbfsvblcIiw2LFwi7L6B7L6C7L6D7L6E7L6GXCIsNSxcIuy+jVwiXSxbXCJiMjYxXCIsXCLsvo5cIiwxOCxcIuy+olwiLDUsXCLsvqlcIl0sW1wiYjI4MVwiLFwi7L6qXCIsNSxcIuy+sVwiLDE4LFwi7L+FXCIsNixcIuq5ueq5u+q5vOq5veq6hOq6heq6jOq6vOq6veq6vuq7gOq7hOq7jOq7jeq7j+q7kOq7keq7mOq7meq7nOq7qOq7q+q7req7tOq7uOq7vOq8h+q8iOq8jeq8kOq8rOq8req8sOq8suq8tOq8vOq8veq8v+q9geq9guq9g+q9iOq9ieq9kOq9nOq9neq9pOq9peq9ueq+gOq+hOq+iOq+kOq+keq+leq+nOq+uOq+ueq+vOq/gOq/h+q/iOq/ieq/i+q/jeq/juq/lOq/nOq/qOq/qeq/sOq/seq/tOq/uOuAgOuAgeuAhOuAjOuAkOuAlOuAnOuAneuAqOuBhOuBheuBiOuBiuuBjOuBjuuBk+uBlOuBleuBl+uBmVwiXSxbXCJiMzQxXCIsXCLsv4xcIiwxOSxcIuy/ouy/o+y/pey/puy/p+y/qVwiXSxbXCJiMzYxXCIsXCLsv6pcIiw1LFwi7L+y7L+07L+2XCIsNSxcIuy/vey/vuy/v+2Age2Agu2Ag+2AhVwiLDVdLFtcImIzODFcIixcIu2Ai1wiLDUsXCLtgJJcIiw1LFwi7YCZXCIsMTksXCLrgZ3rgbzrgb3rgoDrgoTrgozrgo3rgo/rgpHrgpjrgpnrgprrgpzrgp/rgqDrgqHrgqLrgqjrgqnrgqtcIiw0LFwi64Kx64Kz64K064K164K464K864OE64OF64OH64OI64OJ64OQ64OR64OU64OY64Og64Ol64SI64SJ64SL64SM64SQ64SS64ST64SY64SZ64Sb64Sc64Sd64Sj64Sk64Sl64So64Ss64S064S164S364S464S564WA64WB64WE64WI64WQ64WR64WU64WV64WY64Wc64Wg64W464W564W864aA64aC64aI64aJ64aL64aN64aS64aT64aU64aY64ac64ao64eM64eQ64eU64ec64edXCJdLFtcImI0NDFcIixcIu2ArlwiLDUsXCLtgLbtgLftgLntgLrtgLvtgL1cIiw2LFwi7YGG7YGI7YGKXCIsNV0sW1wiYjQ2MVwiLFwi7YGR7YGS7YGT7YGV7YGW7YGX7YGZXCIsNixcIu2BoVwiLDEwLFwi7YGu7YGvXCJdLFtcImI0ODFcIixcIu2Bse2Bsu2Bs+2BtVwiLDYsXCLtgb7tgb/tgoDtgoJcIiwxOCxcIuuHn+uHqOuHqeuHrOuHsOuHueuHu+uHveuIhOuIheuIiOuIi+uIjOuIlOuIleuIl+uImeuIoOuItOuIvOuJmOuJnOuJoOuJqOuJqeuJtOuJteuJvOuKhOuKheuKieuKkOuKkeuKlOuKmOuKmeuKmuuKoOuKoeuKo+uKpeuKpuuKquuKrOuKsOuKtOuLiOuLieuLjOuLkOuLkuuLmOuLmeuLm+uLneuLouuLpOuLpeuLpuuLqOuLq1wiLDQsXCLri7Pri7Tri7Xri7dcIiw0LFwi64u/64yA64yB64yE64yI64yQ64yR64yT64yU64yV64yc642U642V642W642Y642b642c642e642f642k642lXCJdLFtcImI1NDFcIixcIu2ClVwiLDE0LFwi7YKm7YKn7YKp7YKq7YKr7YKtXCIsNV0sW1wiYjU2MVwiLFwi7YKz7YK27YK47YK6XCIsNSxcIu2Dgu2Dg+2Dhe2Dhu2Dh+2DilwiLDUsXCLtg5Ltg5ZcIiw0XSxbXCJiNTgxXCIsXCLtg5vtg57tg5/tg6Htg6Ltg6Ptg6VcIiw2LFwi7YOu7YOyXCIsNSxcIu2DuVwiLDExLFwi642n642p642r642u642w642x64206424646A646B646D646E646F646M646Q646U646g646h646o646s64+E64+F64+I64+L64+M64+O64+Q64+U64+V64+X64+Z64+b64+d64+g64+k64+o64+865CQ65CY65Cc65Cg65Co65Cp65Cr65C065GQ65GR65GU65GY65Gg65Gh65Gj65Gl65Gs65KA65KI65Kd65Kk65Ko65Ks65K165K365K565OA65OE65OI65OQ65OV65Oc65Od65Og65Oj65Ok65Om65Os65Ot65Ov65Ox65O465SU65SV65SY65Sb65Sc65Sk65Sl65Sn65So65Sp65Sq65Sw65Sx65S065S4XCJdLFtcImI2NDFcIixcIu2EhVwiLDcsXCLthI5cIiwxN10sW1wiYjY2MVwiLFwi7YSgXCIsMTUsXCLthLLthLPthLXthLbthLfthLnthLvthLzthL3thL5cIl0sW1wiYjY4MVwiLFwi7YS/7YWC7YWGXCIsNSxcIu2Fju2Fj+2Fke2Fku2Fk+2FlVwiLDYsXCLthZ7thaDthaJcIiw1LFwi7YWp7YWq7YWr7YWt65WA65WB65WD65WE65WF65WL65WM65WN65WQ65WU65Wc65Wd65Wf65Wg65Wh65ag65ah65ak65ao65aq65ar65aw65ax65az65a065a165a765a865a965eA65eE65eM65eN65eP65eQ65eR65eY65es65iQ65iR65iU65iY65il65is65i065mI65mk65mo65qc65qd65qg65qk65qr65qs65qx65uU65uw65u065u465yA65yB65yF65yo65yp65ys65yv65yw65y465y565y7652E652I652M652U652V652g652k652o652w652x652z652165286529656A656E656M656N656P656Q656R656S656W656XXCJdLFtcImI3NDFcIixcIu2FrlwiLDEzLFwi7YW9XCIsNixcIu2Ghe2Ghu2Gh+2Gie2GilwiXSxbXCJiNzYxXCIsXCLthotcIiwyMCxcIu2Gou2Go+2Gpe2Gpu2Gp1wiXSxbXCJiNzgxXCIsXCLthqlcIiw2LFwi7Yay7Ya07Ya27Ya37Ya47Ya57Ya77Ya97Ya+7Ya/7YeBXCIsMTQsXCLrnpjrnpnrnpzrnqDrnqjrnqnrnqvrnqzrnq3rnrTrnrXrnrjrn4frn4nrn6zrn63rn7Drn7Trn7zrn73rn7/roIDroIHroIfroIjroInroIzroJDroJjroJnroJvroJ3roKTroKXroKjroKzroLTroLXroLfroLjroLnroYDroYTroZHroZProZzroZ3roaDroaTroazroa3roa/robHrobjrobzroo3roqjrorDrorTrorjro4Dro4Hro4Pro4Xro4zro5Dro5Tro53ro5/ro6Hro6jro6nro6zro7Dro7jro7nro7vro73rpITrpJjrpKDrpLzrpL3rpYDrpYTrpYzrpY/rpZHrpZjrpZnrpZzrpaDrpajrpalcIl0sW1wiYjg0MVwiLFwi7YeQXCIsNyxcIu2HmVwiLDE3XSxbXCJiODYxXCIsXCLth6tcIiw4LFwi7Ye17Ye27Ye37Ye5XCIsMTNdLFtcImI4ODFcIixcIu2IiO2IilwiLDUsXCLtiJFcIiwyNCxcIuulq+ulreultOulteuluOulvOumhOumheumh+umieumiuumjeumjuumrOumreumsOumtOumvOumveumv+ungeuniOunieunjOunjlwiLDQsXCLrp5jrp5nrp5vrp53rp57rp6Hrp6Prp6Trp6Xrp6jrp6zrp7Trp7Xrp7frp7jrp7nrp7rrqIDrqIHrqIjrqJXrqLjrqLnrqLzrqYDrqYLrqYjrqYnrqYvrqY3rqY7rqZPrqZTrqZXrqZjrqZzrqaTrqaXrqafrqajrqanrqbDrqbHrqbTrqbjrqoPrqoTrqoXrqofrqozrqqjrqqnrqqvrqqzrqrDrqrLrqrjrqrnrqrvrqr3rq4Trq4jrq5jrq5nrq7xcIl0sW1wiYjk0MVwiLFwi7Yiq7Yir7Yiu7Yiv7Yix7Yiy7Yiz7Yi1XCIsNixcIu2Ivu2JgO2JglwiLDUsXCLtiYntiYrtiYvtiYxcIl0sW1wiYjk2MVwiLFwi7YmNXCIsMTQsXCLtiZ1cIiw2LFwi7Yml7Ymm7Ymn7YmoXCJdLFtcImI5ODFcIixcIu2JqVwiLDIyLFwi7YqC7YqD7YqF7YqG7YqH7YqJ7YqK7YqL7YqM66yA66yE66yN66yP66yR66yY66yc66yg66yp66yr66y066y166y266y466y766y866y966y+662E662F662H662J662N662P662Q662U662Y662h662j662s666I666M666Q666k666o666s6660666366+A66+E66+I66+Q66+T66+466+566+866+/67CA67CC67CI67CJ67CL67CM67CN67CP67CR67CUXCIsNCxcIuuwm1wiLDQsXCLrsKTrsKXrsKfrsKnrsK3rsLDrsLHrsLTrsLjrsYDrsYHrsYPrsYTrsYXrsYnrsYzrsY3rsZDrsZ3rsoTrsoXrsojrsovrsozrso7rspTrspXrspdcIl0sW1wiYmE0MVwiLFwi7YqN7YqO7YqP7YqS7YqT7YqU7YqWXCIsNSxcIu2Kne2Knu2Kn+2Koe2Kou2Ko+2KpVwiLDYsXCLtiq1cIl0sW1wiYmE2MVwiLFwi7Yqu7Yqv7Yqw7YqyXCIsNSxcIu2Kuu2Ku+2Kve2Kvu2Lge2Lg1wiLDQsXCLti4rti4xcIiw1XSxbXCJiYTgxXCIsXCLti5Lti5Pti5Xti5bti5fti5nti5rti5vti51cIiw2LFwi7YumXCIsOSxcIu2Lsu2Ls+2Lte2Ltu2Lt+2Lue2LuuuymeuymuuyoOuyoeuypOuyp+uyqOuysOuyseuys+uytOuyteuyvOuyveuzgOuzhOuzjeuzj+uzkOuzkeuzleuzmOuznOuztOuzteuztuuzuOuzvOu0hOu0heu0h+u0ieu0kOu0lOu0pOu0rOu1gOu1iOu1ieu1jOu1kOu1mOu1meu1pOu1qOu2gOu2geu2hOu2h+u2iOu2ieu2iuu2kOu2keu2k+u2leu2meu2muu2nOu2pOu2sOu2uOu3lOu3leu3mOu3nOu3qeu3sOu3tOu3uOu4gOu4g+u4heu4jOu4jeu4kOu4lOu4nOu4neu4n+u5hOu5heu5iOu5jOu5juu5lOu5leu5l+u5meu5muu5m+u5oOu5oeu5pFwiXSxbXCJiYjQxXCIsXCLti7tcIiw0LFwi7YyC7YyE7YyGXCIsNSxcIu2Mj+2Mke2Mku2Mk+2Mle2Ml1wiLDQsXCLtjJ7tjKLtjKNcIl0sW1wiYmI2MVwiLFwi7Yyk7Yym7Yyn7Yyq7Yyr7Yyt7Yyu7Yyv7YyxXCIsNixcIu2Muu2MvlwiLDUsXCLtjYbtjYftjYjtjYlcIl0sW1wiYmI4MVwiLFwi7Y2KXCIsMzEsXCLruajruarrubDrubHrubPrubTrubXrubvrubzrub3ruoDruoTruozruo3ruo/rupDrupHrupjrupnruqjru5Dru5Hru5Tru5fru5jru6Dru6Pru6Tru6Xru6zrvIHrvIjrvInrvJjrvJnrvJvrvJzrvJ3rvYDrvYHrvYTrvYjrvZDrvZHrvZXrvpTrvrDrv4Xrv4zrv43rv5Drv5Trv5zrv5/rv6HsgLzsgZHsgZjsgZzsgaDsgajsgansgpDsgpHsgpTsgpjsgqDsgqHsgqPsgqXsgqzsgq3sgq/sgrDsgrPsgrTsgrXsgrbsgrzsgr3sgr/sg4Dsg4Hsg4Xsg4jsg4nsg4zsg5Dsg5jsg5nsg5vsg5zsg53sg6RcIl0sW1wiYmM0MVwiLFwi7Y2qXCIsMTcsXCLtjb7tjb/tjoHtjoLtjoPtjoXtjobtjodcIl0sW1wiYmM2MVwiLFwi7Y6I7Y6J7Y6K7Y6L7Y6O7Y6SXCIsNSxcIu2Omu2Om+2One2Onu2On+2OoVwiLDYsXCLtjqrtjqztjq5cIl0sW1wiYmM4MVwiLFwi7Y6vXCIsNCxcIu2Ote2Otu2Ot+2Oue2Ouu2Ou+2OvVwiLDYsXCLtj4btj4ftj4pcIiw1LFwi7Y+RXCIsNSxcIuyDpeyDqOyDrOyDtOyDteyDt+yDueyEgOyEhOyEiOyEkOyEleyEnFwiLDQsXCLshKPshKTshKbshKfshKzshK3shK/shLDshLHshLbshLjshLnshLzshYDshYjshYnshYvshYzshY3shZTshZXshZjshZzshaTshaXshafshajshanshbDshbTshbjshoXshozsho3sho7shpDshpTshpbshpzshp3shp/shqHshqXshqjshqnshqzshrDshr3sh4Tsh4jsh4zsh5Tsh5fsh5jsh6Dsh6Tsh6jsh7Dsh7Hsh7Psh7zsh73siIDsiITsiIzsiI3siI/siJHsiJjsiJnsiJzsiJ/siKDsiKjsiKnsiKvsiK1cIl0sW1wiYmQ0MVwiLFwi7Y+X7Y+ZXCIsNyxcIu2Pou2PpFwiLDcsXCLtj67tj6/tj7Htj7Ltj7Ptj7Xtj7btj7dcIl0sW1wiYmQ2MVwiLFwi7Y+47Y+57Y+67Y+77Y++7ZCA7ZCCXCIsNSxcIu2QiVwiLDEzXSxbXCJiZDgxXCIsXCLtkJdcIiw1LFwi7ZCeXCIsMjUsXCLsiK/siLHsiLLsiLTsiYjsiZDsiZHsiZTsiZjsiaDsiaXsiazsia3sibDsibTsibzsib3sib/sioHsiojsionsipDsipjsipvsip3siqTsiqXsiqjsiqzsiq3sirTsirXsirfsirnsi5zsi53si6Dsi6Psi6Tsi6vsi6zsi63si6/si7Hsi7bsi7jsi7nsi7vsi7zsjIDsjIjsjInsjIzsjI3sjJPsjJTsjJXsjJjsjJzsjKTsjKXsjKjsjKnsjYXsjajsjansjazsjbDsjbLsjbjsjbnsjbzsjb3sjoTsjojsjozsj4Dsj5jsj5nsj5zsj5/sj6Dsj6Lsj6jsj6nsj63sj7Tsj7Xsj7jskIjskJDskKTskKzskLBcIl0sW1wiYmU0MVwiLFwi7ZC4XCIsNyxcIu2Rge2Rgu2Rg+2RhVwiLDE0XSxbXCJiZTYxXCIsXCLtkZRcIiw3LFwi7ZGd7ZGe7ZGf7ZGh7ZGi7ZGj7ZGlXCIsNyxcIu2Rru2RsO2Rse2RslwiXSxbXCJiZTgxXCIsXCLtkbNcIiw0LFwi7ZG67ZG77ZG97ZG+7ZKB7ZKDXCIsNCxcIu2Siu2SjO2SjlwiLDUsXCLtkpVcIiw4LFwi7JC07JC87JC97JGI7JGk7JGl7JGo7JGs7JG07JG17JG57JKA7JKU7JKc7JK47JK87JOp7JOw7JOx7JO07JO47JO67JO/7JSA7JSB7JSM7JSQ7JSU7JSc7JSo7JSp7JSs7JSw7JS47JS57JS77JS97JWE7JWF7JWI7JWJ7JWK7JWM7JWN7JWO7JWT7JWU7JWV7JWX7JWY7JWZ7JWd7JWe7JWg7JWh7JWk7JWo7JWw7JWx7JWz7JW07JW17JW87JW97JaA7JaE7JaH7JaM7JaN7JaP7JaR7JaV7JaX7JaY7Jac7Jag7Jap7Ja07Ja17Ja47Ja57Ja77Ja87Ja97Ja+7JeEXCIsNixcIuyXjOyXjlwiXSxbXCJiZjQxXCIsXCLtkp5cIiwxMCxcIu2SqlwiLDE0XSxbXCJiZjYxXCIsXCLtkrlcIiwxOCxcIu2Tje2Tju2Tj+2Tke2Tku2Tk+2TlVwiXSxbXCJiZjgxXCIsXCLtk5ZcIiw1LFwi7ZOd7ZOe7ZOgXCIsNyxcIu2Tqe2Tqu2Tq+2Tre2Tru2Tr+2TsVwiLDYsXCLtk7ntk7rtk7zsl5Dsl5Hsl5Tsl5jsl6Dsl6Hsl6Psl6Xsl6zsl63sl67sl7Dsl7Tsl7bsl7fsl7xcIiw1LFwi7JiF7JiG7JiH7JiI7JiM7JiQ7JiY7JiZ7Jib7Jic7Jik7Jil7Jio7Jis7Jit7Jiu7Jiw7Jiz7Ji07Ji17Ji37Ji57Ji77JmA7JmB7JmE7JmI7JmQ7JmR7JmT7JmU7JmV7Jmc7Jmd7Jmg7Jms7Jmv7Jmx7Jm47Jm57Jm87JqA7JqI7JqJ7JqL7JqN7JqU7JqV7JqY7Jqc7Jqk7Jql7Jqn7Jqp7Jqw7Jqx7Jq07Jq47Jq57Jq67JuA7JuB7JuD7JuF7JuM7JuN7JuQ7JuU7Juc7Jud7Jug7Juh7JuoXCJdLFtcImMwNDFcIixcIu2TvlwiLDUsXCLtlIXtlIbtlIftlIntlIrtlIvtlI1cIiw2LFwi7ZSW7ZSYXCIsNV0sW1wiYzA2MVwiLFwi7ZSeXCIsMjVdLFtcImMwODFcIixcIu2UuO2Uue2Uuu2Uu+2Uvu2Uv+2Vge2Vgu2Vg+2VhVwiLDYsXCLtlY7tlZDtlZJcIiw1LFwi7ZWa7ZWb7ZWd7ZWe7ZWf7ZWh7ZWi7ZWj7Jup7Jus7Juw7Ju47Ju57Ju97JyE7JyF7JyI7JyM7JyU7JyV7JyX7JyZ7Jyg7Jyh7Jyk7Jyo7Jyw7Jyx7Jyz7Jy17Jy37Jy87Jy97J2A7J2E7J2K7J2M7J2N7J2P7J2RXCIsNyxcIuydnOydoOydqOydq+ydtOydteyduOydvOydveydvuyeg+yehOyeheyeh+yeiOyeieyeiuyejuyekOyekeyelOyeluyel+yemOyemuyeoOyeoeyeo+yepOyepeyepuyerOyereyesOyetOyevOyeveyev+yfgOyfgeyfiOyfieyfjOyfjuyfkOyfmOyfneyfpOyfqOyfrOyggOyggeyghOygiOygilwiXSxbXCJjMTQxXCIsXCLtlaTtlabtlaftlartlaztla5cIiw1LFwi7ZW27ZW37ZW57ZW67ZW77ZW9XCIsNixcIu2Whu2Wiu2Wi1wiXSxbXCJjMTYxXCIsXCLtloztlo3tlo7tlo/tlpFcIiwxOSxcIu2Wpu2Wp1wiXSxbXCJjMTgxXCIsXCLtlqhcIiwzMSxcIuygkOygkeygk+ygleygluygnOygneygoOygpOygrOygreygr+ygseyguOygvOyhgOyhiOyhieyhjOyhjeyhlOyhsOyhseyhtOyhuOyhuuyigOyigeyig+yiheyihuyih+yii+yijOyijeyilOyineyin+yioeyiqOyivOyiveyjhOyjiOyjjOyjlOyjleyjl+yjmeyjoOyjoeyjpOyjteyjvOyjveykgOykhOykheykhuykjOykjeykj+ykkeykmOykrOyktOylkOylkeyllOylmOyloOyloeylo+ylrOylsOyltOylvOymiOymieymjOymkOymmOymmeymm+ymneyngOyngeynhOynh+yniOyniuynkOynkeynk1wiXSxbXCJjMjQxXCIsXCLtl4rtl4vtl43tl47tl4/tl5Htl5NcIiw0LFwi7Zea7Zec7ZeeXCIsNSxcIu2Xpu2Xp+2Xqe2Xqu2Xq+2Xre2XrlwiXSxbXCJjMjYxXCIsXCLtl69cIiw0LFwi7Ze27Ze47Ze6XCIsNSxcIu2Ygu2Yg+2Yhe2Yhu2Yh+2YiVwiLDYsXCLtmJJcIl0sW1wiYzI4MVwiLFwi7ZiWXCIsNSxcIu2Yne2Ynu2Yn+2Yoe2You2Yo+2YpVwiLDcsXCLtmK5cIiw5LFwi7Zi67Zi77KeV7KeW7KeZ7Kea7Kec7Ked7Keg7Kei7Kek7Ken7Kes7Ket7Kev7Kew7Kex7Ke47Ke57Ke87KiA7KiI7KiJ7KiL7KiM7KiN7KiU7KiY7Kip7KmM7KmN7KmQ7KmU7Kmc7Kmd7Kmf7Kmg7Kmh7Kmo7Km97KqE7KqY7Kq87Kq97KuA7KuE7KuM7KuN7KuP7KuR7KuT7KuY7KuZ7Kug7Kus7Ku07KyI7KyQ7KyU7KyY7Kyg7Kyh7K2B7K2I7K2J7K2M7K2Q7K2Y7K2Z7K2d7K2k7K247K257K6c7K647K+U7K+k7K+n7K+p7LCM7LCN7LCQ7LCU7LCc7LCd7LCh7LCi7LCn7LCo7LCp7LCs7LCu7LCw7LC47LC57LC7XCJdLFtcImMzNDFcIixcIu2Yve2Yvu2Yv+2Zge2Zgu2Zg+2ZhO2Zhu2Zh+2Ziu2ZjO2Zju2Zj+2ZkO2Zku2Zk+2Zlu2Zl+2Zme2Zmu2Zm+2ZnVwiLDRdLFtcImMzNjFcIixcIu2ZolwiLDQsXCLtmajtmapcIiw1LFwi7Zmy7Zmz7Zm1XCIsMTFdLFtcImMzODFcIixcIu2age2agu2ahO2ahlwiLDUsXCLtmo7tmo/tmpHtmpLtmpPtmpVcIiw3LFwi7Zqe7Zqg7ZqiXCIsNSxcIu2aqe2aquywvOywveywvuyxhOyxheyxiOyxjOyxlOyxleyxl+yxmOyxmeyxoOyxpOyxpuyxqOyxsOyxteyymOyymeyynOyyoOyyqOyyqeyyq+yyrOyyreyytOyyteyyuOyyvOyzhOyzheyzh+yzieyzkOyzlOyzpOyzrOyzsOy0gey0iOy0iey0jOy0kOy0mOy0mey0m+y0ney0pOy0qOy0rOy0uey1nOy1oOy1pOy1rOy1rey1r+y1sey1uOy2iOy2lOy2ley2mOy2nOy2pOy2pey2p+y2qey2sOy3hOy3jOy3kOy3qOy3rOy3sOy3uOy3uey3u+y3vey4hOy4iOy4jOy4lOy4mey4oOy4oey4pOy4qOy4sOy4sey4s+y4tVwiXSxbXCJjNDQxXCIsXCLtmqvtmq3tmq7tmq/tmrFcIiw3LFwi7Zq67Zq8XCIsNyxcIu2bhu2bh+2bie2biu2bi1wiXSxbXCJjNDYxXCIsXCLtm43tm47tm4/tm5Dtm5Ltm5Ptm5Xtm5btm5jtm5pcIiw1LFwi7Zuh7Zui7Zuj7Zul7Zum7Zun7ZupXCIsNF0sW1wiYzQ4MVwiLFwi7Zuu7Zuv7Zux7Zuy7Zuz7Zu07Zu2XCIsNSxcIu2bvu2bv+2cge2cgu2cg+2chVwiLDExLFwi7ZyS7ZyT7ZyU7LmY7LmZ7Lmc7Lmf7Lmg7Lmh7Lmo7Lmp7Lmr7Lmt7Lm07Lm17Lm47Lm87LqE7LqF7LqH7LqJ7LqQ7LqR7LqU7LqY7Lqg7Lqh7Lqj7Lqk7Lql7Lqs7Lqt7LuB7Luk7Lul7Luo7Lur7Lus7Lu07Lu17Lu37Lu47Lu57LyA7LyB7LyE7LyI7LyQ7LyR7LyT7LyV7Lyc7Lyg7Lyk7Lys7Lyt7Lyv7Lyw7Lyx7Ly47L2U7L2V7L2Y7L2c7L2k7L2l7L2n7L2p7L2w7L2x7L207L247L6A7L6F7L6M7L6h7L6o7L6w7L+E7L+g7L+h7L+k7L+o7L+w7L+x7L+z7L+17L+87YCA7YCE7YCR7YCY7YCt7YC07YC17YC47YC8XCJdLFtcImM1NDFcIixcIu2cle2clu2cl+2cmu2cm+2cne2cnu2cn+2coVwiLDYsXCLtnKrtnKztnK5cIiw1LFwi7Zy27Zy37Zy5XCJdLFtcImM1NjFcIixcIu2cuu2cu+2cvVwiLDYsXCLtnYXtnYbtnYjtnYpcIiw1LFwi7Z2S7Z2T7Z2V7Z2aXCIsNF0sW1wiYzU4MVwiLFwi7Z2f7Z2i7Z2k7Z2m7Z2n7Z2o7Z2q7Z2r7Z2t7Z2u7Z2v7Z2x7Z2y7Z2z7Z21XCIsNixcIu2dvu2dv+2egO2eglwiLDUsXCLtnortnovtgYTtgYXtgYftgYntgZDtgZTtgZjtgaDtgaztga3tgbDtgbTtgbztgb3tgoHtgqTtgqXtgqjtgqztgrTtgrXtgrftgrntg4Dtg4Htg4Ttg4jtg4ntg5Dtg5Htg5Ptg5Ttg5Xtg5ztg53tg6Dtg6Ttg6ztg63tg6/tg7Dtg7Htg7jthI3thLDthLHthLTthLjthLrthYDthYHthYPthYTthYXthYzthY3thZDthZTthZzthZ3thZ/thaHthajthazthbzthoTthojthqDthqHthqTthqjthrDthrHthrPthrXthrrthrzth4Dth5jth7Tth7jtiIftiIntiJDtiKztiK3tiLDtiLTtiLztiL3tiL/tiYHtiYjtiZxcIl0sW1wiYzY0MVwiLFwi7Z6N7Z6O7Z6P7Z6RXCIsNixcIu2emu2enO2enlwiLDVdLFtcImM2YTFcIixcIu2JpO2KgO2Kge2KhO2KiO2KkO2Kke2Kle2KnO2KoO2KpO2KrO2Kse2KuO2Kue2KvO2Kv+2LgO2Lgu2LiO2Lie2Li+2LlO2LmO2LnO2LpO2Lpe2LsO2Lse2LtO2LuO2MgO2Mge2Mg+2Mhe2MjO2Mje2Mju2MkO2MlO2Mlu2MnO2Mne2Mn+2MoO2Moe2Mpe2MqO2Mqe2MrO2MsO2MuO2Mue2Mu+2MvO2Mve2NhO2Nhe2NvO2Nve2OgO2OhO2OjO2Oje2Oj+2OkO2Oke2OmO2Ome2OnO2OoO2OqO2Oqe2Oq+2Ore2OtO2OuO2OvO2PhO2Phe2PiO2Pie2PkO2PmO2Poe2Po+2PrO2Pre2PsO2PtO2PvO2Pve2Pv+2QgVwiXSxbXCJjN2ExXCIsXCLtkIjtkJ3tkYDtkYTtkZztkaDtkaTtka3tka/tkbjtkbntkbztkb/tkoDtkoLtkojtkontkovtko3tkpTtkqntk4ztk5Dtk5Ttk5ztk5/tk6jtk6ztk7Dtk7jtk7vtk73tlITtlIjtlIztlJTtlJXtlJftlLztlL3tlYDtlYTtlYztlY3tlY/tlZHtlZjtlZntlZztlaDtlaXtlajtlantlavtla3tlbTtlbXtlbjtlbztloTtloXtloftlojtlontlpDtlqXtl4jtl4ntl4ztl5Dtl5Ltl5jtl5ntl5vtl53tl6Ttl6Xtl6jtl6ztl7Ttl7Xtl7ftl7ntmIDtmIHtmITtmIjtmJDtmJHtmJPtmJTtmJXtmJztmKBcIl0sW1wiYzhhMVwiLFwi7Zik7Zit7Zi47Zi57Zi87ZmA7ZmF7ZmI7ZmJ7ZmL7ZmN7ZmR7ZmU7ZmV7ZmY7Zmc7Zmn7Zmp7Zmw7Zmx7Zm07ZqD7ZqF7ZqM7ZqN7ZqQ7ZqU7Zqd7Zqf7Zqh7Zqo7Zqs7Zqw7Zq57Zq77ZuE7ZuF7ZuI7ZuM7ZuR7ZuU7ZuX7ZuZ7Zug7Zuk7Zuo7Zuw7Zu17Zu87Zu97ZyA7ZyE7ZyR7ZyY7ZyZ7Zyc7Zyg7Zyo7Zyp7Zyr7Zyt7Zy07Zy17Zy47Zy87Z2E7Z2H7Z2J7Z2Q7Z2R7Z2U7Z2W7Z2X7Z2Y7Z2Z7Z2g7Z2h7Z2j7Z2l7Z2p7Z2s7Z2w7Z207Z287Z297Z6B7Z6I7Z6J7Z6M7Z6Q7Z6Y7Z6Z7Z6b7Z6dXCJdLFtcImNhYTFcIixcIuS8veS9s+WBh+WDueWKoOWPr+WRteWTpeWYieWrgeWutuaah+aetuaet+afr+atjOePgueXgueovOiLm+iMhOihl+iiiOiotuiziOi3j+i7u+i/pumnleWIu+WNtOWQhOaBquaFpOauvOePj+iEmuimuuinkumWo+S+g+WIiuWivuWluOWnpuW5suW5ueaHh+aPgOadhuafrOahv+a+l+eZjueci+ejteeoiOerv+ewoeiCneiJruiJseirq+mWk+S5q+WWneabt+a4tOeio+erreiRm+ikkOidjumeqOWLmOWdjuWgquW1jOaEn+aGvuaIoeaVouafkeaphOa4m+eUmOeWs+ebo+eesOe0uumCr+mRkemRkum+lVwiXSxbXCJjYmExXCIsXCLljKPlsqznlLLog5vpiYDplpjliZvloIjlp5zlsqHltJflurflvLrlvYrmhbfmsZ/nlbrnlobns6DntbPntrHnvozohZToiKHolpHopYHorJvpi7zpmY3psYfku4vku7flgIvlh7HloY/mhLfmhL7mhajmlLnmp6rmvJHnlqXnmobnm5bnrofoiqXok4vvpIDpjqfplovlloDlrqLlnZHvpIHnsrPnvrnphrXlgKjljrvlsYXlt6jmi5Lmja7mk5rmk6fmuKDngqznpZvot53ouJ7vpILpgb3piYXpi7jkub7ku7blgaXlt77lu7rmhIbmpZfohbHomZTouYfpjbXpqKvkuZ7lgpHmnbDmoYDlhInlio3lipLmqqJcIl0sW1wiY2NhMVwiLFwi55686YiQ6buU5Yqr5oCv6L+y5YGI5oap5o+t5pOK5qC85qqE5r+A6IaI6Kah6ZqU5aCF54m954qs55SE57W557mt6IKp6KaL6K206YGj6bWR5oqJ5rG65r2U57WQ57y66Kij5YW85oWK566d6KyZ6YmX6Y6M5Lqs5L+T5YCe5YK+5YSG5YuB5YuN5Y2/5Z2w5aKD5bqa5b6R5oW25oas5pOO5pWs5pmv5pq75pu05qKX5raH54KF54Ox55Kf55Kl55OK55eZ56Gs56Os56uf56u257WF57aT6ICV6IC/6ISb6I6W6K2m6LyV6YCV6Y+h6aCD6aC46ama6a+o5L+C5ZWT5aC65aWR5a2j5bGG5oK45oiS5qGC5qKwXCJdLFtcImNkYTFcIixcIuajqOa6queVjOeZuOejjueoveezu+e5q+e5vOioiOiqoeiwv+majum3hOWPpOWPqeWRiuWRseWbuuWnkeWtpOWwu+W6q+aLt+aUt+aVheaVsuaaoOaer+angeayveeXvOeakOedvueov+e+lOiAg+iCoeiGj+iLpuiLveiPsOiXgeigseiitOiqpe+kg+i+nOmMrumbh+mhp+mrmOm8k+WTreaWm+absuaij+epgOiwt+m1oOWbsOWdpOW0keaYhuaiseajjea7vueQqOiinumvpOaxqO+khOmqqOS+m+WFrOWFseWKn+WtlOW3peaBkOaBreaLseaOp+aUu+ePmeepuuiao+iyoumej+S4suWvoeaIiOaenOeTnFwiXSxbXCJjZWExXCIsXCLnp5Hoj5PoqofoqrLot6jpgY7pjYvpoYblu5Pmp6jol7/pg63vpIXlhqDlrpjlr6zmhaPmo7rmrL7ngYznkK/nk5jnrqHnvZDoj4Xop4Dosqvpl5zppKjliK7mgZ3mi6zpgILkvorlhYnljKHlo5nlu6Pmm6DmtLjngprni4Lnj5bnrZDog7HpkZvljabmjpvnvavkuZblgoDloYrlo57mgKrmhKfmi5Dmp5DprYHlro/ntJjogrHovZ/kuqTlg5HlkqzllqzlrIzltqDlt6fmlKrmlY7moKHmqYvni6Hnmo7nn6/ntZ7nv7nohqDolY7om5/ovIPovY7pg4rppIPpqZXprqvkuJjkuYXkuZ3ku4fkv7Hlhbfli75cIl0sW1wiY2ZhMVwiLFwi5Y2A5Y+j5Y+l5ZKO5ZiU5Z215Z6i5a+H5baH5buQ5oe85ouY5pWR5p645p+p5qeL5q2Q5q+G5q+s5rGC5rqd54G454uX546W55CD556/55+p56m257W/6ICJ6Ie86IiF6IiK6Iuf6KGi6Kyz6LO86LuA6YCR6YKx6Ymk6Yq26aeS6amF6bOp6beX6b6c5ZyL5bGA6I+K6Z6g6Z6r6bq05ZCb56qY576k6KOZ6LuN6YOh5aCA5bGI5o6Y56qf5a6u5byT56m556qu6IqO6Lqs5YCm5Yi45Yu45Y235ZyI5ouz5o2y5qyK5reD55y35Y6l542X6JWo6Lm26ZeV5py65quD5r2w6Kmt6LuM6aWL76SG5pm35q246LK0XCJdLFtcImQwYTFcIixcIumsvO+kh+WPq+WcreWljuaPhuanu+ePquehheequuerheezvuiRteimj+i1s+mAtemWqOWLu+Wdh+eVh+etoOiPjOmInu+kiOapmOWFi+WJi+WKh+aIn+ajmOaltemameWDheWKpOWLpOaHg+aWpOagueanv+eRvueti+iKueiPq+imsuisuei/kemlie+kieS7iuWml+aTkuaYkeaqjueQtOemgeemveiKqeihvuihv+iln++kiumMpuS8i+WPiuaApeaJseaxsue0mue1puS6mOWFouefnOiCr+S8geS8juWFtuWGgOWXnOWZqOWcu+WfuuWfvOWklOWlh+Wmk+WvhOWykOW0juW3seW5vuW/jOaKgOaXl+aXo1wiXSxbXCJkMWExXCIsXCLmnJ7mnJ/mnZ7mo4vmo4TmqZ/mrLrmsKPmsb3msoLmt4fnjpjnkKbnkKrnkoLnkqPnlbjnlb/nooHno6/npYHnpYfnpYjnpbrnrpXntIDntrrnvojogIbogK3ogozoqJjorY/osYjotbfpjKHpjKTpo6LppZHpqI7pqI/pqaXpupLnt4rkvbblkInmi67moZTph5HllqvlhLrvpIvvpIzlqJzmh6bvpI3mi4/mi7/vpI5cIiw1LFwi6YKj76SUXCIsNCxcIuirvu+kme+kmu+km++knOaalu+kneeFlu+knu+kn+mbo++koOaNj+aNuuWNl++koeaej+aloOa5s++koueUt++ko++kpO+kpVwiXSxbXCJkMmExXCIsXCLntI3vpKbvpKfoobLlm4rlqJjvpKhcIiw0LFwi5LmD76St5YWn5aWI5p+w6ICQ76Su5aWz5bm05pKa56eK5b+15oGs5ouI5o275a+n5a+X5Yqq76Sv5aW05byp5oCS76Sw76Sx76Sy55GZ76SzXCIsNSxcIumnke+kuVwiLDEwLFwi5r+D76WE76WF6Ia/6L6y5oOx76WG76WH6IWm76WI76WJ5bC/76WKXCIsNyxcIuWrqeiopeadu+e0kO+lklwiLDUsXCLog73vpZjvpZnlsLzms6XljL/murrlpJrojLZcIl0sW1wiZDNhMVwiLFwi5Li55Lq25L2G5Zau5ZyY5aOH5b2W5pa35pem5qqA5q615rmN55+t56uv57Ce57ee6JuL6KKS6YSy6Y2b5pK75r6+542655a46YGU5ZWW5Z2N5oa65pOU5puH5reh5rmb5r2t5r6555ew6IGD6Ia96JWB6KaD6KuH6K2a6Yyf5rKT55WT562U6LiP6YGd5ZSQ5aCC5aGY5bmi5oiH5pKe5qOg55W257OW6J6z6buo5Luj5Z6I5Z2u5aSn5bCN5bKx5bi25b6F5oi05pOh546z6Ie66KKL6LK46ZqK6bub5a6F5b635oKz5YCS5YiA5Yiw5ZyW5aC15aGX5bCO5bGg5bO25baL5bqm5b6S5oK85oyR5o6J5pCX5qGDXCJdLFtcImQ0YTFcIixcIuajueargua3mOa4oea7lOa/pOeHvuebnOedueemseeou+iQhOimqeizrei3s+i5iOmAg+mAlOmBk+mDvemNjemZtumfnOavkueAhueJmOeKoueNqOedo+emv+evpOe6m+iugOWiqeaDh+aVpuaXveaavuayjOeEnueHieixmumgk+S5reeqgeS7neWGrOWHjeWLleWQjOaGp+adseahkOajn+a0nua9vOeWvOees+erpeiDtOiRo+mKheWFnOaWl+adnOaek+eXmOerh+iNs++lmuixhumAl+mgreWxr+iHgOiKmumBgemBr+mIjeW+l+W2neapmeeHiOeZu+etieiXpOishOmEp+mosOWWh+aHtu+lm+eZqee+hVwiXSxbXCJkNWExXCIsXCLomL/onrroo7jpgo/vpZzmtJvng5nnj57ntaHokL3vpZ3pharpp7HvpZ7kuoLljbXmrITmrJLngL7niJvomK3puJ7liYzovqPltZDmk6XmlKzmrJbmv6vnsYPnupzol43opaTopr3mi4noh5jooJ/lu4rmnJfmtarni7znkIXnka/onoLpg57kvobltI3lvqDokIrlhrfmjqDnlaXkuq7lgIblhanlh4nmooHmqJHnsq7nsrHns6foia/oq5LovJvph4/kvrblhLfli7XlkYLlu6zmha7miL7ml4Xmq5rmv77npKrol5zooKPplq3pqaLpqarpupfpu47lipvmm4bmrbfngJ3npKvovaLpnYLmhpDmiIDmlKPmvKNcIl0sW1wiZDZhMVwiLFwi54WJ55KJ57e06IGv6JOu6Lym6YCj6Y2K5Ya95YiX5Yqj5rSM54OI6KOC5buJ5paC5q6u5r+C57C+54215Luk5Ly25Zu576Wf5bK65ba65oCc546y56yt576a57+O6IGG6YCe6Yi06Zu26Z2I6aCY6b2h5L6L5r6n56au6Ya06Zq35Yue76Wg5pKI5pOE5quT5r2e54CY54iQ55un6ICB6JiG6Jmc6Lev6LyF6Zyy6a2v6be66bm156KM56W/57ag6I+J6YyE6bm/6bqT6KuW5aOf5byE5pyn54Cn55OP57Gg6IG+5YSh54Co54mi56OK6LOC6LOa6LO06Zu35LqG5YOa5a+u5buW5paZ54eO55mC556t6IGK6JO8XCJdLFtcImQ3YTFcIixcIumBvOmsp+m+jeWjmOWpgeWxouaok+a3mua8j+eYu+e0r+e4t+iUnuikuOmPpOmZi+WKieaXkuafs+amtOa1gea6nOeAj+eQieeRoOeVmeeYpOehq+isrOmhnuWFreaIrumZuOS+luWAq+W0mea3que2uOi8quW+i+aFhOagl++loemahuWLkuiCi+WHnOWHjOalnueonOe2vuiPsemZteS/muWIqeWOmOWQj+WUjuWxpeaCp+adjuaiqOa1rOeKgeeLuOeQhueSg++loueXouexrOe9uee+uOiOieijj+ijoemHjOmHkOmboumvieWQnea9vueHkOeSmOiXuui6qumao+mxl+m6n+ael+a3i+eQs+iHqOmcluegrFwiXSxbXCJkOGExXCIsXCLnq4vnrKDnspLmkannkarnl7Lnorzno6jppqzprZTpurvlr57luZXmvKDohpzojqvpgojkuIfljY3lqKnlt5LlvY7mhaLmjL3mmanmm7zmu7/mvKvngaPnnp7okKzolJPooLvovJPppYXpsLvllJzmirnmnKvmsqvojInoparpnbrkuqHlpoTlv5jlv5nmnJvntrLnvZToipLojKvojr3ovJ7pgpnln4vlprnlqpLlr5DmmKfmnprmooXmr4/nhaTnvbXosrfos6PpgoHprYXohIjosorpmYzpqYDpuqXlrZ/msJPnjJvnm7Lnm5/okIzlhqroppPlhY3lhpXli4nmo4nmspTnnITnnKDntr/nt6zpnaLpurXmu4VcIl0sW1wiZDlhMVwiLFwi6JSR5Yal5ZCN5ZG95piO5pqd5qSn5rqf55q/556R6IyX6JOC6J6f6YWp6YqY6bO06KKC5L6u5YaS5Yuf5aeG5bi95oWV5pG45pG55pqu5p+Q5qih5q+N5q+b54mf54mh55GB55y455+b6ICX6Iq86IyF6KyA6Kyo6LKM5pyo5rKQ54mn55uu552m56mG6bap5q2/5rKS5aSi5pym6JKZ5Y2v5aKT5aaZ5buf5o+P5pi05p2z5ri654yr56uX6IuX6Yyo5YuZ5ber5oau5oeL5oiK5ouH5pKr5peg5qWZ5q2m5q+L54Sh54+355Wd57mG6Iie6IyC6JWq6Kqj6LK/6Zyn6bWh5aKo6buY5YCR5YiO5ZC75ZWP5paHXCJdLFtcImRhYTFcIixcIuaxtue0iue0i+iBnuiaiumWgOmbr+WLv+ayleeJqeWRs+WqmuWwvuW1i+W9jOW+ruacquaitualo+a4vOa5hOecieexs+e+juiWh+isjui/t+mdoem7tOWyt+aCtuaEjeaGq+aVj+aXu+aXvOawkeazr+eOn+ePiee3oemWlOWvhuicnOiskOWJneWNmuaLjeaQj+aSsuactOaouOaziuePgOeSnueulOeylee4m+iGiuiItuiWhOi/q+mbuemngeS8tOWNiuWPjeWPm+aLjOaQrOaUgOaWkeang+azrua9mOePreeVlOeYouebpOebvOejkOeju+ekrOe1huiIrOifoOi/lOmgkumjr+WLg+aLlOaSpea4pOa9kVwiXSxbXCJkYmExXCIsXCLnmbzot4vphrHpiaLpq67prYPlgKPlgo3lnYrlpqjlsKjluYflvbfmiL/mlL7mlrnml4HmmInmnovmppzmu4Lno4XntKHogqrohoDoiKvoirPokqHomozoqKrorJfpgqbpmLLpvpDlgI3kv7PvpaPln7nlvpjmi5zmjpLmna/muYPnhJnnm4Pog4zog5roo7Too7XopJnos6DovKnphY3pmarkvK/kvbDluJvmn4/moKLnmb3nmb7prYTluaHmqIrnhannh5TnlarvpaTnuYHolYPol6npo5zkvJDnrY/nvbDplqXlh6HluIbmorXmsL7msY7ms5vniq/nr4TojIPms5XnkLrlg7vliojlo4Hmk5jmqpfnkqfnmZZcIl0sW1wiZGNhMVwiLFwi56Kn6JiX6Zei6Zy576Wl5Y2e5byB6K6K6L6o6L6v6YKK5Yil556l6bGJ6byI5LiZ5YCC5YW15bGb5bm35pie5pi65p+E5qOF54Kz55SB55eF56eJ56ud6Lyn6aSg6aiI5L+d5aCh5aCx5a+25pmu5q2l5rSR5rm65r2954+k55Sr6I+p6KOc6KST6K2c6LyU5LyP5YOV5YyQ5Y2c5a6T5b6p5pyN56aP6IW56Iyv6JSU6KSH6KaG6Ly56Ly76aal6bCS5pys5Lm25L+45aWJ5bCB5bOv5bOw5o2n5qOS54O954ai55Cr57ir6JOs6JyC6YCi6YuS6bOz5LiN5LuY5L+v5YKF5YmW5Ymv5ZCm5ZKQ5Z+g5aSr5ammXCJdLFtcImRkYTFcIixcIuWtmuWtteWvjOW6nO+lpuaJtuaVt+aWp+a1rua6peeItuespuewv+e8tuiFkOiFkeiGmuiJgOiKmeiOqeiog+iyoOizpuizu+i1tOi2uumDqOmHnOmYnOmZhOmnmemzp+WMl+WIhuWQqeWZtOWis+WllOWlruW/v+aGpOaJruaYkOaxvueEmuebhueyieeznue0m+iKrOizgembsO+lp+S9m+W8l+W9v+aLguW0qeaci+ajmuehvOe5g+m1rOS4leWCmeWMleWMquWNkeWmg+WpouW6h+aCsuaGiuaJieaJueaWkOaeh+amp+avlOavluavl+avmOayuO+lqOeQteeXuuegkueikeenleenmOeyg+e3i+e/oeiCpVwiXSxbXCJkZWExXCIsXCLohL7oh4Loj7LonJroo6joqrnorazosrvphJnpnZ7po5vpvLvlmqzlrKrlvazmlozmqrPmrq/mtZzmv7HngJXniZ3njq3osqfos5PpoLvmhpHmsLfogZjpqIHkuY3kuovkupvku5XkvLrkvLzkvb/kv5/lg7/lj7Llj7jllIbll6Plm5vlo6vlpaLlqJHlr6vlr7rlsITlt7PluKvlvpnmgJ3mjajmlpzmlq/mn7bmn7vmoq3mrbvmspnms5fmuKPngInnjYXnoILnpL7npYDnpaDnp4Hnr6nntJfntbLogoboiI3ojo7ok5Hom4foo5/oqZDoqZ7orJ3os5zotabovq3pgqrpo7zpp5/pup3liYrvpanmnJTvpapcIl0sW1wiZGZhMVwiLFwi5YKY5Yiq5bGx5pWj5rGV54+K55Sj55ad566X6JKc6YW46Zyw5Lm35pKS5q6654We6Jap5LiJ76Wr5p2J5qOu5riX6Iqf6JSY6KGr5o+35r6B6YiS6aKv5LiK5YK35YOP5YSf5ZWG5Zaq5ZiX5a2A5bCZ5bOg5bi45bqK5bqg5buC5oOz5qGR5qmh5rmY54i954mA54uA55u456Wl566x57+U6KOz6Ke06Kmz6LGh6LOe6Zyc5aGe55K96LO95ZeH76Ws56mh57Si6Imy54my55Sf55Sl76Wt56yZ5aKF5aO75ba85bqP5bq25b6Q5oGV5oqS5o2/5pWN5pqR5puZ5pu45qCW5qOy54qA55Ge562u57Wu57eW572yXCJdLFtcImUwYTFcIixcIuiDpeiIkuiWr+ilv+iqk+mAnemLpOm7jem8oOWkleWlreW4reaDnOaYlOaZs+aekOaxkOa3hea9n+efs+eiqeiThumHi+mMq+S7meWDiuWFiOWWhOWsi+Wuo+aJh+aVvuaXi+a4sueFveeQgeeRhOeSh+eSv+eZrOemque3mue5lee+qOiFuuiGs+iIueiYmuifrOiptei3o+mBuOmKkemQpemljemuruWNqOWxkeallOazhOa0qea4q+iIjOiWm+iku+ioreiqqumbqum9p+WJoeaaueausue6luifvui0jemWg+mZneaUnea2ieeHru+lruWfjuWnk+WurOaAp+aDuuaIkOaYn+aZn+eMqeePueebm+ecgeetrFwiXSxbXCJlMWExXCIsXCLogZbogbLohaXoqqDphpLkuJbli6LmrbLmtJfnqIXnrLnntLDvpa/osrDlj6zlmK/loZHlrrXlsI/lsJHlt6LmiYDmjoPmkJTmmK3morPmsrzmtojmuq/ngJ/ngqTnh5LnlKbnlo/nlo7nmJnnrJHnr6DnsKvntKDntLnolKzola3omIfoqLTpgI3pgaHpgrXpirfpn7bpqLfkv5flsazmnZ/mtpHnsp/nuozorJbotJbpgJ/lravlt73mkI3ok4DpgZzpo6Hnjoflrovmgprmnb7mt57oqJ/oqqbpgIHpoIzliLfvpbDngZHnoo7pjpboobDph5fkv67lj5fll73lm5rlnoLlo73lq4Llrojlsqvls4DluKXmhIFcIl0sW1wiZTJhMVwiLFwi5oiN5omL5o6I5pCc5pS25pW45qi55q6K5rC05rSZ5ryx54en54up542455CH55Ky55im552h56eA56mX56uq57K557aP57as57mh576e6ISp6Iyx6JKQ6JOa6Jeq6KKW6Kqw6K6Q6Ly46YGC6YKD6YWs6YqW6Yq56ZqL6Zqn6Zqo6ZuW6ZyA6aCI6aaW6auT6aya5Y+U5aG+5aSZ5a2w5a6/5reR5r2a54af55Ch55K56IKF6I+95beh5b6H5b6q5oGC5pes5qCS5qWv5qmT5q6J5rS15rez54+j55u+556s562N57SU6ISj6Iic6I2A6JO06JWj6Kmi6KuE6YaH6Yye6aCG6aa05oiM6KGT6L+w6Yml5bSH5bSnXCJdLFtcImUzYTFcIixcIuW1qeeRn+iGneidqOa/leaLvue/kuiktuilsuS4nuS5mOWDp+WLneWNh+aJv+aYh+e5qeighemZnuS+jeWMmeWYtuWni+WqpOWwuOWxjuWxjeW4guW8keaBg+aWveaYr+aZguaevuaftOeMnOefouekuue/heiSlOiTjeimluippuipqeiroeixleixuuWftOWvlOW8j+aBr+aLreakjeaulua5nOeGhOevkuidleitmOi7vumjn+mjvuS8uOS+geS/oeWRu+WooOWuuOaEvOaWsOaZqOeHvOeUs+elnue0s+iFjuiHo+iOmOiWquiXjuicg+ioiui6q+i+m++lsei/heWkseWupOWvpuaCieWvqeWwi+W/g+aygVwiXSxbXCJlNGExXCIsXCLvpbLmt7HngIvnlJroiq/oq7bku4DljYHvpbPpm5nmsI/kup7kv4TlhZLllZ7lqKXls6jmiJHniZnoir3ojqrom77ooZnoqJ3pmL/pm4XppJPptInptZ3loIrlsrPltr3luYTmg6HmhJXmj6HmqILmuKXphILpjZTpoY7psJDpvbflronlsrjmjInmmY/moYjnnLzpm4Hpno3poZTprp/mlqHorIHou4vplrzllLXlsqnlt5blurXmmpfnmYzoj7Tpl4flo5Pmirzni47ptKjku7DlpK7mgI/mmLvmroPnp6fptKbljpPlk4Dln4PltJbmhJvmm5bmtq/noo3oib7pmpjpnYTljoTmibzmjpbmtrLnuIrohYvpoY1cIl0sW1wiZTVhMVwiLFwi5qu7572M6bav6bia5Lmf5YC75Ya25aSc5oO55o+25qSw54i66IC276W06YeO5byx76W176W257SE6Iul6JGv6JK76Jel6LqN76W35L2v76W476W55aOk5a2D5oGZ5o+a5pSY5pWt5pqY76W65qWK5qij5rSL54CB54Ws55eS55iN56az56mw76W7576K76W86KWE76W96K6T6YeA6Zm976W+6aSK5ZyE5b6h5pa85ryB55iA56am6Kqe6aat6a2a6b2s5YSE5oa25oqR5qqN6IeG5YGD5aCw5b2m54SJ6KiA6Ku65a286JiW5L+65YS85Zq05aWE5o6p5re55baq5qWt5YaG5LqI5L2Z76W/76aA76aB5aaC76aCXCJdLFtcImU2YTFcIixcIu+mg+atn+axne+mhOeSteeklu+mheiIh+iJheiMuei8v+i9ne+mhumkmO+mh++miO+mieS6pu+miuWfn+W9ueaYk++mi++mjOeWq+e5ueitr++mjemAhumpm+WapeWgp+WnuOWon+WutO+mjuW7tu+mj++mkOaNkOaMu++mkeakveayh+ayv+a2jua2k+a3tea8lO+mkueDn+eEtueFme+mk+eHg+eHle+mlOehj+ehr++mleettee3o++mlue4r++ml+ihjei7n++mmO+mme+mmumJm++mm+mztu+mnO+mne+mnuaChea2he+mn+eGse+moO+moemWseWOre+mou+mo++mpOafk++mpeeCjueEsOeQsOiJtuiLklwiXSxbXCJlN2ExXCIsXCLvpqbplrvpq6Xpub3mm4Tvpqfnh4HokYnvpqjvpqnloYvvpqrvpqvltrjlvbHvpqzmmKDmmo7mpbnmpq7msLjms7PmuLbmvYHmv5rngJvngK/nhZDnh5/njbDvpq3nkZvvpq7nk5Tnm4jnqY7nupPvpq/vprDoi7HoqaDov47vprHpjYjvprLpnJnvprPvprTkuYLlgKrvprXliIjlj6Hmm7Pmsa3mv4rnjIrnnb/nqaLoiq7ol53omILvprboo5ToqaPorb3osavvprfpirPvprjpnJPpoJDkupTkvI3kv4nlgrLljYjlkL7lkLPll5rloaLlorrlpaflqJvlr6Tmgp/vprnmh4rmlZbml7/mmaTmoqfmsZrmvrNcIl0sW1wiZThhMVwiLFwi54OP54as542S56296JyI6Kqk6bCy6byH5bGL5rKD542E546J6Yi65rqr55Gl55if56mp57iV6JiK5YWA5aOF5pOB55Ou55SV55mw57+B6YKV6ZuN6aWU5rim55Om56qp56qq6Iel6JuZ6J246Kib5amJ5a6M5a6b5qKh5qSA5rWj546p55CT55Cs56KX57ep57+r6ISY6IWV6I6e6LGM6Ziu6aCR5puw5b6A5pe65p6J5rGq546L5YCt5aiD5q2q55+u5aSW5bWs5beN54yl55WP76a676a75YOl5Ye55aCv5aSt5aaW5aea5a+l76a876a95bai5ouX5pCW5pKT5pO+76a+5puc76a/5qmI76eA54e/55Gk76eBXCJdLFtcImU5YTFcIixcIueqiOeqr+e5h+e5nuiAgOiFsO+nguifr+imgeisoOmBme+ng+mCgOmlkuaFvuassua1tOe4n+ikpei+seS/keWCreWGl+WLh+Wfh+WiieWuueW6uOaFguamlea2jOa5p+a6tueGlOeRoueUqOeUrOiBs+iMuOiTiei4iumOlOmPnu+nhOS6juS9keWBtuWEquWPiOWPi+WPs+Wuh+Wvk+WwpOaEmuaGguaXtOeJm+eOl+eRgOebguelkOemkeemuee0hue+veiKi+iXleiZnui/gumBh+mDtemHqumahembqOmbqeWLluW9p+aXreaYseagr+eFnOeotumDgemgiuS6ke+nheapkuaunua+kOeGieiAmOiKuOiVk1wiXSxbXCJlYWExXCIsXCLpgYvpmpXpm7Lpn7volJrprLHkupDnhorpm4TlhYPljp/lk6HlnJPlnJLlnqPlqpvlq4Tlr4PmgKjmhL/mj7TmsoXmtLnmubLmupDniLDnjL/nkZfoi5HoooHovYXpgaDvp4bpmaLpoZjptJvmnIjotorpiZ7kvY3lgYnlg57ljbHlnI3lp5TlqIHlsInmhbDmmpDmuK3niLLnkYvnt6/og4PokI7okabolL/onZ/ooZvopJjorILpgZXpn4vprY/kubPkvpHlhJLlharvp4fllK/llqnlrbrlrqXlubzlub3lur7mgqDmg5/mhIjmhInmj4TmlLjmnInvp4jmn5Tmn5rvp4nmpaHmpaLmsrnmtKfvp4rmuLjvp4tcIl0sW1wiZWJhMVwiLFwi5r+h54y254y376eM55Gc55Sx76eN55mS76eO76eP57at6Ie+6JC46KOV6KqY6Kub6Kut6Liw6LmC6YGK6YC+6YG66YWJ6YeJ6Y2u76eQ76eR5aCJ76eS5q+T6IKJ6IKy76eT76eU5YWB5aWr5bC576eV76eW5r2k546n6IOk6LSH76eX6YiX6ZaP76eY76eZ76ea76eb6IG/5oiO54Cc57Wo6J6N76ec5Z6g5oGp5oWH5q636Kq+6YqA6Zqx5LmZ5ZCf5rer6JSt6Zmw6Z+z6aOu5o+W5rOj6YKR5Yed5oeJ6Ia66be55L6d5YCa5YSA5a6c5oSP5oe/5pOs5qSF5q+F55aR55+j576p6Imk6JaP6J+76KGj6Kq8XCJdLFtcImVjYTFcIixcIuitsOmGq+S6jOS7peS8iu+nne+nnuWkt+WnqO+nn+W3suW8m+W9m+aAoe+noO+noe+nou+no+eIvuePpe+npOeVsOeXje+npeenu++npuiAjOiAs+iChOiLoeiNke+np++nqOiyveiys+mCh++nqe+nqumjtOmkjO+nq++nrOeAt+ebiue/iue/jOe/vOismuS6uuS7geWIg+WNsO+nreWSveWboOWnu+WvheW8leW/jea5ru+nru+nr+e1quiMte+nsOiak+iqje+nsemdremdt++nsu+ns+S4gOS9muS9vuWjueaXpea6oumAuOmOsOmmueS7u+WjrOWmiuWnmeaBge+ntO+nteeolO+ntuiNj+izg+WFpeWNhFwiXSxbXCJlZGExXCIsXCLvp7fvp7jvp7nku43lianlrZXoir/ku5TliLrlkqjlp4nlp7/lrZDlrZflrZzmgaPmhYjmu4vngpnnha7njobnk7fnlrXno4HntKvogIXoh6rojKjolJfol4noq67os4fpm4zkvZzli7rlmrzmlqvmmKjngbzngrjniLXntr3oio3phYzpm4DptbLlrbHmo6fmrpjmvbrnm57lspHmmqvmvZvnrrTnsKrooLbpm5zkuIjku5fljKDloLTlorvlo6/lpazlsIfluLPluoTlvLXmjozmmrLmnZbmqJ/mqqPmrIzmvL/niYbvp7rnjZDnkovnq6Dnsqfohbjoh5/oh6fojorokazolKPolpTol4/oo53otJPphqzplbdcIl0sW1wiZWVhMVwiLFwi6Zqc5YaN5ZOJ5Zyo5a6w5omN5p2Q5qC95qKT5ri95ruT54G957ih6KOB6LKh6LyJ6b2L6b2O54it566P6KuN6Yya5L2H5L2O5YSy5ZKA5aeQ5bqV5oq15p215qWu5qiX5rKu5ria54uZ54yq55a9566457S16Iun6I+56JGX6Je36Kmb6LKv6LqH6YCZ6YK46ZuO6b2f5Yuj5ZCK5auh5a+C5pGY5pW15ru054uE76e755qE56mN56yb57GN57i+57+f6I276Kyr6LOK6LWk6Leh6Lmf6L+q6L+56YGp6Y+R5L2D5L265YKz5YWo5YW45YmN5Ymq5aGh5aG85aWg5bCI5bGV5bub5oKb5oiw5qCT5q6/5rCI5r6xXCJdLFtcImVmYTFcIixcIueFjueQoOeUsOeUuOeVkeeZsuetjOeui+eureevhue6j+iprui8vui9iemIv+mKk+mMoumQq+mbu+mhmumhq+mknuWIh+aIquaKmOa1meeZpOeriuevgOe1tuWNoOWyvuW6l+a8uOeCueeymOmckemujum7nuaOpeaRuuidtuS4geS6leS6reWBnOWBteWRiOWng+WumuW5gOW6reW7t+W+geaDheaMuuaUv+aVtOaXjOaZtuaZuOafvualqOaqieato+axgOa3gOa3qOa4n+a5nueAnueCoeeOjuePveeUuuedm+eih+emjueoi+epveeyvue2juiJh+ioguirquiynumEremFiumHmOmJpumLjOmMoOmchumdllwiXSxbXCJmMGExXCIsXCLpnZzpoILpvI7liLblipHllbzloKTluJ3lvJ/mgozmj5Dmoq/mv5/npa3nrKzoh43olrroo73oq7jouYTpho3pmaTpmpvpnL3poYzpvYrkv47lhYblh4vliqnlmLLlvJTlvavmjqrmk43ml6nmmYHmm7rmm7nmnJ3mop3mo5fmp73mvJXmva7nhafnh6XniKrnkqrnnLrnpZbnpZrnp5/nqKDnqpXnspfns5/ntYTnubDogofol7vomqToqZToqr/otpnouoHpgKDpga3ph6PpmLvpm5Xps6Xml4/nsIfotrPpj4PlrZjlsIrljZLmi5nnjJ3lgKflrpflvp7mgrDmhavmo5Xmt5nnkK7nqK7ntYLntpznuLHohatcIl0sW1wiZjFhMVwiLFwi6Liq6Li16Y2+6ZCY5L2Q5Z2Q5bem5bqn5oyr572q5Li75L2P5L6P5YGa5aed6IOE5ZGq5ZGo5Ze+5aWP5a6Z5bee5bua5pmd5pyx5p+x5qCq5rOo5rSy5rmK5r6N54K354+g55aH57GM57SC57Ss57ai6Iif6Jub6Ki76KqF6LWw6LqK6Lyz6YCx6YWO6YWS6ZGE6aeQ56u557Kl5L+K5YSB5YeG5Z+I5a+v5bO75pmZ5qi95rWa5rqW5r+s54SM55Wv56uj6KCi6YCh6YG16ZuL6ae/6IyB5Lit5Luy6KGG6YeN5Y295qub5qWr5rGB6JG65aKe5oaO5pu+5ouv54Od55SR55eH57mS6JK46K2J6LSI5LmL5Y+qXCJdLFtcImYyYTFcIixcIuWSq+WcsOWdgOW/l+aMgeaMh+aRr+aUr+aXqOaZuuaeneaes+atouaxoOaymua8rOefpeegpeelieell+e0meiCouiEguiHs+iKneiKt+icmOiqjO+nvOi0hOi2vumBsuebtOeomeeot+e5lOiBt+WUh+WXlOWhteaMr+aQouaZieaZi+ahreamm+auhOa0pea6seePjeeRqOeSoeeVm+eWueeboeecnueei+enpue4iee4neiHu+iUr+iil+iouuizkei7q+i+sOmAsumOremZo+mZs+mch+S+hOWPseWnquWrieW4meahjueThueWvuenqeeqkuiGo+ibreizqui3jOi/reaWn+acle+nveWft+a9l+e3nei8r1wiXSxbXCJmM2ExXCIsXCLpj7bpm4blvrXmh7LmvoTkuJTkvpjlgJ/lj4nll5/lta/lt67mrKHmraTno4vnrprvp77ouYnou4rpga7mjYnmkL7nnYDnqoTpjK/pkb/pvarmkrDmvq/nh6bnkqjnk5rnq4TnsJLnuoLnsrLnupjorprotIrpkb3ppJDppYzliLnlr5/mk6bmnK3ntK7lg63lj4PlobnmhZjmhZnmh7rmlqznq5norpLorpblgInlgKHlibXllLHlqLzlu6DlvbDmhLTmlZ7mmIzmmLbmmqLmp43mu4TmvLLnjJbnmKHnqpPohLnoiZnoj5bokrzlgrXln7Dlr4Dlr6jlvanmjqHnoKbntrXoj5zolKHph4fph7Xlhormn7XnrZZcIl0sW1wiZjRhMVwiLFwi6LKs5YeE5aa75oK96JmV5YCc76e/5YmU5bC65oW95oia5ouT5pOy5pal5ruM55ig6ISK6Lmg6Zmf6Zq75Luf5Y2D5ZaY5aSp5bed5pOF5rOJ5re6546U56m/6Iib6Jam6LOk6LiQ6YG36Yen6Zeh6Zih6Z+G5Ye45ZOy5ZaG5b655pKk5r6I57a06Lyf6L2N6ZC15YOJ5bCW5rK+5re755Sb556757C957Gk6Km56KuC5aCe5aa+5biW5o2354mS55aK552r6Kuc6LK86LyS5buz5pm05re46IG96I+B6KuL6Z2R6a+W76iA5YmD5pu/5raV5ruv57eg6Kum6YCu6YGe6auU5Yid5Ym/5ZOo5oaU5oqE5oub5qKiXCJdLFtcImY1YTFcIixcIuakkualmuaoteeCkueEpuehneekgeekjuenkueojeiCluiJuOiLleiNieiVieiygui2hemFoumGi+mGruS/g+WbkeeHreefl+icgOinuOWvuOW/luadkemCqOWPouWhmuWvteaCpOaGgeaRoOe4veiBsOiUpemKg+aSruWCrOW0lOacgOWinOaKveaOqOakjualuOaonua5q+eauueni+iKu+iQqeirj+i2qOi/vemEkumFi+mGnOmMkOmMmOmOmumbm+motumwjeS4keeVnOelneeruuetkeeviee4ruiThOi5mei5tOi7uOmAkOaYpeakv+eRg+WHuuacrum7nOWFheW/oOayluifsuihneiht+aCtOiGteiQg1wiXSxbXCJmNmExXCIsXCLotIXlj5blkLnlmLTlqLblsLHngornv6DogZrohIboh63otqPphonpqZ/pt7LlgbTku4TljqDmg7vmuKzlsaTkvojlgKTll6Tls5nluZ/mgaXmopTmsrvmt4Tnhr7nl5Tnl7TnmaHnqJrnqYnnt4fnt7vnva7oh7TomqnovJzpm4npprPpvZLliYfli4Xpo63opqrkuIPmn5LmvIbkvrXlr6LmnpXmsojmtbjnkJvnoKfph53pjbzon4Tnp6TnqLHlv6vku5blkqTllL7loq7lpqXmg7DmiZPmi5bmnLbmpZXoiLXpmYDpprHpp53lgKzljZPllYTlnbzvqIHmiZjvqILmk6Lmmavmn53mv4Hmv6/nkKLnkLjoqJdcIl0sW1wiZjdhMVwiLFwi6ZC45ZGR5ZiG5Z2m5b2I5oaa5q2O54GY54Kt57a76KqV5aWq6ISr5o6i55yI6IC96LKq5aGU5pCt5qa75a6V5biR5rmv76iD6JWp5YWM5Y+w5aSq5oCg5oWL5q6G5rGw5rOw56ye6IOO6IuU6LeG6YKw6aKx76iE5pOH5r6k5pKR5pSE5YWO5ZCQ5Zyf6KiO5oWf5qG276iF55eb562S57Wx6YCa5aCG5qeM6IW/6KSq6YCA6aC55YG45aWX5aas5oqV6YCP6ayq5oWd54m56ZeW5Z2h5amG5be05oqK5pKt5pO65p235rOi5rS+54is55C256C057236Iqt6Leb6aCX5Yik5Z2C5p2/54mI55Oj6LKp6L6m6YiRXCJdLFtcImY4YTFcIixcIumYquWFq+WPreaNjOS9qeWUhOaCluaVl+aym+a1v+eJjOeLveeol+imh+iyneW9rea+jueDueiGqOaEjuS+v+WBj+aJgeeJh+evh+e3qOe/qemBjemeremomeiytuWdquW5s+aesOiQjeipleWQoOWsluW5o+W7ouW8iuaWg+iCuuiUvemWiemZm+S9iOWMheWMjeWMj+WShuWTuuWcg+W4g+aAluaKm+aKseaNle+ohuazoea1pueWseegsuiDnuiEr+iLnuiRoeiSsuiijeikkumAi+mLqumjvemukeW5heaatOabneeAkeeIhu+oh+S/teWJveW9quaFk+adk+aomea8gueTouelqOihqOixuemjh+mjhOmpg1wiXSxbXCJmOWExXCIsXCLlk4HnqJ/mpZPoq7fosYrpoqjppq7lvbzmiqvnlrLnmq7ooqvpgb/pmYLljLnlvLzlv4Xms4znj4znlaLnlovnrYboi77ppp3kuY/pgLzkuIvkvZXljqblpI/lu4jmmLDmsrPnkZXojbfonabos4DpgZDpnJ7psJXlo5HlrbjomZDorJTptrTlr5Lmgajmgo3ml7HmsZfmvKLmvqPngJrnvZXnv7DplpHplpLpmZDpn5PlibLovYTlh73lkKvlkrjllaPllormqrvmtrXnt5joiabpipzpmbfpubnlkIjlk4jnm5Lom6TplqTpl5TpmZzkuqLkvInlp67lq6blt7fmgZLmipfmna3moYHmsobmuK/nvLjogpvoiKpcIl0sW1wiZmFhMVwiLFwi76iI76iJ6aCF5Lql5YGV5ZKz5Z6T5aWa5a2p5a6z5oeI5qW35rW354Cj6J+56Kej6Kmy6Kun6YKC6aet6aq45Yq+5qC45YCW5bm45p2P6I2H6KGM5Lqr5ZCR5Zqu54+m6YSV6Z+/6aSJ6aWX6aaZ5ZmT5aKf6Jmb6Kix5oay5qu254276LuS5q2H6Zqq6amX5aWV54iA6LWr6Z2p5L+U5bO05bym5oe45pmb5rOr54Kr546E546554++55yp552N57WD57Wi57ij6Ii36KGS76iK6LOi6YmJ6aGv5a2R56m06KGA6aCB5auM5L+g5Y2U5aS+5bO95oy+5rW554u56ISF6ISH6I6i6YuP6aCw5Lqo5YWE5YiR5Z6LXCJdLFtcImZiYTFcIixcIuW9ouazgua7jueAheeBkOeCr+eGkuePqeeRqeiNiuieouihoemAiOmCoumOo+mmqOWFruW9l+aDoOaFp+aas+iVmei5iumGr+mei+S5juS6kuWRvOWjleWjuuWlveWyteW8p+aItuaJiOaYiuaZp+avq+a1qea3j+a5lua7uOa+lOa/oOa/qeeBneeLkOeQpeeRmueToOeak+elnOeziue4nuiDoeiKpuiRq+iSv+iZjuiZn+idtOitt+ixqumOrOmggOmhpeaDkeaIlumFt+WpmuaYj+a3t+a4vueQv+mtguW/veaDmuesj+WThOW8mOaxnuazk+a0queDmOe0heiZueiojOm0u+WMluWSjOWsheaouueBq+eVtVwiXSxbXCJmY2ExXCIsXCLnpo3npr7oirHoj6/oqbHorYHosqjpnbTvqIvmk7TmlKvnorrnorvnqavkuLjllprlpZDlrqblubvmgqPmj5vmraHmmaXmoZPmuJnnhaXnkrDntIjpgoTpqanpsKXmtLvmu5HnjL7osYHpl4rlh7DluYzlvqjmgY3mg7bmhLDmhYzmmYPmmYTmpqXms4HmuZ/mu4nmvaLnhYznkpznmofnr4HnsKfojZLonZfpgZHpmo3pu4PljK/lm57lu7vlvormgaLmgpTmh7fmmabmnIPmqpzmt67mvq7ngbDnjarnuarohr7ojLTom5Toqqjos4TlioPnjbLlrpbmqavpkITlk67lmoblrZ3mlYjmloXmm4nmop/mto3mt4ZcIl0sW1wiZmRhMVwiLFwi54i76IK06YW16amN5L6v5YCZ5Y6a5ZCO5ZC85ZaJ5ZeF5bi/5b6M5py954Wm54+d6YCF5Yub5Yuz5aGk5aOO54SE54aP54e76Jaw6KiT5pqI6Jao5Zan5pqE54WK6JCx5Y2J5ZaZ5q+B5b2Z5b695o+u5pqJ54WH6Kux6Lyd6bq+5LyR5pC654OL55Wm6Jmn5oGk6K2O6be45YWH5Ye25YyI5rS26IO46buR5piV5qyj54KY55eV5ZCD5bG557SH6KiW5qyg5qy95q2G5ZC45oGw5rS957+V6IiI5YOW5Yee5Zac5Zmr5ZuN5aes5ayJ5biM5oaZ5oaY5oix5pme5pum54aZ54a554a654qn56an56iA576y6KmwXCJdXVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL3RhYmxlcy9jcDk0OS5qc29uXG4vLyBtb2R1bGUgaWQgPSAxMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBbW1wiODc0MFwiLFwi5I+w5LCy5JiD5Jam5JW48KeJp+S1t+SWs/CnsrHks6Lwp7OF466V5Jy25J2E5LGH5LGA8KSKv/CjmJfwp42S8Ka6i/Cng5LksZfwqo2R5J2P5Jea5LKF8KexrOS0h+SqpOSaofCmrKPniKXwpamU8KGpo/CjuIbwo72h5pmN5Zu7XCJdLFtcIjg3NjdcIixcIue2leWknfCorrnjt7TpnLTwp6+v5a+b8KG1nuWqpOOYpfCpurDlq5Hlrrfls7zmna7olpPwqaWF55Gh55Kd46G18KG1k/Cjmp7wpoCh47usXCJdLFtcIjg3YTFcIixcIvClo57jq7Xnq7zpvpfwpIWh8KikjfCjh6rwoKqK8KOJnuSMiuiShOm+lumQr+SksOiYk+WilumdiumImOenkOeosuaZoOaoqeiineeRjOevheaegueorOWJj+mBhuOTpuePhPCltrnnk4bpv4flnrPkpK/lkYzkhLHwo5qO5aCY56my8Ketpeiuj+SarvCmuojkhoHwpbaZ566u8KKSvOm/iPCik4HwopOJ8KKTjOm/ieiUhPCjlrvkgrTpv4rkk6Hwqre/5ouB54Gu6b+LXCJdLFtcIjg4NDBcIixcIuOHgFwiLDQsXCLwoISM44eF8KCDkfCgg43jh4bjh4fwoIOL8KG/qOOHiPCgg4rjh4njh4rjh4vjh4zwoISO44eN44eOxIDDgceNw4DEksOJxJrDiMWMw5PHkcOS4L+/w4rMhOG6vuC/v8OKzIzhu4DDisSBw6HHjsOgyZHEk8OpxJvDqMSrw63HkMOsxY3Ds8eSw7LFq8O6x5TDuceWx5jHmlwiXSxbXCI4OGExXCIsXCLHnMO84L+/w6rMhOG6v+C/v8OqzIzhu4HDqsmh4o+a4o+bXCJdLFtcIjg5NDBcIixcIvCqjqnwoYWFXCJdLFtcIjg5NDNcIixcIuaUilwiXSxbXCI4OTQ2XCIsXCLkuL3mu53ptY7ph59cIl0sW1wiODk0Y1wiLFwi8KecteaSkeS8muS8qOS+qOWFluWFtOWGnOWHpOWKoeWKqOWMu+WNjuWPkeWPmOWbouWjsOWkhOWkh+WksuWktOWtpuWunuWun+WymuW6huaAu+aWieafvuaghOahpea1jueCvOeUtee6pOe6rOe6uue7h+e7j+e7n+e8hue8t+iJuuiLj+iNr+inhuiuvuivoui9pui9p+i9rlwiXSxbXCI4OWExXCIsXCLnkJHns7znt43mpYbnq4nliKdcIl0sW1wiODlhYlwiLFwi6YaM56K46YWe6IK8XCJdLFtcIjg5YjBcIixcIui0i+iDtvCgp6dcIl0sW1wiODliNVwiLFwi6IKf6buH5LON6beJ6biM5LC+8Km3tvCngI7puIrwqoSz45eBXCJdLFtcIjg5YzFcIixcIua6muiIvueUmVwiXSxbXCI4OWM1XCIsXCLkpJHpqazpqo/pvpnnpofwqJGs8KG3ivCgl5Dwoqum5Lik5LqB5LqA5LqH5Lq/5Lur5Ly345GM5L6947mI5YCD5YKI45G945KT45Kl5YaG5aSF5Yeb5Ye85YiF5LqJ5Ym55YqQ5Yyn45eH5Y6p45WR5Y6w45WT5Y+C5ZCj45Wt45Wy45qB5ZKT5ZKj5ZK05ZK55ZOQ5ZOv5ZSY5ZSj5ZSo45aY5ZS/45al45a/5ZeX45eFXCJdLFtcIjhhNDBcIixcIvCntoTllKVcIl0sW1wiOGE0M1wiLFwi8KCxgvCgtJXwpYSr5ZaQ8KKzhuOnrPCgjYHouYbwpLa48KmTpeSBk/Cogr7nnbrworC446i05J+V8KiFnfCmp7LwpLeq5pOd8KC1vPCgvrTwoLOV8KGDtOaSjei5vvCgupbwoLCL8KC9pPCisqnwqImW8KSTk1wiXSxbXCI4YTY0XCIsXCLwoLWG8KmpjfCog6nkn7TwpLqn8KKzgumqsuOpp/Cpl7Tjv63jlIbwpYuH8KmflPCno4jworWE6bWu6aCVXCJdLFtcIjhhNzZcIixcIuSPmfCmgqXmkrTlk6PworWM8KKvivChgbfjp7vwoYGvXCJdLFtcIjhhYTFcIixcIvCmm5rwppyW8KemoOaTqvClgZLwoLGD6Lmo8KKGofCorYzwoJyxXCJdLFtcIjhhYWNcIixcIuSgi/Cghqnjv7rlobPworaNXCJdLFtcIjhhYjJcIixcIvCkl4jwoJO88KaCl/CgvYzwoLaW5ZW55IK75I66XCJdLFtcIjhhYmJcIixcIuSqtPCiqabwoYKd6Iaq6aO18KC2nOaNueOnvvCinbXot4DlmqHmkbzjuYNcIl0sW1wiOGFjOVwiLFwi8KqYgfCguInwoquP8KKziVwiXSxbXCI4YWNlXCIsXCLwoYOI8KOnguOmkuOohvCoipvjlbjwpbmJ8KKDh+WZkvCgvLHworKy8KmcoOOSvOawvfCkuLtcIl0sW1wiOGFkZlwiLFwi8KeVtPCiuovwooiI8KqZm/Cos43woLm68KCwtPCmoJznvpPwoYOP8KKgg/CipLnjl7vwpYej8KC6jPCgvo3woLqq476T8KC8sPCgtYfwoYWP8KC5jFwiXSxbXCI4YWY2XCIsXCLwoLqr8KCuqfCgtYjwoYOA8KGEveO/ufCimpbmkLLwoL6tXCJdLFtcIjhiNDBcIixcIvCjj7Twp5i58KKvjvCgtb7woLW/8KKxkfCisZXjqJjwoLqY8KGDh/CgvK7wqpiy8KatkPCos5LwqLaZ8KiziumWquWTjOiLhOWWuVwiXSxbXCI4YjU1XCIsXCLwqbuD6bCm6aq28KednvCit67nhYDoha3og6zlsJzwppWy6IS0456X5Y2f8KiCvemGtvCgu7rwoLiP8KC5t/Cgu7vjl53wpLer45iJ8KCzluWar/CinrXwoYOJ8KC4kPCgubjwoYG48KGFiPCoiIfwoZGV8KC5ufCkuZDworak5amU8KGAnfChgJ7woYO18KGDtuWenPCguJFcIl0sW1wiOGJhMVwiLFwi8KealPCoi43woL618KC5u/Clhb7jnIPwoL628KGGgPCli5jwqoq98KSnmvChoLrwpIW38KiJvOWimeWJqOOYmvClnL3nrrLlrajkoIDkrKzpvKfkp6fpsJ/pro3wpa208KOEveWXu+OXsuWaieS4qOWkgvChr4Hwr6G46Z2R8KCChuS5m+S6u+OUvuWwo+W9keW/hOOjuuaJjOaUteatuuawteawuueBrOeIq+S4rOeKrfCko6nnvZLnpLvns7nnvZPwpomq45OBXCJdLFtcIjhiZGVcIixcIvCmjYvogILogoDwppiS8KalkeWNneihpOingfCnorLorqDotJ3pkoXplbjplb/pl6jwqLiP6Z+m6aG16aOO6aOe6aWj8KmgkOmxvOm4n+m7hOatr++kh+S4t/CggofpmJ3miLfpkqJcIl0sW1wiOGM0MFwiLFwi5YC75re+8Kmxs+m+puO3ieiij/CkhY7ngbfls7XkrKDwpYeN45WZ8KW0sOaEovCoqLLovqfph7bnhpHmnJnnjrrwo4qB8KqEh+Oyi/ChpoDkrJDno6TnkILlhq7wqJyP5ICJ5qmj8KqKuuSIo+iYj/Cgqa/nqKrwqaWH8KirqumdleeBjeWMpPCigb7pj7Tnm5nwqKej6b6n55+d5Lqj5L+w5YK85Liv5LyX6b6o5ZC057aL5aKS5aOQ8KG2tuW6kuW6meW/gvCinJLmlotcIl0sW1wiOGNhMVwiLFwi8KOPueakmeapg/CjsaPms79cIl0sW1wiOGNhN1wiLFwi54iA8KSUheeOjOO7m/CkqJPlrJXnkrnoroPwpbKk8KWaleeqk+evrOezg+e5rOiLuOiWl+m+qeiikOm+qui6uem+q+i/j+iVn+mnoOmIoem+rPCotrnwoZC/5IGx5Iqi5aiaXCJdLFtcIjhjYzlcIixcIumhqOadq+SJtuWcvVwiXSxbXCI4Y2NlXCIsXCLol5bwpKW76Iq/8KeEjeSygfCmtbTltbvwpqyV8Ka+vum+rem+ruWulum+r+abp+e5m+a5l+eniuO2iOSTg/CjiZbwop6W5I6a5JS2XCJdLFtcIjhjZTZcIixcIuWzlfCjrJroq7nlsbjjtJLwo5WR5bW46b6y54WX5JWY8KSDrPChuKPksbfjpbjjkYrwoIak8KaxgeirjOS+tPCgiLnlpr/ohazpoZbwqaO65by7XCJdLFtcIjhkNDBcIixcIvCgrp9cIl0sW1wiOGQ0MlwiLFwi8KKHgfCopa3khILkmrvwqYG547yH6b6z8KqGteSDuOOfluSbt/CmsYbkhbzwqJqy8KePv+SVreOjlPClkprklaHklJvktonksbvktbbkl6rjv4jwpKyP45mh5JOe5JK95Iet5bS+5bWI5bWW47e846CP5bak5ba546Cg46C45bmC5bq95byl5b6D46SI46SU46S/46WN5oOX5oS95bOl46aJ5oa35oa55oeP46a45ois5oqQ5oul5oyY46e45ZqxXCJdLFtcIjhkYTFcIixcIuOog+aPouaPu+aQh+aRmuOpi+aTgOW0leWYoem+n+Oql+aWhuOqveaXv+aZk+OrsuaakuOsouacluOtguaepOaggOOtmOahiuaihOOtsuOtseOtu+akiealg+eJnOalpOamn+amheOuvOanluOvneappeaptOapseaqguOvrOaqmeOvsuaqq+aqtearlOartuaugeavgeavquaxteayquOzi+a0gua0hua0pua2geOzr+a2pOa2sea4lea4mOa4qea6hvCop4Dmurvmu6Lmu5rpvb/mu6jmu6nmvKTmvLTjtYbwo72B5r6B5r6+47Wq47W154a35bKZ47aK54Cs47aR54GQ54GU54Gv54G/54KJ8KCMpeSPgeOXsfCgu5hcIl0sW1wiOGU0MFwiLFwi8KO7l+WevvCmu5PnhL7wpZ+g45mO5qai8KivqeWttOepifClo6HwqZOZ56ml56m98KWmrOequ+eqsOerguerg+eHkfCmko3kh4rnq5rnq53nq6rkh6/lkrLwpbCB56yL562V56yp8KWMjvCls77nrqLnra/ojpzwpa608Kaxv+evkOiQoeeukueuuPCltKDjtq3wpbGl6JKS56+657CG57C18KWzgeexhOeyg/CkooLnsqbmmb3wpJW457OJ57OH57Om57G057Oz57O157OOXCJdLFtcIjhlYTFcIixcIue5p+SUnfCmuYTntZ3wpruW55KN57aJ57ar54S157az57eS8KSBl/CmgKnnt6TjtJPnt7XwoZ+557el8KiNree4nfCmhKHwpoWa57mu57qS5Iyr6ZGs57in572A572B572H56S28KaLkOmnoee+l/CmjZHnvqPwoZmh8KCBqOSVnPCjnabklIPwqIy657+68KaSieiAheiAiOiAneiAqOiAr/CqgofwprOD6IC76IC86IGh8KKclOSmifCmmKbwo7ej8KabqOacpeiCp/CoqYjohIfohJrlorDwopu25rG/8KaSmPCkvrjmk6fwoZKK6IiY8KGhnuapk/CkqaXwpKqV5JG66Iip8KCsjfCmqZLwo7W+5L+58KGTveiTouiNovCmrIrwpKan8KOUsPChnbPwo7e46Iqq5qSb8K+mlOSHm1wiXSxbXCI4ZjQwXCIsXCLolYvoi5DojJrwoLiW8KGetOObgfCjhb3wo5Wa6Im76Iui6IyY8KO6i/CmtqPwpqyF8Kaul/Cjl47jtr/ojJ3ll6zojoXklIvwpral6I6s6I+B6I+T45G+8Ka7lOapl+iVmuOSlvCmuYLworuv6JGY8KWvpOiRseO3k+STpOaqp+iRivCjsrXnpZjokqjwpq6W8Ka5t/CmuYPok57okI/ojpHkkqDokpPok6TwpbKR5ImA8KWzgOSVg+iUtOWrsvCmupnklKfolbPklJbmnr/omJZcIl0sW1wiOGZhMVwiLFwi8KiYpfComLvol4Hwp4KI6JiC8KGWgvCng43wr6ay5JWq6Jio45mI8KGiouWPt/Cnjpromb7onbHwqoO46J+u8KKwp+ieseifmuigj+WZoeiZrOahluSYj+ihheihhvCnl6Dwo7a58KeXpOihnuiinOSZm+iitOiiteaPgeijheedt/CnnI/opofoporopqbopqnopqfoprzwqKil6Ken8KekpPCnqr3oqpznnpPph77oqpDwp6mZ56up8KesuvCjvo/knJPwp6y454W86KyM6Kyf8KWQsPCllaXorL/orYzorY3oqqnwpKm66K6Q6K6b6Kqv8KGbn+SYleihj+iym/CntZTwp7aP8K+nlOOcpfCntZPos5bwp7aY8Ke2vei0kui0g/ChpJDos5vngZzotJHwpLOJ47uQ6LW3XCJdLFtcIjkwNDBcIixcIui2qfCogILwoYCU8KSmiuOtvPCohrzwp4SM56un6Lqt6Lq26LuD6YuU6LyZ6Lyt8KiNpfCokJLovqXpjIPwqoqf8KCpkOi+s+SkqvCop57wqJS98KO2u+W7uPCjiaLov7nwqoCU8KiavPColIHwooyl46aA8Ka7l+mAt/ColLzwp6q+6YGh8KiVrPComIvpgqjwqJyT6YOE8KibpumCrumDvemFp+OrsOmGqemHhOeyrPCopLPwobqJ6YiO5rKf6YmB6Ymi8KWWuemKufCoq4bwo7Kb8KisjPCll5tcIl0sW1wiOTBhMVwiLFwi8KC0semMrOmNq/Coq6HwqK+r54KP5auD8KirovCoq6XkpaXpiYTwqK+s8KiwufCor7/pjbPpkZvourzploXplqbpkKbplqDmv7bkirnwopm68KibmPChibzwo7iu5Kef5rCc6Zm76ZqW5IWs6Zqj8Ka7leaHmumatuejtfCoq6Dpmr3lj4zkpqHwprK48KCJtPCmkJDwqYKv8KmDpfCkq5HwoaSV8KOMiumcseiZgumctuSoj+SUveSWhfCkq6nngbXlrYHpnJvpnZzwqYeV6Z2X5a2K8KmHq+mdn+mQpeWDkPCjgrfwo4K86Z6J6Z6f6Z6x6Z6+6Z+A6Z+S6Z+g8KWRrOmfrueQnPCpkLPpn7/pn7XwqZCd8KeluuSrkemgtOmgs+mhi+mhpuOsjvCnhbXjtZHwoJiw8KSFnFwiXSxbXCI5MTQwXCIsXCLwpZyG6aOK6aK36aOI6aOH5Ku/8Ka0p/Chm5PllrDpo6Hpo6bpo6zpjbjppLnwpKip5K2y8Kmhl/CppIXpp7XpqIzpqLvpqJDpqZjwpZyl45uE8KmCsfCpr5Xpq6Dpq6LwqayF6au05LCO6ayU6ayt8KiYgOWAtOmstPCmpqjjo4Pwo4G96a2Q6a2A8Km0vuWphfChoaPpro7wpImL6bCC6a+/6bCM8Km5qOm3lPCpvrfwqoaS8KqGq/Cqg6HwqoSj8KqHn+m1vum2g/CqhLTpuI7moohcIl0sW1wiOTFhMVwiLFwi6beE8KKFm/CqhpPwqoig8KGku/CqiLPptLnwqoK58KqKtOm6kOm6lem6num6ouS0tOm6qum6r/CkjaTpu4HjraDjp6XjtJ3kvLLjnr7wqLCr6byC6byI5K6W6ZCk8Ka2oum8l+m8lum8ueWan+Waium9hemmuPCpgovpn7Lokb/pvaLpvannq5zpvo7niJbkrr7wpKW18KSmu+eFt/Ckp7jwpI2I8KSpkeeOnvCor5rwoaO656af8KilvvCouLbpjanpj7PwqKmE6Yus6Y6B6Y+L8KilrPCkkrnniJfju6vnnbLnqYPng5DwpJGz8KSPuOeFvvChn6/ngqPwoaK+8KOWmeO7h/ChooXwpZCv8KGfuOOcovChm7vwoaC545uh8KGdtPCho5Hwpb2L45yj8KGbgOWdm/CkqKXwoY++8KGKqFwiXSxbXCI5MjQwXCIsXCLwoY+G8KGStuiUg/CjmqbolIPokZXwpKaU8KeFpfCjuLHwpZWc8KO7u/CngZLkk7Two5uu8KmmnfCmvKbmn7njnLPjsJXjt6floazwoaSi5qCQ5IGX8KOcv/Ckg6HwpIKL8KSEj/CmsKHlk4vlmp7wppqx5ZqS8KC/n/CgrqjwoLiN6Y+G8Kisk+mOnOS7uOWEq+OgmfCkkLbkurzwoJGl8KCNv+S9i+S+ivClmZHlqajwoIar8KCPi+OmmfCgjIrwoJCU45C15Lyp8KCLgPCourPwoIm16Kua8KCIjOS6mFwiXSxbXCI5MmExXCIsXCLlg43lhI3kvqLkvIPwpKiO8KO6iuS9guWAruWBrOWCgeS/jOS/peWBmOWDvOWFmeWFm+WFneWFnua5tvCjlpXwo7i58KO6v+a1svChooTwo7qJ5Yao5YeD8KCXoOSTnfCgkqPwoJKS8KCSkei1uvCoqpzwoJyO5YmZ5Yqk8KChs+WLoemNruSZuueGjPCkjozwoLCg8KSmrPChg6Tmp5HwoLid55G547ue55KZ55CU55GW546Y5K6O8KSqvPCkgo3lj5DjloTniI/wpIOJ5Za08KCNheWTjfCgr4blnJ3piZ3pm7Tpjabln53lno3lnb/jmL7lo4vlqpnwqKmG8KGbuvChna/woZyQ5ais5aa46YqP5am+5auP5aiS8KWlhvChp7PwoaGh8KSKleObtea0heeRg+WoofCluoNcIl0sW1wiOTM0MFwiLFwi5aqB8Kivl/CgkJPpj6DnkozwoYyD54SF5KWy6ZCI8Kinu+mOveOeoOWwnuWynuW5nuW5iPChppbwoaW88KOrruW7jeWtj/ChpIPwoaSE45yB8KGioOObnfChm77jm5PohKrwqKmH8KG2uvCjkbLwqKao5byM5byO8KGkp/ChnqvlqavwoZy75a2E6JiU8KeXveihoOaBvvCioaDwopir5b+b47q48KKWr/Cilr7wqYKI8Ka9s+aHgPCggL7woIGG8KKYm+aGmeaGmOaBtfCispvworSH8KSblPCphY1cIl0sW1wiOTNhMVwiLFwi5pGx8KSZpfCirarjqKnwoqyi8KORkPCpo6rworm45oy38KqRm+aStuaMseaPkfCkp6PworWn5oqk8KKyoeaQu+aVq+alsuOvtPCjgo7wo4qt8KSmifCjiqvllI3wo4ug8KGjmfCpkL/mm47wo4qJ8KOGs+OroOSGkPClloTwqKyi8KWWj/Chm7zwpZWb8KWQpeejrvCjhIPwoaCq8KOItOORpPCjiI/wo4aC8KSLieaajvCmtKTmmavkrpPmmLDwp6Gw8KG3q+aZo/Cji5Lwo4uh5pie8KWhsuOjkfCjoLrwo568466Z8KOeovCjj77nk5Djrpbmno/wpJiq5qK25qCe46+E5qq+46Gj8KOflfCkkofmqLPmqZLmq4nmrIXwoaSS5pSR5qKY5qmM46+X5qm65q2X8KO/gPCjsprpjqDpi7LwqK+q8Kiri1wiXSxbXCI5NDQwXCIsXCLpionwqICe8KinnOmRp+a2pea8i/Ckp6zmtafwo72/47aP5riE8KSAvOWovea4iuWhh+a0pOehgueEu/CkjJrwpIm254Ox54mQ54qH54qU8KSej/CknKXlhbnwpKqk8KCXq+eRuvCju7jwo5mf8KSpivCkpJfwpb+h47yG47qx8KSrn/CosKPwo7y15oKn47uz55OM55C86Y6H55C35JKf8Ka3quSVkeeWg+O9o/Cks5nwpLSG472Y55WV55mz8KqXhuOsmeeRqPCoq4zwpKar8KSmjuOru1wiXSxbXCI5NGExXCIsXCLjt43wpKmO47u/8KSnhfCko7Pph7rlnLLpjYLwqKuj8KGhpOWDn/CliKHwpYen55248KOIsuecjuecj+edu/Ckmpfwo56B46me8KSjsOeQuOeSm+O6v/CkqrrwpKuH5IOI8KSqlvCmhq7pjIfwpZaB56Ce56KN56KI56OS54+Q56WZ8KedgfClm6PkhI7nppvokpbnpqXmqK3wo7u656i656e05IWu8KGbpuSEsumIteensfCgtYzwpKaM8KCKmfCjtrrwoZ2u45aX5ZWr45Ww45qq8KCHlPCgsI3nq6LlqZnwopu18KWqr/ClqpzlqI3woImb56Ow5aiq8KWvhuervuSHueexneexreSIkfClrrPwpbq88KW6puezjfCkp7nwoZ6w57KO57G857Ku5qqy57ec57iH57eT572O8KaJoVwiXSxbXCI5NTQwXCIsXCLwpoWc8KetiOe2l/CluoLkiarwpq218KCkluaflvCggY7wo5eP5Z+E8KaQkvCmj7jwpKWi57+d56yn8KCgrPClq6nwpbWD56yM8KW4jumnpuiZhempo+aonPCjkL/jp6LwpKe38KaWremon/CmlqDokoDwp4Sn8KazkeSTquiEt+SQguiDhuiEieiFgvCmnrTpo4PwpqmC6Imi6Iml8KapkeiRk/CmtqfomJDwp4ib5aqG5IW/8KGhgOWsq/ChoqHlq6TwoaOY6Jqg8K+mvPCjto/ooK3wp5Ci5aiCXCJdLFtcIjk1YTFcIixcIuihruS9heiih+iiv+ijpuilpeiljfClmoPopZTwp56F8KeehPCor7XwqK+Z8KiunPCop7njuq3okqPkm7Xkm4/jn7LoqL3oqJzwqZGI5b2N6Yir8KSKhOaXlOeEqeeDhPChoYXpta3osp/os6nwp7ec5aaa55+D5aew5I2u45uU6Liq6Lqn8KSwiei8sOi9iuSLtOaxmOa+u/CijKHkopvmvbnmuovwoZ+a6a+p45q18KSkr+mCu+mCl+WVseSkhumGu+mQhPCoqYvkgaLwqKu86ZCn8KiwnfCosLvok6XoqKvplpnplqfplpfplpbwqLS055GF47uC8KSjv/CkqYLwpI+q47un8KOIpemaj/Cou6fwqLmm8Ki5peO7jPCkp63wpKm48KO/rueQkueRq+O7vOmdgfCpgrBcIl0sW1wiOTY0MFwiLFwi5qGH5Kid8KmCk/Cln5/pnZ3pjajwqKaJ8KiwpvCorK/wpo6+6Yq65ayR6K2p5KS854+58KSIm+mem+mdsemkuPCgvKblt4HwqK+F8KSqsumgn/Cpk5rpi7bwqZeX6Yel5JOA8KitkPCkqafwqK2k6aOc8KipheO8gOmIquSkpeiQlOmku+mljfCnrIbjt73pppvkra/ppqrpqZzwqK2l8KWjiOaqj+mooeWrvumor/Cpo7HkrpDwqaWI6aa85K695K6X6Y295aGy8KGMguWgovCkprhcIl0sW1wiOTZhMVwiLFwi8KGTqOehhPCinJ/wo7a45qOF47W96ZGY46Sn5oWQ8KKegfCipavmhIfpsY/psZPpsbvpsLXpsJDprb/pr4/wqbit6a6f8KqHtfCqg77ptKHksq7wpISE6biY5LKw6bSM8KqGtPCqg63wqoOz8Kmkr+m2peiSvfCmuJLwpr+f8KauguiXvOSUs/CmtqTwprqE8Ka3sOiQoOiXrvCmuIDwo5+X8KaBpOenovCjlpzwo5mA5KSt8KSnnuO1oumPm+mKvumNiPCgir/nornpibfpkY3kv6TjkYDpgaTwpZWd56C956GU56K256GL8KGdl/Cjh4nwpKWB45qa5L2y5r+a5r+Z54Ce54Ce5ZCU8KSGteWeu+Wjs+Weium0luWfl+eEtOOSr/Ckhqznh6vwprGA8KS+l+WsqPChnrXwqKmJXCJdLFtcIjk3NDBcIixcIuaEjOWrjuWoi+SKvPCkkojjnKzkrbvwqKe86Y676Y648KGjlvCgvJ3okbLwprOA8KGQk/Cki7rworCm8KSPgeWmlPCjtrfwpp2B57ao8KaFm/CmgqTwpKa58KSmi/Cop7rpi6Xnj6Lju6nnkrTwqK2j8KGin+O7ofCkqrPmq5jnj7Pnj7vju5bwpKi+8KSqlPChn5nwpKmm8KCOp/ChkKTwpKel55GI8KSklueCpfCkpbbpioTnj6bpjZ/woJO+6Yyx8KirjvCoqJbpjobwqK+n8KWXleSktfCoqoLnhatcIl0sW1wiOTdhMVwiLFwi8KSlg/Cgs7/lmqTwoJia8KCvq/CgsrjllILnp4TwoZ+657e+8KGbgvCkqZDwoaGS5JSu6ZCB45yK8KirgPCkpq3lprDwoaK/8KGig/CnkoTlqqHjm6Lwo7Wb45qw6Ymf5am58KiqgfChoaLpjbTjs43woKq05KqW46aK5YO047Wp47WM8KGOnOeFteSLu/CoiJjmuI/wqYOk5JOr5rWX8Ke5j+eBp+ayr+OzlvCjv63wo7it5riC5ryM47Wv8KCPteeVkeOavOOTiOSagOO7muShseWnhOmJruSkvui9gfCosJzwpq+A5aCS5Z+I45uW8KGRkueDvvCkjaLwpKmx8KK/o/ChirDwoo695qK55qWn8KGOmPCjk6Xwp6+08KObn/CoqoPwo5+W8KOPuvCksp/mqJrwo5qt8Kayt+iQvuSTn+STjlwiXSxbXCI5ODQwXCIsXCLwprSm8Ka1kfCmsoLwpr+e5ryX8KeEieiMvfChnLroj63wprKA8KeBk/Chn5vlponlqoLwoZ6z5amh5amx8KGkhfCkh7zjnK3lp6/woZy845uH54aO6Y6Q5pqa8KSKpeWpruWoq/CkipPmqKvwo7u58KectvCkkZvwpIuK54Sd8KSJmfCop6HkvrDwprSo5bOC8KSTjvCnuY3wpI695qiM8KSJlvChjITngqbnhLPwpI+p47al5rOf8K+gpfCkqY/nuaXlp6vltK/jt7PlvZzwpKmd8KGfn+e2pOiQplwiXSxbXCI5OGExXCIsXCLlkoXwo6u68KOMgPCgiJTlnb7woKOV8KCYmeO/pfChvp7wqoq254CD8KmFm+W1sOeOj+ezk/CoqZnwqZCg5L+I57+n54uN54yQ8KertOeMuOeMufClm7bnjYHnjYjjuqnwp6yY6YGs54e18KSjsuePoeiHtuO7iuecjOO7keayouWbveeQmeeQnueQn+O7ouO7sOO7tOO7uueTk+O8juO9k+eVgueVreeVsueWjeO9vOeXiOeXnOO/gOeZjeO/l+eZtOO/nOeZuvCkvZznhojlmKPopoDloankgJ3nnYPkgLnmnaHkgYXjl5vnnpjkgarkga/lsZ7nnr7nn4vlo7LnoJjngrnnoJzkgqjnoLnnoYfnoZHnoabokYjwpZS156Sz5qCD56Sy5ISDXCJdLFtcIjk5NDBcIixcIuSEieemkeemmei+u+eohui+vOSFp+eqkeSGsueqvOiJueSHhOerj+erm+SHj+S4oeetouetrOetu+ewkuewm+SJoOSJuuexu+eynOSKjOeyuOSKlOezrei+k+eDgPCgs4/nt4/nt5Tnt5Dnt73nvq7nvrTnip/kjpfogKDogKXnrLnogK7ogLHogZTjt4zlnrTngqDogrfog6nkj63ohIznjKrohI7ohJLnlaDohJTkkIHjrLnohZbohZnohZpcIl0sW1wiOTlhMVwiLFwi5JCT5aC66IW86IaE5JCl6IaT5JCt6Ial5Z+v6IeB6Iek6ImU5JKP6Iqm6Im26IuK6IuY6Iu/5JKw6I2X6Zmp5qaK6JCF54O16JGk5oOj6JKI5JSE6JK+6JOh6JO46JSQ6JS46JWS5JS76JWv6JWw6Jeg5JW36Jmy6JqS6Jqy6Juv6ZmF6J6L5JiG5JiX6KKu6KO/6KSk6KWH6KaR8Kelp+ioqeiouOiqlOiqtOixkeizlOizsui0nOSemOWhn+i3g+SfreS7rui4uuWXmOWdlOi5seWXtei6sOSgt+i7jui7oui7pOi7rei7sui+t+i/gei/iui/jOmAs+mnhOSiremjoOmIk+SknumIqOmJmOmJq+mKsemKrumKv1wiXSxbXCI5YTQwXCIsXCLpi6Ppi6vpi7Ppi7Tpi73pjYPpjoTpjq3kpYXkpZHpur/pkJfljIHpkJ3pkK3pkL7kparpkZTpkbnplK3plqLkpqfpl7TpmLPkp6XmnqDkqKTpnYDkqLXpnrLpn4LlmZTkq6Tmg6jpornkrJnpo7HloYTppI7ppJnlhrTppJzppLfppYLppZ3ppaLkrbDpp4Xkrp3pqLzprI/nqoPpranproHpr53pr7Hpr7Tksa3psKDjna/woa+C6bWJ6bC6XCJdLFtcIjlhYTFcIixcIum7vuWZkOm2k+m2vem3gOm3vOmTtui+tum5u+m6rOm6sem6vem7humTnOm7oum7sem7uOeriOm9hPCggpTwoIq38KCOoOakmumTg+WmrPCgk5floYDpk4HjnrnwoJeV8KCYlfCgmbbwoZq65Z2X54Wz8KCrgvCgq43woK6/5ZGq8K+gu/Cgr4vlkp7woK+78KCwu/CgsZPwoLGl8KCxvOaDp/Cgso3lmbrwoLK18KCznfCgs63woLWv8KC2svCgt4jmpZXpsK/onqXwoLiE8KC4jvCgu5fwoL6Q8KC8rfCgubPlsKDwoL685biL8KGBnPChgY/woYG25pye8KGBu/ChgojwoYKW45mH8KGCv/Chg5PwoYSv8KGEu+WNpOiSrfChi6PwoY218KGMtuiugfChlbfwoZiZ8KGfg/Chn4fkubjngrvwoaCt8KGlqlwiXSxbXCI5YjQwXCIsXCLwoait8KGphfChsKrwobGw8KGyrPChu4jmi4PwobuV8KG8leeGmOahlfCigYXmp6njm4jwoom88KKPl/Cij7rwopyq8KKhsfCipY/oi73woqWn8KKmk/Ciq5XopqXwoquo6L6g8KKsjumeuPCirL/poYfpqr3worGMXCJdLFtcIjliNjJcIixcIvCisojworK38KWvqPCitIjworSS8KK2t/CitpXwormC8KK9tPCiv4zwo4Cz8KOBpvCjjJ/wo4+e5b6x5pmI5pq/8KepufCjlafwo5ez54iB8KSmuuefl/CjmJrwo5yW57qH8KCNhuWiteacjlwiXSxbXCI5YmExXCIsXCLmpJjwo6qn8KeZl/Clv6Lwo7iR8KO6ufCnl77wooKa5KOQ5Kq48KSEmfCoqprwpIuu8KSMjfCkgLvwpIy08KSOlvCkqYXwoJeK5YeS8KCYkeWmn/Chuqjjrr7wo7O/8KSQhPCkk5blnojwpJm046ab8KScr/Col6jwqaeJ452i8KKHg+itnvCorY7pp5bwpKCS8KSju/CkqJXniInwpKuA8KCxuOWlpfCkuqXwpL6G8KCduei7mvClgKzlio/lnL/nhbHwpYqZ8KWQmfCjvYrwpKqn5Za88KWRhvClka7wpq2S6YeU45Gz8KWUv/CnmLLwpZWe5JyY8KWVovCllabwpZ+H8KSkv/CloZ3lgabjk7vwo4+M5oOe8KWkg+SdvPCopYjwpaqu8KWuifClsIbwobaQ5Z6h54WR5r628KaEgvCnsJLpgZbwpoay8KS+muitovCmkILwppGKXCJdLFtcIjljNDBcIixcIuW1m/Cmr7fovLbwppKE8KGknOirqvCkp7bwppKI8KO/r/CmlJLkr4Dwppa/8KaatfCinJvpkaXwpZ+h5oaV5ain8K+jjeS+u+WaufCklKHwppu85Lmq8KSktOmZlua2j/Cmsr3jmJjopbfwpp6Z8KahrvCmkJHwpqGe54ef8Kajh+etgvCpg4DwoKiR8KakpumEhPCmpLnnqYXpt7Dwpqe66aim8KaoreOZn/CmkanwoICh56aD8KaotPCmrZvltKzwo5SZ6I+P8KauneSbkPCmsqTnlLvooaXwprau5aK2XCJdLFtcIjljYTFcIixcIuOcnPCilo3wp4GL8KeHjeOxlPCnioDwp4qF6YqB8KKFuvCniovpjLDwp4um8KSnkOawuemSn/CnkZDwoLu46KCn6KO18KKkpvCokbPwoZ6x5rq48KSoqvChoKDjpqTjmrnlsJDnp6PklL/mmrbwqbKt8KmipOilg/Cnn4zwp6GY5ZuW5IOf8KGYiuOmofCjnK/wqIOo8KGPheeGreiNpvCnp53wqYao5amn5LK38KeCr/Copqvwp6e98KeoivCnrIvwp7Wm8KSFuuetg+elvvCogInmvrXwqouf5qiD8KiMmOWOovCmuIfpjr/moLbpnZ3wqIWv8KiAo/CmprXwoY+t8KOIr/CogYjltoXwqLCw8KiCg+Wclemgo/CopYnltqvwpKaI5pa+5qeV5Y+S8KSqpfCjvoHjsJHmnLbwqIKQ8KiDtPCohK7wob6h8KiFj1wiXSxbXCI5ZDQwXCIsXCLwqIaJ8KiGr/CoiJrwqIyG8KiMr/Cojorjl4rwqJGo8KiaquSjuuaPpvCopZbnoIjpiZXwqKa45I+y8Kinp+SPn/Cop6jwqK2G8KivlOWnuPCosInovIvwqL+F8KmDrOetkfCphJDwqYS847e38KmFnvCkq4rov5Dnio/lmovwqZOn8KmXqfCplrDwqZa48KmcsvCpo5HwqaWJ8KmlqvCpp4Pwqaio8KmsjvCptZrwqbab57qf8Km7uPCpvKPksqTplYfwqoqT54ai8KqLv+S2kemAkvCql4vktpzwoLKc6L6+5ZeBXCJdLFtcIjlkYTFcIixcIui+uvCikrDovrnwpKqT5JSJ57m/5r2W5qqx5Luq45Ok8KisrPCnop3jnLrouoDwoZ+18KiApPCorazwqK6Z8KeovvCmmq/jt6vwp5mV8KOyt/ClmLXwpaWW5Lqa8KW6gfCmiZjlmr/woLmt6LiO5a2t8KO6iPCksp7mj57mi5DwoZ+28KGhu+aUsOWYrfClsYrlkJrwpYyR47eG8Km2mOSxveWYouWYnue9ifClu5jlpbXwo7WA6J2w5Lic8KC/qvCgtYnwo5q66ISX6bWe6LSY55i76bGF55mO55656Y2F5ZCy6IWI6Iu35Zil6ISy6JCY6IK95Zeq56Wi5ZmD5ZCW8KC6neOXjuWYheWXseabsfCoi6LjmK3nlLTll7DllrrlkpfllbLwoLGB8KCyluW7kPClhYjwoLm28KKxolwiXSxbXCI5ZTQwXCIsXCLwoLqi6bqr57Wa5Zee8KGBteaKnemdreWSlOizjeeHtumFtuaPvOaOueaPvuWVqfCirYPpsbLworqz5Yaa45Of8KC2p+WGp+WRjeWUnuWUk+eZpui4rfCmoornlrHogrbooITonoboo4fohrbokJzwoYOB5JOs54yE8KSchuWukOiMi/CmopPlmbvwopu08Ke0r/CkhqPwp7Wz8Ka7kPCnirbphbDwoYeZ6YiI8KOzvPCqmqnwoLqs8KC7ueeJpvChsqLknY7wpL+C8Ke/ufCgv6vkg7pcIl0sW1wiOWVhMVwiLFwi6bGd5pSf8KK2oOSjs/Ckn6DwqbW88KC/rPCguIrmgaLwp5aj8KC/rVwiXSxbXCI5ZWFkXCIsXCLwpoGI8KGGh+eGo+e6jum1kOS4muS4hOOVt+WsjeaysuWNp+OarOOnnOWNveOapfCkmJjloprwpK2u6Iit5ZGL5Z6q8KWqlfCgpblcIl0sW1wiOWVjNVwiLFwi46mS8KKRpeeNtPCpuqzktInpr63wo7O+8Km8sOSxm/CkvqnwqZae8Km/nuiRnPCjtrbwp4qy8Kaes/CjnKDmjK7ntKXwo7u38KO4rOOoqumAiOWLjOO5tOOZuuSXqfCgko7nmYDlq7DwoLq256G68Ke8ruWip+SCv+WZvOmui+W1tOeZlPCqkLTpuoXks6Hnl7njn7vmhJnwo4Oa8KSPslwiXSxbXCI5ZWY1XCIsXCLlmZ3woYqp5Z6n8KSlo/CpuIbliLTwp4Ku45at5rGK6bW8XCJdLFtcIjlmNDBcIixcIuexlumsueWfnvChnazlsZPmk5PwqZOQ8KaMtfCnhaTomq3woLSo8Ka0ovCkq6LwoLWxXCJdLFtcIjlmNGZcIixcIuWHvvChvI/lto7pnIPwobeR6bqB6YGM56yf6ayC5bOR566j5omo5oy16au/56+P6ayq57G+6ayu57GC57KG6bCV56+86ayJ6byX6bCb8KSkvum9muWVs+Wvg+S/vem6mOS/suWJoOO4huWLkeWdp+WBluWmt+W4kumfiOm2q+i9nOWRqemetOmlgOmeuuWMrOaEsFwiXSxbXCI5ZmExXCIsXCLmpKzlj5rpsIrptILksLvpmYHmpoDlgqbnlYbwoZ2t6aea5YmzXCJdLFtcIjlmYWVcIixcIumFmemagemFnFwiXSxbXCI5ZmIyXCIsXCLphZHwqLqX5o2/8Ka0o+ariuWYkemGjueVuuaKhfCgj7znjY/nsbDwpbCh8KOzvVwiXSxbXCI5ZmMxXCIsXCLwpKSZ55uW6a6d5Liq8KCzlOiOvuihglwiXSxbXCI5ZmM5XCIsXCLlsYrmp4Dlg63lnbrliJ/lt7Xku47msLHwoIey5Ly55ZKc5ZOa5Yqa6LaC45e+5byM45ezXCJdLFtcIjlmZGJcIixcIuatkumFvOm+pemul+mgrumitOmquum6qOm6hOeFuueslFwiXSxbXCI5ZmU3XCIsXCLmr7rooJjnvbhcIl0sW1wiOWZlYlwiLFwi5Zig8KqZiui5t+m9k1wiXSxbXCI5ZmYwXCIsXCLot5TouY/puJzouIHmioLwqI296Lio6Lm156uT8KSpt+eovuejmOazquipp+eYh1wiXSxbXCJhMDQwXCIsXCLwqKma6bym5rOO6J+W55eD8KqKsuehk/CvoYDotIzni6LnjbHorK3njILnk7Hos6vwpKq76Jiv5b666KKg5JK3XCJdLFtcImEwNTVcIixcIvChoLvwpriFXCJdLFtcImEwNThcIixcIuipvvCilJtcIl0sW1wiYTA1YlwiLFwi5oO955mn6auX6bWE6Y2u6a6P6J+1XCJdLFtcImEwNjNcIixcIuigj+izt+eMrOmcoemusOOXlueKsuSwh+exkemlivCmhZnmhZnksITpupbmhb1cIl0sW1wiYTA3M1wiLFwi5Z2f5oWv5oqm5oi55ouO46mc5oei5Y6q8KOPteaNpOagguOXklwiXSxbXCJhMGExXCIsXCLltZfwqK+C6L+a8Ki4uVwiXSxbXCJhMGE2XCIsXCLlg5nwobWG56SG5Yyy6Zi48KC8u+SBpVwiXSxbXCJhMGFlXCIsXCLnn75cIl0sW1wiYTBiMFwiLFwi57OC8KW8muezmueoreiBpuiBo+e1jeeUheeTsuimlOiImuacjOiBovCnkobogZvnk7DohIPnnKToponwpp+M55WT8Ka7keieqeifjuiHiOiejOipieiyreitg+ecq+eTuOiTmuOYteamsui2plwiXSxbXCJhMGQ0XCIsXCLopqnnkajmtrnon4HwpICR55On47eb54W25oKk5oac47OR54Wi5oG3XCJdLFtcImEwZTJcIixcIue9sfCorK3niZDmg6nkrb7liKDjsJjwo7OH8KW7l/CnmZbwpZSx8KGlhPChi77wqaSD8Ka3nPCngq3ls4Hwpoat8Kioj/CjmbfwoIOu8KahhvCkvI7klaLlrJ/wpo2M6b2Q6bqm8KaJq1wiXSxbXCJhM2MwXCIsXCLikIBcIiwzMSxcIuKQoVwiXSxbXCJjNmExXCIsXCLikaBcIiw5LFwi4pG0XCIsOSxcIuKFsFwiLDksXCLkuLbkuL/kuoXkuqDlhoLlhpblhqvli7nljLjljanljrblpIrlroDlt5vivLPlub/lu7TlvZDlvaHmlLTml6DnlpLnmbbovrXpmrbCqMuG44O944O+44Kd44Ke44CD5Lud44CF44CG44CH44O877y777y94py944GBXCIsMjNdLFtcImM3NDBcIixcIuOBmVwiLDU4LFwi44Kh44Ki44Kj44KkXCJdLFtcImM3YTFcIixcIuOCpVwiLDgxLFwi0JBcIiw1LFwi0IHQllwiLDRdLFtcImM4NDBcIixcItCbXCIsMjYsXCLRkdC2XCIsMjUsXCLih6fihrjihrnjh4/woIOM5Lma8KCCiuWIguSSkVwiXSxbXCJjOGExXCIsXCLpvrDlhojpvrHwp5iHXCJdLFtcImM4Y2RcIixcIu+/ou+/pO+8h++8guOIseKEluKEoeOCm+OCnOK6gOK6hOK6huK6h+K6iOK6iuK6jOK6jeK6leK6nOK6neK6peK6p+K6quK6rOK6ruK6tuK6vOK6vuK7huK7iuK7jOK7jeK7j+K7luK7l+K7nuK7o1wiXSxbXCJjOGY1XCIsXCLKg8mQyZvJlMm1xZPDuMWLyorJqlwiXSxbXCJmOWZlXCIsXCLvv61cIl0sW1wiZmE0MFwiLFwi8KCVh+mLm/Cgl5/wo7+F6JWM5Iq154+v5Ya145mJ8KSlgvCop6TpjYTwoaeb6Iuu8KOziOegvOadhOaLn/CkpLPwqKaq8KCKoPCmrrPwoYyF5L6r8KKTreWAiPCmtKnwp6qE8KOYgPCkqrHwopST5YCp8KCNvuW+pPCgjoDwoI2H5rub8KCQn+WBveWEgeORuuWEjumhrOOdg+iQlvCkpqTwoJKH5YWg8KOOtOWFqvCgr7/wooO88KCLpfCilLDwoJaO8KOIs/ChpoPlroLonb3woJaz8KOymeWGsuWGuFwiXSxbXCJmYWExXCIsXCLptLTlh4nlh4/lh5Hjs5zlh5PwpKqm5Yaz5Yei5Y2C5Yet6I+N5qS+8KOcreW9u+WIi+WIpuWIvOWKteWJl+WKlOWKueWLheewleiVguWLoOiYjfCmrJPljIXwqKue5ZWJ5ruZ8KO+gPCgpZTwo7+s5Yyz5Y2E8KCvouazi/ChnKbmoJvnj5XmgYrjuqrjo4zwoZuo54ed5JKi5Y2t5Y208Kiaq+WNvuWNv/ChlpbwoZiT55+m5Y6T8Kiqm+WOoOWOq+WOrueOp/ClnbLjvZnnjpzlj4Hlj4XmsYnkuYnln77lj5njqqvwoK6P5Y+g8KO/q/CitqPlj7bwoLG35ZCT54G55ZSr5pmX5rWb5ZGt8Katk/CgtbTllZ3lko/lkqTknqbwoZyN8KC7neO2tPCgtY1cIl0sW1wiZmI0MFwiLFwi8KimvPCimpjllYfks63lkK/nkJfllobllqnlmIXwoaOX8KSAuuSVkvCkkLXmmrPwoYK05Zi35puN8KOKiuaapOaareWZjeWZj+ejseWbsemeh+WPvuWcgOWbr+WbrfCorabjmKPwoYmP5Z2G8KSGpeaxrueCi+WdguOasfCmsb7ln6bwoZCW5aCD8KGRlPCkjaPloKbwpK+15aGc5aKq45Wh5aOg5aOc8KGIvOWju+Wvv+Wdg/CqhZDwpIm46Y+T45ah5aSf5qKm45uD5rmZXCJdLFtcImZiYTFcIixcIvChmL7lqKTllZPwoZqS6JSF5aeJ8KC1jvCmsoHwprSq8KGfnOWnmfChn7vwoZ6y8Ka2pua1sfChoKjwoZuV5ae58Ka5heWqq+Wpo+ObpvCkpqnlqbfjnIjlqpbnkaXlq5Pwpr6h8KKVlOO2hfChpJHjnLLwoZq45bqD5YuQ5a225paI5a288KeojuSAhOShnfCgiITlr5XmhaDwoai08KWnjPCglqXlr7Plrp3ktJDlsIXwoa2E5bCT54+O5bCU8KGypfCmrKjlsYnko53lsoXls6nls6/ltovwobe58KG4t+W0kOW0mOW1hvChuqTlsrrlt5foi7zjoK3wpKSB8KKBifCihbPoiofjoLbjr4LluK7mqorlubXlubrwpJK88KCzk+WOpuS6t+W7kOWOqPChnbHluInlu7TwqJKCXCJdLFtcImZjNDBcIixcIuW7ueW7u+OioOW7vOagvumQm+W8jfCgh4Hwr6KU46ue5KKu8KGMuuW8uvCmoojwoo+Q5b2Y8KKRseW9o+mevfCmua7lvbLpjYDwqKi25b6n5ba247Wf8KWJkPChvarwp4O48KKZqOmHlvCgip7wqKip5oCx5pqF8KGht+Olo+O3h+OYueWekPCinrTnpbHjuYDmgp7mgqTmgrPwpKaC8KSmj/CnqZPnkqTlg6HlqqDmhaTokKTmhYLwr6Km8Ka7kuaGgeWHtPCgmZbmhoflrqrwo763XCJdLFtcImZjYTFcIixcIvCioZ/mh5PwqK6d8KmlneaHkOOksvCipoDwoqOB5oCj5oWc5pSe5o6L8KCEmOaLhfChnbDmi5XworiN5o2s8KSnn+Ool+aQuOaPuPChjo7woZ+85pKQ5r6K8KK4tumglPCkgozwpZyd5pOh5pOl6ZG746mm5pC646mX5pWN5ryW8KSoqPCkqKPmloXmla3mlZ/wo4G+5pa18KSlgOSst+aXkeSDmPChoKnml6Dml6Plv5/wo5CA5piY8KOHt/Cjh7jmmYTwo4ak8KOGpeaZi/CgubXmmafwpYem5pmz5pm08KG4vfCjiLHwqJe08KOHiPCljJPnn4XwoqO36aak5pyC8KSOnPCkqKHjrKvmp7rwo5+C5p2e5p2n5p2i8KSHjfCpg63mn5fkk6nmoKLmuZDpiLzmoIHwo4+m8Ka2oOahnVwiXSxbXCJmZDQwXCIsXCLwo5Gv5qeh5qiL8Kirn+als+ajg/Cjl43mpIHmpIDjtLLjqIHwo5i8466A5p6s5qWh8KipiuSLvOaktuammOOuofCgj4nojaPlgpDmp7nwo5mZ8KKEquaphfCjnIPmqp3jr7PmnrHmq4jwqYac47CN5qyd8KCko+aDnuasteattPCin43murXwo6ub8KCOtfChpZjjnYDlkKHwo62a5q+h8KO7vOavnOawt/CikovwpKOx8KatkeaxmuiIpuaxufCjtrzkk4Xwo7a98KSGpPCkpIzwpKSAXCJdLFtcImZkYTFcIixcIvCjs4njm6Xjs6vwoLSy6a6D8KOHufCikpHnvo/moLfwprSl8Ka2ofCmt6vmtpbmtZzmubzmvITwpKW/8KSChfCmubLolLPwpr205YeH5rKc5rid6JCu8Kisoea4r/CjuK/nkZPwo76C56eM5rmP5aqR8KOBi+a/uOOcjea+nfCjuLDmu7rwoZKX8KSAveSVlemPsOa9hOa9nOO1jua9tPCphbDjtLvmvp/wpIWE5r+T8KSCkfCkhZXwpIC58KO/sPCjvrTwpIS/5Yef8KSFlvCkhZfwpIWA8KaHneeBi+eBvueCp+eCgeeDjOeDleeDlueDn+SEhOO3qOeGtOeGlvCkibfnhKvnhYXlqojnhYrnha7lspzwpI2l54WP6Y2i8KSLgeeErPCkkZrwpKin8KSooueGuvCor6jngr3niI5cIl0sW1wiZmU0MFwiLFwi6ZGC54iV5aSR6ZGD54ik6Y2B8KWYheeIrueJgPCkpbTmor3niZXniZfjuZXwo4GE5qCN5ry954qC54yq54yr8KSgo/CooKvko63wqKCE54yo54yu54+P546q8KCwuvCmqK7nj4nnkYnwpIei8KGbp/CkqKTmmKPjm4XwpKa38KSmjfCkp7vnj7fnkJXmpIPwpKim55C58KCXg+O7l+eRnPCioq3nkaDwqLqy55GH54+k55G26I6555Gs45yw55G06Y+x5qis55KC5KWT8KSqjFwiXSxbXCJmZWExXCIsXCLwpIWf8KSpufCoro/lrYbwqLCD8KGinueTiPChpojnlI7nk6nnlJ7wqLuZ8KGpi+Wvl/CouqzpjoXnlY3nlYrnlafnla7wpL6C47yE8KS0k+eWjueRneeWnueWtOeYgueYrOeZkeeZj+eZr+eZtvCmj7XnmpDoh6/jn7jwpqSR8Kakjueaoeeapeeat+ebjPCmvp/okaLwpYKd8KWFvfChuJznnJ7nnKbnnYDmkq/wpYig552Y8KOKrOeer/CopaTwqKWo8KGbgeeftOegifChjbbwpKiS5qOK56Kv56OH56OT6Zql56Su8KWXoOejl+ektOeisfCnmIzovrjoooTwqKyr8KaCg/CimJznpobopIDmpILnpoDwpaGX56ad8KesueekvOemqea4qvCnhKbjuqjnp4bwqYSN56eUXCJdXVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL3RhYmxlcy9iaWc1LWFkZGVkLmpzb25cbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoXCJzdHJlYW1cIikuVHJhbnNmb3JtO1xuXG5cbi8vID09IEV4cG9ydHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGljb252KSB7XG4gICAgXG4gICAgLy8gQWRkaXRpb25hbCBQdWJsaWMgQVBJLlxuICAgIGljb252LmVuY29kZVN0cmVhbSA9IGZ1bmN0aW9uIGVuY29kZVN0cmVhbShlbmNvZGluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEljb252TGl0ZUVuY29kZXJTdHJlYW0oaWNvbnYuZ2V0RW5jb2RlcihlbmNvZGluZywgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGljb252LmRlY29kZVN0cmVhbSA9IGZ1bmN0aW9uIGRlY29kZVN0cmVhbShlbmNvZGluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEljb252TGl0ZURlY29kZXJTdHJlYW0oaWNvbnYuZ2V0RGVjb2RlcihlbmNvZGluZywgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGljb252LnN1cHBvcnRzU3RyZWFtcyA9IHRydWU7XG5cblxuICAgIC8vIE5vdCBwdWJsaXNoZWQgeWV0LlxuICAgIGljb252Lkljb252TGl0ZUVuY29kZXJTdHJlYW0gPSBJY29udkxpdGVFbmNvZGVyU3RyZWFtO1xuICAgIGljb252Lkljb252TGl0ZURlY29kZXJTdHJlYW0gPSBJY29udkxpdGVEZWNvZGVyU3RyZWFtO1xuICAgIGljb252Ll9jb2xsZWN0ID0gSWNvbnZMaXRlRGVjb2RlclN0cmVhbS5wcm90b3R5cGUuY29sbGVjdDtcbn07XG5cblxuLy8gPT0gRW5jb2RlciBzdHJlYW0gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuZnVuY3Rpb24gSWNvbnZMaXRlRW5jb2RlclN0cmVhbShjb252LCBvcHRpb25zKSB7XG4gICAgdGhpcy5jb252ID0gY29udjtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmRlY29kZVN0cmluZ3MgPSBmYWxzZTsgLy8gV2UgYWNjZXB0IG9ubHkgc3RyaW5ncywgc28gd2UgZG9uJ3QgbmVlZCB0byBkZWNvZGUgdGhlbS5cbiAgICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuSWNvbnZMaXRlRW5jb2RlclN0cmVhbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybS5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogSWNvbnZMaXRlRW5jb2RlclN0cmVhbSB9XG59KTtcblxuSWNvbnZMaXRlRW5jb2RlclN0cmVhbS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgZG9uZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgIT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcihcIkljb252IGVuY29kaW5nIHN0cmVhbSBuZWVkcyBzdHJpbmdzIGFzIGl0cyBpbnB1dC5cIikpO1xuICAgIHRyeSB7XG4gICAgICAgIHZhciByZXMgPSB0aGlzLmNvbnYud3JpdGUoY2h1bmspO1xuICAgICAgICBpZiAocmVzICYmIHJlcy5sZW5ndGgpIHRoaXMucHVzaChyZXMpO1xuICAgICAgICBkb25lKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGRvbmUoZSk7XG4gICAgfVxufVxuXG5JY29udkxpdGVFbmNvZGVyU3RyZWFtLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbihkb25lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuY29udi5lbmQoKTtcbiAgICAgICAgaWYgKHJlcyAmJiByZXMubGVuZ3RoKSB0aGlzLnB1c2gocmVzKTtcbiAgICAgICAgZG9uZSgpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBkb25lKGUpO1xuICAgIH1cbn1cblxuSWNvbnZMaXRlRW5jb2RlclN0cmVhbS5wcm90b3R5cGUuY29sbGVjdCA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgdmFyIGNodW5rcyA9IFtdO1xuICAgIHRoaXMub24oJ2Vycm9yJywgY2IpO1xuICAgIHRoaXMub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykgeyBjaHVua3MucHVzaChjaHVuayk7IH0pO1xuICAgIHRoaXMub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjYihudWxsLCBCdWZmZXIuY29uY2F0KGNodW5rcykpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5cbi8vID09IERlY29kZXIgc3RyZWFtID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbmZ1bmN0aW9uIEljb252TGl0ZURlY29kZXJTdHJlYW0oY29udiwgb3B0aW9ucykge1xuICAgIHRoaXMuY29udiA9IGNvbnY7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5lbmNvZGluZyA9IHRoaXMuZW5jb2RpbmcgPSAndXRmOCc7IC8vIFdlIG91dHB1dCBzdHJpbmdzLlxuICAgIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5JY29udkxpdGVEZWNvZGVyU3RyZWFtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBJY29udkxpdGVEZWNvZGVyU3RyZWFtIH1cbn0pO1xuXG5JY29udkxpdGVEZWNvZGVyU3RyZWFtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBkb25lKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKVxuICAgICAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoXCJJY29udiBkZWNvZGluZyBzdHJlYW0gbmVlZHMgYnVmZmVycyBhcyBpdHMgaW5wdXQuXCIpKTtcbiAgICB0cnkge1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5jb252LndyaXRlKGNodW5rKTtcbiAgICAgICAgaWYgKHJlcyAmJiByZXMubGVuZ3RoKSB0aGlzLnB1c2gocmVzLCB0aGlzLmVuY29kaW5nKTtcbiAgICAgICAgZG9uZSgpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBkb25lKGUpO1xuICAgIH1cbn1cblxuSWNvbnZMaXRlRGVjb2RlclN0cmVhbS5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24oZG9uZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciByZXMgPSB0aGlzLmNvbnYuZW5kKCk7XG4gICAgICAgIGlmIChyZXMgJiYgcmVzLmxlbmd0aCkgdGhpcy5wdXNoKHJlcywgdGhpcy5lbmNvZGluZyk7ICAgICAgICAgICAgICAgIFxuICAgICAgICBkb25lKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGRvbmUoZSk7XG4gICAgfVxufVxuXG5JY29udkxpdGVEZWNvZGVyU3RyZWFtLnByb3RvdHlwZS5jb2xsZWN0ID0gZnVuY3Rpb24oY2IpIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgdGhpcy5vbignZXJyb3InLCBjYik7XG4gICAgdGhpcy5vbignZGF0YScsIGZ1bmN0aW9uKGNodW5rKSB7IHJlcyArPSBjaHVuazsgfSk7XG4gICAgdGhpcy5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNiKG51bGwsIHJlcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvbGliL3N0cmVhbXMuanNcbi8vIG1vZHVsZSBpZCA9IDEwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBCdWZmZXIgPSByZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbi8vIE5vdGU6IG5vdCBwb2x5ZmlsbGVkIHdpdGggc2FmZXItYnVmZmVyIG9uIGEgcHVycG9zZSwgYXMgb3ZlcnJpZGVzIEJ1ZmZlclxuXG4vLyA9PSBFeHRlbmQgTm9kZSBwcmltaXRpdmVzIHRvIHVzZSBpY29udi1saXRlID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpY29udikge1xuICAgIHZhciBvcmlnaW5hbCA9IHVuZGVmaW5lZDsgLy8gUGxhY2UgdG8ga2VlcCBvcmlnaW5hbCBtZXRob2RzLlxuXG4gICAgLy8gTm9kZSBhdXRob3JzIHJld3JvdGUgQnVmZmVyIGludGVybmFscyB0byBtYWtlIGl0IGNvbXBhdGlibGUgd2l0aFxuICAgIC8vIFVpbnQ4QXJyYXkgYW5kIHdlIGNhbm5vdCBwYXRjaCBrZXkgZnVuY3Rpb25zIHNpbmNlIHRoZW4uXG4gICAgLy8gTm90ZTogdGhpcyBkb2VzIHVzZSBvbGRlciBCdWZmZXIgQVBJIG9uIGEgcHVycG9zZVxuICAgIGljb252LnN1cHBvcnRzTm9kZUVuY29kaW5nc0V4dGVuc2lvbiA9ICEoQnVmZmVyLmZyb20gfHwgbmV3IEJ1ZmZlcigwKSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpO1xuXG4gICAgaWNvbnYuZXh0ZW5kTm9kZUVuY29kaW5ncyA9IGZ1bmN0aW9uIGV4dGVuZE5vZGVFbmNvZGluZ3MoKSB7XG4gICAgICAgIGlmIChvcmlnaW5hbCkgcmV0dXJuO1xuICAgICAgICBvcmlnaW5hbCA9IHt9O1xuXG4gICAgICAgIGlmICghaWNvbnYuc3VwcG9ydHNOb2RlRW5jb2RpbmdzRXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQUNUSU9OIE5FRURFRDogcmVxdWlyZSgnaWNvbnYtbGl0ZScpLmV4dGVuZE5vZGVFbmNvZGluZ3MoKSBpcyBub3Qgc3VwcG9ydGVkIGluIHlvdXIgdmVyc2lvbiBvZiBOb2RlXCIpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlNlZSBtb3JlIGluZm8gYXQgaHR0cHM6Ly9naXRodWIuY29tL2FzaHR1Y2hraW4vaWNvbnYtbGl0ZS93aWtpL05vZGUtdjQtY29tcGF0aWJpbGl0eVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub2RlTmF0aXZlRW5jb2RpbmdzID0ge1xuICAgICAgICAgICAgJ2hleCc6IHRydWUsICd1dGY4JzogdHJ1ZSwgJ3V0Zi04JzogdHJ1ZSwgJ2FzY2lpJzogdHJ1ZSwgJ2JpbmFyeSc6IHRydWUsIFxuICAgICAgICAgICAgJ2Jhc2U2NCc6IHRydWUsICd1Y3MyJzogdHJ1ZSwgJ3Vjcy0yJzogdHJ1ZSwgJ3V0ZjE2bGUnOiB0cnVlLCAndXRmLTE2bGUnOiB0cnVlLFxuICAgICAgICB9O1xuXG4gICAgICAgIEJ1ZmZlci5pc05hdGl2ZUVuY29kaW5nID0gZnVuY3Rpb24oZW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5jICYmIG5vZGVOYXRpdmVFbmNvZGluZ3NbZW5jLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0gU2xvd0J1ZmZlciAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB2YXIgU2xvd0J1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLlNsb3dCdWZmZXI7XG5cbiAgICAgICAgb3JpZ2luYWwuU2xvd0J1ZmZlclRvU3RyaW5nID0gU2xvd0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgICAgIFNsb3dCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgLy8gVXNlIG5hdGl2ZSBjb252ZXJzaW9uIHdoZW4gcG9zc2libGVcbiAgICAgICAgICAgIGlmIChCdWZmZXIuaXNOYXRpdmVFbmNvZGluZyhlbmNvZGluZykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLlNsb3dCdWZmZXJUb1N0cmluZy5jYWxsKHRoaXMsIGVuY29kaW5nLCBzdGFydCwgZW5kKTtcblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB1c2Ugb3VyIGRlY29kaW5nIG1ldGhvZC5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhcnQgPT0gJ3VuZGVmaW5lZCcpIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBpY29udi5kZWNvZGUodGhpcy5zbGljZShzdGFydCwgZW5kKSwgZW5jb2RpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3JpZ2luYWwuU2xvd0J1ZmZlcldyaXRlID0gU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGU7XG4gICAgICAgIFNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gICAgICAgICAgICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICAgICAgICAgICAgICB2YXIgc3dhcCA9IGVuY29kaW5nO1xuICAgICAgICAgICAgICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IGxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBzd2FwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvZmZzZXQgPSArb2Zmc2V0IHx8IDA7XG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gK2xlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIC8vIFVzZSBuYXRpdmUgY29udmVyc2lvbiB3aGVuIHBvc3NpYmxlXG4gICAgICAgICAgICBpZiAoQnVmZmVyLmlzTmF0aXZlRW5jb2RpbmcoZW5jb2RpbmcpKVxuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5TbG93QnVmZmVyV3JpdGUuY2FsbCh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZyk7XG5cbiAgICAgICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYXR0ZW1wdCB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGJvdW5kcycpO1xuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHVzZSBvdXIgZW5jb2RpbmcgbWV0aG9kLlxuICAgICAgICAgICAgdmFyIGJ1ZiA9IGljb252LmVuY29kZShzdHJpbmcsIGVuY29kaW5nKTtcbiAgICAgICAgICAgIGlmIChidWYubGVuZ3RoIDwgbGVuZ3RoKSBsZW5ndGggPSBidWYubGVuZ3RoO1xuICAgICAgICAgICAgYnVmLmNvcHkodGhpcywgb2Zmc2V0LCAwLCBsZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tIEJ1ZmZlciAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBvcmlnaW5hbC5CdWZmZXJJc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2Rpbmc7XG4gICAgICAgIEJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuaXNOYXRpdmVFbmNvZGluZyhlbmNvZGluZykgfHwgaWNvbnYuZW5jb2RpbmdFeGlzdHMoZW5jb2RpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3JpZ2luYWwuQnVmZmVyQnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBCdWZmZXIuYnl0ZUxlbmd0aCA9IFNsb3dCdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uKHN0ciwgZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgLy8gVXNlIG5hdGl2ZSBjb252ZXJzaW9uIHdoZW4gcG9zc2libGVcbiAgICAgICAgICAgIGlmIChCdWZmZXIuaXNOYXRpdmVFbmNvZGluZyhlbmNvZGluZykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLkJ1ZmZlckJ5dGVMZW5ndGguY2FsbCh0aGlzLCBzdHIsIGVuY29kaW5nKTtcblxuICAgICAgICAgICAgLy8gU2xvdywgSSBrbm93LCBidXQgd2UgZG9uJ3QgaGF2ZSBhIGJldHRlciB3YXkgeWV0LlxuICAgICAgICAgICAgcmV0dXJuIGljb252LmVuY29kZShzdHIsIGVuY29kaW5nKS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBvcmlnaW5hbC5CdWZmZXJUb1N0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgICAgIEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICAvLyBVc2UgbmF0aXZlIGNvbnZlcnNpb24gd2hlbiBwb3NzaWJsZVxuICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc05hdGl2ZUVuY29kaW5nKGVuY29kaW5nKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuQnVmZmVyVG9TdHJpbmcuY2FsbCh0aGlzLCBlbmNvZGluZywgc3RhcnQsIGVuZCk7XG5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdXNlIG91ciBkZWNvZGluZyBtZXRob2QuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXJ0ID09ICd1bmRlZmluZWQnKSBzdGFydCA9IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuZCA9PSAndW5kZWZpbmVkJykgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gaWNvbnYuZGVjb2RlKHRoaXMuc2xpY2Uoc3RhcnQsIGVuZCksIGVuY29kaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9yaWdpbmFsLkJ1ZmZlcldyaXRlID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZTtcbiAgICAgICAgQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gICAgICAgICAgICB2YXIgX29mZnNldCA9IG9mZnNldCwgX2xlbmd0aCA9IGxlbmd0aCwgX2VuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgICAgICAgICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAgICAgICAgICAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgICAgICAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgICAgICAgICAgICAgdmFyIHN3YXAgPSBlbmNvZGluZztcbiAgICAgICAgICAgICAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBsZW5ndGg7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gc3dhcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICAvLyBVc2UgbmF0aXZlIGNvbnZlcnNpb24gd2hlbiBwb3NzaWJsZVxuICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc05hdGl2ZUVuY29kaW5nKGVuY29kaW5nKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuQnVmZmVyV3JpdGUuY2FsbCh0aGlzLCBzdHJpbmcsIF9vZmZzZXQsIF9sZW5ndGgsIF9lbmNvZGluZyk7XG5cbiAgICAgICAgICAgIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgICAgICAgICAgIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcbiAgICAgICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhdHRlbXB0IHRvIHdyaXRlIGJleW9uZCBidWZmZXIgYm91bmRzJyk7XG5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdXNlIG91ciBlbmNvZGluZyBtZXRob2QuXG4gICAgICAgICAgICB2YXIgYnVmID0gaWNvbnYuZW5jb2RlKHN0cmluZywgZW5jb2RpbmcpO1xuICAgICAgICAgICAgaWYgKGJ1Zi5sZW5ndGggPCBsZW5ndGgpIGxlbmd0aCA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgICAgICBidWYuY29weSh0aGlzLCBvZmZzZXQsIDAsIGxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBTZXQgX2NoYXJzV3JpdHRlbi5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gLS0gUmVhZGFibGUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBpZiAoaWNvbnYuc3VwcG9ydHNTdHJlYW1zKSB7XG4gICAgICAgICAgICB2YXIgUmVhZGFibGUgPSByZXF1aXJlKCdzdHJlYW0nKS5SZWFkYWJsZTtcblxuICAgICAgICAgICAgb3JpZ2luYWwuUmVhZGFibGVTZXRFbmNvZGluZyA9IFJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZztcbiAgICAgICAgICAgIFJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldEVuY29kaW5nKGVuYywgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIC8vIFVzZSBvdXIgb3duIGRlY29kZXIsIGl0IGhhcyB0aGUgc2FtZSBpbnRlcmZhY2UuXG4gICAgICAgICAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBvcmlnaW5hbCBmdW5jdGlvbiBhcyBpdCBkb2Vzbid0IGhhbmRsZSBCT00tcy5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBpY29udi5nZXREZWNvZGVyKGVuYywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgUmVhZGFibGUucHJvdG90eXBlLmNvbGxlY3QgPSBpY29udi5fY29sbGVjdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBpY29udi1saXRlIE5vZGUgcHJpbWl0aXZlIGV4dGVuc2lvbnMuXG4gICAgaWNvbnYudW5kb0V4dGVuZE5vZGVFbmNvZGluZ3MgPSBmdW5jdGlvbiB1bmRvRXh0ZW5kTm9kZUVuY29kaW5ncygpIHtcbiAgICAgICAgaWYgKCFpY29udi5zdXBwb3J0c05vZGVFbmNvZGluZ3NFeHRlbnNpb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghb3JpZ2luYWwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXF1aXJlKCdpY29udi1saXRlJykudW5kb0V4dGVuZE5vZGVFbmNvZGluZ3MoKTogTm90aGluZyB0byB1bmRvOyBleHRlbmROb2RlRW5jb2RpbmdzKCkgaXMgbm90IGNhbGxlZC5cIilcblxuICAgICAgICBkZWxldGUgQnVmZmVyLmlzTmF0aXZlRW5jb2Rpbmc7XG5cbiAgICAgICAgdmFyIFNsb3dCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5TbG93QnVmZmVyO1xuXG4gICAgICAgIFNsb3dCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gb3JpZ2luYWwuU2xvd0J1ZmZlclRvU3RyaW5nO1xuICAgICAgICBTbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IG9yaWdpbmFsLlNsb3dCdWZmZXJXcml0ZTtcblxuICAgICAgICBCdWZmZXIuaXNFbmNvZGluZyA9IG9yaWdpbmFsLkJ1ZmZlcklzRW5jb2Rpbmc7XG4gICAgICAgIEJ1ZmZlci5ieXRlTGVuZ3RoID0gb3JpZ2luYWwuQnVmZmVyQnl0ZUxlbmd0aDtcbiAgICAgICAgQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IG9yaWdpbmFsLkJ1ZmZlclRvU3RyaW5nO1xuICAgICAgICBCdWZmZXIucHJvdG90eXBlLndyaXRlID0gb3JpZ2luYWwuQnVmZmVyV3JpdGU7XG5cbiAgICAgICAgaWYgKGljb252LnN1cHBvcnRzU3RyZWFtcykge1xuICAgICAgICAgICAgdmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnc3RyZWFtJykuUmVhZGFibGU7XG5cbiAgICAgICAgICAgIFJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IG9yaWdpbmFsLlJlYWRhYmxlU2V0RW5jb2Rpbmc7XG4gICAgICAgICAgICBkZWxldGUgUmVhZGFibGUucHJvdG90eXBlLmNvbGxlY3Q7XG4gICAgICAgIH1cblxuICAgICAgICBvcmlnaW5hbCA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9pY29udi1saXRlL2xpYi9leHRlbmQtbm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogZWUtZmlyc3RcbiAqIENvcHlyaWdodChjKSAyMDE0IEpvbmF0aGFuIE9uZ1xuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmaXJzdFxuXG4vKipcbiAqIEdldCB0aGUgZmlyc3QgZXZlbnQgaW4gYSBzZXQgb2YgZXZlbnQgZW1pdHRlcnMgYW5kIGV2ZW50IHBhaXJzLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IHN0dWZmXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkb25lXG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZmlyc3Qoc3R1ZmYsIGRvbmUpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHN0dWZmKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmcgbXVzdCBiZSBhbiBhcnJheSBvZiBbZWUsIGV2ZW50cy4uLl0gYXJyYXlzJylcblxuICB2YXIgY2xlYW51cHMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R1ZmYubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXJyID0gc3R1ZmZbaV1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnIpIHx8IGFyci5sZW5ndGggPCAyKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZWFjaCBhcnJheSBtZW1iZXIgbXVzdCBiZSBbZWUsIGV2ZW50cy4uLl0nKVxuXG4gICAgdmFyIGVlID0gYXJyWzBdXG5cbiAgICBmb3IgKHZhciBqID0gMTsgaiA8IGFyci5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGV2ZW50ID0gYXJyW2pdXG4gICAgICB2YXIgZm4gPSBsaXN0ZW5lcihldmVudCwgY2FsbGJhY2spXG5cbiAgICAgIC8vIGxpc3RlbiB0byB0aGUgZXZlbnRcbiAgICAgIGVlLm9uKGV2ZW50LCBmbilcbiAgICAgIC8vIHB1c2ggdGhpcyBsaXN0ZW5lciB0byB0aGUgbGlzdCBvZiBjbGVhbnVwc1xuICAgICAgY2xlYW51cHMucHVzaCh7XG4gICAgICAgIGVlOiBlZSxcbiAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICBmbjogZm4sXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuICAgIGNsZWFudXAoKVxuICAgIGRvbmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICB2YXIgeFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xlYW51cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHggPSBjbGVhbnVwc1tpXVxuICAgICAgeC5lZS5yZW1vdmVMaXN0ZW5lcih4LmV2ZW50LCB4LmZuKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRodW5rKGZuKSB7XG4gICAgZG9uZSA9IGZuXG4gIH1cblxuICB0aHVuay5jYW5jZWwgPSBjbGVhbnVwXG5cbiAgcmV0dXJuIHRodW5rXG59XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBldmVudCBsaXN0ZW5lci5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbGlzdGVuZXIoZXZlbnQsIGRvbmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uZXZlbnQoYXJnMSkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgdmFyIGVlID0gdGhpc1xuICAgIHZhciBlcnIgPSBldmVudCA9PT0gJ2Vycm9yJ1xuICAgICAgPyBhcmcxXG4gICAgICA6IG51bGxcblxuICAgIC8vIGNvcHkgYXJncyB0byBwcmV2ZW50IGFyZ3VtZW50cyBlc2NhcGluZyBzY29wZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgIH1cblxuICAgIGRvbmUoZXJyLCBlZSwgZXZlbnQsIGFyZ3MpXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VlLWZpcnN0L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBtZWRpYS10eXBlclxuICogQ29weXJpZ2h0KGMpIDIwMTQgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogUmVnRXhwIHRvIG1hdGNoICooIFwiO1wiIHBhcmFtZXRlciApIGluIFJGQyAyNjE2IHNlYyAzLjdcbiAqXG4gKiBwYXJhbWV0ZXIgICAgID0gdG9rZW4gXCI9XCIgKCB0b2tlbiB8IHF1b3RlZC1zdHJpbmcgKVxuICogdG9rZW4gICAgICAgICA9IDEqPGFueSBDSEFSIGV4Y2VwdCBDVExzIG9yIHNlcGFyYXRvcnM+XG4gKiBzZXBhcmF0b3JzICAgID0gXCIoXCIgfCBcIilcIiB8IFwiPFwiIHwgXCI+XCIgfCBcIkBcIlxuICogICAgICAgICAgICAgICB8IFwiLFwiIHwgXCI7XCIgfCBcIjpcIiB8IFwiXFxcIiB8IDxcIj5cbiAqICAgICAgICAgICAgICAgfCBcIi9cIiB8IFwiW1wiIHwgXCJdXCIgfCBcIj9cIiB8IFwiPVwiXG4gKiAgICAgICAgICAgICAgIHwgXCJ7XCIgfCBcIn1cIiB8IFNQIHwgSFRcbiAqIHF1b3RlZC1zdHJpbmcgPSAoIDxcIj4gKihxZHRleHQgfCBxdW90ZWQtcGFpciApIDxcIj4gKVxuICogcWR0ZXh0ICAgICAgICA9IDxhbnkgVEVYVCBleGNlcHQgPFwiPj5cbiAqIHF1b3RlZC1wYWlyICAgPSBcIlxcXCIgQ0hBUlxuICogQ0hBUiAgICAgICAgICA9IDxhbnkgVVMtQVNDSUkgY2hhcmFjdGVyIChvY3RldHMgMCAtIDEyNyk+XG4gKiBURVhUICAgICAgICAgID0gPGFueSBPQ1RFVCBleGNlcHQgQ1RMcywgYnV0IGluY2x1ZGluZyBMV1M+XG4gKiBMV1MgICAgICAgICAgID0gW0NSTEZdIDEqKCBTUCB8IEhUIClcbiAqIENSTEYgICAgICAgICAgPSBDUiBMRlxuICogQ1IgICAgICAgICAgICA9IDxVUy1BU0NJSSBDUiwgY2FycmlhZ2UgcmV0dXJuICgxMyk+XG4gKiBMRiAgICAgICAgICAgID0gPFVTLUFTQ0lJIExGLCBsaW5lZmVlZCAoMTApPlxuICogU1AgICAgICAgICAgICA9IDxVUy1BU0NJSSBTUCwgc3BhY2UgKDMyKT5cbiAqIFNIVCAgICAgICAgICAgPSA8VVMtQVNDSUkgSFQsIGhvcml6b250YWwtdGFiICg5KT5cbiAqIENUTCAgICAgICAgICAgPSA8YW55IFVTLUFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVyIChvY3RldHMgMCAtIDMxKSBhbmQgREVMICgxMjcpPlxuICogT0NURVQgICAgICAgICA9IDxhbnkgOC1iaXQgc2VxdWVuY2Ugb2YgZGF0YT5cbiAqL1xudmFyIHBhcmFtUmVnRXhwID0gLzsgKihbISMkJSYnXFwqXFwrXFwtXFwuMC05QS1aXFxeX2BhLXpcXHx+XSspICo9ICooXCIoPzpbICFcXHUwMDIzLVxcdTAwNWJcXHUwMDVkLVxcdTAwN2VcXHUwMDgwLVxcdTAwZmZdfFxcXFxbXFx1MDAyMC1cXHUwMDdlXSkqXCJ8WyEjJCUmJ1xcKlxcK1xcLVxcLjAtOUEtWlxcXl9gYS16XFx8fl0rKSAqL2c7XG52YXIgdGV4dFJlZ0V4cCA9IC9eW1xcdTAwMjAtXFx1MDA3ZVxcdTAwODAtXFx1MDBmZl0rJC9cbnZhciB0b2tlblJlZ0V4cCA9IC9eWyEjJCUmJ1xcKlxcK1xcLVxcLjAtOUEtWlxcXl9gYS16XFx8fl0rJC9cblxuLyoqXG4gKiBSZWdFeHAgdG8gbWF0Y2ggcXVvdGVkLXBhaXIgaW4gUkZDIDI2MTZcbiAqXG4gKiBxdW90ZWQtcGFpciA9IFwiXFxcIiBDSEFSXG4gKiBDSEFSICAgICAgICA9IDxhbnkgVVMtQVNDSUkgY2hhcmFjdGVyIChvY3RldHMgMCAtIDEyNyk+XG4gKi9cbnZhciBxZXNjUmVnRXhwID0gL1xcXFwoW1xcdTAwMDAtXFx1MDA3Zl0pL2c7XG5cbi8qKlxuICogUmVnRXhwIHRvIG1hdGNoIGNoYXJzIHRoYXQgbXVzdCBiZSBxdW90ZWQtcGFpciBpbiBSRkMgMjYxNlxuICovXG52YXIgcXVvdGVSZWdFeHAgPSAvKFtcXFxcXCJdKS9nO1xuXG4vKipcbiAqIFJlZ0V4cCB0byBtYXRjaCB0eXBlIGluIFJGQyA2ODM4XG4gKlxuICogdHlwZS1uYW1lID0gcmVzdHJpY3RlZC1uYW1lXG4gKiBzdWJ0eXBlLW5hbWUgPSByZXN0cmljdGVkLW5hbWVcbiAqIHJlc3RyaWN0ZWQtbmFtZSA9IHJlc3RyaWN0ZWQtbmFtZS1maXJzdCAqMTI2cmVzdHJpY3RlZC1uYW1lLWNoYXJzXG4gKiByZXN0cmljdGVkLW5hbWUtZmlyc3QgID0gQUxQSEEgLyBESUdJVFxuICogcmVzdHJpY3RlZC1uYW1lLWNoYXJzICA9IEFMUEhBIC8gRElHSVQgLyBcIiFcIiAvIFwiI1wiIC9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBcIiRcIiAvIFwiJlwiIC8gXCItXCIgLyBcIl5cIiAvIFwiX1wiXG4gKiByZXN0cmljdGVkLW5hbWUtY2hhcnMgPS8gXCIuXCIgOyBDaGFyYWN0ZXJzIGJlZm9yZSBmaXJzdCBkb3QgYWx3YXlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgc3BlY2lmeSBhIGZhY2V0IG5hbWVcbiAqIHJlc3RyaWN0ZWQtbmFtZS1jaGFycyA9LyBcIitcIiA7IENoYXJhY3RlcnMgYWZ0ZXIgbGFzdCBwbHVzIGFsd2F5c1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7IHNwZWNpZnkgYSBzdHJ1Y3R1cmVkIHN5bnRheCBzdWZmaXhcbiAqIEFMUEhBID0gICV4NDEtNUEgLyAleDYxLTdBICAgOyBBLVogLyBhLXpcbiAqIERJR0lUID0gICV4MzAtMzkgICAgICAgICAgICAgOyAwLTlcbiAqL1xudmFyIHN1YnR5cGVOYW1lUmVnRXhwID0gL15bQS1aYS16MC05XVtBLVphLXowLTkhIyQmXl8uLV17MCwxMjZ9JC9cbnZhciB0eXBlTmFtZVJlZ0V4cCA9IC9eW0EtWmEtejAtOV1bQS1aYS16MC05ISMkJl5fLV17MCwxMjZ9JC9cbnZhciB0eXBlUmVnRXhwID0gL14gKihbQS1aYS16MC05XVtBLVphLXowLTkhIyQmXl8tXXswLDEyNn0pXFwvKFtBLVphLXowLTldW0EtWmEtejAtOSEjJCZeXy4rLV17MCwxMjZ9KSAqJC87XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXQgPSBmb3JtYXRcbmV4cG9ydHMucGFyc2UgPSBwYXJzZVxuXG4vKipcbiAqIEZvcm1hdCBvYmplY3QgdG8gbWVkaWEgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdChvYmopIHtcbiAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBvYmogaXMgcmVxdWlyZWQnKVxuICB9XG5cbiAgdmFyIHBhcmFtZXRlcnMgPSBvYmoucGFyYW1ldGVyc1xuICB2YXIgc3VidHlwZSA9IG9iai5zdWJ0eXBlXG4gIHZhciBzdWZmaXggPSBvYmouc3VmZml4XG4gIHZhciB0eXBlID0gb2JqLnR5cGVcblxuICBpZiAoIXR5cGUgfHwgIXR5cGVOYW1lUmVnRXhwLnRlc3QodHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHR5cGUnKVxuICB9XG5cbiAgaWYgKCFzdWJ0eXBlIHx8ICFzdWJ0eXBlTmFtZVJlZ0V4cC50ZXN0KHN1YnR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWJ0eXBlJylcbiAgfVxuXG4gIC8vIGZvcm1hdCBhcyB0eXBlL3N1YnR5cGVcbiAgdmFyIHN0cmluZyA9IHR5cGUgKyAnLycgKyBzdWJ0eXBlXG5cbiAgLy8gYXBwZW5kICtzdWZmaXhcbiAgaWYgKHN1ZmZpeCkge1xuICAgIGlmICghdHlwZU5hbWVSZWdFeHAudGVzdChzdWZmaXgpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1ZmZpeCcpXG4gICAgfVxuXG4gICAgc3RyaW5nICs9ICcrJyArIHN1ZmZpeFxuICB9XG5cbiAgLy8gYXBwZW5kIHBhcmFtZXRlcnNcbiAgaWYgKHBhcmFtZXRlcnMgJiYgdHlwZW9mIHBhcmFtZXRlcnMgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHBhcmFtXG4gICAgdmFyIHBhcmFtcyA9IE9iamVjdC5rZXlzKHBhcmFtZXRlcnMpLnNvcnQoKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhcmFtID0gcGFyYW1zW2ldXG5cbiAgICAgIGlmICghdG9rZW5SZWdFeHAudGVzdChwYXJhbSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXJhbWV0ZXIgbmFtZScpXG4gICAgICB9XG5cbiAgICAgIHN0cmluZyArPSAnOyAnICsgcGFyYW0gKyAnPScgKyBxc3RyaW5nKHBhcmFtZXRlcnNbcGFyYW1dKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHJpbmdcbn1cblxuLyoqXG4gKiBQYXJzZSBtZWRpYSB0eXBlIHRvIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHN0cmluZ1xuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHJpbmcpIHtcbiAgaWYgKCFzdHJpbmcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzdHJpbmcgaXMgcmVxdWlyZWQnKVxuICB9XG5cbiAgLy8gc3VwcG9ydCByZXEvcmVzLWxpa2Ugb2JqZWN0cyBhcyBhcmd1bWVudFxuICBpZiAodHlwZW9mIHN0cmluZyA9PT0gJ29iamVjdCcpIHtcbiAgICBzdHJpbmcgPSBnZXRjb250ZW50dHlwZShzdHJpbmcpXG4gIH1cblxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzdHJpbmcgaXMgcmVxdWlyZWQgdG8gYmUgYSBzdHJpbmcnKVxuICB9XG5cbiAgdmFyIGluZGV4ID0gc3RyaW5nLmluZGV4T2YoJzsnKVxuICB2YXIgdHlwZSA9IGluZGV4ICE9PSAtMVxuICAgID8gc3RyaW5nLnN1YnN0cigwLCBpbmRleClcbiAgICA6IHN0cmluZ1xuXG4gIHZhciBrZXlcbiAgdmFyIG1hdGNoXG4gIHZhciBvYmogPSBzcGxpdFR5cGUodHlwZSlcbiAgdmFyIHBhcmFtcyA9IHt9XG4gIHZhciB2YWx1ZVxuXG4gIHBhcmFtUmVnRXhwLmxhc3RJbmRleCA9IGluZGV4XG5cbiAgd2hpbGUgKG1hdGNoID0gcGFyYW1SZWdFeHAuZXhlYyhzdHJpbmcpKSB7XG4gICAgaWYgKG1hdGNoLmluZGV4ICE9PSBpbmRleCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXJhbWV0ZXIgZm9ybWF0JylcbiAgICB9XG5cbiAgICBpbmRleCArPSBtYXRjaFswXS5sZW5ndGhcbiAgICBrZXkgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpXG4gICAgdmFsdWUgPSBtYXRjaFsyXVxuXG4gICAgaWYgKHZhbHVlWzBdID09PSAnXCInKSB7XG4gICAgICAvLyByZW1vdmUgcXVvdGVzIGFuZCBlc2NhcGVzXG4gICAgICB2YWx1ZSA9IHZhbHVlXG4gICAgICAgIC5zdWJzdHIoMSwgdmFsdWUubGVuZ3RoIC0gMilcbiAgICAgICAgLnJlcGxhY2UocWVzY1JlZ0V4cCwgJyQxJylcbiAgICB9XG5cbiAgICBwYXJhbXNba2V5XSA9IHZhbHVlXG4gIH1cblxuICBpZiAoaW5kZXggIT09IC0xICYmIGluZGV4ICE9PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXJhbWV0ZXIgZm9ybWF0JylcbiAgfVxuXG4gIG9iai5wYXJhbWV0ZXJzID0gcGFyYW1zXG5cbiAgcmV0dXJuIG9ialxufVxuXG4vKipcbiAqIEdldCBjb250ZW50LXR5cGUgZnJvbSByZXEvcmVzIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRjb250ZW50dHlwZShvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmouZ2V0SGVhZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gcmVzLWxpa2VcbiAgICByZXR1cm4gb2JqLmdldEhlYWRlcignY29udGVudC10eXBlJylcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqLmhlYWRlcnMgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gcmVxLWxpa2VcbiAgICByZXR1cm4gb2JqLmhlYWRlcnMgJiYgb2JqLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddXG4gIH1cbn1cblxuLyoqXG4gKiBRdW90ZSBhIHN0cmluZyBpZiBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbFxuICogQHJldHVybiB7c3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcXN0cmluZyh2YWwpIHtcbiAgdmFyIHN0ciA9IFN0cmluZyh2YWwpXG5cbiAgLy8gbm8gbmVlZCB0byBxdW90ZSB0b2tlbnNcbiAgaWYgKHRva2VuUmVnRXhwLnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBzdHJcbiAgfVxuXG4gIGlmIChzdHIubGVuZ3RoID4gMCAmJiAhdGV4dFJlZ0V4cC50ZXN0KHN0cikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhcmFtZXRlciB2YWx1ZScpXG4gIH1cblxuICByZXR1cm4gJ1wiJyArIHN0ci5yZXBsYWNlKHF1b3RlUmVnRXhwLCAnXFxcXCQxJykgKyAnXCInXG59XG5cbi8qKlxuICogU2ltcGx5IFwidHlwZS9zdWJ0eXBlK3NpZmZ4XCIgaW50byBwYXJ0cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzcGxpdFR5cGUoc3RyaW5nKSB7XG4gIHZhciBtYXRjaCA9IHR5cGVSZWdFeHAuZXhlYyhzdHJpbmcudG9Mb3dlckNhc2UoKSlcblxuICBpZiAoIW1hdGNoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBtZWRpYSB0eXBlJylcbiAgfVxuXG4gIHZhciB0eXBlID0gbWF0Y2hbMV1cbiAgdmFyIHN1YnR5cGUgPSBtYXRjaFsyXVxuICB2YXIgc3VmZml4XG5cbiAgLy8gc3VmZml4IGFmdGVyIGxhc3QgK1xuICB2YXIgaW5kZXggPSBzdWJ0eXBlLmxhc3RJbmRleE9mKCcrJylcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIHN1ZmZpeCA9IHN1YnR5cGUuc3Vic3RyKGluZGV4ICsgMSlcbiAgICBzdWJ0eXBlID0gc3VidHlwZS5zdWJzdHIoMCwgaW5kZXgpXG4gIH1cblxuICB2YXIgb2JqID0ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgc3VidHlwZTogc3VidHlwZSxcbiAgICBzdWZmaXg6IHN1ZmZpeFxuICB9XG5cbiAgcmV0dXJuIG9ialxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWVkaWEtdHlwZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIG1pbWUtZGJcbiAqIENvcHlyaWdodChjKSAyMDE0IEpvbmF0aGFuIE9uZ1xuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGIuanNvbicpXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9taW1lLWRiL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XCJhcHBsaWNhdGlvbi8xZC1pbnRlcmxlYXZlZC1wYXJpdHlmZWNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi8zZ3BkYXNoLXFvZS1yZXBvcnQreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uLzNncHAtaW1zK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9hMmxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9hY3RpdmVtZXNzYWdlXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vYWN0aXZpdHkranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9hbHRvLWNvc3RtYXAranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9hbHRvLWNvc3RtYXBmaWx0ZXIranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9hbHRvLWRpcmVjdG9yeStqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2FsdG8tZW5kcG9pbnRjb3N0K2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vYWx0by1lbmRwb2ludGNvc3RwYXJhbXMranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9hbHRvLWVuZHBvaW50cHJvcCtqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2FsdG8tZW5kcG9pbnRwcm9wcGFyYW1zK2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vYWx0by1lcnJvcitqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2FsdG8tbmV0d29ya21hcCtqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2FsdG8tbmV0d29ya21hcGZpbHRlcitqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2FtbFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL2FuZHJldy1pbnNldFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImV6XCJdfSxcImFwcGxpY2F0aW9uL2FwcGxlZmlsZVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL2FwcGxpeHdhcmVcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcImF3XCJdfSxcImFwcGxpY2F0aW9uL2F0ZlwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL2F0ZnhcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9hdG9tK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJhdG9tXCJdfSxcImFwcGxpY2F0aW9uL2F0b21jYXQreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcImF0b21jYXRcIl19LFwiYXBwbGljYXRpb24vYXRvbWRlbGV0ZWQreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2F0b21pY21haWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9hdG9tc3ZjK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJhdG9tc3ZjXCJdfSxcImFwcGxpY2F0aW9uL2F0c2MtZHdkK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9hdHNjLWhlbGQreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2F0c2MtcnNhdCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vYXR4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9hdXRoLXBvbGljeSt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vYmFjbmV0LXhkZCt6aXBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlfSxcImFwcGxpY2F0aW9uL2JhdGNoLXNtdHBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9iZG9jXCI6e1wiY29tcHJlc3NpYmxlXCI6ZmFsc2UsXCJleHRlbnNpb25zXCI6W1wiYmRvY1wiXX0sXCJhcHBsaWNhdGlvbi9iZWVwK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9jYWxlbmRhcitqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2NhbGVuZGFyK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9jYWxsLWNvbXBsZXRpb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9jYWxzLTE4NDBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9jYm9yXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vY2NjZXhcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9jY21wK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9jY3htbCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wiY2N4bWxcIl19LFwiYXBwbGljYXRpb24vY2RmeCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vY2RtaS1jYXBhYmlsaXR5XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiY2RtaWFcIl19LFwiYXBwbGljYXRpb24vY2RtaS1jb250YWluZXJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJjZG1pY1wiXX0sXCJhcHBsaWNhdGlvbi9jZG1pLWRvbWFpblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImNkbWlkXCJdfSxcImFwcGxpY2F0aW9uL2NkbWktb2JqZWN0XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiY2RtaW9cIl19LFwiYXBwbGljYXRpb24vY2RtaS1xdWV1ZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImNkbWlxXCJdfSxcImFwcGxpY2F0aW9uL2NkbmlcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9jZWFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9jZWEtMjAxOCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vY2VsbG1sK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9jZndcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9jbHVlX2luZm8reG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2Ntc1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL2NucnAreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2NvYXAtZ3JvdXAranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9jb2FwLXBheWxvYWRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9jb21tb25ncm91bmRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9jb25mZXJlbmNlLWluZm8reG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2Nvc2VcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9jb3NlLWtleVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL2Nvc2Uta2V5LXNldFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL2NwbCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vY3NyYXR0cnNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9jc3RhK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9jc3RhZGF0YSt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vY3N2bStqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2N1LXNlZW1lXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJjdVwiXX0sXCJhcHBsaWNhdGlvbi9jd3RcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9jeWJlcmNhc2hcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9kYXJ0XCI6e1wiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9kYXNoK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJtcGRcIl19LFwiYXBwbGljYXRpb24vZGFzaGRlbHRhXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vZGF2bW91bnQreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcImRhdm1vdW50XCJdfSxcImFwcGxpY2F0aW9uL2RjYS1yZnRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9kY2RcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9kZWMtZHhcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9kaWFsb2ctaW5mbyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vZGljb21cIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9kaWNvbStqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2RpY29tK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9kaWlcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9kaXRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9kbnNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9kbnMranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9kbnMtbWVzc2FnZVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL2RvY2Jvb2sreG1sXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wiZGJrXCJdfSxcImFwcGxpY2F0aW9uL2Rza3BwK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9kc3NjK2RlclwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImRzc2NcIl19LFwiYXBwbGljYXRpb24vZHNzYyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wieGRzc2NcIl19LFwiYXBwbGljYXRpb24vZHZjc1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wiZWNtYVwiLFwiZXNcIl19LFwiYXBwbGljYXRpb24vZWRpLWNvbnNlbnRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9lZGkteDEyXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZX0sXCJhcHBsaWNhdGlvbi9lZGlmYWN0XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZX0sXCJhcHBsaWNhdGlvbi9lZmlcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9lbWVyZ2VuY3ljYWxsZGF0YS5jb21tZW50K3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9lbWVyZ2VuY3ljYWxsZGF0YS5jb250cm9sK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9lbWVyZ2VuY3ljYWxsZGF0YS5kZXZpY2VpbmZvK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9lbWVyZ2VuY3ljYWxsZGF0YS5lY2FsbC5tc2RcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9lbWVyZ2VuY3ljYWxsZGF0YS5wcm92aWRlcmluZm8reG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2VtZXJnZW5jeWNhbGxkYXRhLnNlcnZpY2VpbmZvK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9lbWVyZ2VuY3ljYWxsZGF0YS5zdWJzY3JpYmVyaW5mbyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vZW1lcmdlbmN5Y2FsbGRhdGEudmVkcyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vZW1tYSt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wiZW1tYVwiXX0sXCJhcHBsaWNhdGlvbi9lbW90aW9ubWwreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2VuY2FwcnRwXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vZXBwK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9lcHViK3ppcFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6ZmFsc2UsXCJleHRlbnNpb25zXCI6W1wiZXB1YlwiXX0sXCJhcHBsaWNhdGlvbi9lc2hvcFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL2V4aVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImV4aVwiXX0sXCJhcHBsaWNhdGlvbi9leHBlY3QtY3QtcmVwb3J0K2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vZmFzdGluZm9zZXRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9mYXN0c29hcFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL2ZkdCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vZmhpcitqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2ZoaXIreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2ZpZG8udHJ1c3RlZC1hcHBzK2pzb25cIjp7XCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2ZpdHNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9mb250LXNmbnRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9mb250LXRkcGZyXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wicGZyXCJdfSxcImFwcGxpY2F0aW9uL2ZvbnQtd29mZlwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6ZmFsc2V9LFwiYXBwbGljYXRpb24vZnJhbWV3b3JrLWF0dHJpYnV0ZXMreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2dlbytqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcImdlb2pzb25cIl19LFwiYXBwbGljYXRpb24vZ2VvK2pzb24tc2VxXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vZ2VvcGFja2FnZStzcWxpdGUzXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vZ2VveGFjbWwreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2dsdGYtYnVmZmVyXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vZ21sK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJnbWxcIl19LFwiYXBwbGljYXRpb24vZ3B4K3htbFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcImdweFwiXX0sXCJhcHBsaWNhdGlvbi9neGZcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcImd4ZlwiXX0sXCJhcHBsaWNhdGlvbi9nemlwXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJnelwiXX0sXCJhcHBsaWNhdGlvbi9oMjI0XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vaGVsZCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vaGpzb25cIjp7XCJleHRlbnNpb25zXCI6W1wiaGpzb25cIl19LFwiYXBwbGljYXRpb24vaHR0cFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL2h5cGVyc3R1ZGlvXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wic3RrXCJdfSxcImFwcGxpY2F0aW9uL2liZS1rZXktcmVxdWVzdCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vaWJlLXBrZy1yZXBseSt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vaWJlLXBwLWRhdGFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9pZ2VzXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vaW0taXNjb21wb3NpbmcreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2luZGV4XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vaW5kZXguY21kXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vaW5kZXgub2JqXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vaW5kZXgucmVzcG9uc2VcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9pbmRleC52bmRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9pbmttbCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wiaW5rXCIsXCJpbmttbFwiXX0sXCJhcHBsaWNhdGlvbi9pb3RwXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vaXBmaXhcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJpcGZpeFwiXX0sXCJhcHBsaWNhdGlvbi9pcHBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9pc3VwXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vaXRzK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9qYXZhLWFyY2hpdmVcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiY29tcHJlc3NpYmxlXCI6ZmFsc2UsXCJleHRlbnNpb25zXCI6W1wiamFyXCIsXCJ3YXJcIixcImVhclwiXX0sXCJhcHBsaWNhdGlvbi9qYXZhLXNlcmlhbGl6ZWQtb2JqZWN0XCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcInNlclwiXX0sXCJhcHBsaWNhdGlvbi9qYXZhLXZtXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcImNsYXNzXCJdfSxcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNoYXJzZXRcIjpcIlVURi04XCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcImpzXCIsXCJtanNcIl19LFwiYXBwbGljYXRpb24vamYyZmVlZCtqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2pvc2VcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9qb3NlK2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vanJkK2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vanNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY2hhcnNldFwiOlwiVVRGLThcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wianNvblwiLFwibWFwXCJdfSxcImFwcGxpY2F0aW9uL2pzb24tcGF0Y2granNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9qc29uLXNlcVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL2pzb241XCI6e1wiZXh0ZW5zaW9uc1wiOltcImpzb241XCJdfSxcImFwcGxpY2F0aW9uL2pzb25tbCtqc29uXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wianNvbm1sXCJdfSxcImFwcGxpY2F0aW9uL2p3aytqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2p3ay1zZXQranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9qd3RcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9rcG1sLXJlcXVlc3QreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2twbWwtcmVzcG9uc2UreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2xkK2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wianNvbmxkXCJdfSxcImFwcGxpY2F0aW9uL2xncit4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vbGluay1mb3JtYXRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9sb2FkLWNvbnRyb2wreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2xvc3QreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcImxvc3R4bWxcIl19LFwiYXBwbGljYXRpb24vbG9zdHN5bmMreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL2x4ZlwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL21hYy1iaW5oZXg0MFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImhxeFwiXX0sXCJhcHBsaWNhdGlvbi9tYWMtY29tcGFjdHByb1wiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiY3B0XCJdfSxcImFwcGxpY2F0aW9uL21hY3dyaXRlaWlcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9tYWRzK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJtYWRzXCJdfSxcImFwcGxpY2F0aW9uL21hbmlmZXN0K2pzb25cIjp7XCJjaGFyc2V0XCI6XCJVVEYtOFwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJ3ZWJtYW5pZmVzdFwiXX0sXCJhcHBsaWNhdGlvbi9tYXJjXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wibXJjXCJdfSxcImFwcGxpY2F0aW9uL21hcmN4bWwreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcIm1yY3hcIl19LFwiYXBwbGljYXRpb24vbWF0aGVtYXRpY2FcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJtYVwiLFwibmJcIixcIm1iXCJdfSxcImFwcGxpY2F0aW9uL21hdGhtbCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wibWF0aG1sXCJdfSxcImFwcGxpY2F0aW9uL21hdGhtbC1jb250ZW50K3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9tYXRobWwtcHJlc2VudGF0aW9uK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9tYm1zLWFzc29jaWF0ZWQtcHJvY2VkdXJlLWRlc2NyaXB0aW9uK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9tYm1zLWRlcmVnaXN0ZXIreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL21ibXMtZW52ZWxvcGUreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL21ibXMtbXNrK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9tYm1zLW1zay1yZXNwb25zZSt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vbWJtcy1wcm90ZWN0aW9uLWRlc2NyaXB0aW9uK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9tYm1zLXJlY2VwdGlvbi1yZXBvcnQreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL21ibXMtcmVnaXN0ZXIreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL21ibXMtcmVnaXN0ZXItcmVzcG9uc2UreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL21ibXMtc2NoZWR1bGUreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL21ibXMtdXNlci1zZXJ2aWNlLWRlc2NyaXB0aW9uK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9tYm94XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wibWJveFwiXX0sXCJhcHBsaWNhdGlvbi9tZWRpYS1wb2xpY3ktZGF0YXNldCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vbWVkaWFfY29udHJvbCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vbWVkaWFzZXJ2ZXJjb250cm9sK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJtc2NtbFwiXX0sXCJhcHBsaWNhdGlvbi9tZXJnZS1wYXRjaCtqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL21ldGFsaW5rK3htbFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcIm1ldGFsaW5rXCJdfSxcImFwcGxpY2F0aW9uL21ldGFsaW5rNCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wibWV0YTRcIl19LFwiYXBwbGljYXRpb24vbWV0cyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wibWV0c1wiXX0sXCJhcHBsaWNhdGlvbi9tZjRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9taWtleVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL21tdC1hZWkreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL21tdC11c2QreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL21vZHMreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcIm1vZHNcIl19LFwiYXBwbGljYXRpb24vbW9zcy1rZXlzXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vbW9zcy1zaWduYXR1cmVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9tb3Nza2V5LWRhdGFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9tb3Nza2V5LXJlcXVlc3RcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9tcDIxXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wibTIxXCIsXCJtcDIxXCJdfSxcImFwcGxpY2F0aW9uL21wNFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm1wNHNcIixcIm00cFwiXX0sXCJhcHBsaWNhdGlvbi9tcGVnNC1nZW5lcmljXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vbXBlZzQtaW9kXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vbXBlZzQtaW9kLXhtdFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL21yYi1jb25zdW1lcit4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vbXJiLXB1Ymxpc2greG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL21zYy1pdnIreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL21zYy1taXhlcit4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vbXN3b3JkXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJkb2NcIixcImRvdFwiXX0sXCJhcHBsaWNhdGlvbi9tdWQranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9teGZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJteGZcIl19LFwiYXBwbGljYXRpb24vbi1xdWFkc1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm5xXCJdfSxcImFwcGxpY2F0aW9uL24tdHJpcGxlc1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm50XCJdfSxcImFwcGxpY2F0aW9uL25hc2RhdGFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9uZXdzLWNoZWNrZ3JvdXBzXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vbmV3cy1ncm91cGluZm9cIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9uZXdzLXRyYW5zbWlzc2lvblwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL25sc21sK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9ub2RlXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vbnNzXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vb2NzcC1yZXF1ZXN0XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vb2NzcC1yZXNwb25zZVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6ZmFsc2UsXCJleHRlbnNpb25zXCI6W1wiYmluXCIsXCJkbXNcIixcImxyZlwiLFwibWFyXCIsXCJzb1wiLFwiZGlzdFwiLFwiZGlzdHpcIixcInBrZ1wiLFwiYnBrXCIsXCJkdW1wXCIsXCJlbGNcIixcImRlcGxveVwiLFwiZXhlXCIsXCJkbGxcIixcImRlYlwiLFwiZG1nXCIsXCJpc29cIixcImltZ1wiLFwibXNpXCIsXCJtc3BcIixcIm1zbVwiLFwiYnVmZmVyXCJdfSxcImFwcGxpY2F0aW9uL29kYVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm9kYVwiXX0sXCJhcHBsaWNhdGlvbi9vZG0reG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL29keFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL29lYnBzLXBhY2thZ2UreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcIm9wZlwiXX0sXCJhcHBsaWNhdGlvbi9vZ2dcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcIm9neFwiXX0sXCJhcHBsaWNhdGlvbi9vbWRvYyt4bWxcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJvbWRvY1wiXX0sXCJhcHBsaWNhdGlvbi9vbmVub3RlXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJvbmV0b2NcIixcIm9uZXRvYzJcIixcIm9uZXRtcFwiLFwib25lcGtnXCJdfSxcImFwcGxpY2F0aW9uL29zY29yZVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL294cHNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJveHBzXCJdfSxcImFwcGxpY2F0aW9uL3AycC1vdmVybGF5K3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9wYXJpdHlmZWNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9wYXNzcG9ydFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3BhdGNoLW9wcy1lcnJvcit4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wieGVyXCJdfSxcImFwcGxpY2F0aW9uL3BkZlwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6ZmFsc2UsXCJleHRlbnNpb25zXCI6W1wicGRmXCJdfSxcImFwcGxpY2F0aW9uL3BkeFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3BlbS1jZXJ0aWZpY2F0ZS1jaGFpblwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3BncC1lbmNyeXB0ZWRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcInBncFwiXX0sXCJhcHBsaWNhdGlvbi9wZ3Ata2V5c1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3BncC1zaWduYXR1cmVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJhc2NcIixcInNpZ1wiXX0sXCJhcHBsaWNhdGlvbi9waWNzLXJ1bGVzXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJwcmZcIl19LFwiYXBwbGljYXRpb24vcGlkZit4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vcGlkZi1kaWZmK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9wa2NzMTBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJwMTBcIl19LFwiYXBwbGljYXRpb24vcGtjczEyXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vcGtjczctbWltZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInA3bVwiLFwicDdjXCJdfSxcImFwcGxpY2F0aW9uL3BrY3M3LXNpZ25hdHVyZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInA3c1wiXX0sXCJhcHBsaWNhdGlvbi9wa2NzOFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInA4XCJdfSxcImFwcGxpY2F0aW9uL3BrY3M4LWVuY3J5cHRlZFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3BraXgtYXR0ci1jZXJ0XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiYWNcIl19LFwiYXBwbGljYXRpb24vcGtpeC1jZXJ0XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiY2VyXCJdfSxcImFwcGxpY2F0aW9uL3BraXgtY3JsXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiY3JsXCJdfSxcImFwcGxpY2F0aW9uL3BraXgtcGtpcGF0aFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInBraXBhdGhcIl19LFwiYXBwbGljYXRpb24vcGtpeGNtcFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInBraVwiXX0sXCJhcHBsaWNhdGlvbi9wbHMreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcInBsc1wiXX0sXCJhcHBsaWNhdGlvbi9wb2Mtc2V0dGluZ3MreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3Bvc3RzY3JpcHRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wiYWlcIixcImVwc1wiLFwicHNcIl19LFwiYXBwbGljYXRpb24vcHBzcC10cmFja2VyK2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vcHJvYmxlbStqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3Byb2JsZW0reG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3Byb3ZlbmFuY2UreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3Bycy5hbHZlc3RyYW5kLnRpdHJheC1zaGVldFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3Bycy5jd3dcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJjd3dcIl19LFwiYXBwbGljYXRpb24vcHJzLmhwdWIremlwXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZX0sXCJhcHBsaWNhdGlvbi9wcnMubnByZW5kXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vcHJzLnBsdWNrZXJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9wcnMucmRmLXhtbC1jcnlwdFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3Bycy54c2YreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3Bza2MreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcInBza2N4bWxcIl19LFwiYXBwbGljYXRpb24vcXNpZ1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3JhbWwreWFtbFwiOntcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wicmFtbFwiXX0sXCJhcHBsaWNhdGlvbi9yYXB0b3JmZWNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9yZGFwK2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vcmRmK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJyZGZcIixcIm93bFwiXX0sXCJhcHBsaWNhdGlvbi9yZWdpbmZvK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJyaWZcIl19LFwiYXBwbGljYXRpb24vcmVsYXgtbmctY29tcGFjdC1zeW50YXhcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJybmNcIl19LFwiYXBwbGljYXRpb24vcmVtb3RlLXByaW50aW5nXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vcmVwdXRvbitqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3Jlc291cmNlLWxpc3RzK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJybFwiXX0sXCJhcHBsaWNhdGlvbi9yZXNvdXJjZS1saXN0cy1kaWZmK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJybGRcIl19LFwiYXBwbGljYXRpb24vcmZjK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9yaXNjb3NcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9ybG1pK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9ybHMtc2VydmljZXMreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcInJzXCJdfSxcImFwcGxpY2F0aW9uL3JvdXRlLWFwZCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vcm91dGUtcy10c2lkK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9yb3V0ZS11c2QreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3Jwa2ktZ2hvc3RidXN0ZXJzXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZ2JyXCJdfSxcImFwcGxpY2F0aW9uL3Jwa2ktbWFuaWZlc3RcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJtZnRcIl19LFwiYXBwbGljYXRpb24vcnBraS1wdWJsaWNhdGlvblwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3Jwa2ktcm9hXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wicm9hXCJdfSxcImFwcGxpY2F0aW9uL3Jwa2ktdXBkb3duXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vcnNkK3htbFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcInJzZFwiXX0sXCJhcHBsaWNhdGlvbi9yc3MreG1sXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wicnNzXCJdfSxcImFwcGxpY2F0aW9uL3J0ZlwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJydGZcIl19LFwiYXBwbGljYXRpb24vcnRwbG9vcGJhY2tcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9ydHhcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9zYW1sYXNzZXJ0aW9uK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9zYW1sbWV0YWRhdGEreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3NibWwreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcInNibWxcIl19LFwiYXBwbGljYXRpb24vc2NhaXAreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3NjaW0ranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9zY3ZwLWN2LXJlcXVlc3RcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJzY3FcIl19LFwiYXBwbGljYXRpb24vc2N2cC1jdi1yZXNwb25zZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInNjc1wiXX0sXCJhcHBsaWNhdGlvbi9zY3ZwLXZwLXJlcXVlc3RcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJzcHFcIl19LFwiYXBwbGljYXRpb24vc2N2cC12cC1yZXNwb25zZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInNwcFwiXX0sXCJhcHBsaWNhdGlvbi9zZHBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJzZHBcIl19LFwiYXBwbGljYXRpb24vc2VjZXZlbnQrand0XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vc2VubWwrY2JvclwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3Nlbm1sK2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vc2VubWwreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3Nlbm1sLWV4aVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3NlbnNtbCtjYm9yXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vc2Vuc21sK2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vc2Vuc21sK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9zZW5zbWwtZXhpXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vc2VwK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi9zZXAtZXhpXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vc2Vzc2lvbi1pbmZvXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vc2V0LXBheW1lbnRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9zZXQtcGF5bWVudC1pbml0aWF0aW9uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wic2V0cGF5XCJdfSxcImFwcGxpY2F0aW9uL3NldC1yZWdpc3RyYXRpb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9zZXQtcmVnaXN0cmF0aW9uLWluaXRpYXRpb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJzZXRyZWdcIl19LFwiYXBwbGljYXRpb24vc2dtbFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3NnbWwtb3Blbi1jYXRhbG9nXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vc2hmK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJzaGZcIl19LFwiYXBwbGljYXRpb24vc2lldmVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJzaXZcIixcInNpZXZlXCJdfSxcImFwcGxpY2F0aW9uL3NpbXBsZS1maWx0ZXIreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3NpbXBsZS1tZXNzYWdlLXN1bW1hcnlcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9zaW1wbGVzeW1ib2xjb250YWluZXJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9zbGF0ZVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3NtaWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi9zbWlsK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJzbWlcIixcInNtaWxcIl19LFwiYXBwbGljYXRpb24vc21wdGUzMzZtXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vc29hcCtmYXN0aW5mb3NldFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3NvYXAreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3NwYXJxbC1xdWVyeVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInJxXCJdfSxcImFwcGxpY2F0aW9uL3NwYXJxbC1yZXN1bHRzK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJzcnhcIl19LFwiYXBwbGljYXRpb24vc3Bpcml0cy1ldmVudCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vc3FsXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vc3Jnc1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImdyYW1cIl19LFwiYXBwbGljYXRpb24vc3Jncyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wiZ3J4bWxcIl19LFwiYXBwbGljYXRpb24vc3J1K3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJzcnVcIl19LFwiYXBwbGljYXRpb24vc3NkbCt4bWxcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJzc2RsXCJdfSxcImFwcGxpY2F0aW9uL3NzbWwreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcInNzbWxcIl19LFwiYXBwbGljYXRpb24vc3RpeCtqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3RhbXAtYXBleC11cGRhdGVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi90YW1wLWFwZXgtdXBkYXRlLWNvbmZpcm1cIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi90YW1wLWNvbW11bml0eS11cGRhdGVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi90YW1wLWNvbW11bml0eS11cGRhdGUtY29uZmlybVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3RhbXAtZXJyb3JcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi90YW1wLXNlcXVlbmNlLWFkanVzdFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3RhbXAtc2VxdWVuY2UtYWRqdXN0LWNvbmZpcm1cIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi90YW1wLXN0YXR1cy1xdWVyeVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3RhbXAtc3RhdHVzLXJlc3BvbnNlXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdGFtcC11cGRhdGVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi90YW1wLXVwZGF0ZS1jb25maXJtXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdGFyXCI6e1wiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi90YXhpaStqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3RlaSt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1widGVpXCIsXCJ0ZWljb3JwdXNcIl19LFwiYXBwbGljYXRpb24vdGV0cmFfaXNpXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdGhyYXVkK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJ0ZmlcIl19LFwiYXBwbGljYXRpb24vdGltZXN0YW1wLXF1ZXJ5XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdGltZXN0YW1wLXJlcGx5XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdGltZXN0YW1wZWQtZGF0YVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInRzZFwiXX0sXCJhcHBsaWNhdGlvbi90bHNycHQrZ3ppcFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3Rsc3JwdCtqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3RuYXV0aGxpc3RcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi90cmlja2xlLWljZS1zZHBmcmFnXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdHJpZ1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3R0bWwreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3R2ZS10cmlnZ2VyXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdHppZlwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3R6aWYtbGVhcFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3VscGZlY1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3VyYy1ncnBzaGVldCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdXJjLXJlc3NoZWV0K3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi91cmMtdGFyZ2V0ZGVzYyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdXJjLXVpc29ja2V0ZGVzYyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdmNhcmQranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92Y2FyZCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdmVtbWlcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92aXZpZGVuY2Uuc2NyaXB0ZmlsZVwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCJ9LFwiYXBwbGljYXRpb24vdm5kLjEwMDBtaW5kcy5kZWNpc2lvbi1tb2RlbCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLjNncHAtcHJvc2UreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwLXByb3NlLXBjM2NoK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuM2dwcC12MngtbG9jYWwtc2VydmljZS1pbmZvcm1hdGlvblwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwLmFjY2Vzcy10cmFuc2Zlci1ldmVudHMreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwLmJzZit4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLjNncHAuZ21vcCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLjNncHAubWMtc2lnbmFsbGluZy1lYXJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuM2dwcC5tY2RhdGEtYWZmaWxpYXRpb24tY29tbWFuZCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLjNncHAubWNkYXRhLWluZm8reG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwLm1jZGF0YS1wYXlsb2FkXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLjNncHAubWNkYXRhLXNlcnZpY2UtY29uZmlnK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuM2dwcC5tY2RhdGEtc2lnbmFsbGluZ1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwLm1jZGF0YS11ZS1jb25maWcreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwLm1jZGF0YS11c2VyLXByb2ZpbGUreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwLm1jcHR0LWFmZmlsaWF0aW9uLWNvbW1hbmQreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwLm1jcHR0LWZsb29yLXJlcXVlc3QreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwLm1jcHR0LWluZm8reG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwLm1jcHR0LWxvY2F0aW9uLWluZm8reG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwLm1jcHR0LW1ibXMtdXNhZ2UtaW5mbyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLjNncHAubWNwdHQtc2VydmljZS1jb25maWcreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwLm1jcHR0LXNpZ25lZCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLjNncHAubWNwdHQtdWUtY29uZmlnK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuM2dwcC5tY3B0dC11ZS1pbml0LWNvbmZpZyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLjNncHAubWNwdHQtdXNlci1wcm9maWxlK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuM2dwcC5tY3ZpZGVvLWFmZmlsaWF0aW9uLWNvbW1hbmQreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwLm1jdmlkZW8tYWZmaWxpYXRpb24taW5mbyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLjNncHAubWN2aWRlby1sb2NhdGlvbi1pbmZvK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuM2dwcC5tY3ZpZGVvLW1ibXMtdXNhZ2UtaW5mbyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLjNncHAubWN2aWRlby1zZXJ2aWNlLWNvbmZpZyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLjNncHAubWN2aWRlby10cmFuc21pc3Npb24tcmVxdWVzdCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLjNncHAubWN2aWRlby11ZS1jb25maWcreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwLm1jdmlkZW8tdXNlci1wcm9maWxlK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuM2dwcC5taWQtY2FsbCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLjNncHAucGljLWJ3LWxhcmdlXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wicGxiXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwLnBpYy1idy1zbWFsbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInBzYlwiXX0sXCJhcHBsaWNhdGlvbi92bmQuM2dwcC5waWMtYnctdmFyXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wicHZiXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwLnNtc1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwLnNtcyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLjNncHAuc3J2Y2MtZXh0K3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuM2dwcC5zcnZjYy1pbmZvK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuM2dwcC5zdGF0ZS1hbmQtZXZlbnQtaW5mbyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLjNncHAudXNzZCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLjNncHAyLmJjbWNzaW5mbyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLjNncHAyLnNtc1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwMi50Y2FwXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1widGNhcFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuM2xpZ2h0c3NvZnR3YXJlLmltYWdlc2NhbFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC4zbS5wb3N0LWl0LW5vdGVzXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wicHduXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5hY2NwYWMuc2ltcGx5LmFzb1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImFzb1wiXX0sXCJhcHBsaWNhdGlvbi92bmQuYWNjcGFjLnNpbXBseS5pbXBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJpbXBcIl19LFwiYXBwbGljYXRpb24vdm5kLmFjdWNvYm9sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiYWN1XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5hY3Vjb3JwXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiYXRjXCIsXCJhY3V0Y1wiXX0sXCJhcHBsaWNhdGlvbi92bmQuYWRvYmUuYWlyLWFwcGxpY2F0aW9uLWluc3RhbGxlci1wYWNrYWdlK3ppcFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJhaXJcIl19LFwiYXBwbGljYXRpb24vdm5kLmFkb2JlLmZsYXNoLm1vdmllXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmFkb2JlLmZvcm1zY2VudHJhbC5mY2R0XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZmNkdFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuYWRvYmUuZnhwXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZnhwXCIsXCJmeHBsXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5wYXJ0aWFsLXVwbG9hZFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5hZG9iZS54ZHAreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcInhkcFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuYWRvYmUueGZkZlwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInhmZGZcIl19LFwiYXBwbGljYXRpb24vdm5kLmFldGhlci5pbXBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuYWZwYy5hZnBsaW5lZGF0YVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5hZnBjLm1vZGNhXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmFoLWJhcmNvZGVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuYWhlYWQuc3BhY2VcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJhaGVhZFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuYWlyemlwLmZpbGVzZWN1cmUuYXpmXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiYXpmXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5haXJ6aXAuZmlsZXNlY3VyZS5henNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJhenNcIl19LFwiYXBwbGljYXRpb24vdm5kLmFtYWRldXMranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuYW1hem9uLmVib29rXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJhendcIl19LFwiYXBwbGljYXRpb24vdm5kLmFtYXpvbi5tb2JpOC1lYm9va1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5hbWVyaWNhbmR5bmFtaWNzLmFjY1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImFjY1wiXX0sXCJhcHBsaWNhdGlvbi92bmQuYW1pZ2EuYW1pXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiYW1pXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5hbXVuZHNlbi5tYXplK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuYW5kcm9pZC5wYWNrYWdlLWFyY2hpdmVcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiY29tcHJlc3NpYmxlXCI6ZmFsc2UsXCJleHRlbnNpb25zXCI6W1wiYXBrXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5hbmtpXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmFuc2VyLXdlYi1jZXJ0aWZpY2F0ZS1pc3N1ZS1pbml0aWF0aW9uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiY2lpXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5hbnNlci13ZWItZnVuZHMtdHJhbnNmZXItaW5pdGlhdGlvblwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiZnRpXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5hbnRpeC5nYW1lLWNvbXBvbmVudFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImF0eFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuYXBhY2hlLnRocmlmdC5iaW5hcnlcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuYXBhY2hlLnRocmlmdC5jb21wYWN0XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmFwYWNoZS50aHJpZnQuanNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5hcGkranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuYXBvdGhla2VuZGUucmVzZXJ2YXRpb24ranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuYXBwbGUuaW5zdGFsbGVyK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJtcGtnXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5hcHBsZS5rZXlub3RlXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wia2V5bm90ZVwiXX0sXCJhcHBsaWNhdGlvbi92bmQuYXBwbGUubXBlZ3VybFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm0zdThcIl19LFwiYXBwbGljYXRpb24vdm5kLmFwcGxlLm51bWJlcnNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJudW1iZXJzXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5hcHBsZS5wYWdlc1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInBhZ2VzXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5hcHBsZS5wa3Bhc3NcIjp7XCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJwa3Bhc3NcIl19LFwiYXBwbGljYXRpb24vdm5kLmFyYXN0cmEuc3dpXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmFyaXN0YW5ldHdvcmtzLnN3aVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInN3aVwiXX0sXCJhcHBsaWNhdGlvbi92bmQuYXJ0aXNhbitqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5hcnRzcXVhcmVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuYXN0cmFlYS1zb2Z0d2FyZS5pb3RhXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiaW90YVwiXX0sXCJhcHBsaWNhdGlvbi92bmQuYXVkaW9ncmFwaFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImFlcFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuYXV0b3BhY2thZ2VcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuYXZhbG9uK2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLmF2aXN0YXIreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5iYWxzYW1pcS5ibW1sK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuYmFsc2FtaXEuYm1wclwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5iYW5hbmEtYWNjb3VudGluZ1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5iYmYudXNwLm1zZ1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5iYmYudXNwLm1zZytqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5iZWtpdHp1ci1zdGVjaCtqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5iaW50Lm1lZC1jb250ZW50XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmJpb3BheC5yZGYreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5ibGluay1pZGItdmFsdWUtd3JhcHBlclwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5ibHVlaWNlLm11bHRpcGFzc1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm1wbVwiXX0sXCJhcHBsaWNhdGlvbi92bmQuYmx1ZXRvb3RoLmVwLm9vYlwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5ibHVldG9vdGgubGUub29iXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmJtaVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImJtaVwiXX0sXCJhcHBsaWNhdGlvbi92bmQuYnVzaW5lc3NvYmplY3RzXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wicmVwXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5ieXUudWFwaStqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5jYWItanNjcmlwdFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5jYW5vbi1jcGRsXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmNhbm9uLWxpcHNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuY2FwYXN5c3RlbXMtcGcranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuY2VuZGlvLnRoaW5saW5jLmNsaWVudGNvbmZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuY2VudHVyeS1zeXN0ZW1zLnRjcF9zdHJlYW1cIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuY2hlbWRyYXcreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcImNkeG1sXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5jaGVzcy1wZ25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuY2hpcG51dHMua2FyYW9rZS1tbWRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJtbWRcIl19LFwiYXBwbGljYXRpb24vdm5kLmNpbmRlcmVsbGFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJjZHlcIl19LFwiYXBwbGljYXRpb24vdm5kLmNpcnBhY2suaXNkbi1leHRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuY2l0YXRpb25zdHlsZXMuc3R5bGUreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcImNzbFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuY2xheW1vcmVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJjbGFcIl19LFwiYXBwbGljYXRpb24vdm5kLmNsb2FudG8ucnA5XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wicnA5XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5jbG9uay5jNGdyb3VwXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiYzRnXCIsXCJjNGRcIixcImM0ZlwiLFwiYzRwXCIsXCJjNHVcIl19LFwiYXBwbGljYXRpb24vdm5kLmNsdWV0cnVzdC5jYXJ0b21vYmlsZS1jb25maWdcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJjMTFhbWNcIl19LFwiYXBwbGljYXRpb24vdm5kLmNsdWV0cnVzdC5jYXJ0b21vYmlsZS1jb25maWctcGtnXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiYzExYW16XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5jb2ZmZWVzY3JpcHRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuY29sbGFiaW8ueG9kb2N1bWVudHMuZG9jdW1lbnRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuY29sbGFiaW8ueG9kb2N1bWVudHMuZG9jdW1lbnQtdGVtcGxhdGVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuY29sbGFiaW8ueG9kb2N1bWVudHMucHJlc2VudGF0aW9uXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmNvbGxhYmlvLnhvZG9jdW1lbnRzLnByZXNlbnRhdGlvbi10ZW1wbGF0ZVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5jb2xsYWJpby54b2RvY3VtZW50cy5zcHJlYWRzaGVldFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5jb2xsYWJpby54b2RvY3VtZW50cy5zcHJlYWRzaGVldC10ZW1wbGF0ZVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5jb2xsZWN0aW9uK2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLmNvbGxlY3Rpb24uZG9jK2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLmNvbGxlY3Rpb24ubmV4dCtqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5jb21pY2Jvb2sremlwXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZX0sXCJhcHBsaWNhdGlvbi92bmQuY29taWNib29rLXJhclwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5jb21tZXJjZS1iYXR0ZWxsZVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5jb21tb25zcGFjZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImNzcFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuY29udGFjdC5jbXNnXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiY2RiY21zZ1wiXX0sXCJhcHBsaWNhdGlvbi92bmQuY29yZW9zLmlnbml0aW9uK2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLmNvc21vY2FsbGVyXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiY21jXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5jcmljay5jbGlja2VyXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiY2xreFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuY3JpY2suY2xpY2tlci5rZXlib2FyZFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImNsa2tcIl19LFwiYXBwbGljYXRpb24vdm5kLmNyaWNrLmNsaWNrZXIucGFsZXR0ZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImNsa3BcIl19LFwiYXBwbGljYXRpb24vdm5kLmNyaWNrLmNsaWNrZXIudGVtcGxhdGVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJjbGt0XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5jcmljay5jbGlja2VyLndvcmRiYW5rXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiY2xrd1wiXX0sXCJhcHBsaWNhdGlvbi92bmQuY3JpdGljYWx0b29scy53YnMreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcIndic1wiXX0sXCJhcHBsaWNhdGlvbi92bmQuY3RjLXBvc21sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wicG1sXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5jdGN0LndzK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuY3Vwcy1wZGZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuY3Vwcy1wb3N0c2NyaXB0XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmN1cHMtcHBkXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wicHBkXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5jdXBzLXJhc3RlclwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5jdXBzLXJhd1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5jdXJsXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmN1cmwuY2FyXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJjYXJcIl19LFwiYXBwbGljYXRpb24vdm5kLmN1cmwucGN1cmxcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInBjdXJsXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5jeWFuLmRlYW4ucm9vdCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLmN5YmFua1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5kMmwuY291cnNlcGFja2FnZTFwMCt6aXBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlfSxcImFwcGxpY2F0aW9uL3ZuZC5kYXJ0XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcImRhcnRcIl19LFwiYXBwbGljYXRpb24vdm5kLmRhdGEtdmlzaW9uLnJkelwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInJkelwiXX0sXCJhcHBsaWNhdGlvbi92bmQuZGF0YXBhY2thZ2UranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuZGF0YXJlc291cmNlK2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLmRlYmlhbi5iaW5hcnktcGFja2FnZVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5kZWNlLmRhdGFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ1dmZcIixcInV2dmZcIixcInV2ZFwiLFwidXZ2ZFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuZGVjZS50dG1sK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJ1dnRcIixcInV2dnRcIl19LFwiYXBwbGljYXRpb24vdm5kLmRlY2UudW5zcGVjaWZpZWRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ1dnhcIixcInV2dnhcIl19LFwiYXBwbGljYXRpb24vdm5kLmRlY2UuemlwXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1widXZ6XCIsXCJ1dnZ6XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5kZW5vdm8uZmNzZWxheW91dC1saW5rXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZmVfbGF1bmNoXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5kZXNtdW1lLm1vdmllXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmRpci1iaS5wbGF0ZS1kbC1ub3N1ZmZpeFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5kbS5kZWxlZ2F0aW9uK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuZG5hXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZG5hXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5kb2N1bWVudCtqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5kb2xieS5tbHBcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcIm1scFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuZG9sYnkubW9iaWxlLjFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuZG9sYnkubW9iaWxlLjJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuZG9yZW1pci5zY29yZWNsb3VkLWJpbmFyeS1kb2N1bWVudFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5kcGdyYXBoXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZHBnXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5kcmVhbWZhY3RvcnlcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJkZmFjXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5kcml2ZStqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5kcy1rZXlwb2ludFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wia3B4eFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuZHRnLmxvY2FsXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmR0Zy5sb2NhbC5mbGFzaFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5kdGcubG9jYWwuaHRtbFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5kdmIuYWl0XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiYWl0XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5kdmIuZHZialwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5kdmIuZXNnY29udGFpbmVyXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmR2Yi5pcGRjZGZ0bm90aWZhY2Nlc3NcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuZHZiLmlwZGNlc2dhY2Nlc3NcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuZHZiLmlwZGNlc2dhY2Nlc3MyXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmR2Yi5pcGRjZXNncGRkXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmR2Yi5pcGRjcm9hbWluZ1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5kdmIuaXB0di5hbGZlYy1iYXNlXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmR2Yi5pcHR2LmFsZmVjLWVuaGFuY2VtZW50XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmR2Yi5ub3RpZi1hZ2dyZWdhdGUtcm9vdCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLmR2Yi5ub3RpZi1jb250YWluZXIreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5kdmIubm90aWYtZ2VuZXJpYyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLmR2Yi5ub3RpZi1pYS1tc2dsaXN0K3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuZHZiLm5vdGlmLWlhLXJlZ2lzdHJhdGlvbi1yZXF1ZXN0K3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuZHZiLm5vdGlmLWlhLXJlZ2lzdHJhdGlvbi1yZXNwb25zZSt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLmR2Yi5ub3RpZi1pbml0K3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuZHZiLnBmclwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5kdmIuc2VydmljZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInN2Y1wiXX0sXCJhcHBsaWNhdGlvbi92bmQuZHhyXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmR5bmFnZW9cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJnZW9cIl19LFwiYXBwbGljYXRpb24vdm5kLmR6clwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5lYXN5a2FyYW9rZS5jZGdkb3dubG9hZFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5lY2Rpcy11cGRhdGVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuZWNpcC5ybHBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuZWNvd2luLmNoYXJ0XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wibWFnXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5lY293aW4uZmlsZXJlcXVlc3RcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuZWNvd2luLmZpbGV1cGRhdGVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuZWNvd2luLnNlcmllc1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5lY293aW4uc2VyaWVzcmVxdWVzdFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5lY293aW4uc2VyaWVzdXBkYXRlXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmVmaS5pbWdcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuZWZpLmlzb1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5lbWNsaWVudC5hY2Nlc3NyZXF1ZXN0K3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuZW5saXZlblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm5tbFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuZW5waGFzZS5lbnZveVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5lcHJpbnRzLmRhdGEreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5lcHNvbi5lc2ZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJlc2ZcIl19LFwiYXBwbGljYXRpb24vdm5kLmVwc29uLm1zZlwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm1zZlwiXX0sXCJhcHBsaWNhdGlvbi92bmQuZXBzb24ucXVpY2thbmltZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInFhbVwiXX0sXCJhcHBsaWNhdGlvbi92bmQuZXBzb24uc2FsdFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInNsdFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuZXBzb24uc3NmXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wic3NmXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5lcmljc3Nvbi5xdWlja2NhbGxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuZXNwYXNzLWVzcGFzcyt6aXBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlfSxcImFwcGxpY2F0aW9uL3ZuZC5lc3ppZ25vMyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wiZXMzXCIsXCJldDNcIl19LFwiYXBwbGljYXRpb24vdm5kLmV0c2kuYW9jK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuZXRzaS5hc2ljLWUremlwXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZX0sXCJhcHBsaWNhdGlvbi92bmQuZXRzaS5hc2ljLXMremlwXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZX0sXCJhcHBsaWNhdGlvbi92bmQuZXRzaS5jdWcreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5ldHNpLmlwdHZjb21tYW5kK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuZXRzaS5pcHR2ZGlzY292ZXJ5K3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuZXRzaS5pcHR2cHJvZmlsZSt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLmV0c2kuaXB0dnNhZC1iYyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLmV0c2kuaXB0dnNhZC1jb2QreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5ldHNpLmlwdHZzYWQtbnB2cit4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLmV0c2kuaXB0dnNlcnZpY2UreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5ldHNpLmlwdHZzeW5jK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuZXRzaS5pcHR2dWVwcm9maWxlK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuZXRzaS5tY2lkK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuZXRzaS5taGVnNVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5ldHNpLm92ZXJsb2FkLWNvbnRyb2wtcG9saWN5LWRhdGFzZXQreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5ldHNpLnBzdG4reG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5ldHNpLnNjaSt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLmV0c2kuc2ltc2VydnMreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5ldHNpLnRpbWVzdGFtcC10b2tlblwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5ldHNpLnRzbCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLmV0c2kudHNsLmRlclwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5ldWRvcmEuZGF0YVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5ldm9sdi5lY2lnLnByb2ZpbGVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuZXZvbHYuZWNpZy5zZXR0aW5nc1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5ldm9sdi5lY2lnLnRoZW1lXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmV4c3RyZWFtLWVtcG93ZXIremlwXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZX0sXCJhcHBsaWNhdGlvbi92bmQuZXhzdHJlYW0tcGFja2FnZVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5lenBpeC1hbGJ1bVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImV6MlwiXX0sXCJhcHBsaWNhdGlvbi92bmQuZXpwaXgtcGFja2FnZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImV6M1wiXX0sXCJhcHBsaWNhdGlvbi92bmQuZi1zZWN1cmUubW9iaWxlXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmZhc3Rjb3B5LWRpc2staW1hZ2VcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuZmRmXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZmRmXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5mZHNuLm1zZWVkXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wibXNlZWRcIl19LFwiYXBwbGljYXRpb24vdm5kLmZkc24uc2VlZFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInNlZWRcIixcImRhdGFsZXNzXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5mZnNuc1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5maWxtaXQuemZjXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmZpbnRzXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmZpcmVtb25rZXlzLmNsb3VkY2VsbFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5mbG9ncmFwaGl0XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZ3BoXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5mbHV4dGltZS5jbGlwXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZnRjXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5mb250LWZvbnRmb3JnZS1zZmRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuZnJhbWVtYWtlclwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImZtXCIsXCJmcmFtZVwiLFwibWFrZXJcIixcImJvb2tcIl19LFwiYXBwbGljYXRpb24vdm5kLmZyb2dhbnMuZm5jXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZm5jXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5mcm9nYW5zLmx0ZlwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImx0ZlwiXX0sXCJhcHBsaWNhdGlvbi92bmQuZnNjLndlYmxhdW5jaFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImZzY1wiXX0sXCJhcHBsaWNhdGlvbi92bmQuZnVqaXRzdS5vYXN5c1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm9hc1wiXX0sXCJhcHBsaWNhdGlvbi92bmQuZnVqaXRzdS5vYXN5czJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJvYTJcIl19LFwiYXBwbGljYXRpb24vdm5kLmZ1aml0c3Uub2FzeXMzXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wib2EzXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5mdWppdHN1Lm9hc3lzZ3BcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJmZzVcIl19LFwiYXBwbGljYXRpb24vdm5kLmZ1aml0c3Uub2FzeXNwcnNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJiaDJcIl19LFwiYXBwbGljYXRpb24vdm5kLmZ1aml4ZXJveC5hcnQtZXhcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuZnVqaXhlcm94LmFydDRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuZnVqaXhlcm94LmRkZFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImRkZFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuZnVqaXhlcm94LmRvY3V3b3Jrc1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInhkd1wiXX0sXCJhcHBsaWNhdGlvbi92bmQuZnVqaXhlcm94LmRvY3V3b3Jrcy5iaW5kZXJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ4YmRcIl19LFwiYXBwbGljYXRpb24vdm5kLmZ1aml4ZXJveC5kb2N1d29ya3MuY29udGFpbmVyXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmZ1aml4ZXJveC5oYnBsXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmZ1dC1taXNuZXRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuZnV0b2luK2Nib3JcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuZnV0b2luK2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLmZ1enp5c2hlZXRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJmenNcIl19LFwiYXBwbGljYXRpb24vdm5kLmdlbm9tYXRpeC50dXhlZG9cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ0eGRcIl19LFwiYXBwbGljYXRpb24vdm5kLmdlbytqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5nZW9jdWJlK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuZ2VvZ2VicmEuZmlsZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImdnYlwiXX0sXCJhcHBsaWNhdGlvbi92bmQuZ2VvZ2VicmEudG9vbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImdndFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuZ2VvbWV0cnktZXhwbG9yZXJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJnZXhcIixcImdyZVwiXX0sXCJhcHBsaWNhdGlvbi92bmQuZ2VvbmV4dFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImd4dFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuZ2VvcGxhblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImcyd1wiXX0sXCJhcHBsaWNhdGlvbi92bmQuZ2Vvc3BhY2VcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJnM3dcIl19LFwiYXBwbGljYXRpb24vdm5kLmdlcmJlclwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5nbG9iYWxwbGF0Zm9ybS5jYXJkLWNvbnRlbnQtbWd0XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmdsb2JhbHBsYXRmb3JtLmNhcmQtY29udGVudC1tZ3QtcmVzcG9uc2VcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuZ214XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZ214XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5nb29nbGUtYXBwcy5kb2N1bWVudFwiOntcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcImdkb2NcIl19LFwiYXBwbGljYXRpb24vdm5kLmdvb2dsZS1hcHBzLnByZXNlbnRhdGlvblwiOntcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcImdzbGlkZXNcIl19LFwiYXBwbGljYXRpb24vdm5kLmdvb2dsZS1hcHBzLnNwcmVhZHNoZWV0XCI6e1wiY29tcHJlc3NpYmxlXCI6ZmFsc2UsXCJleHRlbnNpb25zXCI6W1wiZ3NoZWV0XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5nb29nbGUtZWFydGgua21sK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJrbWxcIl19LFwiYXBwbGljYXRpb24vdm5kLmdvb2dsZS1lYXJ0aC5rbXpcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcImttelwiXX0sXCJhcHBsaWNhdGlvbi92bmQuZ292LnNrLmUtZm9ybSt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLmdvdi5zay5lLWZvcm0remlwXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZX0sXCJhcHBsaWNhdGlvbi92bmQuZ292LnNrLnhtbGRhdGFjb250YWluZXIreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5ncmFmZXFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJncWZcIixcImdxc1wiXX0sXCJhcHBsaWNhdGlvbi92bmQuZ3JpZG1wXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmdyb292ZS1hY2NvdW50XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZ2FjXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5ncm9vdmUtaGVscFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImdoZlwiXX0sXCJhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLWlkZW50aXR5LW1lc3NhZ2VcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJnaW1cIl19LFwiYXBwbGljYXRpb24vdm5kLmdyb292ZS1pbmplY3RvclwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImdydlwiXX0sXCJhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLXRvb2wtbWVzc2FnZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImd0bVwiXX0sXCJhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLXRvb2wtdGVtcGxhdGVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ0cGxcIl19LFwiYXBwbGljYXRpb24vdm5kLmdyb292ZS12Y2FyZFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInZjZ1wiXX0sXCJhcHBsaWNhdGlvbi92bmQuaGFsK2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLmhhbCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wiaGFsXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5oYW5kaGVsZC1lbnRlcnRhaW5tZW50K3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJ6bW1cIl19LFwiYXBwbGljYXRpb24vdm5kLmhiY2lcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJoYmNpXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5oYytqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5oY2wtYmlyZXBvcnRzXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmhkdFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5oZXJva3UranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuaGhlLmxlc3Nvbi1wbGF5ZXJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJsZXNcIl19LFwiYXBwbGljYXRpb24vdm5kLmhwLWhwZ2xcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJocGdsXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5ocC1ocGlkXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiaHBpZFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuaHAtaHBzXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiaHBzXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5ocC1qbHl0XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiamx0XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5ocC1wY2xcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJwY2xcIl19LFwiYXBwbGljYXRpb24vdm5kLmhwLXBjbHhsXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wicGNseGxcIl19LFwiYXBwbGljYXRpb24vdm5kLmh0dHBob25lXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmh5ZHJvc3RhdGl4LnNvZi1kYXRhXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wic2ZkLWhkc3R4XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5oeXBlcitqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5oeXBlci1pdGVtK2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLmh5cGVyZHJpdmUranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuaHpuLTNkLWNyb3Nzd29yZFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5pYm0uYWZwbGluZWRhdGFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuaWJtLmVsZWN0cm9uaWMtbWVkaWFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuaWJtLm1pbmlwYXlcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJtcHlcIl19LFwiYXBwbGljYXRpb24vdm5kLmlibS5tb2RjYXBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJhZnBcIixcImxpc3RhZnBcIixcImxpc3QzODIwXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5pYm0ucmlnaHRzLW1hbmFnZW1lbnRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJpcm1cIl19LFwiYXBwbGljYXRpb24vdm5kLmlibS5zZWN1cmUtY29udGFpbmVyXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wic2NcIl19LFwiYXBwbGljYXRpb24vdm5kLmljY3Byb2ZpbGVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJpY2NcIixcImljbVwiXX0sXCJhcHBsaWNhdGlvbi92bmQuaWVlZS4xOTA1XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmlnbG9hZGVyXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiaWdsXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5pbWFnZW1ldGVyLmZvbGRlcit6aXBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlfSxcImFwcGxpY2F0aW9uL3ZuZC5pbWFnZW1ldGVyLmltYWdlK3ppcFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6ZmFsc2V9LFwiYXBwbGljYXRpb24vdm5kLmltbWVydmlzaW9uLWl2cFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIml2cFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuaW1tZXJ2aXNpb24taXZ1XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiaXZ1XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5pbXMuaW1zY2N2MXAxXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmltcy5pbXNjY3YxcDJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuaW1zLmltc2NjdjFwM1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5pbXMubGlzLnYyLnJlc3VsdCtqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5pbXMubHRpLnYyLnRvb2xjb25zdW1lcnByb2ZpbGUranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuaW1zLmx0aS52Mi50b29scHJveHkranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuaW1zLmx0aS52Mi50b29scHJveHkuaWQranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuaW1zLmx0aS52Mi50b29sc2V0dGluZ3MranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuaW1zLmx0aS52Mi50b29sc2V0dGluZ3Muc2ltcGxlK2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLmluZm9ybWVkY29udHJvbC5ybXMreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5pbmZvcm1peC12aXNpb25hcnlcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuaW5mb3RlY2gucHJvamVjdFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5pbmZvdGVjaC5wcm9qZWN0K3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuaW5ub3BhdGgud2FtcC5ub3RpZmljYXRpb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuaW5zb3JzLmlnbVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImlnbVwiXX0sXCJhcHBsaWNhdGlvbi92bmQuaW50ZXJjb24uZm9ybW5ldFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInhwd1wiLFwieHB4XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5pbnRlcmdlb1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImkyZ1wiXX0sXCJhcHBsaWNhdGlvbi92bmQuaW50ZXJ0cnVzdC5kaWdpYm94XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmludGVydHJ1c3Qubm5jcFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5pbnR1LnFib1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInFib1wiXX0sXCJhcHBsaWNhdGlvbi92bmQuaW50dS5xZnhcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJxZnhcIl19LFwiYXBwbGljYXRpb24vdm5kLmlwdGMuZzIuY2F0YWxvZ2l0ZW0reG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5pcHRjLmcyLmNvbmNlcHRpdGVtK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuaXB0Yy5nMi5rbm93bGVkZ2VpdGVtK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuaXB0Yy5nMi5uZXdzaXRlbSt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLmlwdGMuZzIubmV3c21lc3NhZ2UreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5pcHRjLmcyLnBhY2thZ2VpdGVtK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuaXB0Yy5nMi5wbGFubmluZ2l0ZW0reG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5pcHVucGx1Z2dlZC5yY3Byb2ZpbGVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJyY3Byb2ZpbGVcIl19LFwiYXBwbGljYXRpb24vdm5kLmlyZXBvc2l0b3J5LnBhY2thZ2UreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcImlycFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuaXMteHByXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wieHByXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5pc2FjLmZjc1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImZjc1wiXX0sXCJhcHBsaWNhdGlvbi92bmQuamFtXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiamFtXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5qYXBhbm5ldC1kaXJlY3Rvcnktc2VydmljZVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5qYXBhbm5ldC1qcG5zdG9yZS13YWtldXBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuamFwYW5uZXQtcGF5bWVudC13YWtldXBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuamFwYW5uZXQtcmVnaXN0cmF0aW9uXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmphcGFubmV0LXJlZ2lzdHJhdGlvbi13YWtldXBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuamFwYW5uZXQtc2V0c3RvcmUtd2FrZXVwXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmphcGFubmV0LXZlcmlmaWNhdGlvblwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5qYXBhbm5ldC12ZXJpZmljYXRpb24td2FrZXVwXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLmpjcC5qYXZhbWUubWlkbGV0LXJtc1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInJtc1wiXX0sXCJhcHBsaWNhdGlvbi92bmQuamlzcFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImppc3BcIl19LFwiYXBwbGljYXRpb24vdm5kLmpvb3N0LmpvZGEtYXJjaGl2ZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImpvZGFcIl19LFwiYXBwbGljYXRpb24vdm5kLmpzay5pc2RuLW5nblwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5rYWhvb3R6XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wia3R6XCIsXCJrdHJcIl19LFwiYXBwbGljYXRpb24vdm5kLmtkZS5rYXJib25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJrYXJib25cIl19LFwiYXBwbGljYXRpb24vdm5kLmtkZS5rY2hhcnRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJjaHJ0XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5rZGUua2Zvcm11bGFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJrZm9cIl19LFwiYXBwbGljYXRpb24vdm5kLmtkZS5raXZpb1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImZsd1wiXX0sXCJhcHBsaWNhdGlvbi92bmQua2RlLmtvbnRvdXJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJrb25cIl19LFwiYXBwbGljYXRpb24vdm5kLmtkZS5rcHJlc2VudGVyXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wia3ByXCIsXCJrcHRcIl19LFwiYXBwbGljYXRpb24vdm5kLmtkZS5rc3ByZWFkXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wia3NwXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5rZGUua3dvcmRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJrd2RcIixcImt3dFwiXX0sXCJhcHBsaWNhdGlvbi92bmQua2VuYW1lYWFwcFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImh0a2VcIl19LFwiYXBwbGljYXRpb24vdm5kLmtpZHNwaXJhdGlvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImtpYVwiXX0sXCJhcHBsaWNhdGlvbi92bmQua2luYXJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJrbmVcIixcImtucFwiXX0sXCJhcHBsaWNhdGlvbi92bmQua29hblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInNrcFwiLFwic2tkXCIsXCJza3RcIixcInNrbVwiXX0sXCJhcHBsaWNhdGlvbi92bmQua29kYWstZGVzY3JpcHRvclwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInNzZVwiXX0sXCJhcHBsaWNhdGlvbi92bmQubGFzLmxhcytqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5sYXMubGFzK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJsYXN4bWxcIl19LFwiYXBwbGljYXRpb24vdm5kLmxlYXAranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQubGliZXJ0eS1yZXF1ZXN0K3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQubGxhbWFncmFwaGljcy5saWZlLWJhbGFuY2UuZGVza3RvcFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImxiZFwiXX0sXCJhcHBsaWNhdGlvbi92bmQubGxhbWFncmFwaGljcy5saWZlLWJhbGFuY2UuZXhjaGFuZ2UreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcImxiZVwiXX0sXCJhcHBsaWNhdGlvbi92bmQubG90dXMtMS0yLTNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCIxMjNcIl19LFwiYXBwbGljYXRpb24vdm5kLmxvdHVzLWFwcHJvYWNoXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiYXByXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5sb3R1cy1mcmVlbGFuY2VcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJwcmVcIl19LFwiYXBwbGljYXRpb24vdm5kLmxvdHVzLW5vdGVzXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wibnNmXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5sb3R1cy1vcmdhbml6ZXJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJvcmdcIl19LFwiYXBwbGljYXRpb24vdm5kLmxvdHVzLXNjcmVlbmNhbVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInNjbVwiXX0sXCJhcHBsaWNhdGlvbi92bmQubG90dXMtd29yZHByb1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImx3cFwiXX0sXCJhcHBsaWNhdGlvbi92bmQubWFjcG9ydHMucG9ydHBrZ1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInBvcnRwa2dcIl19LFwiYXBwbGljYXRpb24vdm5kLm1hcGJveC12ZWN0b3ItdGlsZVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5tYXJsaW4uZHJtLmFjdGlvbnRva2VuK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQubWFybGluLmRybS5jb25mdG9rZW4reG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5tYXJsaW4uZHJtLmxpY2Vuc2UreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5tYXJsaW4uZHJtLm1kY2ZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQubWFzb24ranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQubWF4bWluZC5tYXhtaW5kLWRiXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLm1jZFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm1jZFwiXX0sXCJhcHBsaWNhdGlvbi92bmQubWVkY2FsY2RhdGFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJtYzFcIl19LFwiYXBwbGljYXRpb24vdm5kLm1lZGlhc3RhdGlvbi5jZGtleVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImNka2V5XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5tZXJpZGlhbi1zbGluZ3Nob3RcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQubWZlclwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm13ZlwiXX0sXCJhcHBsaWNhdGlvbi92bmQubWZtcFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm1mbVwiXX0sXCJhcHBsaWNhdGlvbi92bmQubWljcm8ranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQubWljcm9ncmFmeC5mbG9cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJmbG9cIl19LFwiYXBwbGljYXRpb24vdm5kLm1pY3JvZ3JhZnguaWd4XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiaWd4XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5taWNyb3NvZnQucG9ydGFibGUtZXhlY3V0YWJsZVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5taWNyb3NvZnQud2luZG93cy50aHVtYm5haWwtY2FjaGVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQubWllbGUranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQubWlmXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wibWlmXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5taW5pc29mdC1ocDMwMDAtc2F2ZVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5taXRzdWJpc2hpLm1pc3R5LWd1YXJkLnRydXN0d2ViXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLm1vYml1cy5kYWZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJkYWZcIl19LFwiYXBwbGljYXRpb24vdm5kLm1vYml1cy5kaXNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJkaXNcIl19LFwiYXBwbGljYXRpb24vdm5kLm1vYml1cy5tYmtcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJtYmtcIl19LFwiYXBwbGljYXRpb24vdm5kLm1vYml1cy5tcXlcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJtcXlcIl19LFwiYXBwbGljYXRpb24vdm5kLm1vYml1cy5tc2xcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJtc2xcIl19LFwiYXBwbGljYXRpb24vdm5kLm1vYml1cy5wbGNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJwbGNcIl19LFwiYXBwbGljYXRpb24vdm5kLm1vYml1cy50eGZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ0eGZcIl19LFwiYXBwbGljYXRpb24vdm5kLm1vcGh1bi5hcHBsaWNhdGlvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm1wblwiXX0sXCJhcHBsaWNhdGlvbi92bmQubW9waHVuLmNlcnRpZmljYXRlXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wibXBjXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5tb3Rvcm9sYS5mbGV4c3VpdGVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQubW90b3JvbGEuZmxleHN1aXRlLmFkc2lcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQubW90b3JvbGEuZmxleHN1aXRlLmZpc1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5tb3Rvcm9sYS5mbGV4c3VpdGUuZ290YXBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQubW90b3JvbGEuZmxleHN1aXRlLmttclwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5tb3Rvcm9sYS5mbGV4c3VpdGUudHRjXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLm1vdG9yb2xhLmZsZXhzdWl0ZS53ZW1cIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQubW90b3JvbGEuaXBybVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5tb3ppbGxhLnh1bCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wieHVsXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5tcy0zbWZkb2N1bWVudFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1hcnRnYWxyeVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImNpbFwiXX0sXCJhcHBsaWNhdGlvbi92bmQubXMtYXNmXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLm1zLWNhYi1jb21wcmVzc2VkXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiY2FiXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1jb2xvci5pY2Nwcm9maWxlXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIn0sXCJhcHBsaWNhdGlvbi92bmQubXMtZXhjZWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcInhsc1wiLFwieGxtXCIsXCJ4bGFcIixcInhsY1wiLFwieGx0XCIsXCJ4bHdcIl19LFwiYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLmFkZGluLm1hY3JvZW5hYmxlZC4xMlwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInhsYW1cIl19LFwiYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLnNoZWV0LmJpbmFyeS5tYWNyb2VuYWJsZWQuMTJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ4bHNiXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5zaGVldC5tYWNyb2VuYWJsZWQuMTJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ4bHNtXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC50ZW1wbGF0ZS5tYWNyb2VuYWJsZWQuMTJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ4bHRtXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1mb250b2JqZWN0XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcImVvdFwiXX0sXCJhcHBsaWNhdGlvbi92bmQubXMtaHRtbGhlbHBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJjaG1cIl19LFwiYXBwbGljYXRpb24vdm5kLm1zLWltc1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImltc1wiXX0sXCJhcHBsaWNhdGlvbi92bmQubXMtbHJtXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wibHJtXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1vZmZpY2UuYWN0aXZleCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm1zLW9mZmljZXRoZW1lXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1widGhteFwiXX0sXCJhcHBsaWNhdGlvbi92bmQubXMtb3BlbnR5cGVcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQubXMtb3V0bG9va1wiOntcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcIm1zZ1wiXX0sXCJhcHBsaWNhdGlvbi92bmQubXMtcGFja2FnZS5vYmZ1c2NhdGVkLW9wZW50eXBlXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIn0sXCJhcHBsaWNhdGlvbi92bmQubXMtcGtpLnNlY2NhdFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiY2F0XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1wa2kuc3RsXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJzdGxcIl19LFwiYXBwbGljYXRpb24vdm5kLm1zLXBsYXlyZWFkeS5pbml0aWF0b3IreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJwcHRcIixcInBwc1wiLFwicG90XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LmFkZGluLm1hY3JvZW5hYmxlZC4xMlwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInBwYW1cIl19LFwiYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQucHJlc2VudGF0aW9uLm1hY3JvZW5hYmxlZC4xMlwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInBwdG1cIl19LFwiYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQuc2xpZGUubWFjcm9lbmFibGVkLjEyXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wic2xkbVwiXX0sXCJhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludC5zbGlkZXNob3cubWFjcm9lbmFibGVkLjEyXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wicHBzbVwiXX0sXCJhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludC50ZW1wbGF0ZS5tYWNyb2VuYWJsZWQuMTJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJwb3RtXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1wcmludGRldmljZWNhcGFiaWxpdGllcyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm1zLXByaW50aW5nLnByaW50dGlja2V0K3htbFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1wcmludHNjaGVtYXRpY2tldCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm1zLXByb2plY3RcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJtcHBcIixcIm1wdFwiXX0sXCJhcHBsaWNhdGlvbi92bmQubXMtdG5lZlwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5tcy13aW5kb3dzLmRldmljZXBhaXJpbmdcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQubXMtd2luZG93cy5ud3ByaW50aW5nLm9vYlwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5tcy13aW5kb3dzLnByaW50ZXJwYWlyaW5nXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLm1zLXdpbmRvd3Mud3NkLm9vYlwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5tcy13bWRybS5saWMtY2hsZy1yZXFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQubXMtd21kcm0ubGljLXJlc3BcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQubXMtd21kcm0ubWV0ZXItY2hsZy1yZXFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQubXMtd21kcm0ubWV0ZXItcmVzcFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5tcy13b3JkLmRvY3VtZW50Lm1hY3JvZW5hYmxlZC4xMlwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImRvY21cIl19LFwiYXBwbGljYXRpb24vdm5kLm1zLXdvcmQudGVtcGxhdGUubWFjcm9lbmFibGVkLjEyXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZG90bVwiXX0sXCJhcHBsaWNhdGlvbi92bmQubXMtd29ya3NcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ3cHNcIixcIndrc1wiLFwid2NtXCIsXCJ3ZGJcIl19LFwiYXBwbGljYXRpb24vdm5kLm1zLXdwbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIndwbFwiXX0sXCJhcHBsaWNhdGlvbi92bmQubXMteHBzZG9jdW1lbnRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcInhwc1wiXX0sXCJhcHBsaWNhdGlvbi92bmQubXNhLWRpc2staW1hZ2VcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQubXNlcVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm1zZXFcIl19LFwiYXBwbGljYXRpb24vdm5kLm1zaWduXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLm11bHRpYWQuY3JlYXRvclwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5tdWx0aWFkLmNyZWF0b3IuY2lmXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLm11c2ljLW5pZmZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQubXVzaWNpYW5cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJtdXNcIl19LFwiYXBwbGljYXRpb24vdm5kLm11dmVlLnN0eWxlXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wibXN0eVwiXX0sXCJhcHBsaWNhdGlvbi92bmQubXluZmNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ0YWdsZXRcIl19LFwiYXBwbGljYXRpb24vdm5kLm5jZC5jb250cm9sXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLm5jZC5yZWZlcmVuY2VcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQubmVhcnN0Lmluditqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5uZXJ2YW5hXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLm5ldGZweFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5uZXVyb2xhbmd1YWdlLm5sdVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm5sdVwiXX0sXCJhcHBsaWNhdGlvbi92bmQubmltblwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5uaW50ZW5kby5uaXRyby5yb21cIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQubmludGVuZG8uc25lcy5yb21cIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQubml0ZlwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm50ZlwiLFwibml0ZlwiXX0sXCJhcHBsaWNhdGlvbi92bmQubm9ibGVuZXQtZGlyZWN0b3J5XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wibm5kXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5ub2JsZW5ldC1zZWFsZXJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJubnNcIl19LFwiYXBwbGljYXRpb24vdm5kLm5vYmxlbmV0LXdlYlwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm5ud1wiXX0sXCJhcHBsaWNhdGlvbi92bmQubm9raWEuY2F0YWxvZ3NcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQubm9raWEuY29ubWwrd2J4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQubm9raWEuY29ubWwreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5ub2tpYS5pcHR2LmNvbmZpZyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm5va2lhLmlzZHMtcmFkaW8tcHJlc2V0c1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5ub2tpYS5sYW5kbWFyayt3YnhtbFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5ub2tpYS5sYW5kbWFyayt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm5va2lhLmxhbmRtYXJrY29sbGVjdGlvbit4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm5va2lhLm4tZ2FnZS5hYyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm5va2lhLm4tZ2FnZS5kYXRhXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wibmdkYXRcIl19LFwiYXBwbGljYXRpb24vdm5kLm5va2lhLm4tZ2FnZS5zeW1iaWFuLmluc3RhbGxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJuLWdhZ2VcIl19LFwiYXBwbGljYXRpb24vdm5kLm5va2lhLm5jZFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5ub2tpYS5wY2Qrd2J4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQubm9raWEucGNkK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQubm9raWEucmFkaW8tcHJlc2V0XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wicnBzdFwiXX0sXCJhcHBsaWNhdGlvbi92bmQubm9raWEucmFkaW8tcHJlc2V0c1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInJwc3NcIl19LFwiYXBwbGljYXRpb24vdm5kLm5vdmFkaWdtLmVkbVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImVkbVwiXX0sXCJhcHBsaWNhdGlvbi92bmQubm92YWRpZ20uZWR4XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZWR4XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5ub3ZhZGlnbS5leHRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJleHRcIl19LFwiYXBwbGljYXRpb24vdm5kLm50dC1sb2NhbC5jb250ZW50LXNoYXJlXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLm50dC1sb2NhbC5maWxlLXRyYW5zZmVyXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLm50dC1sb2NhbC5vZ3dfcmVtb3RlLWFjY2Vzc1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5udHQtbG9jYWwuc2lwLXRhX3JlbW90ZVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5udHQtbG9jYWwuc2lwLXRhX3RjcF9zdHJlYW1cIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmNoYXJ0XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wib2RjXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuY2hhcnQtdGVtcGxhdGVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJvdGNcIl19LFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5kYXRhYmFzZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm9kYlwiXX0sXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmZvcm11bGFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJvZGZcIl19LFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5mb3JtdWxhLXRlbXBsYXRlXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wib2RmdFwiXX0sXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmdyYXBoaWNzXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJvZGdcIl19LFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5ncmFwaGljcy10ZW1wbGF0ZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm90Z1wiXX0sXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmltYWdlXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wib2RpXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuaW1hZ2UtdGVtcGxhdGVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJvdGlcIl19LFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5wcmVzZW50YXRpb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcIm9kcFwiXX0sXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnByZXNlbnRhdGlvbi10ZW1wbGF0ZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm90cFwiXX0sXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnNwcmVhZHNoZWV0XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJvZHNcIl19LFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5zcHJlYWRzaGVldC10ZW1wbGF0ZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm90c1wiXX0sXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcIm9kdFwiXX0sXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHQtbWFzdGVyXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wib2RtXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQudGV4dC10ZW1wbGF0ZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm90dFwiXX0sXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHQtd2ViXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wib3RoXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5vYm5cIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQub2NmK2Nib3JcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQub2Z0bi5sMTBuK2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9pcGYuY29udGVudGFjY2Vzc2Rvd25sb2FkK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub2lwZi5jb250ZW50YWNjZXNzc3RyZWFtaW5nK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub2lwZi5jc3BnLWhleGJpbmFyeVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5vaXBmLmRhZS5zdmcreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vaXBmLmRhZS54aHRtbCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9pcGYubWlwcHZjb250cm9sbWVzc2FnZSt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9pcGYucGFlLmdlbVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5vaXBmLnNwZGlzY292ZXJ5K3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub2lwZi5zcGRsaXN0K3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub2lwZi51ZXByb2ZpbGUreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vaXBmLnVzZXJwcm9maWxlK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub2xwYy1zdWdhclwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInhvXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5vbWEtc2N3cy1jb25maWdcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQub21hLXNjd3MtaHR0cC1yZXF1ZXN0XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLm9tYS1zY3dzLWh0dHAtcmVzcG9uc2VcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQub21hLmJjYXN0LmFzc29jaWF0ZWQtcHJvY2VkdXJlLXBhcmFtZXRlcit4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9tYS5iY2FzdC5kcm0tdHJpZ2dlcit4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9tYS5iY2FzdC5pbWQreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vbWEuYmNhc3QubHRrbVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5vbWEuYmNhc3Qubm90aWZpY2F0aW9uK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub21hLmJjYXN0LnByb3Zpc2lvbmluZ3RyaWdnZXJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQub21hLmJjYXN0LnNnYm9vdFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5vbWEuYmNhc3Quc2dkZCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9tYS5iY2FzdC5zZ2R1XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLm9tYS5iY2FzdC5zaW1wbGUtc3ltYm9sLWNvbnRhaW5lclwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5vbWEuYmNhc3Quc21hcnRjYXJkLXRyaWdnZXIreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vbWEuYmNhc3Quc3Byb3YreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vbWEuYmNhc3Quc3RrbVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5vbWEuY2FiLWFkZHJlc3MtYm9vayt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9tYS5jYWItZmVhdHVyZS1oYW5kbGVyK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub21hLmNhYi1wY2MreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vbWEuY2FiLXN1YnMtaW52aXRlK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub21hLmNhYi11c2VyLXByZWZzK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub21hLmRjZFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5vbWEuZGNkY1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5vbWEuZGQyK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJkZDJcIl19LFwiYXBwbGljYXRpb24vdm5kLm9tYS5kcm0ucmlzZCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9tYS5ncm91cC11c2FnZS1saXN0K3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub21hLmx3bTJtK2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9tYS5sd20ybSt0bHZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQub21hLnBhbCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9tYS5wb2MuZGV0YWlsZWQtcHJvZ3Jlc3MtcmVwb3J0K3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub21hLnBvYy5maW5hbC1yZXBvcnQreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vbWEucG9jLmdyb3Vwcyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9tYS5wb2MuaW52b2NhdGlvbi1kZXNjcmlwdG9yK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub21hLnBvYy5vcHRpbWl6ZWQtcHJvZ3Jlc3MtcmVwb3J0K3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub21hLnB1c2hcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQub21hLnNjaWRtLm1lc3NhZ2VzK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub21hLnhjYXAtZGlyZWN0b3J5K3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub21hZHMtZW1haWwreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vbWFkcy1maWxlK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub21hZHMtZm9sZGVyK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub21hbG9jLXN1cGwtaW5pdFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5vbmVwYWdlclwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5vbmVwYWdlcnRhbXBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQub25lcGFnZXJ0YW14XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLm9uZXBhZ2VydGF0XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLm9uZXBhZ2VydGF0cFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5vbmVwYWdlcnRhdHhcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQub3BlbmJsb3guZ2FtZSt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9wZW5ibG94LmdhbWUtYmluYXJ5XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLm9wZW5leWUub2ViXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLm9wZW5vZmZpY2VvcmcuZXh0ZW5zaW9uXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJveHRcIl19LFwiYXBwbGljYXRpb24vdm5kLm9wZW5zdHJlZXRtYXAuZGF0YSt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LmN1c3RvbS1wcm9wZXJ0aWVzK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuY3VzdG9teG1scHJvcGVydGllcyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LmRyYXdpbmcreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5kcmF3aW5nbWwuY2hhcnQreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5kcmF3aW5nbWwuY2hhcnRzaGFwZXMreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5kcmF3aW5nbWwuZGlhZ3JhbWNvbG9ycyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LmRyYXdpbmdtbC5kaWFncmFtZGF0YSt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LmRyYXdpbmdtbC5kaWFncmFtbGF5b3V0K3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuZHJhd2luZ21sLmRpYWdyYW1zdHlsZSt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LmV4dGVuZGVkLXByb3BlcnRpZXMreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5jb21tZW50YXV0aG9ycyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLmNvbW1lbnRzK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwuaGFuZG91dG1hc3Rlcit4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLm5vdGVzbWFzdGVyK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwubm90ZXNzbGlkZSt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnByZXNlbnRhdGlvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6ZmFsc2UsXCJleHRlbnNpb25zXCI6W1wicHB0eFwiXX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwucHJlc2VudGF0aW9uLm1haW4reG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5wcmVzcHJvcHMreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5zbGlkZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInNsZHhcIl19LFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnNsaWRlK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwuc2xpZGVsYXlvdXQreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5zbGlkZW1hc3Rlcit4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnNsaWRlc2hvd1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInBwc3hcIl19LFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnNsaWRlc2hvdy5tYWluK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwuc2xpZGV1cGRhdGVpbmZvK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwudGFibGVzdHlsZXMreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC50YWdzK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwudGVtcGxhdGVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJwb3R4XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC50ZW1wbGF0ZS5tYWluK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwudmlld3Byb3BzK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5jYWxjY2hhaW4reG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLmNoYXJ0c2hlZXQreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLmNvbW1lbnRzK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5jb25uZWN0aW9ucyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuZGlhbG9nc2hlZXQreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLmV4dGVybmFsbGluayt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwucGl2b3RjYWNoZWRlZmluaXRpb24reG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnBpdm90Y2FjaGVyZWNvcmRzK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5waXZvdHRhYmxlK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5xdWVyeXRhYmxlK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5yZXZpc2lvbmhlYWRlcnMreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnJldmlzaW9ubG9nK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5zaGFyZWRzdHJpbmdzK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5zaGVldFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6ZmFsc2UsXCJleHRlbnNpb25zXCI6W1wieGxzeFwiXX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5zaGVldC5tYWluK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5zaGVldG1ldGFkYXRhK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5zdHlsZXMreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnRhYmxlK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC50YWJsZXNpbmdsZWNlbGxzK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC50ZW1wbGF0ZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInhsdHhcIl19LFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwudGVtcGxhdGUubWFpbit4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwudXNlcm5hbWVzK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC52b2xhdGlsZWRlcGVuZGVuY2llcyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwud29ya3NoZWV0K3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQudGhlbWUreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC50aGVtZW92ZXJyaWRlK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQudm1sZHJhd2luZ1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmNvbW1lbnRzK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6ZmFsc2UsXCJleHRlbnNpb25zXCI6W1wiZG9jeFwiXX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudC5nbG9zc2FyeSt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQubWFpbit4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZW5kbm90ZXMreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmZvbnR0YWJsZSt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZm9vdGVyK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5mb290bm90ZXMreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLm51bWJlcmluZyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuc2V0dGluZ3MreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLnN0eWxlcyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwudGVtcGxhdGVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJkb3R4XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLnRlbXBsYXRlLm1haW4reG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLndlYnNldHRpbmdzK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtcGFja2FnZS5jb3JlLXByb3BlcnRpZXMreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1wYWNrYWdlLmRpZ2l0YWwtc2lnbmF0dXJlLXhtbHNpZ25hdHVyZSt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLXBhY2thZ2UucmVsYXRpb25zaGlwcyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLm9yYWNsZS5yZXNvdXJjZStqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5vcmFuZ2UuaW5kYXRhXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLm9zYS5uZXRkZXBsb3lcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQub3NnZW8ubWFwZ3VpZGUucGFja2FnZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm1ncFwiXX0sXCJhcHBsaWNhdGlvbi92bmQub3NnaS5idW5kbGVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQub3NnaS5kcFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImRwXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5vc2dpLnN1YnN5c3RlbVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImVzYVwiXX0sXCJhcHBsaWNhdGlvbi92bmQub3Rwcy5jdC1raXAreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5veGxpLmNvdW50Z3JhcGhcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQucGFnZXJkdXR5K2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLnBhbG1cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJwZGJcIixcInBxYVwiLFwib3ByY1wiXX0sXCJhcHBsaWNhdGlvbi92bmQucGFub3BseVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5wYW9zLnhtbFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5wYXRlbnRkaXZlXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnBhdGllbnRlY29tbXNkb2NcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQucGF3YWFmaWxlXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wicGF3XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5wY29zXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnBnLmZvcm1hdFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInN0clwiXX0sXCJhcHBsaWNhdGlvbi92bmQucGcub3Nhc2xpXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZWk2XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5waWFjY2Vzcy5hcHBsaWNhdGlvbi1saWNlbmNlXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnBpY3NlbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImVmaWZcIl19LFwiYXBwbGljYXRpb24vdm5kLnBtaS53aWRnZXRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ3Z1wiXX0sXCJhcHBsaWNhdGlvbi92bmQucG9jLmdyb3VwLWFkdmVydGlzZW1lbnQreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5wb2NrZXRsZWFyblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInBsZlwiXX0sXCJhcHBsaWNhdGlvbi92bmQucG93ZXJidWlsZGVyNlwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInBiZFwiXX0sXCJhcHBsaWNhdGlvbi92bmQucG93ZXJidWlsZGVyNi1zXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnBvd2VyYnVpbGRlcjdcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQucG93ZXJidWlsZGVyNy1zXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnBvd2VyYnVpbGRlcjc1XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnBvd2VyYnVpbGRlcjc1LXNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQucHJlbWluZXRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQucHJldmlld3N5c3RlbXMuYm94XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiYm94XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5wcm90ZXVzLm1hZ2F6aW5lXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wibWd6XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5wc2ZzXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnB1Ymxpc2hhcmUtZGVsdGEtdHJlZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInFwc1wiXX0sXCJhcHBsaWNhdGlvbi92bmQucHZpLnB0aWQxXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wicHRpZFwiXX0sXCJhcHBsaWNhdGlvbi92bmQucHdnLW11bHRpcGxleGVkXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnB3Zy14aHRtbC1wcmludCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLnF1YWxjb21tLmJyZXctYXBwLXJlc1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5xdWFyYW50YWluZW5ldFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5xdWFyay5xdWFya3hwcmVzc1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInF4ZFwiLFwicXh0XCIsXCJxd2RcIixcInF3dFwiLFwicXhsXCIsXCJxeGJcIl19LFwiYXBwbGljYXRpb24vdm5kLnF1b2JqZWN0LXF1b3hkb2N1bWVudFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5yYWRpc3lzLm1vbWwreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5yYWRpc3lzLm1zbWwreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5yYWRpc3lzLm1zbWwtYXVkaXQreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5yYWRpc3lzLm1zbWwtYXVkaXQtY29uZit4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLnJhZGlzeXMubXNtbC1hdWRpdC1jb25uK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQucmFkaXN5cy5tc21sLWF1ZGl0LWRpYWxvZyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLnJhZGlzeXMubXNtbC1hdWRpdC1zdHJlYW0reG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5yYWRpc3lzLm1zbWwtY29uZit4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLnJhZGlzeXMubXNtbC1kaWFsb2creG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5yYWRpc3lzLm1zbWwtZGlhbG9nLWJhc2UreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5yYWRpc3lzLm1zbWwtZGlhbG9nLWZheC1kZXRlY3QreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5yYWRpc3lzLm1zbWwtZGlhbG9nLWZheC1zZW5kcmVjdit4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLnJhZGlzeXMubXNtbC1kaWFsb2ctZ3JvdXAreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC5yYWRpc3lzLm1zbWwtZGlhbG9nLXNwZWVjaCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLnJhZGlzeXMubXNtbC1kaWFsb2ctdHJhbnNmb3JtK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQucmFpbnN0b3IuZGF0YVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5yYXBpZFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5yYXJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQucmVhbHZuYy5iZWRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJiZWRcIl19LFwiYXBwbGljYXRpb24vdm5kLnJlY29yZGFyZS5tdXNpY3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm14bFwiXX0sXCJhcHBsaWNhdGlvbi92bmQucmVjb3JkYXJlLm11c2ljeG1sK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJtdXNpY3htbFwiXX0sXCJhcHBsaWNhdGlvbi92bmQucmVubGVhcm4ucmxwcmludFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5yZXN0ZnVsK2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLnJpZy5jcnlwdG9ub3RlXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiY3J5cHRvbm90ZVwiXX0sXCJhcHBsaWNhdGlvbi92bmQucmltLmNvZFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiY29kXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5ybi1yZWFsbWVkaWFcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInJtXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5ybi1yZWFsbWVkaWEtdmJyXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJybXZiXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5yb3V0ZTY2Lmxpbms2Nit4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wibGluazY2XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5ycy0yNzR4XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnJ1Y2t1cy5kb3dubG9hZFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5zM3Ntc1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5zYWlsaW5ndHJhY2tlci50cmFja1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInN0XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5zYm0uY2lkXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnNibS5taWQyXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnNjcmlidXNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuc2VhbGVkLjNkZlwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5zZWFsZWQuY3NmXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnNlYWxlZC5kb2NcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuc2VhbGVkLmVtbFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5zZWFsZWQubWh0XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnNlYWxlZC5uZXRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuc2VhbGVkLnBwdFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5zZWFsZWQudGlmZlwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5zZWFsZWQueGxzXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnNlYWxlZG1lZGlhLnNvZnRzZWFsLmh0bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuc2VhbGVkbWVkaWEuc29mdHNlYWwucGRmXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnNlZW1haWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJzZWVcIl19LFwiYXBwbGljYXRpb24vdm5kLnNlbWFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJzZW1hXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5zZW1kXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wic2VtZFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuc2VtZlwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInNlbWZcIl19LFwiYXBwbGljYXRpb24vdm5kLnNoYW5hLmluZm9ybWVkLmZvcm1kYXRhXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiaWZtXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5zaGFuYS5pbmZvcm1lZC5mb3JtdGVtcGxhdGVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJpdHBcIl19LFwiYXBwbGljYXRpb24vdm5kLnNoYW5hLmluZm9ybWVkLmludGVyY2hhbmdlXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiaWlmXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5zaGFuYS5pbmZvcm1lZC5wYWNrYWdlXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiaXBrXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5zaG9vdHByb29mK2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLnNpZ3Jvay5zZXNzaW9uXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnNpbXRlY2gtbWluZG1hcHBlclwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInR3ZFwiLFwidHdkc1wiXX0sXCJhcHBsaWNhdGlvbi92bmQuc2lyZW4ranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuc21hZlwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm1tZlwiXX0sXCJhcHBsaWNhdGlvbi92bmQuc21hcnQubm90ZWJvb2tcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuc21hcnQudGVhY2hlclwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInRlYWNoZXJcIl19LFwiYXBwbGljYXRpb24vdm5kLnNvZnR3YXJlNjAyLmZpbGxlci5mb3JtK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQuc29mdHdhcmU2MDIuZmlsbGVyLmZvcm0teG1sLXppcFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5zb2xlbnQuc2RrbSt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wic2RrbVwiLFwic2RrZFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuc3BvdGZpcmUuZHhwXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZHhwXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5zcG90ZmlyZS5zZnNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJzZnNcIl19LFwiYXBwbGljYXRpb24vdm5kLnNxbGl0ZTNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuc3NzLWNvZFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5zc3MtZHRmXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnNzcy1udGZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLmNhbGNcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInNkY1wiXX0sXCJhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLmRyYXdcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInNkYVwiXX0sXCJhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLmltcHJlc3NcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInNkZFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLm1hdGhcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInNtZlwiXX0sXCJhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLndyaXRlclwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wic2R3XCIsXCJ2b3JcIl19LFwiYXBwbGljYXRpb24vdm5kLnN0YXJkaXZpc2lvbi53cml0ZXItZ2xvYmFsXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJzZ2xcIl19LFwiYXBwbGljYXRpb24vdm5kLnN0ZXBtYW5pYS5wYWNrYWdlXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wic216aXBcIl19LFwiYXBwbGljYXRpb24vdm5kLnN0ZXBtYW5pYS5zdGVwY2hhcnRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJzbVwiXX0sXCJhcHBsaWNhdGlvbi92bmQuc3RyZWV0LXN0cmVhbVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5zdW4ud2FkbCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wid2FkbFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC5jYWxjXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJzeGNcIl19LFwiYXBwbGljYXRpb24vdm5kLnN1bi54bWwuY2FsYy50ZW1wbGF0ZVwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wic3RjXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLmRyYXdcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInN4ZFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC5kcmF3LnRlbXBsYXRlXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJzdGRcIl19LFwiYXBwbGljYXRpb24vdm5kLnN1bi54bWwuaW1wcmVzc1wiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wic3hpXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLmltcHJlc3MudGVtcGxhdGVcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInN0aVwiXX0sXCJhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC5tYXRoXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJzeG1cIl19LFwiYXBwbGljYXRpb24vdm5kLnN1bi54bWwud3JpdGVyXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJzeHdcIl19LFwiYXBwbGljYXRpb24vdm5kLnN1bi54bWwud3JpdGVyLmdsb2JhbFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wic3hnXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLndyaXRlci50ZW1wbGF0ZVwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wic3R3XCJdfSxcImFwcGxpY2F0aW9uL3ZuZC5zdXMtY2FsZW5kYXJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJzdXNcIixcInN1c3BcIl19LFwiYXBwbGljYXRpb24vdm5kLnN2ZFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInN2ZFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuc3dpZnR2aWV3LWljc1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC5zeW1iaWFuLmluc3RhbGxcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInNpc1wiLFwic2lzeFwiXX0sXCJhcHBsaWNhdGlvbi92bmQuc3luY21sK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJ4c21cIl19LFwiYXBwbGljYXRpb24vdm5kLnN5bmNtbC5kbSt3YnhtbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImJkbVwiXX0sXCJhcHBsaWNhdGlvbi92bmQuc3luY21sLmRtK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJ4ZG1cIl19LFwiYXBwbGljYXRpb24vdm5kLnN5bmNtbC5kbS5ub3RpZmljYXRpb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuc3luY21sLmRtZGRmK3dieG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnN5bmNtbC5kbWRkZit4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLnN5bmNtbC5kbXRuZHMrd2J4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQuc3luY21sLmRtdG5kcyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLnN5bmNtbC5kcy5ub3RpZmljYXRpb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQudGFibGVzY2hlbWEranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQudGFvLmludGVudC1tb2R1bGUtYXJjaGl2ZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInRhb1wiXX0sXCJhcHBsaWNhdGlvbi92bmQudGNwZHVtcC5wY2FwXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wicGNhcFwiLFwiY2FwXCIsXCJkbXBcIl19LFwiYXBwbGljYXRpb24vdm5kLnRoaW5rLWNlbGwucHB0dGMranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi92bmQudG1kLm1lZGlhZmxleC5hcGkreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC50bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQudG1vYmlsZS1saXZldHZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ0bW9cIl19LFwiYXBwbGljYXRpb24vdm5kLnRyaS5vbmVzb3VyY2VcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQudHJpZC50cHRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ0cHRcIl19LFwiYXBwbGljYXRpb24vdm5kLnRyaXNjYXBlLm14c1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm14c1wiXX0sXCJhcHBsaWNhdGlvbi92bmQudHJ1ZWFwcFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInRyYVwiXX0sXCJhcHBsaWNhdGlvbi92bmQudHJ1ZWRvY1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC51Ymlzb2Z0LndlYnBsYXllclwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC51ZmRsXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1widWZkXCIsXCJ1ZmRsXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC51aXEudGhlbWVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ1dHpcIl19LFwiYXBwbGljYXRpb24vdm5kLnVtYWppblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInVtalwiXX0sXCJhcHBsaWNhdGlvbi92bmQudW5pdHlcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ1bml0eXdlYlwiXX0sXCJhcHBsaWNhdGlvbi92bmQudW9tbCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1widW9tbFwiXX0sXCJhcHBsaWNhdGlvbi92bmQudXBsYW5ldC5hbGVydFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC51cGxhbmV0LmFsZXJ0LXdieG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnVwbGFuZXQuYmVhcmVyLWNob2ljZVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC51cGxhbmV0LmJlYXJlci1jaG9pY2Utd2J4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQudXBsYW5ldC5jYWNoZW9wXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnVwbGFuZXQuY2FjaGVvcC13YnhtbFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC51cGxhbmV0LmNoYW5uZWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQudXBsYW5ldC5jaGFubmVsLXdieG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnVwbGFuZXQubGlzdFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC51cGxhbmV0Lmxpc3Qtd2J4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQudXBsYW5ldC5saXN0Y21kXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnVwbGFuZXQubGlzdGNtZC13YnhtbFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC51cGxhbmV0LnNpZ25hbFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC51cmktbWFwXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnZhbHZlLnNvdXJjZS5tYXRlcmlhbFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC52Y3hcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ2Y3hcIl19LFwiYXBwbGljYXRpb24vdm5kLnZkLXN0dWR5XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnZlY3RvcndvcmtzXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnZlbCtqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC52ZXJpbWF0cml4LnZjYXNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQudmVyeWFudC50aGluXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnZpZHNvZnQudmlkY29uZmVyZW5jZVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC52aXNpb1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInZzZFwiLFwidnN0XCIsXCJ2c3NcIixcInZzd1wiXX0sXCJhcHBsaWNhdGlvbi92bmQudmlzaW9uYXJ5XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1widmlzXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC52aXZpZGVuY2Uuc2NyaXB0ZmlsZVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC52c2ZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ2c2ZcIl19LFwiYXBwbGljYXRpb24vdm5kLndhcC5zaWNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQud2FwLnNsY1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC53YXAud2J4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ3YnhtbFwiXX0sXCJhcHBsaWNhdGlvbi92bmQud2FwLndtbGNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ3bWxjXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC53YXAud21sc2NyaXB0Y1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIndtbHNjXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC53ZWJ0dXJib1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInd0YlwiXX0sXCJhcHBsaWNhdGlvbi92bmQud2ZhLnAycFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC53ZmEud3NjXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLndpbmRvd3MuZGV2aWNlcGFpcmluZ1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC53bWNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQud21mLmJvb3RzdHJhcFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC53b2xmcmFtLm1hdGhlbWF0aWNhXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLndvbGZyYW0ubWF0aGVtYXRpY2EucGFja2FnZVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC53b2xmcmFtLnBsYXllclwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm5icFwiXX0sXCJhcHBsaWNhdGlvbi92bmQud29yZHBlcmZlY3RcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ3cGRcIl19LFwiYXBwbGljYXRpb24vdm5kLndxZFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIndxZFwiXX0sXCJhcHBsaWNhdGlvbi92bmQud3JxLWhwMzAwMC1sYWJlbGxlZFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC53dC5zdGZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJzdGZcIl19LFwiYXBwbGljYXRpb24vdm5kLnd2LmNzcCt3YnhtbFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC53di5jc3AreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC53di5zc3AreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC54YWNtbCtqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZuZC54YXJhXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wieGFyXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC54ZmRsXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wieGZkbFwiXX0sXCJhcHBsaWNhdGlvbi92bmQueGZkbC53ZWJmb3JtXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnhtaSt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24vdm5kLnhtcGllLmNwa2dcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQueG1waWUuZHBrZ1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC54bXBpZS5wbGFuXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnhtcGllLnBwa2dcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQueG1waWUueGxpbVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC55YW1haGEuaHYtZGljXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiaHZkXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC55YW1haGEuaHYtc2NyaXB0XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiaHZzXCJdfSxcImFwcGxpY2F0aW9uL3ZuZC55YW1haGEuaHYtdm9pY2VcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJodnBcIl19LFwiYXBwbGljYXRpb24vdm5kLnlhbWFoYS5vcGVuc2NvcmVmb3JtYXRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJvc2ZcIl19LFwiYXBwbGljYXRpb24vdm5kLnlhbWFoYS5vcGVuc2NvcmVmb3JtYXQub3NmcHZnK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJvc2ZwdmdcIl19LFwiYXBwbGljYXRpb24vdm5kLnlhbWFoYS5yZW1vdGUtc2V0dXBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQueWFtYWhhLnNtYWYtYXVkaW9cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJzYWZcIl19LFwiYXBwbGljYXRpb24vdm5kLnlhbWFoYS5zbWFmLXBocmFzZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInNwZlwiXX0sXCJhcHBsaWNhdGlvbi92bmQueWFtYWhhLnRocm91Z2gtbmduXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vdm5kLnlhbWFoYS50dW5uZWwtdWRwZW5jYXBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi92bmQueWFvd2VtZVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC55ZWxsb3dyaXZlci1jdXN0b20tbWVudVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImNtcFwiXX0sXCJhcHBsaWNhdGlvbi92bmQueW91dHViZS55dFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3ZuZC56dWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ6aXJcIixcInppcnpcIl19LFwiYXBwbGljYXRpb24vdm5kLnp6YXp6LmRlY2sreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcInphelwiXX0sXCJhcHBsaWNhdGlvbi92b2ljZXhtbCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1widnhtbFwiXX0sXCJhcHBsaWNhdGlvbi92b3VjaGVyLWNtcytqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3ZxLXJ0Y3B4clwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3dhc21cIjp7XCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcIndhc21cIl19LFwiYXBwbGljYXRpb24vd2F0Y2hlcmluZm8reG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3dlYnB1c2gtb3B0aW9ucytqc29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3dob2lzcHAtcXVlcnlcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi93aG9pc3BwLXJlc3BvbnNlXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24vd2lkZ2V0XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wid2d0XCJdfSxcImFwcGxpY2F0aW9uL3dpbmhscFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiaGxwXCJdfSxcImFwcGxpY2F0aW9uL3dpdGFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi93b3JkcGVyZmVjdDUuMVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3dzZGwreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcIndzZGxcIl19LFwiYXBwbGljYXRpb24vd3Nwb2xpY3kreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcIndzcG9saWN5XCJdfSxcImFwcGxpY2F0aW9uL3gtN3otY29tcHJlc3NlZFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCI3elwiXX0sXCJhcHBsaWNhdGlvbi94LWFiaXdvcmRcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcImFid1wiXX0sXCJhcHBsaWNhdGlvbi94LWFjZS1jb21wcmVzc2VkXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJhY2VcIl19LFwiYXBwbGljYXRpb24veC1hbWZcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwifSxcImFwcGxpY2F0aW9uL3gtYXBwbGUtZGlza2ltYWdlXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJkbWdcIl19LFwiYXBwbGljYXRpb24veC1hcmpcIjp7XCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJhcmpcIl19LFwiYXBwbGljYXRpb24veC1hdXRob3J3YXJlLWJpblwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiYWFiXCIsXCJ4MzJcIixcInUzMlwiLFwidm94XCJdfSxcImFwcGxpY2F0aW9uL3gtYXV0aG9yd2FyZS1tYXBcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcImFhbVwiXX0sXCJhcHBsaWNhdGlvbi94LWF1dGhvcndhcmUtc2VnXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJhYXNcIl19LFwiYXBwbGljYXRpb24veC1iY3Bpb1wiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiYmNwaW9cIl19LFwiYXBwbGljYXRpb24veC1iZG9jXCI6e1wiY29tcHJlc3NpYmxlXCI6ZmFsc2UsXCJleHRlbnNpb25zXCI6W1wiYmRvY1wiXX0sXCJhcHBsaWNhdGlvbi94LWJpdHRvcnJlbnRcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInRvcnJlbnRcIl19LFwiYXBwbGljYXRpb24veC1ibG9yYlwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiYmxiXCIsXCJibG9yYlwiXX0sXCJhcHBsaWNhdGlvbi94LWJ6aXBcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiY29tcHJlc3NpYmxlXCI6ZmFsc2UsXCJleHRlbnNpb25zXCI6W1wiYnpcIl19LFwiYXBwbGljYXRpb24veC1iemlwMlwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJiejJcIixcImJvelwiXX0sXCJhcHBsaWNhdGlvbi94LWNiclwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiY2JyXCIsXCJjYmFcIixcImNidFwiLFwiY2J6XCIsXCJjYjdcIl19LFwiYXBwbGljYXRpb24veC1jZGxpbmtcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInZjZFwiXX0sXCJhcHBsaWNhdGlvbi94LWNmcy1jb21wcmVzc2VkXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJjZnNcIl19LFwiYXBwbGljYXRpb24veC1jaGF0XCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJjaGF0XCJdfSxcImFwcGxpY2F0aW9uL3gtY2hlc3MtcGduXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJwZ25cIl19LFwiYXBwbGljYXRpb24veC1jaHJvbWUtZXh0ZW5zaW9uXCI6e1wiZXh0ZW5zaW9uc1wiOltcImNyeFwiXX0sXCJhcHBsaWNhdGlvbi94LWNvY29hXCI6e1wic291cmNlXCI6XCJuZ2lueFwiLFwiZXh0ZW5zaW9uc1wiOltcImNjb1wiXX0sXCJhcHBsaWNhdGlvbi94LWNvbXByZXNzXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIn0sXCJhcHBsaWNhdGlvbi94LWNvbmZlcmVuY2VcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcIm5zY1wiXX0sXCJhcHBsaWNhdGlvbi94LWNwaW9cIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcImNwaW9cIl19LFwiYXBwbGljYXRpb24veC1jc2hcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcImNzaFwiXX0sXCJhcHBsaWNhdGlvbi94LWRlYlwiOntcImNvbXByZXNzaWJsZVwiOmZhbHNlfSxcImFwcGxpY2F0aW9uL3gtZGViaWFuLXBhY2thZ2VcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcImRlYlwiLFwidWRlYlwiXX0sXCJhcHBsaWNhdGlvbi94LWRnYy1jb21wcmVzc2VkXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJkZ2NcIl19LFwiYXBwbGljYXRpb24veC1kaXJlY3RvclwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiZGlyXCIsXCJkY3JcIixcImR4clwiLFwiY3N0XCIsXCJjY3RcIixcImN4dFwiLFwidzNkXCIsXCJmZ2RcIixcInN3YVwiXX0sXCJhcHBsaWNhdGlvbi94LWRvb21cIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcIndhZFwiXX0sXCJhcHBsaWNhdGlvbi94LWR0Ym5jeCt4bWxcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJuY3hcIl19LFwiYXBwbGljYXRpb24veC1kdGJvb2sreG1sXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wiZHRiXCJdfSxcImFwcGxpY2F0aW9uL3gtZHRicmVzb3VyY2UreG1sXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wicmVzXCJdfSxcImFwcGxpY2F0aW9uL3gtZHZpXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcImR2aVwiXX0sXCJhcHBsaWNhdGlvbi94LWVudm95XCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJldnlcIl19LFwiYXBwbGljYXRpb24veC1ldmFcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcImV2YVwiXX0sXCJhcHBsaWNhdGlvbi94LWZvbnQtYmRmXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJiZGZcIl19LFwiYXBwbGljYXRpb24veC1mb250LWRvc1wiOntcInNvdXJjZVwiOlwiYXBhY2hlXCJ9LFwiYXBwbGljYXRpb24veC1mb250LWZyYW1lbWFrZXJcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwifSxcImFwcGxpY2F0aW9uL3gtZm9udC1naG9zdHNjcmlwdFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiZ3NmXCJdfSxcImFwcGxpY2F0aW9uL3gtZm9udC1saWJncnhcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwifSxcImFwcGxpY2F0aW9uL3gtZm9udC1saW51eC1wc2ZcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInBzZlwiXX0sXCJhcHBsaWNhdGlvbi94LWZvbnQtcGNmXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJwY2ZcIl19LFwiYXBwbGljYXRpb24veC1mb250LXNuZlwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wic25mXCJdfSxcImFwcGxpY2F0aW9uL3gtZm9udC1zcGVlZG9cIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwifSxcImFwcGxpY2F0aW9uL3gtZm9udC1zdW5vcy1uZXdzXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIn0sXCJhcHBsaWNhdGlvbi94LWZvbnQtdHlwZTFcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInBmYVwiLFwicGZiXCIsXCJwZm1cIixcImFmbVwiXX0sXCJhcHBsaWNhdGlvbi94LWZvbnQtdmZvbnRcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwifSxcImFwcGxpY2F0aW9uL3gtZnJlZWFyY1wiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiYXJjXCJdfSxcImFwcGxpY2F0aW9uL3gtZnV0dXJlc3BsYXNoXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJzcGxcIl19LFwiYXBwbGljYXRpb24veC1nY2EtY29tcHJlc3NlZFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiZ2NhXCJdfSxcImFwcGxpY2F0aW9uL3gtZ2x1bHhcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInVseFwiXX0sXCJhcHBsaWNhdGlvbi94LWdudW1lcmljXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJnbnVtZXJpY1wiXX0sXCJhcHBsaWNhdGlvbi94LWdyYW1wcy14bWxcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcImdyYW1wc1wiXX0sXCJhcHBsaWNhdGlvbi94LWd0YXJcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcImd0YXJcIl19LFwiYXBwbGljYXRpb24veC1nemlwXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIn0sXCJhcHBsaWNhdGlvbi94LWhkZlwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiaGRmXCJdfSxcImFwcGxpY2F0aW9uL3gtaHR0cGQtcGhwXCI6e1wiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJwaHBcIl19LFwiYXBwbGljYXRpb24veC1pbnN0YWxsLWluc3RydWN0aW9uc1wiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiaW5zdGFsbFwiXX0sXCJhcHBsaWNhdGlvbi94LWlzbzk2NjAtaW1hZ2VcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcImlzb1wiXX0sXCJhcHBsaWNhdGlvbi94LWphdmEtYXJjaGl2ZS1kaWZmXCI6e1wic291cmNlXCI6XCJuZ2lueFwiLFwiZXh0ZW5zaW9uc1wiOltcImphcmRpZmZcIl19LFwiYXBwbGljYXRpb24veC1qYXZhLWpubHAtZmlsZVwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJqbmxwXCJdfSxcImFwcGxpY2F0aW9uL3gtamF2YXNjcmlwdFwiOntcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24veC1sYXRleFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJsYXRleFwiXX0sXCJhcHBsaWNhdGlvbi94LWx1YS1ieXRlY29kZVwiOntcImV4dGVuc2lvbnNcIjpbXCJsdWFjXCJdfSxcImFwcGxpY2F0aW9uL3gtbHpoLWNvbXByZXNzZWRcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcImx6aFwiLFwibGhhXCJdfSxcImFwcGxpY2F0aW9uL3gtbWFrZXNlbGZcIjp7XCJzb3VyY2VcIjpcIm5naW54XCIsXCJleHRlbnNpb25zXCI6W1wicnVuXCJdfSxcImFwcGxpY2F0aW9uL3gtbWllXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJtaWVcIl19LFwiYXBwbGljYXRpb24veC1tb2JpcG9ja2V0LWVib29rXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJwcmNcIixcIm1vYmlcIl19LFwiYXBwbGljYXRpb24veC1tcGVndXJsXCI6e1wiY29tcHJlc3NpYmxlXCI6ZmFsc2V9LFwiYXBwbGljYXRpb24veC1tcy1hcHBsaWNhdGlvblwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiYXBwbGljYXRpb25cIl19LFwiYXBwbGljYXRpb24veC1tcy1zaG9ydGN1dFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wibG5rXCJdfSxcImFwcGxpY2F0aW9uL3gtbXMtd21kXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJ3bWRcIl19LFwiYXBwbGljYXRpb24veC1tcy13bXpcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcIndtelwiXX0sXCJhcHBsaWNhdGlvbi94LW1zLXhiYXBcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInhiYXBcIl19LFwiYXBwbGljYXRpb24veC1tc2FjY2Vzc1wiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wibWRiXCJdfSxcImFwcGxpY2F0aW9uL3gtbXNiaW5kZXJcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcIm9iZFwiXX0sXCJhcHBsaWNhdGlvbi94LW1zY2FyZGZpbGVcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcImNyZFwiXX0sXCJhcHBsaWNhdGlvbi94LW1zY2xpcFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiY2xwXCJdfSxcImFwcGxpY2F0aW9uL3gtbXNkb3MtcHJvZ3JhbVwiOntcImV4dGVuc2lvbnNcIjpbXCJleGVcIl19LFwiYXBwbGljYXRpb24veC1tc2Rvd25sb2FkXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJleGVcIixcImRsbFwiLFwiY29tXCIsXCJiYXRcIixcIm1zaVwiXX0sXCJhcHBsaWNhdGlvbi94LW1zbWVkaWF2aWV3XCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJtdmJcIixcIm0xM1wiLFwibTE0XCJdfSxcImFwcGxpY2F0aW9uL3gtbXNtZXRhZmlsZVwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wid21mXCIsXCJ3bXpcIixcImVtZlwiLFwiZW16XCJdfSxcImFwcGxpY2F0aW9uL3gtbXNtb25leVwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wibW55XCJdfSxcImFwcGxpY2F0aW9uL3gtbXNwdWJsaXNoZXJcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInB1YlwiXX0sXCJhcHBsaWNhdGlvbi94LW1zc2NoZWR1bGVcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInNjZFwiXX0sXCJhcHBsaWNhdGlvbi94LW1zdGVybWluYWxcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInRybVwiXX0sXCJhcHBsaWNhdGlvbi94LW1zd3JpdGVcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcIndyaVwiXX0sXCJhcHBsaWNhdGlvbi94LW5ldGNkZlwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wibmNcIixcImNkZlwiXX0sXCJhcHBsaWNhdGlvbi94LW5zLXByb3h5LWF1dG9jb25maWdcIjp7XCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcInBhY1wiXX0sXCJhcHBsaWNhdGlvbi94LW56YlwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wibnpiXCJdfSxcImFwcGxpY2F0aW9uL3gtcGVybFwiOntcInNvdXJjZVwiOlwibmdpbnhcIixcImV4dGVuc2lvbnNcIjpbXCJwbFwiLFwicG1cIl19LFwiYXBwbGljYXRpb24veC1waWxvdFwiOntcInNvdXJjZVwiOlwibmdpbnhcIixcImV4dGVuc2lvbnNcIjpbXCJwcmNcIixcInBkYlwiXX0sXCJhcHBsaWNhdGlvbi94LXBrY3MxMlwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJwMTJcIixcInBmeFwiXX0sXCJhcHBsaWNhdGlvbi94LXBrY3M3LWNlcnRpZmljYXRlc1wiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wicDdiXCIsXCJzcGNcIl19LFwiYXBwbGljYXRpb24veC1wa2NzNy1jZXJ0cmVxcmVzcFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wicDdyXCJdfSxcImFwcGxpY2F0aW9uL3gtcmFyLWNvbXByZXNzZWRcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiY29tcHJlc3NpYmxlXCI6ZmFsc2UsXCJleHRlbnNpb25zXCI6W1wicmFyXCJdfSxcImFwcGxpY2F0aW9uL3gtcmVkaGF0LXBhY2thZ2UtbWFuYWdlclwiOntcInNvdXJjZVwiOlwibmdpbnhcIixcImV4dGVuc2lvbnNcIjpbXCJycG1cIl19LFwiYXBwbGljYXRpb24veC1yZXNlYXJjaC1pbmZvLXN5c3RlbXNcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInJpc1wiXX0sXCJhcHBsaWNhdGlvbi94LXNlYVwiOntcInNvdXJjZVwiOlwibmdpbnhcIixcImV4dGVuc2lvbnNcIjpbXCJzZWFcIl19LFwiYXBwbGljYXRpb24veC1zaFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcInNoXCJdfSxcImFwcGxpY2F0aW9uL3gtc2hhclwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wic2hhclwiXX0sXCJhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJzd2ZcIl19LFwiYXBwbGljYXRpb24veC1zaWx2ZXJsaWdodC1hcHBcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInhhcFwiXX0sXCJhcHBsaWNhdGlvbi94LXNxbFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wic3FsXCJdfSxcImFwcGxpY2F0aW9uL3gtc3R1ZmZpdFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJzaXRcIl19LFwiYXBwbGljYXRpb24veC1zdHVmZml0eFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wic2l0eFwiXX0sXCJhcHBsaWNhdGlvbi94LXN1YnJpcFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wic3J0XCJdfSxcImFwcGxpY2F0aW9uL3gtc3Y0Y3Bpb1wiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wic3Y0Y3Bpb1wiXX0sXCJhcHBsaWNhdGlvbi94LXN2NGNyY1wiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wic3Y0Y3JjXCJdfSxcImFwcGxpY2F0aW9uL3gtdDN2bS1pbWFnZVwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1widDNcIl19LFwiYXBwbGljYXRpb24veC10YWRzXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJnYW1cIl19LFwiYXBwbGljYXRpb24veC10YXJcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJ0YXJcIl19LFwiYXBwbGljYXRpb24veC10Y2xcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInRjbFwiLFwidGtcIl19LFwiYXBwbGljYXRpb24veC10ZXhcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInRleFwiXX0sXCJhcHBsaWNhdGlvbi94LXRleC10Zm1cIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInRmbVwiXX0sXCJhcHBsaWNhdGlvbi94LXRleGluZm9cIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInRleGluZm9cIixcInRleGlcIl19LFwiYXBwbGljYXRpb24veC10Z2lmXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJvYmpcIl19LFwiYXBwbGljYXRpb24veC11c3RhclwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1widXN0YXJcIl19LFwiYXBwbGljYXRpb24veC12aXJ0dWFsYm94LWhkZFwiOntcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wiaGRkXCJdfSxcImFwcGxpY2F0aW9uL3gtdmlydHVhbGJveC1vdmFcIjp7XCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcIm92YVwiXX0sXCJhcHBsaWNhdGlvbi94LXZpcnR1YWxib3gtb3ZmXCI6e1wiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJvdmZcIl19LFwiYXBwbGljYXRpb24veC12aXJ0dWFsYm94LXZib3hcIjp7XCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcInZib3hcIl19LFwiYXBwbGljYXRpb24veC12aXJ0dWFsYm94LXZib3gtZXh0cGFja1wiOntcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcInZib3gtZXh0cGFja1wiXX0sXCJhcHBsaWNhdGlvbi94LXZpcnR1YWxib3gtdmRpXCI6e1wiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJ2ZGlcIl19LFwiYXBwbGljYXRpb24veC12aXJ0dWFsYm94LXZoZFwiOntcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1widmhkXCJdfSxcImFwcGxpY2F0aW9uL3gtdmlydHVhbGJveC12bWRrXCI6e1wiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJ2bWRrXCJdfSxcImFwcGxpY2F0aW9uL3gtd2Fpcy1zb3VyY2VcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInNyY1wiXX0sXCJhcHBsaWNhdGlvbi94LXdlYi1hcHAtbWFuaWZlc3QranNvblwiOntcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wid2ViYXBwXCJdfSxcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi94LXg1MDktY2EtY2VydFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiZGVyXCIsXCJjcnRcIixcInBlbVwiXX0sXCJhcHBsaWNhdGlvbi94LXhmaWdcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcImZpZ1wiXX0sXCJhcHBsaWNhdGlvbi94LXhsaWZmK3htbFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcInhsZlwiXX0sXCJhcHBsaWNhdGlvbi94LXhwaW5zdGFsbFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJ4cGlcIl19LFwiYXBwbGljYXRpb24veC14elwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wieHpcIl19LFwiYXBwbGljYXRpb24veC16bWFjaGluZVwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiejFcIixcInoyXCIsXCJ6M1wiLFwiejRcIixcIno1XCIsXCJ6NlwiLFwiejdcIixcIno4XCJdfSxcImFwcGxpY2F0aW9uL3g0MDAtYnBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhcHBsaWNhdGlvbi94YWNtbCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24veGFtbCt4bWxcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJ4YW1sXCJdfSxcImFwcGxpY2F0aW9uL3hjYXAtYXR0K3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi94Y2FwLWNhcHMreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3hjYXAtZGlmZit4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wieGRmXCJdfSxcImFwcGxpY2F0aW9uL3hjYXAtZWwreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3hjYXAtZXJyb3IreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3hjYXAtbnMreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3hjb24tY29uZmVyZW5jZS1pbmZvK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi94Y29uLWNvbmZlcmVuY2UtaW5mby1kaWZmK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi94ZW5jK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJ4ZW5jXCJdfSxcImFwcGxpY2F0aW9uL3hodG1sK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJ4aHRtbFwiLFwieGh0XCJdfSxcImFwcGxpY2F0aW9uL3hodG1sLXZvaWNlK3htbFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJjb21wcmVzc2libGVcIjp0cnVlfSxcImFwcGxpY2F0aW9uL3hsaWZmK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi94bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wieG1sXCIsXCJ4c2xcIixcInhzZFwiLFwicm5nXCJdfSxcImFwcGxpY2F0aW9uL3htbC1kdGRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wiZHRkXCJdfSxcImFwcGxpY2F0aW9uL3htbC1leHRlcm5hbC1wYXJzZWQtZW50aXR5XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXBwbGljYXRpb24veG1sLXBhdGNoK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi94bXBwK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi94b3AreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcInhvcFwiXX0sXCJhcHBsaWNhdGlvbi94cHJvYyt4bWxcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJ4cGxcIl19LFwiYXBwbGljYXRpb24veHNsdCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wieHNsdFwiXX0sXCJhcHBsaWNhdGlvbi94c3BmK3htbFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcInhzcGZcIl19LFwiYXBwbGljYXRpb24veHYreG1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcIm14bWxcIixcInhodm1sXCIsXCJ4dm1sXCIsXCJ4dm1cIl19LFwiYXBwbGljYXRpb24veWFuZ1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInlhbmdcIl19LFwiYXBwbGljYXRpb24veWFuZy1kYXRhK2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24veWFuZy1kYXRhK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJhcHBsaWNhdGlvbi95YW5nLXBhdGNoK2pzb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24veWFuZy1wYXRjaCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwiYXBwbGljYXRpb24veWluK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJ5aW5cIl19LFwiYXBwbGljYXRpb24vemlwXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJ6aXBcIl19LFwiYXBwbGljYXRpb24vemxpYlwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImFwcGxpY2F0aW9uL3pzdGRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby8xZC1pbnRlcmxlYXZlZC1wYXJpdHlmZWNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby8zMmthZHBjbVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvLzNncHBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcIjNncHBcIl19LFwiYXVkaW8vM2dwcDJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9hYWNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9hYzNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9hZHBjbVwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiYWRwXCJdfSxcImF1ZGlvL2FtclwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL2Ftci13YlwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL2Ftci13YitcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9hcHR4XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vYXNjXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vYXRyYWMtYWR2YW5jZWQtbG9zc2xlc3NcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9hdHJhYy14XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vYXRyYWMzXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vYmFzaWNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcImF1XCIsXCJzbmRcIl19LFwiYXVkaW8vYnYxNlwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL2J2MzJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9jbGVhcm1vZGVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9jblwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL2RhdDEyXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vZGxzXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vZHNyLWVzMjAxMTA4XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vZHNyLWVzMjAyMDUwXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vZHNyLWVzMjAyMjExXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vZHNyLWVzMjAyMjEyXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vZHZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9kdmk0XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vZWFjM1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL2VuY2FwcnRwXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vZXZyY1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL2V2cmMtcWNwXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vZXZyYzBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9ldnJjMVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL2V2cmNiXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vZXZyY2IwXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vZXZyY2IxXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vZXZyY253XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vZXZyY253MFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL2V2cmNudzFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9ldnJjd2JcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9ldnJjd2IwXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vZXZyY3diMVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL2V2c1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL2Z3ZHJlZFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL2c3MTEtMFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL2c3MTlcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9nNzIyXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vZzcyMjFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9nNzIzXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vZzcyNi0xNlwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL2c3MjYtMjRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9nNzI2LTMyXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vZzcyNi00MFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL2c3MjhcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9nNzI5XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vZzcyOTFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9nNzI5ZFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL2c3MjllXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vZ3NtXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vZ3NtLWVmclwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL2dzbS1oci0wOFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL2lsYmNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9pcC1tcl92Mi41XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vaXNhY1wiOntcInNvdXJjZVwiOlwiYXBhY2hlXCJ9LFwiYXVkaW8vbDE2XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vbDIwXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vbDI0XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZX0sXCJhdWRpby9sOFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL2xwY1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL21lbHBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9tZWxwMTIwMFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL21lbHAyNDAwXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vbWVscDYwMFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL21pZGlcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcIm1pZFwiLFwibWlkaVwiLFwia2FyXCIsXCJybWlcIl19LFwiYXVkaW8vbW9iaWxlLXhtZlwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL21wM1wiOntcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcIm1wM1wiXX0sXCJhdWRpby9tcDRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcIm00YVwiLFwibXA0YVwiXX0sXCJhdWRpby9tcDRhLWxhdG1cIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9tcGFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9tcGEtcm9idXN0XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vbXBlZ1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6ZmFsc2UsXCJleHRlbnNpb25zXCI6W1wibXBnYVwiLFwibXAyXCIsXCJtcDJhXCIsXCJtcDNcIixcIm0yYVwiLFwibTNhXCJdfSxcImF1ZGlvL21wZWc0LWdlbmVyaWNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9tdXNlcGFja1wiOntcInNvdXJjZVwiOlwiYXBhY2hlXCJ9LFwiYXVkaW8vb2dnXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJvZ2FcIixcIm9nZ1wiLFwic3B4XCJdfSxcImF1ZGlvL29wdXNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9wYXJpdHlmZWNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9wY21hXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vcGNtYS13YlwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL3BjbXVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9wY211LXdiXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vcHJzLnNpZFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL3FjZWxwXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vcmFwdG9yZmVjXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vcmVkXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vcnRwLWVuYy1hZXNjbTEyOFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL3J0cC1taWRpXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vcnRwbG9vcGJhY2tcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9ydHhcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9zM21cIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInMzbVwiXX0sXCJhdWRpby9zaWxrXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJzaWxcIl19LFwiYXVkaW8vc212XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vc212LXFjcFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL3NtdjBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby9zcC1taWRpXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vc3BlZXhcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby90MTQwY1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL3QzOFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL3RlbGVwaG9uZS1ldmVudFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL3RldHJhX2FjZWxwXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vdG9uZVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL3VlbWNsaXBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby91bHBmZWNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby91c2FjXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vdmR2aVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL3Ztci13YlwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL3ZuZC4zZ3BwLml1ZnBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby92bmQuNHNiXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vdm5kLmF1ZGlva296XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vdm5kLmNlbHBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby92bmQuY2lzY28ubnNlXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vdm5kLmNtbGVzLnJhZGlvLWV2ZW50c1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL3ZuZC5jbnMuYW5wMVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL3ZuZC5jbnMuaW5mMVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL3ZuZC5kZWNlLmF1ZGlvXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1widXZhXCIsXCJ1dnZhXCJdfSxcImF1ZGlvL3ZuZC5kaWdpdGFsLXdpbmRzXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZW9sXCJdfSxcImF1ZGlvL3ZuZC5kbG5hLmFkdHNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby92bmQuZG9sYnkuaGVhYWMuMVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL3ZuZC5kb2xieS5oZWFhYy4yXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vdm5kLmRvbGJ5Lm1scFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL3ZuZC5kb2xieS5tcHNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby92bmQuZG9sYnkucGwyXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vdm5kLmRvbGJ5LnBsMnhcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby92bmQuZG9sYnkucGwyelwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL3ZuZC5kb2xieS5wdWxzZS4xXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vdm5kLmRyYVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImRyYVwiXX0sXCJhdWRpby92bmQuZHRzXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZHRzXCJdfSxcImF1ZGlvL3ZuZC5kdHMuaGRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJkdHNoZFwiXX0sXCJhdWRpby92bmQuZHRzLnVoZFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL3ZuZC5kdmIuZmlsZVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL3ZuZC5ldmVyYWQucGxqXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vdm5kLmhucy5hdWRpb1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL3ZuZC5sdWNlbnQudm9pY2VcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJsdnBcIl19LFwiYXVkaW8vdm5kLm1zLXBsYXlyZWFkeS5tZWRpYS5weWFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJweWFcIl19LFwiYXVkaW8vdm5kLm5va2lhLm1vYmlsZS14bWZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby92bmQubm9ydGVsLnZia1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL3ZuZC5udWVyYS5lY2VscDQ4MDBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJlY2VscDQ4MDBcIl19LFwiYXVkaW8vdm5kLm51ZXJhLmVjZWxwNzQ3MFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImVjZWxwNzQ3MFwiXX0sXCJhdWRpby92bmQubnVlcmEuZWNlbHA5NjAwXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZWNlbHA5NjAwXCJdfSxcImF1ZGlvL3ZuZC5vY3RlbC5zYmNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby92bmQucHJlc29udXMubXVsdGl0cmFja1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL3ZuZC5xY2VscFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL3ZuZC5yaGV0b3JleC4zMmthZHBjbVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImF1ZGlvL3ZuZC5yaXBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJyaXBcIl19LFwiYXVkaW8vdm5kLnJuLXJlYWxhdWRpb1wiOntcImNvbXByZXNzaWJsZVwiOmZhbHNlfSxcImF1ZGlvL3ZuZC5zZWFsZWRtZWRpYS5zb2Z0c2VhbC5tcGVnXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vdm5kLnZteC5jdnNkXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiYXVkaW8vdm5kLndhdmVcIjp7XCJjb21wcmVzc2libGVcIjpmYWxzZX0sXCJhdWRpby92b3JiaXNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlfSxcImF1ZGlvL3ZvcmJpcy1jb25maWdcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJhdWRpby93YXZcIjp7XCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJ3YXZcIl19LFwiYXVkaW8vd2F2ZVwiOntcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcIndhdlwiXX0sXCJhdWRpby93ZWJtXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcIndlYmFcIl19LFwiYXVkaW8veC1hYWNcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiY29tcHJlc3NpYmxlXCI6ZmFsc2UsXCJleHRlbnNpb25zXCI6W1wiYWFjXCJdfSxcImF1ZGlvL3gtYWlmZlwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiYWlmXCIsXCJhaWZmXCIsXCJhaWZjXCJdfSxcImF1ZGlvL3gtY2FmXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcImNhZlwiXX0sXCJhdWRpby94LWZsYWNcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcImZsYWNcIl19LFwiYXVkaW8veC1tNGFcIjp7XCJzb3VyY2VcIjpcIm5naW54XCIsXCJleHRlbnNpb25zXCI6W1wibTRhXCJdfSxcImF1ZGlvL3gtbWF0cm9za2FcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcIm1rYVwiXX0sXCJhdWRpby94LW1wZWd1cmxcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcIm0zdVwiXX0sXCJhdWRpby94LW1zLXdheFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wid2F4XCJdfSxcImF1ZGlvL3gtbXMtd21hXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJ3bWFcIl19LFwiYXVkaW8veC1wbi1yZWFsYXVkaW9cIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInJhbVwiLFwicmFcIl19LFwiYXVkaW8veC1wbi1yZWFsYXVkaW8tcGx1Z2luXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJybXBcIl19LFwiYXVkaW8veC1yZWFsYXVkaW9cIjp7XCJzb3VyY2VcIjpcIm5naW54XCIsXCJleHRlbnNpb25zXCI6W1wicmFcIl19LFwiYXVkaW8veC10dGFcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwifSxcImF1ZGlvL3gtd2F2XCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJ3YXZcIl19LFwiYXVkaW8veG1cIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInhtXCJdfSxcImNoZW1pY2FsL3gtY2R4XCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJjZHhcIl19LFwiY2hlbWljYWwveC1jaWZcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcImNpZlwiXX0sXCJjaGVtaWNhbC94LWNtZGZcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcImNtZGZcIl19LFwiY2hlbWljYWwveC1jbWxcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcImNtbFwiXX0sXCJjaGVtaWNhbC94LWNzbWxcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcImNzbWxcIl19LFwiY2hlbWljYWwveC1wZGJcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwifSxcImNoZW1pY2FsL3gteHl6XCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJ4eXpcIl19LFwiZm9udC9jb2xsZWN0aW9uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1widHRjXCJdfSxcImZvbnQvb3RmXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcIm90ZlwiXX0sXCJmb250L3NmbnRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJmb250L3R0ZlwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInR0ZlwiXX0sXCJmb250L3dvZmZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ3b2ZmXCJdfSxcImZvbnQvd29mZjJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ3b2ZmMlwiXX0sXCJpbWFnZS9hY2VzXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZXhyXCJdfSxcImltYWdlL2FwbmdcIjp7XCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJhcG5nXCJdfSxcImltYWdlL2F2Y2lcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJpbWFnZS9hdmNzXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiaW1hZ2UvYm1wXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcImJtcFwiXX0sXCJpbWFnZS9jZ21cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJjZ21cIl19LFwiaW1hZ2UvZGljb20tcmxlXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZHJsZVwiXX0sXCJpbWFnZS9lbWZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJlbWZcIl19LFwiaW1hZ2UvZml0c1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImZpdHNcIl19LFwiaW1hZ2UvZzNmYXhcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJnM1wiXX0sXCJpbWFnZS9naWZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcImdpZlwiXX0sXCJpbWFnZS9oZWljXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiaGVpY1wiXX0sXCJpbWFnZS9oZWljLXNlcXVlbmNlXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiaGVpY3NcIl19LFwiaW1hZ2UvaGVpZlwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImhlaWZcIl19LFwiaW1hZ2UvaGVpZi1zZXF1ZW5jZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImhlaWZzXCJdfSxcImltYWdlL2llZlwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImllZlwiXX0sXCJpbWFnZS9qbHNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJqbHNcIl19LFwiaW1hZ2UvanAyXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJqcDJcIixcImpwZzJcIl19LFwiaW1hZ2UvanBlZ1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6ZmFsc2UsXCJleHRlbnNpb25zXCI6W1wianBlZ1wiLFwianBnXCIsXCJqcGVcIl19LFwiaW1hZ2UvanBtXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJqcG1cIl19LFwiaW1hZ2UvanB4XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJqcHhcIixcImpwZlwiXX0sXCJpbWFnZS9qeHJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJqeHJcIl19LFwiaW1hZ2Uva3R4XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wia3R4XCJdfSxcImltYWdlL25hcGxwc1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImltYWdlL3BqcGVnXCI6e1wiY29tcHJlc3NpYmxlXCI6ZmFsc2V9LFwiaW1hZ2UvcG5nXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJwbmdcIl19LFwiaW1hZ2UvcHJzLmJ0aWZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJidGlmXCJdfSxcImltYWdlL3Bycy5wdGlcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJwdGlcIl19LFwiaW1hZ2UvcHdnLXJhc3RlclwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImltYWdlL3NnaVwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wic2dpXCJdfSxcImltYWdlL3N2Zyt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wic3ZnXCIsXCJzdmd6XCJdfSxcImltYWdlL3QzOFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInQzOFwiXX0sXCJpbWFnZS90aWZmXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJ0aWZcIixcInRpZmZcIl19LFwiaW1hZ2UvdGlmZi1meFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInRmeFwiXX0sXCJpbWFnZS92bmQuYWRvYmUucGhvdG9zaG9wXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcInBzZFwiXX0sXCJpbWFnZS92bmQuYWlyemlwLmFjY2VsZXJhdG9yLmF6dlwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImF6dlwiXX0sXCJpbWFnZS92bmQuY25zLmluZjJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJpbWFnZS92bmQuZGVjZS5ncmFwaGljXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1widXZpXCIsXCJ1dnZpXCIsXCJ1dmdcIixcInV2dmdcIl19LFwiaW1hZ2Uvdm5kLmRqdnVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJkanZ1XCIsXCJkanZcIl19LFwiaW1hZ2Uvdm5kLmR2Yi5zdWJ0aXRsZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInN1YlwiXX0sXCJpbWFnZS92bmQuZHdnXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZHdnXCJdfSxcImltYWdlL3ZuZC5keGZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJkeGZcIl19LFwiaW1hZ2Uvdm5kLmZhc3RiaWRzaGVldFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImZic1wiXX0sXCJpbWFnZS92bmQuZnB4XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZnB4XCJdfSxcImltYWdlL3ZuZC5mc3RcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJmc3RcIl19LFwiaW1hZ2Uvdm5kLmZ1aml4ZXJveC5lZG1pY3MtbW1yXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wibW1yXCJdfSxcImltYWdlL3ZuZC5mdWppeGVyb3guZWRtaWNzLXJsY1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInJsY1wiXX0sXCJpbWFnZS92bmQuZ2xvYmFsZ3JhcGhpY3MucGdiXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiaW1hZ2Uvdm5kLm1pY3Jvc29mdC5pY29uXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiaWNvXCJdfSxcImltYWdlL3ZuZC5taXhcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJpbWFnZS92bmQubW96aWxsYS5hcG5nXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiaW1hZ2Uvdm5kLm1zLW1vZGlcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJtZGlcIl19LFwiaW1hZ2Uvdm5kLm1zLXBob3RvXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJ3ZHBcIl19LFwiaW1hZ2Uvdm5kLm5ldC1mcHhcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJucHhcIl19LFwiaW1hZ2Uvdm5kLnJhZGlhbmNlXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiaW1hZ2Uvdm5kLnNlYWxlZC5wbmdcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJpbWFnZS92bmQuc2VhbGVkbWVkaWEuc29mdHNlYWwuZ2lmXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwiaW1hZ2Uvdm5kLnNlYWxlZG1lZGlhLnNvZnRzZWFsLmpwZ1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcImltYWdlL3ZuZC5zdmZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJpbWFnZS92bmQudGVuY2VudC50YXBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ0YXBcIl19LFwiaW1hZ2Uvdm5kLnZhbHZlLnNvdXJjZS50ZXh0dXJlXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1widnRmXCJdfSxcImltYWdlL3ZuZC53YXAud2JtcFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIndibXBcIl19LFwiaW1hZ2Uvdm5kLnhpZmZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ4aWZcIl19LFwiaW1hZ2Uvdm5kLnpicnVzaC5wY3hcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJwY3hcIl19LFwiaW1hZ2Uvd2VicFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wid2VicFwiXX0sXCJpbWFnZS93bWZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ3bWZcIl19LFwiaW1hZ2UveC0zZHNcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcIjNkc1wiXX0sXCJpbWFnZS94LWNtdS1yYXN0ZXJcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInJhc1wiXX0sXCJpbWFnZS94LWNteFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiY214XCJdfSxcImltYWdlL3gtZnJlZWhhbmRcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcImZoXCIsXCJmaGNcIixcImZoNFwiLFwiZmg1XCIsXCJmaDdcIl19LFwiaW1hZ2UveC1pY29uXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wiaWNvXCJdfSxcImltYWdlL3gtam5nXCI6e1wic291cmNlXCI6XCJuZ2lueFwiLFwiZXh0ZW5zaW9uc1wiOltcImpuZ1wiXX0sXCJpbWFnZS94LW1yc2lkLWltYWdlXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJzaWRcIl19LFwiaW1hZ2UveC1tcy1ibXBcIjp7XCJzb3VyY2VcIjpcIm5naW54XCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcImJtcFwiXX0sXCJpbWFnZS94LXBjeFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wicGN4XCJdfSxcImltYWdlL3gtcGljdFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wicGljXCIsXCJwY3RcIl19LFwiaW1hZ2UveC1wb3J0YWJsZS1hbnltYXBcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInBubVwiXX0sXCJpbWFnZS94LXBvcnRhYmxlLWJpdG1hcFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wicGJtXCJdfSxcImltYWdlL3gtcG9ydGFibGUtZ3JheW1hcFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wicGdtXCJdfSxcImltYWdlL3gtcG9ydGFibGUtcGl4bWFwXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJwcG1cIl19LFwiaW1hZ2UveC1yZ2JcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInJnYlwiXX0sXCJpbWFnZS94LXRnYVwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1widGdhXCJdfSxcImltYWdlL3gteGJpdG1hcFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wieGJtXCJdfSxcImltYWdlL3gteGNmXCI6e1wiY29tcHJlc3NpYmxlXCI6ZmFsc2V9LFwiaW1hZ2UveC14cGl4bWFwXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJ4cG1cIl19LFwiaW1hZ2UveC14d2luZG93ZHVtcFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wieHdkXCJdfSxcIm1lc3NhZ2UvY3BpbVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcIm1lc3NhZ2UvZGVsaXZlcnktc3RhdHVzXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwibWVzc2FnZS9kaXNwb3NpdGlvbi1ub3RpZmljYXRpb25cIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJkaXNwb3NpdGlvbi1ub3RpZmljYXRpb25cIl19LFwibWVzc2FnZS9leHRlcm5hbC1ib2R5XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwibWVzc2FnZS9mZWVkYmFjay1yZXBvcnRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJtZXNzYWdlL2dsb2JhbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInU4bXNnXCJdfSxcIm1lc3NhZ2UvZ2xvYmFsLWRlbGl2ZXJ5LXN0YXR1c1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInU4ZHNuXCJdfSxcIm1lc3NhZ2UvZ2xvYmFsLWRpc3Bvc2l0aW9uLW5vdGlmaWNhdGlvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInU4bWRuXCJdfSxcIm1lc3NhZ2UvZ2xvYmFsLWhlYWRlcnNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ1OGhkclwiXX0sXCJtZXNzYWdlL2h0dHBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlfSxcIm1lc3NhZ2UvaW1kbit4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwibWVzc2FnZS9uZXdzXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwibWVzc2FnZS9wYXJ0aWFsXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZX0sXCJtZXNzYWdlL3JmYzgyMlwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJlbWxcIixcIm1pbWVcIl19LFwibWVzc2FnZS9zLWh0dHBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJtZXNzYWdlL3NpcFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcIm1lc3NhZ2Uvc2lwZnJhZ1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcIm1lc3NhZ2UvdHJhY2tpbmctc3RhdHVzXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwibWVzc2FnZS92bmQuc2kuc2ltcFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcIm1lc3NhZ2Uvdm5kLndmYS53c2NcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ3c2NcIl19LFwibW9kZWwvM21mXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiM21mXCJdfSxcIm1vZGVsL2dsdGYranNvblwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJnbHRmXCJdfSxcIm1vZGVsL2dsdGYtYmluYXJ5XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcImdsYlwiXX0sXCJtb2RlbC9pZ2VzXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJpZ3NcIixcImlnZXNcIl19LFwibW9kZWwvbWVzaFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6ZmFsc2UsXCJleHRlbnNpb25zXCI6W1wibXNoXCIsXCJtZXNoXCIsXCJzaWxvXCJdfSxcIm1vZGVsL3N0bFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInN0bFwiXX0sXCJtb2RlbC92bmQuY29sbGFkYSt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wiZGFlXCJdfSxcIm1vZGVsL3ZuZC5kd2ZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJkd2ZcIl19LFwibW9kZWwvdm5kLmZsYXRsYW5kLjNkbWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJtb2RlbC92bmQuZ2RsXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZ2RsXCJdfSxcIm1vZGVsL3ZuZC5ncy1nZGxcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwifSxcIm1vZGVsL3ZuZC5ncy5nZGxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJtb2RlbC92bmQuZ3R3XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZ3R3XCJdfSxcIm1vZGVsL3ZuZC5tb21sK3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJtb2RlbC92bmQubXRzXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wibXRzXCJdfSxcIm1vZGVsL3ZuZC5vcGVuZ2V4XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wib2dleFwiXX0sXCJtb2RlbC92bmQucGFyYXNvbGlkLnRyYW5zbWl0LmJpbmFyeVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInhfYlwiXX0sXCJtb2RlbC92bmQucGFyYXNvbGlkLnRyYW5zbWl0LnRleHRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ4X3RcIl19LFwibW9kZWwvdm5kLnJvc2V0dGUuYW5ub3RhdGVkLWRhdGEtbW9kZWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJtb2RlbC92bmQudXNkeit6aXBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcInVzZHpcIl19LFwibW9kZWwvdm5kLnZhbHZlLnNvdXJjZS5jb21waWxlZC1tYXBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJic3BcIl19LFwibW9kZWwvdm5kLnZ0dVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInZ0dVwiXX0sXCJtb2RlbC92cm1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJ3cmxcIixcInZybWxcIl19LFwibW9kZWwveDNkK2JpbmFyeVwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJ4M2RiXCIsXCJ4M2RielwiXX0sXCJtb2RlbC94M2QrZmFzdGluZm9zZXRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ4M2RiXCJdfSxcIm1vZGVsL3gzZCt2cm1sXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcIngzZHZcIixcIngzZHZ6XCJdfSxcIm1vZGVsL3gzZCt4bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wieDNkXCIsXCJ4M2R6XCJdfSxcIm1vZGVsL3gzZC12cm1sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wieDNkdlwiXX0sXCJtdWx0aXBhcnQvYWx0ZXJuYXRpdmVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlfSxcIm11bHRpcGFydC9hcHBsZWRvdWJsZVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcIm11bHRpcGFydC9ieXRlcmFuZ2VzXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwibXVsdGlwYXJ0L2RpZ2VzdFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcIm11bHRpcGFydC9lbmNyeXB0ZWRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlfSxcIm11bHRpcGFydC9mb3JtLWRhdGFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlfSxcIm11bHRpcGFydC9oZWFkZXItc2V0XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwibXVsdGlwYXJ0L21peGVkXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZX0sXCJtdWx0aXBhcnQvbXVsdGlsaW5ndWFsXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwibXVsdGlwYXJ0L3BhcmFsbGVsXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwibXVsdGlwYXJ0L3JlbGF0ZWRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlfSxcIm11bHRpcGFydC9yZXBvcnRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJtdWx0aXBhcnQvc2lnbmVkXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZX0sXCJtdWx0aXBhcnQvdm5kLmJpbnQubWVkLXBsdXNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJtdWx0aXBhcnQvdm9pY2UtbWVzc2FnZVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcIm11bHRpcGFydC94LW1peGVkLXJlcGxhY2VcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ0ZXh0LzFkLWludGVybGVhdmVkLXBhcml0eWZlY1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcInRleHQvY2FjaGUtbWFuaWZlc3RcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wiYXBwY2FjaGVcIixcIm1hbmlmZXN0XCJdfSxcInRleHQvY2FsZW5kYXJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJpY3NcIixcImlmYlwiXX0sXCJ0ZXh0L2NhbGVuZGVyXCI6e1wiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJ0ZXh0L2NtZFwiOntcImNvbXByZXNzaWJsZVwiOnRydWV9LFwidGV4dC9jb2ZmZWVzY3JpcHRcIjp7XCJleHRlbnNpb25zXCI6W1wiY29mZmVlXCIsXCJsaXRjb2ZmZWVcIl19LFwidGV4dC9jc3NcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNoYXJzZXRcIjpcIlVURi04XCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcImNzc1wiXX0sXCJ0ZXh0L2NzdlwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJjc3ZcIl19LFwidGV4dC9jc3Ytc2NoZW1hXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidGV4dC9kaXJlY3RvcnlcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ0ZXh0L2Ruc1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcInRleHQvZWNtYXNjcmlwdFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcInRleHQvZW5jYXBydHBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ0ZXh0L2VucmljaGVkXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidGV4dC9md2RyZWRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ0ZXh0L2dyYW1tYXItcmVmLWxpc3RcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ0ZXh0L2h0bWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wiaHRtbFwiLFwiaHRtXCIsXCJzaHRtbFwiXX0sXCJ0ZXh0L2phZGVcIjp7XCJleHRlbnNpb25zXCI6W1wiamFkZVwiXX0sXCJ0ZXh0L2phdmFzY3JpcHRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWV9LFwidGV4dC9qY3ItY25kXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidGV4dC9qc3hcIjp7XCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcImpzeFwiXX0sXCJ0ZXh0L2xlc3NcIjp7XCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcImxlc3NcIl19LFwidGV4dC9tYXJrZG93blwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJtYXJrZG93blwiLFwibWRcIl19LFwidGV4dC9tYXRobWxcIjp7XCJzb3VyY2VcIjpcIm5naW54XCIsXCJleHRlbnNpb25zXCI6W1wibW1sXCJdfSxcInRleHQvbWR4XCI6e1wiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJtZHhcIl19LFwidGV4dC9taXphclwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcInRleHQvbjNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wibjNcIl19LFwidGV4dC9wYXJhbWV0ZXJzXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidGV4dC9wYXJpdHlmZWNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ0ZXh0L3BsYWluXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcInR4dFwiLFwidGV4dFwiLFwiY29uZlwiLFwiZGVmXCIsXCJsaXN0XCIsXCJsb2dcIixcImluXCIsXCJpbmlcIl19LFwidGV4dC9wcm92ZW5hbmNlLW5vdGF0aW9uXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidGV4dC9wcnMuZmFsbGVuc3RlaW4ucnN0XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidGV4dC9wcnMubGluZXMudGFnXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZHNjXCJdfSxcInRleHQvcHJzLnByb3AubG9naWNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ0ZXh0L3JhcHRvcmZlY1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcInRleHQvcmVkXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidGV4dC9yZmM4MjItaGVhZGVyc1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcInRleHQvcmljaHRleHRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1wicnR4XCJdfSxcInRleHQvcnRmXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcInJ0ZlwiXX0sXCJ0ZXh0L3J0cC1lbmMtYWVzY20xMjhcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ0ZXh0L3J0cGxvb3BiYWNrXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidGV4dC9ydHhcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ0ZXh0L3NnbWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJzZ21sXCIsXCJzZ21cIl19LFwidGV4dC9zaGV4XCI6e1wiZXh0ZW5zaW9uc1wiOltcInNoZXhcIl19LFwidGV4dC9zbGltXCI6e1wiZXh0ZW5zaW9uc1wiOltcInNsaW1cIixcInNsbVwiXX0sXCJ0ZXh0L3N0cmluZ3NcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ0ZXh0L3N0eWx1c1wiOntcImV4dGVuc2lvbnNcIjpbXCJzdHlsdXNcIixcInN0eWxcIl19LFwidGV4dC90MTQwXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidGV4dC90YWItc2VwYXJhdGVkLXZhbHVlc1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJ0c3ZcIl19LFwidGV4dC90cm9mZlwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInRcIixcInRyXCIsXCJyb2ZmXCIsXCJtYW5cIixcIm1lXCIsXCJtc1wiXX0sXCJ0ZXh0L3R1cnRsZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY2hhcnNldFwiOlwiVVRGLThcIixcImV4dGVuc2lvbnNcIjpbXCJ0dGxcIl19LFwidGV4dC91bHBmZWNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ0ZXh0L3VyaS1saXN0XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcInVyaVwiLFwidXJpc1wiLFwidXJsc1wiXX0sXCJ0ZXh0L3ZjYXJkXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcInZjYXJkXCJdfSxcInRleHQvdm5kLmFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ0ZXh0L3ZuZC5hYmNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ0ZXh0L3ZuZC5hc2NpaS1hcnRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ0ZXh0L3ZuZC5jdXJsXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiY3VybFwiXX0sXCJ0ZXh0L3ZuZC5jdXJsLmRjdXJsXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJkY3VybFwiXX0sXCJ0ZXh0L3ZuZC5jdXJsLm1jdXJsXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJtY3VybFwiXX0sXCJ0ZXh0L3ZuZC5jdXJsLnNjdXJsXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJzY3VybFwiXX0sXCJ0ZXh0L3ZuZC5kZWJpYW4uY29weXJpZ2h0XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidGV4dC92bmQuZG1jbGllbnRzY3JpcHRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ0ZXh0L3ZuZC5kdmIuc3VidGl0bGVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJzdWJcIl19LFwidGV4dC92bmQuZXNtZXJ0ZWMudGhlbWUtZGVzY3JpcHRvclwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcInRleHQvdm5kLmZseVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImZseVwiXX0sXCJ0ZXh0L3ZuZC5mbWkuZmxleHN0b3JcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJmbHhcIl19LFwidGV4dC92bmQuZ21sXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidGV4dC92bmQuZ3JhcGh2aXpcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJndlwiXX0sXCJ0ZXh0L3ZuZC5oZ2xcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ0ZXh0L3ZuZC5pbjNkLjNkbWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCIzZG1sXCJdfSxcInRleHQvdm5kLmluM2Quc3BvdFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInNwb3RcIl19LFwidGV4dC92bmQuaXB0Yy5uZXdzbWxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ0ZXh0L3ZuZC5pcHRjLm5pdGZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ0ZXh0L3ZuZC5sYXRleC16XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidGV4dC92bmQubW90b3JvbGEucmVmbGV4XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidGV4dC92bmQubXMtbWVkaWFwYWNrYWdlXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidGV4dC92bmQubmV0MnBob25lLmNvbW1jZW50ZXIuY29tbWFuZFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcInRleHQvdm5kLnJhZGlzeXMubXNtbC1iYXNpYy1sYXlvdXRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ0ZXh0L3ZuZC5zZW54LndhcnBzY3JpcHRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ0ZXh0L3ZuZC5zaS51cmljYXRhbG9ndWVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ0ZXh0L3ZuZC5zdW4uajJtZS5hcHAtZGVzY3JpcHRvclwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImphZFwiXX0sXCJ0ZXh0L3ZuZC50cm9sbHRlY2gubGluZ3Vpc3RcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ0ZXh0L3ZuZC53YXAuc2lcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ0ZXh0L3ZuZC53YXAuc2xcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ0ZXh0L3ZuZC53YXAud21sXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wid21sXCJdfSxcInRleHQvdm5kLndhcC53bWxzY3JpcHRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ3bWxzXCJdfSxcInRleHQvdnR0XCI6e1wiY2hhcnNldFwiOlwiVVRGLThcIixcImNvbXByZXNzaWJsZVwiOnRydWUsXCJleHRlbnNpb25zXCI6W1widnR0XCJdfSxcInRleHQveC1hc21cIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInNcIixcImFzbVwiXX0sXCJ0ZXh0L3gtY1wiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiY1wiLFwiY2NcIixcImN4eFwiLFwiY3BwXCIsXCJoXCIsXCJoaFwiLFwiZGljXCJdfSxcInRleHQveC1jb21wb25lbnRcIjp7XCJzb3VyY2VcIjpcIm5naW54XCIsXCJleHRlbnNpb25zXCI6W1wiaHRjXCJdfSxcInRleHQveC1mb3J0cmFuXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJmXCIsXCJmb3JcIixcImY3N1wiLFwiZjkwXCJdfSxcInRleHQveC1nd3QtcnBjXCI6e1wiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJ0ZXh0L3gtaGFuZGxlYmFycy10ZW1wbGF0ZVwiOntcImV4dGVuc2lvbnNcIjpbXCJoYnNcIl19LFwidGV4dC94LWphdmEtc291cmNlXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJqYXZhXCJdfSxcInRleHQveC1qcXVlcnktdG1wbFwiOntcImNvbXByZXNzaWJsZVwiOnRydWV9LFwidGV4dC94LWx1YVwiOntcImV4dGVuc2lvbnNcIjpbXCJsdWFcIl19LFwidGV4dC94LW1hcmtkb3duXCI6e1wiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJta2RcIl19LFwidGV4dC94LW5mb1wiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wibmZvXCJdfSxcInRleHQveC1vcG1sXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJvcG1sXCJdfSxcInRleHQveC1vcmdcIjp7XCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcIm9yZ1wiXX0sXCJ0ZXh0L3gtcGFzY2FsXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJwXCIsXCJwYXNcIl19LFwidGV4dC94LXByb2Nlc3NpbmdcIjp7XCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcInBkZVwiXX0sXCJ0ZXh0L3gtc2Fzc1wiOntcImV4dGVuc2lvbnNcIjpbXCJzYXNzXCJdfSxcInRleHQveC1zY3NzXCI6e1wiZXh0ZW5zaW9uc1wiOltcInNjc3NcIl19LFwidGV4dC94LXNldGV4dFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiZXR4XCJdfSxcInRleHQveC1zZnZcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInNmdlwiXX0sXCJ0ZXh0L3gtc3VzZS15bXBcIjp7XCJjb21wcmVzc2libGVcIjp0cnVlLFwiZXh0ZW5zaW9uc1wiOltcInltcFwiXX0sXCJ0ZXh0L3gtdXVlbmNvZGVcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInV1XCJdfSxcInRleHQveC12Y2FsZW5kYXJcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInZjc1wiXX0sXCJ0ZXh0L3gtdmNhcmRcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcInZjZlwiXX0sXCJ0ZXh0L3htbFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6dHJ1ZSxcImV4dGVuc2lvbnNcIjpbXCJ4bWxcIl19LFwidGV4dC94bWwtZXh0ZXJuYWwtcGFyc2VkLWVudGl0eVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcInRleHQveWFtbFwiOntcImV4dGVuc2lvbnNcIjpbXCJ5YW1sXCIsXCJ5bWxcIl19LFwidmlkZW8vMWQtaW50ZXJsZWF2ZWQtcGFyaXR5ZmVjXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidmlkZW8vM2dwcFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIjNncFwiLFwiM2dwcFwiXX0sXCJ2aWRlby8zZ3BwLXR0XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidmlkZW8vM2dwcDJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCIzZzJcIl19LFwidmlkZW8vYm1wZWdcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby9idDY1NlwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcInZpZGVvL2NlbGJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby9kdlwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcInZpZGVvL2VuY2FwcnRwXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidmlkZW8vaDI2MVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImgyNjFcIl19LFwidmlkZW8vaDI2M1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImgyNjNcIl19LFwidmlkZW8vaDI2My0xOTk4XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidmlkZW8vaDI2My0yMDAwXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidmlkZW8vaDI2NFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImgyNjRcIl19LFwidmlkZW8vaDI2NC1yY2RvXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidmlkZW8vaDI2NC1zdmNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby9oMjY1XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidmlkZW8vaXNvLnNlZ21lbnRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby9qcGVnXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wianBndlwiXX0sXCJ2aWRlby9qcGVnMjAwMFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcInZpZGVvL2pwbVwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wianBtXCIsXCJqcGdtXCJdfSxcInZpZGVvL21qMlwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcIm1qMlwiLFwibWpwMlwiXX0sXCJ2aWRlby9tcDFzXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidmlkZW8vbXAycFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcInZpZGVvL21wMnRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJ0c1wiXX0sXCJ2aWRlby9tcDRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcIm1wNFwiLFwibXA0dlwiLFwibXBnNFwiXX0sXCJ2aWRlby9tcDR2LWVzXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidmlkZW8vbXBlZ1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6ZmFsc2UsXCJleHRlbnNpb25zXCI6W1wibXBlZ1wiLFwibXBnXCIsXCJtcGVcIixcIm0xdlwiLFwibTJ2XCJdfSxcInZpZGVvL21wZWc0LWdlbmVyaWNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby9tcHZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby9udlwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcInZpZGVvL29nZ1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiY29tcHJlc3NpYmxlXCI6ZmFsc2UsXCJleHRlbnNpb25zXCI6W1wib2d2XCJdfSxcInZpZGVvL3Bhcml0eWZlY1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcInZpZGVvL3BvaW50ZXJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby9xdWlja3RpbWVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcInF0XCIsXCJtb3ZcIl19LFwidmlkZW8vcmFwdG9yZmVjXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidmlkZW8vcmF3XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidmlkZW8vcnRwLWVuYy1hZXNjbTEyOFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcInZpZGVvL3J0cGxvb3BiYWNrXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidmlkZW8vcnR4XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidmlkZW8vc21wdGUyOTFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby9zbXB0ZTI5Mm1cIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby91bHBmZWNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby92YzFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby92YzJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby92bmQuY2N0dlwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcInZpZGVvL3ZuZC5kZWNlLmhkXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1widXZoXCIsXCJ1dnZoXCJdfSxcInZpZGVvL3ZuZC5kZWNlLm1vYmlsZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInV2bVwiLFwidXZ2bVwiXX0sXCJ2aWRlby92bmQuZGVjZS5tcDRcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby92bmQuZGVjZS5wZFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInV2cFwiLFwidXZ2cFwiXX0sXCJ2aWRlby92bmQuZGVjZS5zZFwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInV2c1wiLFwidXZ2c1wiXX0sXCJ2aWRlby92bmQuZGVjZS52aWRlb1wiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInV2dlwiLFwidXZ2dlwiXX0sXCJ2aWRlby92bmQuZGlyZWN0di5tcGVnXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidmlkZW8vdm5kLmRpcmVjdHYubXBlZy10dHNcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby92bmQuZGxuYS5tcGVnLXR0c1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcInZpZGVvL3ZuZC5kdmIuZmlsZVwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcImR2YlwiXX0sXCJ2aWRlby92bmQuZnZ0XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1wiZnZ0XCJdfSxcInZpZGVvL3ZuZC5obnMudmlkZW9cIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby92bmQuaXB0dmZvcnVtLjFkcGFyaXR5ZmVjLTEwMTBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby92bmQuaXB0dmZvcnVtLjFkcGFyaXR5ZmVjLTIwMDVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby92bmQuaXB0dmZvcnVtLjJkcGFyaXR5ZmVjLTEwMTBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby92bmQuaXB0dmZvcnVtLjJkcGFyaXR5ZmVjLTIwMDVcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby92bmQuaXB0dmZvcnVtLnR0c2F2Y1wiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcInZpZGVvL3ZuZC5pcHR2Zm9ydW0udHRzbXBlZzJcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby92bmQubW90b3JvbGEudmlkZW9cIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby92bmQubW90b3JvbGEudmlkZW9wXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidmlkZW8vdm5kLm1wZWd1cmxcIjp7XCJzb3VyY2VcIjpcImlhbmFcIixcImV4dGVuc2lvbnNcIjpbXCJteHVcIixcIm00dVwiXX0sXCJ2aWRlby92bmQubXMtcGxheXJlYWR5Lm1lZGlhLnB5dlwiOntcInNvdXJjZVwiOlwiaWFuYVwiLFwiZXh0ZW5zaW9uc1wiOltcInB5dlwiXX0sXCJ2aWRlby92bmQubm9raWEuaW50ZXJsZWF2ZWQtbXVsdGltZWRpYVwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcInZpZGVvL3ZuZC5ub2tpYS5tcDR2clwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcInZpZGVvL3ZuZC5ub2tpYS52aWRlb3ZvaXBcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby92bmQub2JqZWN0dmlkZW9cIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby92bmQucmFkZ2FtZXR0b29scy5iaW5rXCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidmlkZW8vdm5kLnJhZGdhbWV0dG9vbHMuc21hY2tlclwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcInZpZGVvL3ZuZC5zZWFsZWQubXBlZzFcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby92bmQuc2VhbGVkLm1wZWc0XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidmlkZW8vdm5kLnNlYWxlZC5zd2ZcIjp7XCJzb3VyY2VcIjpcImlhbmFcIn0sXCJ2aWRlby92bmQuc2VhbGVkbWVkaWEuc29mdHNlYWwubW92XCI6e1wic291cmNlXCI6XCJpYW5hXCJ9LFwidmlkZW8vdm5kLnV2dnUubXA0XCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1widXZ1XCIsXCJ1dnZ1XCJdfSxcInZpZGVvL3ZuZC52aXZvXCI6e1wic291cmNlXCI6XCJpYW5hXCIsXCJleHRlbnNpb25zXCI6W1widml2XCJdfSxcInZpZGVvL3ZwOFwiOntcInNvdXJjZVwiOlwiaWFuYVwifSxcInZpZGVvL3dlYm1cIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiY29tcHJlc3NpYmxlXCI6ZmFsc2UsXCJleHRlbnNpb25zXCI6W1wid2VibVwiXX0sXCJ2aWRlby94LWY0dlwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wiZjR2XCJdfSxcInZpZGVvL3gtZmxpXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJmbGlcIl19LFwidmlkZW8veC1mbHZcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiY29tcHJlc3NpYmxlXCI6ZmFsc2UsXCJleHRlbnNpb25zXCI6W1wiZmx2XCJdfSxcInZpZGVvL3gtbTR2XCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJtNHZcIl19LFwidmlkZW8veC1tYXRyb3NrYVwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJjb21wcmVzc2libGVcIjpmYWxzZSxcImV4dGVuc2lvbnNcIjpbXCJta3ZcIixcIm1rM2RcIixcIm1rc1wiXX0sXCJ2aWRlby94LW1uZ1wiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wibW5nXCJdfSxcInZpZGVvL3gtbXMtYXNmXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJhc2ZcIixcImFzeFwiXX0sXCJ2aWRlby94LW1zLXZvYlwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1widm9iXCJdfSxcInZpZGVvL3gtbXMtd21cIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcIndtXCJdfSxcInZpZGVvL3gtbXMtd212XCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImNvbXByZXNzaWJsZVwiOmZhbHNlLFwiZXh0ZW5zaW9uc1wiOltcIndtdlwiXX0sXCJ2aWRlby94LW1zLXdteFwiOntcInNvdXJjZVwiOlwiYXBhY2hlXCIsXCJleHRlbnNpb25zXCI6W1wid214XCJdfSxcInZpZGVvL3gtbXMtd3Z4XCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJ3dnhcIl19LFwidmlkZW8veC1tc3ZpZGVvXCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJhdmlcIl19LFwidmlkZW8veC1zZ2ktbW92aWVcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcIm1vdmllXCJdfSxcInZpZGVvL3gtc212XCI6e1wic291cmNlXCI6XCJhcGFjaGVcIixcImV4dGVuc2lvbnNcIjpbXCJzbXZcIl19LFwieC1jb25mZXJlbmNlL3gtY29vbHRhbGtcIjp7XCJzb3VyY2VcIjpcImFwYWNoZVwiLFwiZXh0ZW5zaW9uc1wiOltcImljZVwiXX0sXCJ4LXNoYWRlci94LWZyYWdtZW50XCI6e1wiY29tcHJlc3NpYmxlXCI6dHJ1ZX0sXCJ4LXNoYWRlci94LXZlcnRleFwiOntcImNvbXByZXNzaWJsZVwiOnRydWV9fVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21pbWUtZGIvZGIuanNvblxuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogYm9keS1wYXJzZXJcbiAqIENvcHlyaWdodChjKSAyMDE0LTIwMTUgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGJ5dGVzID0gcmVxdWlyZSgnYnl0ZXMnKVxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnYm9keS1wYXJzZXI6cmF3JylcbnZhciByZWFkID0gcmVxdWlyZSgnLi4vcmVhZCcpXG52YXIgdHlwZWlzID0gcmVxdWlyZSgndHlwZS1pcycpXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByYXdcblxuLyoqXG4gKiBDcmVhdGUgYSBtaWRkbGV3YXJlIHRvIHBhcnNlIHJhdyBib2RpZXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHJhdyAob3B0aW9ucykge1xuICB2YXIgb3B0cyA9IG9wdGlvbnMgfHwge31cblxuICB2YXIgaW5mbGF0ZSA9IG9wdHMuaW5mbGF0ZSAhPT0gZmFsc2VcbiAgdmFyIGxpbWl0ID0gdHlwZW9mIG9wdHMubGltaXQgIT09ICdudW1iZXInXG4gICAgPyBieXRlcy5wYXJzZShvcHRzLmxpbWl0IHx8ICcxMDBrYicpXG4gICAgOiBvcHRzLmxpbWl0XG4gIHZhciB0eXBlID0gb3B0cy50eXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXG4gIHZhciB2ZXJpZnkgPSBvcHRzLnZlcmlmeSB8fCBmYWxzZVxuXG4gIGlmICh2ZXJpZnkgIT09IGZhbHNlICYmIHR5cGVvZiB2ZXJpZnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gdmVyaWZ5IG11c3QgYmUgZnVuY3Rpb24nKVxuICB9XG5cbiAgLy8gY3JlYXRlIHRoZSBhcHByb3ByaWF0ZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9uXG4gIHZhciBzaG91bGRQYXJzZSA9IHR5cGVvZiB0eXBlICE9PSAnZnVuY3Rpb24nXG4gICAgPyB0eXBlQ2hlY2tlcih0eXBlKVxuICAgIDogdHlwZVxuXG4gIGZ1bmN0aW9uIHBhcnNlIChidWYpIHtcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcmF3UGFyc2VyIChyZXEsIHJlcywgbmV4dCkge1xuICAgIGlmIChyZXEuX2JvZHkpIHtcbiAgICAgIGRlYnVnKCdib2R5IGFscmVhZHkgcGFyc2VkJylcbiAgICAgIG5leHQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgcmVxLmJvZHkgPSByZXEuYm9keSB8fCB7fVxuXG4gICAgLy8gc2tpcCByZXF1ZXN0cyB3aXRob3V0IGJvZGllc1xuICAgIGlmICghdHlwZWlzLmhhc0JvZHkocmVxKSkge1xuICAgICAgZGVidWcoJ3NraXAgZW1wdHkgYm9keScpXG4gICAgICBuZXh0KClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGRlYnVnKCdjb250ZW50LXR5cGUgJWonLCByZXEuaGVhZGVyc1snY29udGVudC10eXBlJ10pXG5cbiAgICAvLyBkZXRlcm1pbmUgaWYgcmVxdWVzdCBzaG91bGQgYmUgcGFyc2VkXG4gICAgaWYgKCFzaG91bGRQYXJzZShyZXEpKSB7XG4gICAgICBkZWJ1Zygnc2tpcCBwYXJzaW5nJylcbiAgICAgIG5leHQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gcmVhZFxuICAgIHJlYWQocmVxLCByZXMsIG5leHQsIHBhcnNlLCBkZWJ1Zywge1xuICAgICAgZW5jb2Rpbmc6IG51bGwsXG4gICAgICBpbmZsYXRlOiBpbmZsYXRlLFxuICAgICAgbGltaXQ6IGxpbWl0LFxuICAgICAgdmVyaWZ5OiB2ZXJpZnlcbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBzaW1wbGUgdHlwZSBjaGVja2VyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiB0eXBlQ2hlY2tlciAodHlwZSkge1xuICByZXR1cm4gZnVuY3Rpb24gY2hlY2tUeXBlIChyZXEpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0eXBlaXMocmVxLCB0eXBlKSlcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYm9keS1wYXJzZXIvbGliL3R5cGVzL3Jhdy5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogYm9keS1wYXJzZXJcbiAqIENvcHlyaWdodChjKSAyMDE0LTIwMTUgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGJ5dGVzID0gcmVxdWlyZSgnYnl0ZXMnKVxudmFyIGNvbnRlbnRUeXBlID0gcmVxdWlyZSgnY29udGVudC10eXBlJylcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2JvZHktcGFyc2VyOnRleHQnKVxudmFyIHJlYWQgPSByZXF1aXJlKCcuLi9yZWFkJylcbnZhciB0eXBlaXMgPSByZXF1aXJlKCd0eXBlLWlzJylcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRleHRcblxuLyoqXG4gKiBDcmVhdGUgYSBtaWRkbGV3YXJlIHRvIHBhcnNlIHRleHQgYm9kaWVzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiB0ZXh0IChvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gb3B0aW9ucyB8fCB7fVxuXG4gIHZhciBkZWZhdWx0Q2hhcnNldCA9IG9wdHMuZGVmYXVsdENoYXJzZXQgfHwgJ3V0Zi04J1xuICB2YXIgaW5mbGF0ZSA9IG9wdHMuaW5mbGF0ZSAhPT0gZmFsc2VcbiAgdmFyIGxpbWl0ID0gdHlwZW9mIG9wdHMubGltaXQgIT09ICdudW1iZXInXG4gICAgPyBieXRlcy5wYXJzZShvcHRzLmxpbWl0IHx8ICcxMDBrYicpXG4gICAgOiBvcHRzLmxpbWl0XG4gIHZhciB0eXBlID0gb3B0cy50eXBlIHx8ICd0ZXh0L3BsYWluJ1xuICB2YXIgdmVyaWZ5ID0gb3B0cy52ZXJpZnkgfHwgZmFsc2VcblxuICBpZiAodmVyaWZ5ICE9PSBmYWxzZSAmJiB0eXBlb2YgdmVyaWZ5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIHZlcmlmeSBtdXN0IGJlIGZ1bmN0aW9uJylcbiAgfVxuXG4gIC8vIGNyZWF0ZSB0aGUgYXBwcm9wcmlhdGUgdHlwZSBjaGVja2luZyBmdW5jdGlvblxuICB2YXIgc2hvdWxkUGFyc2UgPSB0eXBlb2YgdHlwZSAhPT0gJ2Z1bmN0aW9uJ1xuICAgID8gdHlwZUNoZWNrZXIodHlwZSlcbiAgICA6IHR5cGVcblxuICBmdW5jdGlvbiBwYXJzZSAoYnVmKSB7XG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHRleHRQYXJzZXIgKHJlcSwgcmVzLCBuZXh0KSB7XG4gICAgaWYgKHJlcS5fYm9keSkge1xuICAgICAgZGVidWcoJ2JvZHkgYWxyZWFkeSBwYXJzZWQnKVxuICAgICAgbmV4dCgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICByZXEuYm9keSA9IHJlcS5ib2R5IHx8IHt9XG5cbiAgICAvLyBza2lwIHJlcXVlc3RzIHdpdGhvdXQgYm9kaWVzXG4gICAgaWYgKCF0eXBlaXMuaGFzQm9keShyZXEpKSB7XG4gICAgICBkZWJ1Zygnc2tpcCBlbXB0eSBib2R5JylcbiAgICAgIG5leHQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZGVidWcoJ2NvbnRlbnQtdHlwZSAlaicsIHJlcS5oZWFkZXJzWydjb250ZW50LXR5cGUnXSlcblxuICAgIC8vIGRldGVybWluZSBpZiByZXF1ZXN0IHNob3VsZCBiZSBwYXJzZWRcbiAgICBpZiAoIXNob3VsZFBhcnNlKHJlcSkpIHtcbiAgICAgIGRlYnVnKCdza2lwIHBhcnNpbmcnKVxuICAgICAgbmV4dCgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBnZXQgY2hhcnNldFxuICAgIHZhciBjaGFyc2V0ID0gZ2V0Q2hhcnNldChyZXEpIHx8IGRlZmF1bHRDaGFyc2V0XG5cbiAgICAvLyByZWFkXG4gICAgcmVhZChyZXEsIHJlcywgbmV4dCwgcGFyc2UsIGRlYnVnLCB7XG4gICAgICBlbmNvZGluZzogY2hhcnNldCxcbiAgICAgIGluZmxhdGU6IGluZmxhdGUsXG4gICAgICBsaW1pdDogbGltaXQsXG4gICAgICB2ZXJpZnk6IHZlcmlmeVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNoYXJzZXQgb2YgYSByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSByZXFcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGdldENoYXJzZXQgKHJlcSkge1xuICB0cnkge1xuICAgIHJldHVybiAoY29udGVudFR5cGUucGFyc2UocmVxKS5wYXJhbWV0ZXJzLmNoYXJzZXQgfHwgJycpLnRvTG93ZXJDYXNlKClcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgc2ltcGxlIHR5cGUgY2hlY2tlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gdHlwZUNoZWNrZXIgKHR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNoZWNrVHlwZSAocmVxKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odHlwZWlzKHJlcSwgdHlwZSkpXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JvZHktcGFyc2VyL2xpYi90eXBlcy90ZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBib2R5LXBhcnNlclxuICogQ29weXJpZ2h0KGMpIDIwMTQgSm9uYXRoYW4gT25nXG4gKiBDb3B5cmlnaHQoYykgMjAxNC0yMDE1IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgYnl0ZXMgPSByZXF1aXJlKCdieXRlcycpXG52YXIgY29udGVudFR5cGUgPSByZXF1aXJlKCdjb250ZW50LXR5cGUnKVxudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnaHR0cC1lcnJvcnMnKVxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnYm9keS1wYXJzZXI6dXJsZW5jb2RlZCcpXG52YXIgZGVwcmVjYXRlID0gcmVxdWlyZSgnZGVwZCcpKCdib2R5LXBhcnNlcicpXG52YXIgcmVhZCA9IHJlcXVpcmUoJy4uL3JlYWQnKVxudmFyIHR5cGVpcyA9IHJlcXVpcmUoJ3R5cGUtaXMnKVxuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gdXJsZW5jb2RlZFxuXG4vKipcbiAqIENhY2hlIG9mIHBhcnNlciBtb2R1bGVzLlxuICovXG5cbnZhciBwYXJzZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4vKipcbiAqIENyZWF0ZSBhIG1pZGRsZXdhcmUgdG8gcGFyc2UgdXJsZW5jb2RlZCBib2RpZXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gdXJsZW5jb2RlZCAob3B0aW9ucykge1xuICB2YXIgb3B0cyA9IG9wdGlvbnMgfHwge31cblxuICAvLyBub3RpY2UgYmVjYXVzZSBvcHRpb24gZGVmYXVsdCB3aWxsIGZsaXAgaW4gbmV4dCBtYWpvclxuICBpZiAob3B0cy5leHRlbmRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZGVwcmVjYXRlKCd1bmRlZmluZWQgZXh0ZW5kZWQ6IHByb3ZpZGUgZXh0ZW5kZWQgb3B0aW9uJylcbiAgfVxuXG4gIHZhciBleHRlbmRlZCA9IG9wdHMuZXh0ZW5kZWQgIT09IGZhbHNlXG4gIHZhciBpbmZsYXRlID0gb3B0cy5pbmZsYXRlICE9PSBmYWxzZVxuICB2YXIgbGltaXQgPSB0eXBlb2Ygb3B0cy5saW1pdCAhPT0gJ251bWJlcidcbiAgICA/IGJ5dGVzLnBhcnNlKG9wdHMubGltaXQgfHwgJzEwMGtiJylcbiAgICA6IG9wdHMubGltaXRcbiAgdmFyIHR5cGUgPSBvcHRzLnR5cGUgfHwgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbiAgdmFyIHZlcmlmeSA9IG9wdHMudmVyaWZ5IHx8IGZhbHNlXG5cbiAgaWYgKHZlcmlmeSAhPT0gZmFsc2UgJiYgdHlwZW9mIHZlcmlmeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiB2ZXJpZnkgbXVzdCBiZSBmdW5jdGlvbicpXG4gIH1cblxuICAvLyBjcmVhdGUgdGhlIGFwcHJvcHJpYXRlIHF1ZXJ5IHBhcnNlclxuICB2YXIgcXVlcnlwYXJzZSA9IGV4dGVuZGVkXG4gICAgPyBleHRlbmRlZHBhcnNlcihvcHRzKVxuICAgIDogc2ltcGxlcGFyc2VyKG9wdHMpXG5cbiAgLy8gY3JlYXRlIHRoZSBhcHByb3ByaWF0ZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9uXG4gIHZhciBzaG91bGRQYXJzZSA9IHR5cGVvZiB0eXBlICE9PSAnZnVuY3Rpb24nXG4gICAgPyB0eXBlQ2hlY2tlcih0eXBlKVxuICAgIDogdHlwZVxuXG4gIGZ1bmN0aW9uIHBhcnNlIChib2R5KSB7XG4gICAgcmV0dXJuIGJvZHkubGVuZ3RoXG4gICAgICA/IHF1ZXJ5cGFyc2UoYm9keSlcbiAgICAgIDoge31cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cmxlbmNvZGVkUGFyc2VyIChyZXEsIHJlcywgbmV4dCkge1xuICAgIGlmIChyZXEuX2JvZHkpIHtcbiAgICAgIGRlYnVnKCdib2R5IGFscmVhZHkgcGFyc2VkJylcbiAgICAgIG5leHQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgcmVxLmJvZHkgPSByZXEuYm9keSB8fCB7fVxuXG4gICAgLy8gc2tpcCByZXF1ZXN0cyB3aXRob3V0IGJvZGllc1xuICAgIGlmICghdHlwZWlzLmhhc0JvZHkocmVxKSkge1xuICAgICAgZGVidWcoJ3NraXAgZW1wdHkgYm9keScpXG4gICAgICBuZXh0KClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGRlYnVnKCdjb250ZW50LXR5cGUgJWonLCByZXEuaGVhZGVyc1snY29udGVudC10eXBlJ10pXG5cbiAgICAvLyBkZXRlcm1pbmUgaWYgcmVxdWVzdCBzaG91bGQgYmUgcGFyc2VkXG4gICAgaWYgKCFzaG91bGRQYXJzZShyZXEpKSB7XG4gICAgICBkZWJ1Zygnc2tpcCBwYXJzaW5nJylcbiAgICAgIG5leHQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gYXNzZXJ0IGNoYXJzZXRcbiAgICB2YXIgY2hhcnNldCA9IGdldENoYXJzZXQocmVxKSB8fCAndXRmLTgnXG4gICAgaWYgKGNoYXJzZXQgIT09ICd1dGYtOCcpIHtcbiAgICAgIGRlYnVnKCdpbnZhbGlkIGNoYXJzZXQnKVxuICAgICAgbmV4dChjcmVhdGVFcnJvcig0MTUsICd1bnN1cHBvcnRlZCBjaGFyc2V0IFwiJyArIGNoYXJzZXQudG9VcHBlckNhc2UoKSArICdcIicsIHtcbiAgICAgICAgY2hhcnNldDogY2hhcnNldCxcbiAgICAgICAgdHlwZTogJ2NoYXJzZXQudW5zdXBwb3J0ZWQnXG4gICAgICB9KSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHJlYWRcbiAgICByZWFkKHJlcSwgcmVzLCBuZXh0LCBwYXJzZSwgZGVidWcsIHtcbiAgICAgIGRlYnVnOiBkZWJ1ZyxcbiAgICAgIGVuY29kaW5nOiBjaGFyc2V0LFxuICAgICAgaW5mbGF0ZTogaW5mbGF0ZSxcbiAgICAgIGxpbWl0OiBsaW1pdCxcbiAgICAgIHZlcmlmeTogdmVyaWZ5XG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgZXh0ZW5kZWQgcXVlcnkgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gZXh0ZW5kZWRwYXJzZXIgKG9wdGlvbnMpIHtcbiAgdmFyIHBhcmFtZXRlckxpbWl0ID0gb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCAhPT0gdW5kZWZpbmVkXG4gICAgPyBvcHRpb25zLnBhcmFtZXRlckxpbWl0XG4gICAgOiAxMDAwXG4gIHZhciBwYXJzZSA9IHBhcnNlcigncXMnKVxuXG4gIGlmIChpc05hTihwYXJhbWV0ZXJMaW1pdCkgfHwgcGFyYW1ldGVyTGltaXQgPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIHBhcmFtZXRlckxpbWl0IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKVxuICB9XG5cbiAgaWYgKGlzRmluaXRlKHBhcmFtZXRlckxpbWl0KSkge1xuICAgIHBhcmFtZXRlckxpbWl0ID0gcGFyYW1ldGVyTGltaXQgfCAwXG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcXVlcnlwYXJzZSAoYm9keSkge1xuICAgIHZhciBwYXJhbUNvdW50ID0gcGFyYW1ldGVyQ291bnQoYm9keSwgcGFyYW1ldGVyTGltaXQpXG5cbiAgICBpZiAocGFyYW1Db3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWJ1ZygndG9vIG1hbnkgcGFyYW1ldGVycycpXG4gICAgICB0aHJvdyBjcmVhdGVFcnJvcig0MTMsICd0b28gbWFueSBwYXJhbWV0ZXJzJywge1xuICAgICAgICB0eXBlOiAncGFyYW1ldGVycy50b28ubWFueSdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdmFyIGFycmF5TGltaXQgPSBNYXRoLm1heCgxMDAsIHBhcmFtQ291bnQpXG5cbiAgICBkZWJ1ZygncGFyc2UgZXh0ZW5kZWQgdXJsZW5jb2RpbmcnKVxuICAgIHJldHVybiBwYXJzZShib2R5LCB7XG4gICAgICBhbGxvd1Byb3RvdHlwZXM6IHRydWUsXG4gICAgICBhcnJheUxpbWl0OiBhcnJheUxpbWl0LFxuICAgICAgZGVwdGg6IEluZmluaXR5LFxuICAgICAgcGFyYW1ldGVyTGltaXQ6IHBhcmFtZXRlckxpbWl0XG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgY2hhcnNldCBvZiBhIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHJlcVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZ2V0Q2hhcnNldCAocmVxKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIChjb250ZW50VHlwZS5wYXJzZShyZXEpLnBhcmFtZXRlcnMuY2hhcnNldCB8fCAnJykudG9Mb3dlckNhc2UoKVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG59XG5cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzLCBzdG9wcGluZyBvbmNlIGxpbWl0IHJlYWNoZWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYm9keVxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJhbWV0ZXJDb3VudCAoYm9keSwgbGltaXQpIHtcbiAgdmFyIGNvdW50ID0gMFxuICB2YXIgaW5kZXggPSAwXG5cbiAgd2hpbGUgKChpbmRleCA9IGJvZHkuaW5kZXhPZignJicsIGluZGV4KSkgIT09IC0xKSB7XG4gICAgY291bnQrK1xuICAgIGluZGV4KytcblxuICAgIGlmIChjb3VudCA9PT0gbGltaXQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY291bnRcbn1cblxuLyoqXG4gKiBHZXQgcGFyc2VyIGZvciBtb2R1bGUgbmFtZSBkeW5hbWljYWxseS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZXIgKG5hbWUpIHtcbiAgdmFyIG1vZCA9IHBhcnNlcnNbbmFtZV1cblxuICBpZiAobW9kICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbW9kLnBhcnNlXG4gIH1cblxuICAvLyB0aGlzIHVzZXMgYSBzd2l0Y2ggZm9yIHN0YXRpYyByZXF1aXJlIGFuYWx5c2lzXG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ3FzJzpcbiAgICAgIG1vZCA9IHJlcXVpcmUoJ3FzJylcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAncXVlcnlzdHJpbmcnOlxuICAgICAgbW9kID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKVxuICAgICAgYnJlYWtcbiAgfVxuXG4gIC8vIHN0b3JlIHRvIHByZXZlbnQgaW52b2tpbmcgcmVxdWlyZSgpXG4gIHBhcnNlcnNbbmFtZV0gPSBtb2RcblxuICByZXR1cm4gbW9kLnBhcnNlXG59XG5cbi8qKlxuICogR2V0IHRoZSBzaW1wbGUgcXVlcnkgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gc2ltcGxlcGFyc2VyIChvcHRpb25zKSB7XG4gIHZhciBwYXJhbWV0ZXJMaW1pdCA9IG9wdGlvbnMucGFyYW1ldGVyTGltaXQgIT09IHVuZGVmaW5lZFxuICAgID8gb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdFxuICAgIDogMTAwMFxuICB2YXIgcGFyc2UgPSBwYXJzZXIoJ3F1ZXJ5c3RyaW5nJylcblxuICBpZiAoaXNOYU4ocGFyYW1ldGVyTGltaXQpIHx8IHBhcmFtZXRlckxpbWl0IDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBwYXJhbWV0ZXJMaW1pdCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChpc0Zpbml0ZShwYXJhbWV0ZXJMaW1pdCkpIHtcbiAgICBwYXJhbWV0ZXJMaW1pdCA9IHBhcmFtZXRlckxpbWl0IHwgMFxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHF1ZXJ5cGFyc2UgKGJvZHkpIHtcbiAgICB2YXIgcGFyYW1Db3VudCA9IHBhcmFtZXRlckNvdW50KGJvZHksIHBhcmFtZXRlckxpbWl0KVxuXG4gICAgaWYgKHBhcmFtQ291bnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVidWcoJ3RvbyBtYW55IHBhcmFtZXRlcnMnKVxuICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoNDEzLCAndG9vIG1hbnkgcGFyYW1ldGVycycsIHtcbiAgICAgICAgdHlwZTogJ3BhcmFtZXRlcnMudG9vLm1hbnknXG4gICAgICB9KVxuICAgIH1cblxuICAgIGRlYnVnKCdwYXJzZSB1cmxlbmNvZGluZycpXG4gICAgcmV0dXJuIHBhcnNlKGJvZHksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7bWF4S2V5czogcGFyYW1ldGVyTGltaXR9KVxuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBzaW1wbGUgdHlwZSBjaGVja2VyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiB0eXBlQ2hlY2tlciAodHlwZSkge1xuICByZXR1cm4gZnVuY3Rpb24gY2hlY2tUeXBlIChyZXEpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0eXBlaXMocmVxLCB0eXBlKSlcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYm9keS1wYXJzZXIvbGliL3R5cGVzL3VybGVuY29kZWQuanNcbi8vIG1vZHVsZSBpZCA9IDExN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG5cbnZhciBhcnJheVByZWZpeEdlbmVyYXRvcnMgPSB7XG4gICAgYnJhY2tldHM6IGZ1bmN0aW9uIGJyYWNrZXRzKHByZWZpeCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgJ1tdJztcbiAgICB9LFxuICAgIGluZGljZXM6IGZ1bmN0aW9uIGluZGljZXMocHJlZml4LCBrZXkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcbiAgICAgICAgcmV0dXJuIHByZWZpeCArICdbJyArIGtleSArICddJztcbiAgICB9LFxuICAgIHJlcGVhdDogZnVuY3Rpb24gcmVwZWF0KHByZWZpeCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgIH1cbn07XG5cbnZhciB0b0lTTyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nO1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gICAgZGVsaW1pdGVyOiAnJicsXG4gICAgZW5jb2RlOiB0cnVlLFxuICAgIGVuY29kZXI6IHV0aWxzLmVuY29kZSxcbiAgICBlbmNvZGVWYWx1ZXNPbmx5OiBmYWxzZSxcbiAgICBzZXJpYWxpemVEYXRlOiBmdW5jdGlvbiBzZXJpYWxpemVEYXRlKGRhdGUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcbiAgICAgICAgcmV0dXJuIHRvSVNPLmNhbGwoZGF0ZSk7XG4gICAgfSxcbiAgICBza2lwTnVsbHM6IGZhbHNlLFxuICAgIHN0cmljdE51bGxIYW5kbGluZzogZmFsc2Vcbn07XG5cbnZhciBzdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkoIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG4gICAgb2JqZWN0LFxuICAgIHByZWZpeCxcbiAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgIHN0cmljdE51bGxIYW5kbGluZyxcbiAgICBza2lwTnVsbHMsXG4gICAgZW5jb2RlcixcbiAgICBmaWx0ZXIsXG4gICAgc29ydCxcbiAgICBhbGxvd0RvdHMsXG4gICAgc2VyaWFsaXplRGF0ZSxcbiAgICBmb3JtYXR0ZXIsXG4gICAgZW5jb2RlVmFsdWVzT25seVxuKSB7XG4gICAgdmFyIG9iaiA9IG9iamVjdDtcbiAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYmogPSBmaWx0ZXIocHJlZml4LCBvYmopO1xuICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBvYmogPSBzZXJpYWxpemVEYXRlKG9iaik7XG4gICAgfSBlbHNlIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHN0cmljdE51bGxIYW5kbGluZykge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZXIgJiYgIWVuY29kZVZhbHVlc09ubHkgPyBlbmNvZGVyKHByZWZpeCwgZGVmYXVsdHMuZW5jb2RlcikgOiBwcmVmaXg7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSAnJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG9iaiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIG9iaiA9PT0gJ2Jvb2xlYW4nIHx8IHV0aWxzLmlzQnVmZmVyKG9iaikpIHtcbiAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgIHZhciBrZXlWYWx1ZSA9IGVuY29kZVZhbHVlc09ubHkgPyBwcmVmaXggOiBlbmNvZGVyKHByZWZpeCwgZGVmYXVsdHMuZW5jb2Rlcik7XG4gICAgICAgICAgICByZXR1cm4gW2Zvcm1hdHRlcihrZXlWYWx1ZSkgKyAnPScgKyBmb3JtYXR0ZXIoZW5jb2RlcihvYmosIGRlZmF1bHRzLmVuY29kZXIpKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtmb3JtYXR0ZXIocHJlZml4KSArICc9JyArIGZvcm1hdHRlcihTdHJpbmcob2JqKSldO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cblxuICAgIHZhciBvYmpLZXlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcikpIHtcbiAgICAgICAgb2JqS2V5cyA9IGZpbHRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIG9iaktleXMgPSBzb3J0ID8ga2V5cy5zb3J0KHNvcnQpIDoga2V5cztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iaktleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IG9iaktleXNbaV07XG5cbiAgICAgICAgaWYgKHNraXBOdWxscyAmJiBvYmpba2V5XSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICBvYmpba2V5XSxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4KHByZWZpeCwga2V5KSxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgICAgICAgICAgICAgIHN0cmljdE51bGxIYW5kbGluZyxcbiAgICAgICAgICAgICAgICBza2lwTnVsbHMsXG4gICAgICAgICAgICAgICAgZW5jb2RlcixcbiAgICAgICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICAgICAgc29ydCxcbiAgICAgICAgICAgICAgICBhbGxvd0RvdHMsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXIsXG4gICAgICAgICAgICAgICAgZW5jb2RlVmFsdWVzT25seVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICBvYmpba2V5XSxcbiAgICAgICAgICAgICAgICBwcmVmaXggKyAoYWxsb3dEb3RzID8gJy4nICsga2V5IDogJ1snICsga2V5ICsgJ10nKSxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgICAgICAgICAgICAgIHN0cmljdE51bGxIYW5kbGluZyxcbiAgICAgICAgICAgICAgICBza2lwTnVsbHMsXG4gICAgICAgICAgICAgICAgZW5jb2RlcixcbiAgICAgICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICAgICAgc29ydCxcbiAgICAgICAgICAgICAgICBhbGxvd0RvdHMsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXIsXG4gICAgICAgICAgICAgICAgZW5jb2RlVmFsdWVzT25seVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBvcHRzKSB7XG4gICAgdmFyIG9iaiA9IG9iamVjdDtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdHMgPyB1dGlscy5hc3NpZ24oe30sIG9wdHMpIDoge307XG5cbiAgICBpZiAob3B0aW9ucy5lbmNvZGVyICE9PSBudWxsICYmIG9wdGlvbnMuZW5jb2RlciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zLmVuY29kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW5jb2RlciBoYXMgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgZGVsaW1pdGVyID0gdHlwZW9mIG9wdGlvbnMuZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzLmRlbGltaXRlciA6IG9wdGlvbnMuZGVsaW1pdGVyO1xuICAgIHZhciBzdHJpY3ROdWxsSGFuZGxpbmcgPSB0eXBlb2Ygb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nIDogZGVmYXVsdHMuc3RyaWN0TnVsbEhhbmRsaW5nO1xuICAgIHZhciBza2lwTnVsbHMgPSB0eXBlb2Ygb3B0aW9ucy5za2lwTnVsbHMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc2tpcE51bGxzIDogZGVmYXVsdHMuc2tpcE51bGxzO1xuICAgIHZhciBlbmNvZGUgPSB0eXBlb2Ygb3B0aW9ucy5lbmNvZGUgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuZW5jb2RlIDogZGVmYXVsdHMuZW5jb2RlO1xuICAgIHZhciBlbmNvZGVyID0gdHlwZW9mIG9wdGlvbnMuZW5jb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuZW5jb2RlciA6IGRlZmF1bHRzLmVuY29kZXI7XG4gICAgdmFyIHNvcnQgPSB0eXBlb2Ygb3B0aW9ucy5zb3J0ID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5zb3J0IDogbnVsbDtcbiAgICB2YXIgYWxsb3dEb3RzID0gdHlwZW9mIG9wdGlvbnMuYWxsb3dEb3RzID09PSAndW5kZWZpbmVkJyA/IGZhbHNlIDogb3B0aW9ucy5hbGxvd0RvdHM7XG4gICAgdmFyIHNlcmlhbGl6ZURhdGUgPSB0eXBlb2Ygb3B0aW9ucy5zZXJpYWxpemVEYXRlID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5zZXJpYWxpemVEYXRlIDogZGVmYXVsdHMuc2VyaWFsaXplRGF0ZTtcbiAgICB2YXIgZW5jb2RlVmFsdWVzT25seSA9IHR5cGVvZiBvcHRpb25zLmVuY29kZVZhbHVlc09ubHkgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuZW5jb2RlVmFsdWVzT25seSA6IGRlZmF1bHRzLmVuY29kZVZhbHVlc09ubHk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZvcm1hdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb3B0aW9ucy5mb3JtYXQgPSBmb3JtYXRzWydkZWZhdWx0J107XG4gICAgfSBlbHNlIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZvcm1hdHMuZm9ybWF0dGVycywgb3B0aW9ucy5mb3JtYXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZm9ybWF0IG9wdGlvbiBwcm92aWRlZC4nKTtcbiAgICB9XG4gICAgdmFyIGZvcm1hdHRlciA9IGZvcm1hdHMuZm9ybWF0dGVyc1tvcHRpb25zLmZvcm1hdF07XG4gICAgdmFyIG9iaktleXM7XG4gICAgdmFyIGZpbHRlcjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIG9iaiA9IGZpbHRlcignJywgb2JqKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5maWx0ZXIpKSB7XG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICBvYmpLZXlzID0gZmlsdGVyO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB2YXIgYXJyYXlGb3JtYXQ7XG4gICAgaWYgKG9wdGlvbnMuYXJyYXlGb3JtYXQgaW4gYXJyYXlQcmVmaXhHZW5lcmF0b3JzKSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gb3B0aW9ucy5hcnJheUZvcm1hdDtcbiAgICB9IGVsc2UgaWYgKCdpbmRpY2VzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gb3B0aW9ucy5pbmRpY2VzID8gJ2luZGljZXMnIDogJ3JlcGVhdCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlGb3JtYXQgPSAnaW5kaWNlcyc7XG4gICAgfVxuXG4gICAgdmFyIGdlbmVyYXRlQXJyYXlQcmVmaXggPSBhcnJheVByZWZpeEdlbmVyYXRvcnNbYXJyYXlGb3JtYXRdO1xuXG4gICAgaWYgKCFvYmpLZXlzKSB7XG4gICAgICAgIG9iaktleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIH1cblxuICAgIGlmIChzb3J0KSB7XG4gICAgICAgIG9iaktleXMuc29ydChzb3J0KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iaktleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IG9iaktleXNbaV07XG5cbiAgICAgICAgaWYgKHNraXBOdWxscyAmJiBvYmpba2V5XSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoc3RyaW5naWZ5KFxuICAgICAgICAgICAgb2JqW2tleV0sXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgICAgICAgICAgc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgICAgICAgICAgc2tpcE51bGxzLFxuICAgICAgICAgICAgZW5jb2RlID8gZW5jb2RlciA6IG51bGwsXG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICBzb3J0LFxuICAgICAgICAgICAgYWxsb3dEb3RzLFxuICAgICAgICAgICAgc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgICAgIGZvcm1hdHRlcixcbiAgICAgICAgICAgIGVuY29kZVZhbHVlc09ubHlcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgdmFyIGpvaW5lZCA9IGtleXMuam9pbihkZWxpbWl0ZXIpO1xuICAgIHZhciBwcmVmaXggPSBvcHRpb25zLmFkZFF1ZXJ5UHJlZml4ID09PSB0cnVlID8gJz8nIDogJyc7XG5cbiAgICByZXR1cm4gam9pbmVkLmxlbmd0aCA+IDAgPyBwcmVmaXggKyBqb2luZWQgOiAnJztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9xcy9saWIvc3RyaW5naWZ5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gICAgYWxsb3dEb3RzOiBmYWxzZSxcbiAgICBhbGxvd1Byb3RvdHlwZXM6IGZhbHNlLFxuICAgIGFycmF5TGltaXQ6IDIwLFxuICAgIGRlY29kZXI6IHV0aWxzLmRlY29kZSxcbiAgICBkZWxpbWl0ZXI6ICcmJyxcbiAgICBkZXB0aDogNSxcbiAgICBwYXJhbWV0ZXJMaW1pdDogMTAwMCxcbiAgICBwbGFpbk9iamVjdHM6IGZhbHNlLFxuICAgIHN0cmljdE51bGxIYW5kbGluZzogZmFsc2Vcbn07XG5cbnZhciBwYXJzZVZhbHVlcyA9IGZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmdWYWx1ZXMoc3RyLCBvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIHZhciBjbGVhblN0ciA9IG9wdGlvbnMuaWdub3JlUXVlcnlQcmVmaXggPyBzdHIucmVwbGFjZSgvXlxcPy8sICcnKSA6IHN0cjtcbiAgICB2YXIgbGltaXQgPSBvcHRpb25zLnBhcmFtZXRlckxpbWl0ID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IG9wdGlvbnMucGFyYW1ldGVyTGltaXQ7XG4gICAgdmFyIHBhcnRzID0gY2xlYW5TdHIuc3BsaXQob3B0aW9ucy5kZWxpbWl0ZXIsIGxpbWl0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcblxuICAgICAgICB2YXIgYnJhY2tldEVxdWFsc1BvcyA9IHBhcnQuaW5kZXhPZignXT0nKTtcbiAgICAgICAgdmFyIHBvcyA9IGJyYWNrZXRFcXVhbHNQb3MgPT09IC0xID8gcGFydC5pbmRleE9mKCc9JykgOiBicmFja2V0RXF1YWxzUG9zICsgMTtcblxuICAgICAgICB2YXIga2V5LCB2YWw7XG4gICAgICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICAgICAgICBrZXkgPSBvcHRpb25zLmRlY29kZXIocGFydCwgZGVmYXVsdHMuZGVjb2Rlcik7XG4gICAgICAgICAgICB2YWwgPSBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA/IG51bGwgOiAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleSA9IG9wdGlvbnMuZGVjb2RlcihwYXJ0LnNsaWNlKDAsIHBvcyksIGRlZmF1bHRzLmRlY29kZXIpO1xuICAgICAgICAgICAgdmFsID0gb3B0aW9ucy5kZWNvZGVyKHBhcnQuc2xpY2UocG9zICsgMSksIGRlZmF1bHRzLmRlY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gW10uY29uY2F0KG9ialtrZXldKS5jb25jYXQodmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBwYXJzZU9iamVjdCA9IGZ1bmN0aW9uIChjaGFpbiwgdmFsLCBvcHRpb25zKSB7XG4gICAgdmFyIGxlYWYgPSB2YWw7XG5cbiAgICBmb3IgKHZhciBpID0gY2hhaW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIG9iajtcbiAgICAgICAgdmFyIHJvb3QgPSBjaGFpbltpXTtcblxuICAgICAgICBpZiAocm9vdCA9PT0gJ1tdJykge1xuICAgICAgICAgICAgb2JqID0gW107XG4gICAgICAgICAgICBvYmogPSBvYmouY29uY2F0KGxlYWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqID0gb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gICAgICAgICAgICB2YXIgY2xlYW5Sb290ID0gcm9vdC5jaGFyQXQoMCkgPT09ICdbJyAmJiByb290LmNoYXJBdChyb290Lmxlbmd0aCAtIDEpID09PSAnXScgPyByb290LnNsaWNlKDEsIC0xKSA6IHJvb3Q7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludChjbGVhblJvb3QsIDEwKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhaXNOYU4oaW5kZXgpXG4gICAgICAgICAgICAgICAgJiYgcm9vdCAhPT0gY2xlYW5Sb290XG4gICAgICAgICAgICAgICAgJiYgU3RyaW5nKGluZGV4KSA9PT0gY2xlYW5Sb290XG4gICAgICAgICAgICAgICAgJiYgaW5kZXggPj0gMFxuICAgICAgICAgICAgICAgICYmIChvcHRpb25zLnBhcnNlQXJyYXlzICYmIGluZGV4IDw9IG9wdGlvbnMuYXJyYXlMaW1pdClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9iaiA9IFtdO1xuICAgICAgICAgICAgICAgIG9ialtpbmRleF0gPSBsZWFmO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmpbY2xlYW5Sb290XSA9IGxlYWY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZWFmID0gb2JqO1xuICAgIH1cblxuICAgIHJldHVybiBsZWFmO1xufTtcblxudmFyIHBhcnNlS2V5cyA9IGZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmdLZXlzKGdpdmVuS2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWdpdmVuS2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUcmFuc2Zvcm0gZG90IG5vdGF0aW9uIHRvIGJyYWNrZXQgbm90YXRpb25cbiAgICB2YXIga2V5ID0gb3B0aW9ucy5hbGxvd0RvdHMgPyBnaXZlbktleS5yZXBsYWNlKC9cXC4oW14uW10rKS9nLCAnWyQxXScpIDogZ2l2ZW5LZXk7XG5cbiAgICAvLyBUaGUgcmVnZXggY2h1bmtzXG5cbiAgICB2YXIgYnJhY2tldHMgPSAvKFxcW1teW1xcXV0qXSkvO1xuICAgIHZhciBjaGlsZCA9IC8oXFxbW15bXFxdXSpdKS9nO1xuXG4gICAgLy8gR2V0IHRoZSBwYXJlbnRcblxuICAgIHZhciBzZWdtZW50ID0gYnJhY2tldHMuZXhlYyhrZXkpO1xuICAgIHZhciBwYXJlbnQgPSBzZWdtZW50ID8ga2V5LnNsaWNlKDAsIHNlZ21lbnQuaW5kZXgpIDoga2V5O1xuXG4gICAgLy8gU3Rhc2ggdGhlIHBhcmVudCBpZiBpdCBleGlzdHNcblxuICAgIHZhciBrZXlzID0gW107XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICAvLyBJZiB3ZSBhcmVuJ3QgdXNpbmcgcGxhaW4gb2JqZWN0cywgb3B0aW9uYWxseSBwcmVmaXgga2V5c1xuICAgICAgICAvLyB0aGF0IHdvdWxkIG92ZXJ3cml0ZSBvYmplY3QgcHJvdG90eXBlIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKCFvcHRpb25zLnBsYWluT2JqZWN0cyAmJiBoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBwYXJlbnQpKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAga2V5cy5wdXNoKHBhcmVudCk7XG4gICAgfVxuXG4gICAgLy8gTG9vcCB0aHJvdWdoIGNoaWxkcmVuIGFwcGVuZGluZyB0byB0aGUgYXJyYXkgdW50aWwgd2UgaGl0IGRlcHRoXG5cbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKChzZWdtZW50ID0gY2hpbGQuZXhlYyhrZXkpKSAhPT0gbnVsbCAmJiBpIDwgb3B0aW9ucy5kZXB0aCkge1xuICAgICAgICBpICs9IDE7XG4gICAgICAgIGlmICghb3B0aW9ucy5wbGFpbk9iamVjdHMgJiYgaGFzLmNhbGwoT2JqZWN0LnByb3RvdHlwZSwgc2VnbWVudFsxXS5zbGljZSgxLCAtMSkpKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGtleXMucHVzaChzZWdtZW50WzFdKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSdzIGEgcmVtYWluZGVyLCBqdXN0IGFkZCB3aGF0ZXZlciBpcyBsZWZ0XG5cbiAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBrZXlzLnB1c2goJ1snICsga2V5LnNsaWNlKHNlZ21lbnQuaW5kZXgpICsgJ10nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VPYmplY3Qoa2V5cywgdmFsLCBvcHRpb25zKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0ciwgb3B0cykge1xuICAgIHZhciBvcHRpb25zID0gb3B0cyA/IHV0aWxzLmFzc2lnbih7fSwgb3B0cykgOiB7fTtcblxuICAgIGlmIChvcHRpb25zLmRlY29kZXIgIT09IG51bGwgJiYgb3B0aW9ucy5kZWNvZGVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdGlvbnMuZGVjb2RlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEZWNvZGVyIGhhcyB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIG9wdGlvbnMuaWdub3JlUXVlcnlQcmVmaXggPSBvcHRpb25zLmlnbm9yZVF1ZXJ5UHJlZml4ID09PSB0cnVlO1xuICAgIG9wdGlvbnMuZGVsaW1pdGVyID0gdHlwZW9mIG9wdGlvbnMuZGVsaW1pdGVyID09PSAnc3RyaW5nJyB8fCB1dGlscy5pc1JlZ0V4cChvcHRpb25zLmRlbGltaXRlcikgPyBvcHRpb25zLmRlbGltaXRlciA6IGRlZmF1bHRzLmRlbGltaXRlcjtcbiAgICBvcHRpb25zLmRlcHRoID0gdHlwZW9mIG9wdGlvbnMuZGVwdGggPT09ICdudW1iZXInID8gb3B0aW9ucy5kZXB0aCA6IGRlZmF1bHRzLmRlcHRoO1xuICAgIG9wdGlvbnMuYXJyYXlMaW1pdCA9IHR5cGVvZiBvcHRpb25zLmFycmF5TGltaXQgPT09ICdudW1iZXInID8gb3B0aW9ucy5hcnJheUxpbWl0IDogZGVmYXVsdHMuYXJyYXlMaW1pdDtcbiAgICBvcHRpb25zLnBhcnNlQXJyYXlzID0gb3B0aW9ucy5wYXJzZUFycmF5cyAhPT0gZmFsc2U7XG4gICAgb3B0aW9ucy5kZWNvZGVyID0gdHlwZW9mIG9wdGlvbnMuZGVjb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuZGVjb2RlciA6IGRlZmF1bHRzLmRlY29kZXI7XG4gICAgb3B0aW9ucy5hbGxvd0RvdHMgPSB0eXBlb2Ygb3B0aW9ucy5hbGxvd0RvdHMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuYWxsb3dEb3RzIDogZGVmYXVsdHMuYWxsb3dEb3RzO1xuICAgIG9wdGlvbnMucGxhaW5PYmplY3RzID0gdHlwZW9mIG9wdGlvbnMucGxhaW5PYmplY3RzID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnBsYWluT2JqZWN0cyA6IGRlZmF1bHRzLnBsYWluT2JqZWN0cztcbiAgICBvcHRpb25zLmFsbG93UHJvdG90eXBlcyA9IHR5cGVvZiBvcHRpb25zLmFsbG93UHJvdG90eXBlcyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMgOiBkZWZhdWx0cy5hbGxvd1Byb3RvdHlwZXM7XG4gICAgb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCA9IHR5cGVvZiBvcHRpb25zLnBhcmFtZXRlckxpbWl0ID09PSAnbnVtYmVyJyA/IG9wdGlvbnMucGFyYW1ldGVyTGltaXQgOiBkZWZhdWx0cy5wYXJhbWV0ZXJMaW1pdDtcbiAgICBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA9IHR5cGVvZiBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcgOiBkZWZhdWx0cy5zdHJpY3ROdWxsSGFuZGxpbmc7XG5cbiAgICBpZiAoc3RyID09PSAnJyB8fCBzdHIgPT09IG51bGwgfHwgdHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuICAgIH1cblxuICAgIHZhciB0ZW1wT2JqID0gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBwYXJzZVZhbHVlcyhzdHIsIG9wdGlvbnMpIDogc3RyO1xuICAgIHZhciBvYmogPSBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUga2V5cyBhbmQgc2V0dXAgdGhlIG5ldyBvYmplY3RcblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGVtcE9iaik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgbmV3T2JqID0gcGFyc2VLZXlzKGtleSwgdGVtcE9ialtrZXldLCBvcHRpb25zKTtcbiAgICAgICAgb2JqID0gdXRpbHMubWVyZ2Uob2JqLCBuZXdPYmosIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlscy5jb21wYWN0KG9iaik7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcXMvbGliL3BhcnNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBtZXJnZS1kZXNjcmlwdG9yc1xuICogQ29weXJpZ2h0KGMpIDIwMTQgSm9uYXRoYW4gT25nXG4gKiBDb3B5cmlnaHQoYykgMjAxNSBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZVxuXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcblxuLyoqXG4gKiBNZXJnZSB0aGUgcHJvcGVydHkgZGVzY3JpcHRvcnMgb2YgYHNyY2AgaW50byBgZGVzdGBcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGVzdCBPYmplY3QgdG8gYWRkIGRlc2NyaXB0b3JzIHRvXG4gKiBAcGFyYW0ge29iamVjdH0gc3JjIE9iamVjdCB0byBjbG9uZSBkZXNjcmlwdG9ycyBmcm9tXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWRlZmluZT10cnVlXSBSZWRlZmluZSBgZGVzdGAgcHJvcGVydGllcyB3aXRoIGBzcmNgIHByb3BlcnRpZXNcbiAqIEByZXR1cm5zIHtvYmplY3R9IFJlZmVyZW5jZSB0byBkZXN0XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbWVyZ2UoZGVzdCwgc3JjLCByZWRlZmluZSkge1xuICBpZiAoIWRlc3QpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBkZXN0IGlzIHJlcXVpcmVkJylcbiAgfVxuXG4gIGlmICghc3JjKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc3JjIGlzIHJlcXVpcmVkJylcbiAgfVxuXG4gIGlmIChyZWRlZmluZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gRGVmYXVsdCB0byB0cnVlXG4gICAgcmVkZWZpbmUgPSB0cnVlXG4gIH1cblxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzcmMpLmZvckVhY2goZnVuY3Rpb24gZm9yRWFjaE93blByb3BlcnR5TmFtZShuYW1lKSB7XG4gICAgaWYgKCFyZWRlZmluZSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRlc3QsIG5hbWUpKSB7XG4gICAgICAvLyBTa2lwIGRlc3JpcHRvclxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gQ29weSBkZXNjcmlwdG9yXG4gICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNyYywgbmFtZSlcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVzdCwgbmFtZSwgZGVzY3JpcHRvcilcbiAgfSlcblxuICByZXR1cm4gZGVzdFxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWVyZ2UtZGVzY3JpcHRvcnMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGV4cHJlc3NcbiAqIENvcHlyaWdodChjKSAyMDA5LTIwMTMgVEogSG9sb3dheWNodWtcbiAqIENvcHlyaWdodChjKSAyMDEzIFJvbWFuIFNodHlsbWFuXG4gKiBDb3B5cmlnaHQoYykgMjAxNC0yMDE1IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIGZpbmFsaGFuZGxlciA9IHJlcXVpcmUoJ2ZpbmFsaGFuZGxlcicpO1xudmFyIFJvdXRlciA9IHJlcXVpcmUoJy4vcm91dGVyJyk7XG52YXIgbWV0aG9kcyA9IHJlcXVpcmUoJ21ldGhvZHMnKTtcbnZhciBtaWRkbGV3YXJlID0gcmVxdWlyZSgnLi9taWRkbGV3YXJlL2luaXQnKTtcbnZhciBxdWVyeSA9IHJlcXVpcmUoJy4vbWlkZGxld2FyZS9xdWVyeScpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZXhwcmVzczphcHBsaWNhdGlvbicpO1xudmFyIFZpZXcgPSByZXF1aXJlKCcuL3ZpZXcnKTtcbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xudmFyIGNvbXBpbGVFVGFnID0gcmVxdWlyZSgnLi91dGlscycpLmNvbXBpbGVFVGFnO1xudmFyIGNvbXBpbGVRdWVyeVBhcnNlciA9IHJlcXVpcmUoJy4vdXRpbHMnKS5jb21waWxlUXVlcnlQYXJzZXI7XG52YXIgY29tcGlsZVRydXN0ID0gcmVxdWlyZSgnLi91dGlscycpLmNvbXBpbGVUcnVzdDtcbnZhciBkZXByZWNhdGUgPSByZXF1aXJlKCdkZXBkJykoJ2V4cHJlc3MnKTtcbnZhciBmbGF0dGVuID0gcmVxdWlyZSgnYXJyYXktZmxhdHRlbicpO1xudmFyIG1lcmdlID0gcmVxdWlyZSgndXRpbHMtbWVyZ2UnKTtcbnZhciByZXNvbHZlID0gcmVxdWlyZSgncGF0aCcpLnJlc29sdmU7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdzZXRwcm90b3R5cGVvZicpXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbi8qKlxuICogQXBwbGljYXRpb24gcHJvdG90eXBlLlxuICovXG5cbnZhciBhcHAgPSBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLyoqXG4gKiBWYXJpYWJsZSBmb3IgdHJ1c3QgcHJveHkgaW5oZXJpdGFuY2UgYmFjay1jb21wYXRcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIHRydXN0UHJveHlEZWZhdWx0U3ltYm9sID0gJ0BAc3ltYm9sOnRydXN0X3Byb3h5X2RlZmF1bHQnO1xuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIHNlcnZlci5cbiAqXG4gKiAgIC0gc2V0dXAgZGVmYXVsdCBjb25maWd1cmF0aW9uXG4gKiAgIC0gc2V0dXAgZGVmYXVsdCBtaWRkbGV3YXJlXG4gKiAgIC0gc2V0dXAgcm91dGUgcmVmbGVjdGlvbiBtZXRob2RzXG4gKlxuICogQHByaXZhdGVcbiAqL1xuXG5hcHAuaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHRoaXMuY2FjaGUgPSB7fTtcbiAgdGhpcy5lbmdpbmVzID0ge307XG4gIHRoaXMuc2V0dGluZ3MgPSB7fTtcblxuICB0aGlzLmRlZmF1bHRDb25maWd1cmF0aW9uKCk7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYXBwbGljYXRpb24gY29uZmlndXJhdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cblxuYXBwLmRlZmF1bHRDb25maWd1cmF0aW9uID0gZnVuY3Rpb24gZGVmYXVsdENvbmZpZ3VyYXRpb24oKSB7XG4gIHZhciBlbnYgPSBwcm9jZXNzLmVudi5OT0RFX0VOViB8fCAnZGV2ZWxvcG1lbnQnO1xuXG4gIC8vIGRlZmF1bHQgc2V0dGluZ3NcbiAgdGhpcy5lbmFibGUoJ3gtcG93ZXJlZC1ieScpO1xuICB0aGlzLnNldCgnZXRhZycsICd3ZWFrJyk7XG4gIHRoaXMuc2V0KCdlbnYnLCBlbnYpO1xuICB0aGlzLnNldCgncXVlcnkgcGFyc2VyJywgJ2V4dGVuZGVkJyk7XG4gIHRoaXMuc2V0KCdzdWJkb21haW4gb2Zmc2V0JywgMik7XG4gIHRoaXMuc2V0KCd0cnVzdCBwcm94eScsIGZhbHNlKTtcblxuICAvLyB0cnVzdCBwcm94eSBpbmhlcml0IGJhY2stY29tcGF0XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnNldHRpbmdzLCB0cnVzdFByb3h5RGVmYXVsdFN5bWJvbCwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICBkZWJ1ZygnYm9vdGluZyBpbiAlcyBtb2RlJywgZW52KTtcblxuICB0aGlzLm9uKCdtb3VudCcsIGZ1bmN0aW9uIG9ubW91bnQocGFyZW50KSB7XG4gICAgLy8gaW5oZXJpdCB0cnVzdCBwcm94eVxuICAgIGlmICh0aGlzLnNldHRpbmdzW3RydXN0UHJveHlEZWZhdWx0U3ltYm9sXSA9PT0gdHJ1ZVxuICAgICAgJiYgdHlwZW9mIHBhcmVudC5zZXR0aW5nc1sndHJ1c3QgcHJveHkgZm4nXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZGVsZXRlIHRoaXMuc2V0dGluZ3NbJ3RydXN0IHByb3h5J107XG4gICAgICBkZWxldGUgdGhpcy5zZXR0aW5nc1sndHJ1c3QgcHJveHkgZm4nXTtcbiAgICB9XG5cbiAgICAvLyBpbmhlcml0IHByb3Rvc1xuICAgIHNldFByb3RvdHlwZU9mKHRoaXMucmVxdWVzdCwgcGFyZW50LnJlcXVlc3QpXG4gICAgc2V0UHJvdG90eXBlT2YodGhpcy5yZXNwb25zZSwgcGFyZW50LnJlc3BvbnNlKVxuICAgIHNldFByb3RvdHlwZU9mKHRoaXMuZW5naW5lcywgcGFyZW50LmVuZ2luZXMpXG4gICAgc2V0UHJvdG90eXBlT2YodGhpcy5zZXR0aW5ncywgcGFyZW50LnNldHRpbmdzKVxuICB9KTtcblxuICAvLyBzZXR1cCBsb2NhbHNcbiAgdGhpcy5sb2NhbHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vIHRvcC1tb3N0IGFwcCBpcyBtb3VudGVkIGF0IC9cbiAgdGhpcy5tb3VudHBhdGggPSAnLyc7XG5cbiAgLy8gZGVmYXVsdCBsb2NhbHNcbiAgdGhpcy5sb2NhbHMuc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzO1xuXG4gIC8vIGRlZmF1bHQgY29uZmlndXJhdGlvblxuICB0aGlzLnNldCgndmlldycsIFZpZXcpO1xuICB0aGlzLnNldCgndmlld3MnLCByZXNvbHZlKCd2aWV3cycpKTtcbiAgdGhpcy5zZXQoJ2pzb25wIGNhbGxiYWNrIG5hbWUnLCAnY2FsbGJhY2snKTtcblxuICBpZiAoZW52ID09PSAncHJvZHVjdGlvbicpIHtcbiAgICB0aGlzLmVuYWJsZSgndmlldyBjYWNoZScpO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyb3V0ZXInLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXFwnYXBwLnJvdXRlclxcJyBpcyBkZXByZWNhdGVkIVxcblBsZWFzZSBzZWUgdGhlIDMueCB0byA0LnggbWlncmF0aW9uIGd1aWRlIGZvciBkZXRhaWxzIG9uIGhvdyB0byB1cGRhdGUgeW91ciBhcHAuJyk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogbGF6aWx5IGFkZHMgdGhlIGJhc2Ugcm91dGVyIGlmIGl0IGhhcyBub3QgeWV0IGJlZW4gYWRkZWQuXG4gKlxuICogV2UgY2Fubm90IGFkZCB0aGUgYmFzZSByb3V0ZXIgaW4gdGhlIGRlZmF1bHRDb25maWd1cmF0aW9uIGJlY2F1c2VcbiAqIGl0IHJlYWRzIGFwcCBzZXR0aW5ncyB3aGljaCBtaWdodCBiZSBzZXQgYWZ0ZXIgdGhhdCBoYXMgcnVuLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmFwcC5sYXp5cm91dGVyID0gZnVuY3Rpb24gbGF6eXJvdXRlcigpIHtcbiAgaWYgKCF0aGlzLl9yb3V0ZXIpIHtcbiAgICB0aGlzLl9yb3V0ZXIgPSBuZXcgUm91dGVyKHtcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHRoaXMuZW5hYmxlZCgnY2FzZSBzZW5zaXRpdmUgcm91dGluZycpLFxuICAgICAgc3RyaWN0OiB0aGlzLmVuYWJsZWQoJ3N0cmljdCByb3V0aW5nJylcbiAgICB9KTtcblxuICAgIHRoaXMuX3JvdXRlci51c2UocXVlcnkodGhpcy5nZXQoJ3F1ZXJ5IHBhcnNlciBmbicpKSk7XG4gICAgdGhpcy5fcm91dGVyLnVzZShtaWRkbGV3YXJlLmluaXQodGhpcykpO1xuICB9XG59O1xuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxLCByZXMgcGFpciBpbnRvIHRoZSBhcHBsaWNhdGlvbi4gU3RhcnRzIHBpcGVsaW5lIHByb2Nlc3NpbmcuXG4gKlxuICogSWYgbm8gY2FsbGJhY2sgaXMgcHJvdmlkZWQsIHRoZW4gZGVmYXVsdCBlcnJvciBoYW5kbGVycyB3aWxsIHJlc3BvbmRcbiAqIGluIHRoZSBldmVudCBvZiBhbiBlcnJvciBidWJibGluZyB0aHJvdWdoIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmFwcC5oYW5kbGUgPSBmdW5jdGlvbiBoYW5kbGUocmVxLCByZXMsIGNhbGxiYWNrKSB7XG4gIHZhciByb3V0ZXIgPSB0aGlzLl9yb3V0ZXI7XG5cbiAgLy8gZmluYWwgaGFuZGxlclxuICB2YXIgZG9uZSA9IGNhbGxiYWNrIHx8IGZpbmFsaGFuZGxlcihyZXEsIHJlcywge1xuICAgIGVudjogdGhpcy5nZXQoJ2VudicpLFxuICAgIG9uZXJyb3I6IGxvZ2Vycm9yLmJpbmQodGhpcylcbiAgfSk7XG5cbiAgLy8gbm8gcm91dGVzXG4gIGlmICghcm91dGVyKSB7XG4gICAgZGVidWcoJ25vIHJvdXRlcyBkZWZpbmVkIG9uIGFwcCcpO1xuICAgIGRvbmUoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICByb3V0ZXIuaGFuZGxlKHJlcSwgcmVzLCBkb25lKTtcbn07XG5cbi8qKlxuICogUHJveHkgYFJvdXRlciN1c2UoKWAgdG8gYWRkIG1pZGRsZXdhcmUgdG8gdGhlIGFwcCByb3V0ZXIuXG4gKiBTZWUgUm91dGVyI3VzZSgpIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuXG4gKlxuICogSWYgdGhlIF9mbl8gcGFyYW1ldGVyIGlzIGFuIGV4cHJlc3MgYXBwLCB0aGVuIGl0IHdpbGwgYmVcbiAqIG1vdW50ZWQgYXQgdGhlIF9yb3V0ZV8gc3BlY2lmaWVkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG5hcHAudXNlID0gZnVuY3Rpb24gdXNlKGZuKSB7XG4gIHZhciBvZmZzZXQgPSAwO1xuICB2YXIgcGF0aCA9ICcvJztcblxuICAvLyBkZWZhdWx0IHBhdGggdG8gJy8nXG4gIC8vIGRpc2FtYmlndWF0ZSBhcHAudXNlKFtmbl0pXG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgYXJnID0gZm47XG5cbiAgICB3aGlsZSAoQXJyYXkuaXNBcnJheShhcmcpICYmIGFyZy5sZW5ndGggIT09IDApIHtcbiAgICAgIGFyZyA9IGFyZ1swXTtcbiAgICB9XG5cbiAgICAvLyBmaXJzdCBhcmcgaXMgdGhlIHBhdGhcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb2Zmc2V0ID0gMTtcbiAgICAgIHBhdGggPSBmbjtcbiAgICB9XG4gIH1cblxuICB2YXIgZm5zID0gZmxhdHRlbihzbGljZS5jYWxsKGFyZ3VtZW50cywgb2Zmc2V0KSk7XG5cbiAgaWYgKGZucy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcHAudXNlKCkgcmVxdWlyZXMgYSBtaWRkbGV3YXJlIGZ1bmN0aW9uJylcbiAgfVxuXG4gIC8vIHNldHVwIHJvdXRlclxuICB0aGlzLmxhenlyb3V0ZXIoKTtcbiAgdmFyIHJvdXRlciA9IHRoaXMuX3JvdXRlcjtcblxuICBmbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAvLyBub24tZXhwcmVzcyBhcHBcbiAgICBpZiAoIWZuIHx8ICFmbi5oYW5kbGUgfHwgIWZuLnNldCkge1xuICAgICAgcmV0dXJuIHJvdXRlci51c2UocGF0aCwgZm4pO1xuICAgIH1cblxuICAgIGRlYnVnKCcudXNlIGFwcCB1bmRlciAlcycsIHBhdGgpO1xuICAgIGZuLm1vdW50cGF0aCA9IHBhdGg7XG4gICAgZm4ucGFyZW50ID0gdGhpcztcblxuICAgIC8vIHJlc3RvcmUgLmFwcCBwcm9wZXJ0eSBvbiByZXEgYW5kIHJlc1xuICAgIHJvdXRlci51c2UocGF0aCwgZnVuY3Rpb24gbW91bnRlZF9hcHAocmVxLCByZXMsIG5leHQpIHtcbiAgICAgIHZhciBvcmlnID0gcmVxLmFwcDtcbiAgICAgIGZuLmhhbmRsZShyZXEsIHJlcywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBzZXRQcm90b3R5cGVPZihyZXEsIG9yaWcucmVxdWVzdClcbiAgICAgICAgc2V0UHJvdG90eXBlT2YocmVzLCBvcmlnLnJlc3BvbnNlKVxuICAgICAgICBuZXh0KGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIG1vdW50ZWQgYW4gYXBwXG4gICAgZm4uZW1pdCgnbW91bnQnLCB0aGlzKTtcbiAgfSwgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFByb3h5IHRvIHRoZSBhcHAgYFJvdXRlciNyb3V0ZSgpYFxuICogUmV0dXJucyBhIG5ldyBgUm91dGVgIGluc3RhbmNlIGZvciB0aGUgX3BhdGhfLlxuICpcbiAqIFJvdXRlcyBhcmUgaXNvbGF0ZWQgbWlkZGxld2FyZSBzdGFja3MgZm9yIHNwZWNpZmljIHBhdGhzLlxuICogU2VlIHRoZSBSb3V0ZSBhcGkgZG9jcyBmb3IgZGV0YWlscy5cbiAqXG4gKiBAcHVibGljXG4gKi9cblxuYXBwLnJvdXRlID0gZnVuY3Rpb24gcm91dGUocGF0aCkge1xuICB0aGlzLmxhenlyb3V0ZXIoKTtcbiAgcmV0dXJuIHRoaXMuX3JvdXRlci5yb3V0ZShwYXRoKTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgdGhlIGdpdmVuIHRlbXBsYXRlIGVuZ2luZSBjYWxsYmFjayBgZm5gXG4gKiBhcyBgZXh0YC5cbiAqXG4gKiBCeSBkZWZhdWx0IHdpbGwgYHJlcXVpcmUoKWAgdGhlIGVuZ2luZSBiYXNlZCBvbiB0aGVcbiAqIGZpbGUgZXh0ZW5zaW9uLiBGb3IgZXhhbXBsZSBpZiB5b3UgdHJ5IHRvIHJlbmRlclxuICogYSBcImZvby5lanNcIiBmaWxlIEV4cHJlc3Mgd2lsbCBpbnZva2UgdGhlIGZvbGxvd2luZyBpbnRlcm5hbGx5OlxuICpcbiAqICAgICBhcHAuZW5naW5lKCdlanMnLCByZXF1aXJlKCdlanMnKS5fX2V4cHJlc3MpO1xuICpcbiAqIEZvciBlbmdpbmVzIHRoYXQgZG8gbm90IHByb3ZpZGUgYC5fX2V4cHJlc3NgIG91dCBvZiB0aGUgYm94LFxuICogb3IgaWYgeW91IHdpc2ggdG8gXCJtYXBcIiBhIGRpZmZlcmVudCBleHRlbnNpb24gdG8gdGhlIHRlbXBsYXRlIGVuZ2luZVxuICogeW91IG1heSB1c2UgdGhpcyBtZXRob2QuIEZvciBleGFtcGxlIG1hcHBpbmcgdGhlIEVKUyB0ZW1wbGF0ZSBlbmdpbmUgdG9cbiAqIFwiLmh0bWxcIiBmaWxlczpcbiAqXG4gKiAgICAgYXBwLmVuZ2luZSgnaHRtbCcsIHJlcXVpcmUoJ2VqcycpLnJlbmRlckZpbGUpO1xuICpcbiAqIEluIHRoaXMgY2FzZSBFSlMgcHJvdmlkZXMgYSBgLnJlbmRlckZpbGUoKWAgbWV0aG9kIHdpdGhcbiAqIHRoZSBzYW1lIHNpZ25hdHVyZSB0aGF0IEV4cHJlc3MgZXhwZWN0czogYChwYXRoLCBvcHRpb25zLCBjYWxsYmFjaylgLFxuICogdGhvdWdoIG5vdGUgdGhhdCBpdCBhbGlhc2VzIHRoaXMgbWV0aG9kIGFzIGBlanMuX19leHByZXNzYCBpbnRlcm5hbGx5XG4gKiBzbyBpZiB5b3UncmUgdXNpbmcgXCIuZWpzXCIgZXh0ZW5zaW9ucyB5b3UgZG9udCBuZWVkIHRvIGRvIGFueXRoaW5nLlxuICpcbiAqIFNvbWUgdGVtcGxhdGUgZW5naW5lcyBkbyBub3QgZm9sbG93IHRoaXMgY29udmVudGlvbiwgdGhlXG4gKiBbQ29uc29saWRhdGUuanNdKGh0dHBzOi8vZ2l0aHViLmNvbS90ai9jb25zb2xpZGF0ZS5qcylcbiAqIGxpYnJhcnkgd2FzIGNyZWF0ZWQgdG8gbWFwIGFsbCBvZiBub2RlJ3MgcG9wdWxhciB0ZW1wbGF0ZVxuICogZW5naW5lcyB0byBmb2xsb3cgdGhpcyBjb252ZW50aW9uLCB0aHVzIGFsbG93aW5nIHRoZW0gdG9cbiAqIHdvcmsgc2VhbWxlc3NseSB3aXRoaW4gRXhwcmVzcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXh0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7YXBwfSBmb3IgY2hhaW5pbmdcbiAqIEBwdWJsaWNcbiAqL1xuXG5hcHAuZW5naW5lID0gZnVuY3Rpb24gZW5naW5lKGV4dCwgZm4pIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGJhY2sgZnVuY3Rpb24gcmVxdWlyZWQnKTtcbiAgfVxuXG4gIC8vIGdldCBmaWxlIGV4dGVuc2lvblxuICB2YXIgZXh0ZW5zaW9uID0gZXh0WzBdICE9PSAnLidcbiAgICA/ICcuJyArIGV4dFxuICAgIDogZXh0O1xuXG4gIC8vIHN0b3JlIGVuZ2luZVxuICB0aGlzLmVuZ2luZXNbZXh0ZW5zaW9uXSA9IGZuO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQcm94eSB0byBgUm91dGVyI3BhcmFtKClgIHdpdGggb25lIGFkZGVkIGFwaSBmZWF0dXJlLiBUaGUgX25hbWVfIHBhcmFtZXRlclxuICogY2FuIGJlIGFuIGFycmF5IG9mIG5hbWVzLlxuICpcbiAqIFNlZSB0aGUgUm91dGVyI3BhcmFtKCkgZG9jcyBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7YXBwfSBmb3IgY2hhaW5pbmdcbiAqIEBwdWJsaWNcbiAqL1xuXG5hcHAucGFyYW0gPSBmdW5jdGlvbiBwYXJhbShuYW1lLCBmbikge1xuICB0aGlzLmxhenlyb3V0ZXIoKTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5wYXJhbShuYW1lW2ldLCBmbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aGlzLl9yb3V0ZXIucGFyYW0obmFtZSwgZm4pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBc3NpZ24gYHNldHRpbmdgIHRvIGB2YWxgLCBvciByZXR1cm4gYHNldHRpbmdgJ3MgdmFsdWUuXG4gKlxuICogICAgYXBwLnNldCgnZm9vJywgJ2JhcicpO1xuICogICAgYXBwLnNldCgnZm9vJyk7XG4gKiAgICAvLyA9PiBcImJhclwiXG4gKlxuICogTW91bnRlZCBzZXJ2ZXJzIGluaGVyaXQgdGhlaXIgcGFyZW50IHNlcnZlcidzIHNldHRpbmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZXR0aW5nXG4gKiBAcGFyYW0geyp9IFt2YWxdXG4gKiBAcmV0dXJuIHtTZXJ2ZXJ9IGZvciBjaGFpbmluZ1xuICogQHB1YmxpY1xuICovXG5cbmFwcC5zZXQgPSBmdW5jdGlvbiBzZXQoc2V0dGluZywgdmFsKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gYXBwLmdldChzZXR0aW5nKVxuICAgIHJldHVybiB0aGlzLnNldHRpbmdzW3NldHRpbmddO1xuICB9XG5cbiAgZGVidWcoJ3NldCBcIiVzXCIgdG8gJW8nLCBzZXR0aW5nLCB2YWwpO1xuXG4gIC8vIHNldCB2YWx1ZVxuICB0aGlzLnNldHRpbmdzW3NldHRpbmddID0gdmFsO1xuXG4gIC8vIHRyaWdnZXIgbWF0Y2hlZCBzZXR0aW5nc1xuICBzd2l0Y2ggKHNldHRpbmcpIHtcbiAgICBjYXNlICdldGFnJzpcbiAgICAgIHRoaXMuc2V0KCdldGFnIGZuJywgY29tcGlsZUVUYWcodmFsKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdxdWVyeSBwYXJzZXInOlxuICAgICAgdGhpcy5zZXQoJ3F1ZXJ5IHBhcnNlciBmbicsIGNvbXBpbGVRdWVyeVBhcnNlcih2YWwpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RydXN0IHByb3h5JzpcbiAgICAgIHRoaXMuc2V0KCd0cnVzdCBwcm94eSBmbicsIGNvbXBpbGVUcnVzdCh2YWwpKTtcblxuICAgICAgLy8gdHJ1c3QgcHJveHkgaW5oZXJpdCBiYWNrLWNvbXBhdFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuc2V0dGluZ3MsIHRydXN0UHJveHlEZWZhdWx0U3ltYm9sLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBhcHAncyBhYnNvbHV0ZSBwYXRobmFtZVxuICogYmFzZWQgb24gdGhlIHBhcmVudChzKSB0aGF0IGhhdmVcbiAqIG1vdW50ZWQgaXQuXG4gKlxuICogRm9yIGV4YW1wbGUgaWYgdGhlIGFwcGxpY2F0aW9uIHdhc1xuICogbW91bnRlZCBhcyBcIi9hZG1pblwiLCB3aGljaCBpdHNlbGZcbiAqIHdhcyBtb3VudGVkIGFzIFwiL2Jsb2dcIiB0aGVuIHRoZVxuICogcmV0dXJuIHZhbHVlIHdvdWxkIGJlIFwiL2Jsb2cvYWRtaW5cIi5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cbmFwcC5wYXRoID0gZnVuY3Rpb24gcGF0aCgpIHtcbiAgcmV0dXJuIHRoaXMucGFyZW50XG4gICAgPyB0aGlzLnBhcmVudC5wYXRoKCkgKyB0aGlzLm1vdW50cGF0aFxuICAgIDogJyc7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGBzZXR0aW5nYCBpcyBlbmFibGVkICh0cnV0aHkpLlxuICpcbiAqICAgIGFwcC5lbmFibGVkKCdmb28nKVxuICogICAgLy8gPT4gZmFsc2VcbiAqXG4gKiAgICBhcHAuZW5hYmxlKCdmb28nKVxuICogICAgYXBwLmVuYWJsZWQoJ2ZvbycpXG4gKiAgICAvLyA9PiB0cnVlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAcHVibGljXG4gKi9cblxuYXBwLmVuYWJsZWQgPSBmdW5jdGlvbiBlbmFibGVkKHNldHRpbmcpIHtcbiAgcmV0dXJuIEJvb2xlYW4odGhpcy5zZXQoc2V0dGluZykpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgc2V0dGluZ2AgaXMgZGlzYWJsZWQuXG4gKlxuICogICAgYXBwLmRpc2FibGVkKCdmb28nKVxuICogICAgLy8gPT4gdHJ1ZVxuICpcbiAqICAgIGFwcC5lbmFibGUoJ2ZvbycpXG4gKiAgICBhcHAuZGlzYWJsZWQoJ2ZvbycpXG4gKiAgICAvLyA9PiBmYWxzZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZXR0aW5nXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHB1YmxpY1xuICovXG5cbmFwcC5kaXNhYmxlZCA9IGZ1bmN0aW9uIGRpc2FibGVkKHNldHRpbmcpIHtcbiAgcmV0dXJuICF0aGlzLnNldChzZXR0aW5nKTtcbn07XG5cbi8qKlxuICogRW5hYmxlIGBzZXR0aW5nYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2V0dGluZ1xuICogQHJldHVybiB7YXBwfSBmb3IgY2hhaW5pbmdcbiAqIEBwdWJsaWNcbiAqL1xuXG5hcHAuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKHNldHRpbmcpIHtcbiAgcmV0dXJuIHRoaXMuc2V0KHNldHRpbmcsIHRydWUpO1xufTtcblxuLyoqXG4gKiBEaXNhYmxlIGBzZXR0aW5nYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2V0dGluZ1xuICogQHJldHVybiB7YXBwfSBmb3IgY2hhaW5pbmdcbiAqIEBwdWJsaWNcbiAqL1xuXG5hcHAuZGlzYWJsZSA9IGZ1bmN0aW9uIGRpc2FibGUoc2V0dGluZykge1xuICByZXR1cm4gdGhpcy5zZXQoc2V0dGluZywgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBEZWxlZ2F0ZSBgLlZFUkIoLi4uKWAgY2FsbHMgdG8gYHJvdXRlci5WRVJCKC4uLilgLlxuICovXG5cbm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbihtZXRob2Qpe1xuICBhcHBbbWV0aG9kXSA9IGZ1bmN0aW9uKHBhdGgpe1xuICAgIGlmIChtZXRob2QgPT09ICdnZXQnICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIGFwcC5nZXQoc2V0dGluZylcbiAgICAgIHJldHVybiB0aGlzLnNldChwYXRoKTtcbiAgICB9XG5cbiAgICB0aGlzLmxhenlyb3V0ZXIoKTtcblxuICAgIHZhciByb3V0ZSA9IHRoaXMuX3JvdXRlci5yb3V0ZShwYXRoKTtcbiAgICByb3V0ZVttZXRob2RdLmFwcGx5KHJvdXRlLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xufSk7XG5cbi8qKlxuICogU3BlY2lhbC1jYXNlZCBcImFsbFwiIG1ldGhvZCwgYXBwbHlpbmcgdGhlIGdpdmVuIHJvdXRlIGBwYXRoYCxcbiAqIG1pZGRsZXdhcmUsIGFuZCBjYWxsYmFjayB0byBfZXZlcnlfIEhUVFAgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSAuLi5cbiAqIEByZXR1cm4ge2FwcH0gZm9yIGNoYWluaW5nXG4gKiBAcHVibGljXG4gKi9cblxuYXBwLmFsbCA9IGZ1bmN0aW9uIGFsbChwYXRoKSB7XG4gIHRoaXMubGF6eXJvdXRlcigpO1xuXG4gIHZhciByb3V0ZSA9IHRoaXMuX3JvdXRlci5yb3V0ZShwYXRoKTtcbiAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgcm91dGVbbWV0aG9kc1tpXV0uYXBwbHkocm91dGUsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBkZWwgLT4gZGVsZXRlIGFsaWFzXG5cbmFwcC5kZWwgPSBkZXByZWNhdGUuZnVuY3Rpb24oYXBwLmRlbGV0ZSwgJ2FwcC5kZWw6IFVzZSBhcHAuZGVsZXRlIGluc3RlYWQnKTtcblxuLyoqXG4gKiBSZW5kZXIgdGhlIGdpdmVuIHZpZXcgYG5hbWVgIG5hbWUgd2l0aCBgb3B0aW9uc2BcbiAqIGFuZCBhIGNhbGxiYWNrIGFjY2VwdGluZyBhbiBlcnJvciBhbmQgdGhlXG4gKiByZW5kZXJlZCB0ZW1wbGF0ZSBzdHJpbmcuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICBhcHAucmVuZGVyKCdlbWFpbCcsIHsgbmFtZTogJ1RvYmknIH0sIGZ1bmN0aW9uKGVyciwgaHRtbCl7XG4gKiAgICAgIC8vIC4uLlxuICogICAgfSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IG9wdGlvbnMgb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcHVibGljXG4gKi9cblxuYXBwLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihuYW1lLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlO1xuICB2YXIgZG9uZSA9IGNhbGxiYWNrO1xuICB2YXIgZW5naW5lcyA9IHRoaXMuZW5naW5lcztcbiAgdmFyIG9wdHMgPSBvcHRpb25zO1xuICB2YXIgcmVuZGVyT3B0aW9ucyA9IHt9O1xuICB2YXIgdmlldztcblxuICAvLyBzdXBwb3J0IGNhbGxiYWNrIGZ1bmN0aW9uIGFzIHNlY29uZCBhcmdcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZG9uZSA9IG9wdGlvbnM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgLy8gbWVyZ2UgYXBwLmxvY2Fsc1xuICBtZXJnZShyZW5kZXJPcHRpb25zLCB0aGlzLmxvY2Fscyk7XG5cbiAgLy8gbWVyZ2Ugb3B0aW9ucy5fbG9jYWxzXG4gIGlmIChvcHRzLl9sb2NhbHMpIHtcbiAgICBtZXJnZShyZW5kZXJPcHRpb25zLCBvcHRzLl9sb2NhbHMpO1xuICB9XG5cbiAgLy8gbWVyZ2Ugb3B0aW9uc1xuICBtZXJnZShyZW5kZXJPcHRpb25zLCBvcHRzKTtcblxuICAvLyBzZXQgLmNhY2hlIHVubGVzcyBleHBsaWNpdGx5IHByb3ZpZGVkXG4gIGlmIChyZW5kZXJPcHRpb25zLmNhY2hlID09IG51bGwpIHtcbiAgICByZW5kZXJPcHRpb25zLmNhY2hlID0gdGhpcy5lbmFibGVkKCd2aWV3IGNhY2hlJyk7XG4gIH1cblxuICAvLyBwcmltZWQgY2FjaGVcbiAgaWYgKHJlbmRlck9wdGlvbnMuY2FjaGUpIHtcbiAgICB2aWV3ID0gY2FjaGVbbmFtZV07XG4gIH1cblxuICAvLyB2aWV3XG4gIGlmICghdmlldykge1xuICAgIHZhciBWaWV3ID0gdGhpcy5nZXQoJ3ZpZXcnKTtcblxuICAgIHZpZXcgPSBuZXcgVmlldyhuYW1lLCB7XG4gICAgICBkZWZhdWx0RW5naW5lOiB0aGlzLmdldCgndmlldyBlbmdpbmUnKSxcbiAgICAgIHJvb3Q6IHRoaXMuZ2V0KCd2aWV3cycpLFxuICAgICAgZW5naW5lczogZW5naW5lc1xuICAgIH0pO1xuXG4gICAgaWYgKCF2aWV3LnBhdGgpIHtcbiAgICAgIHZhciBkaXJzID0gQXJyYXkuaXNBcnJheSh2aWV3LnJvb3QpICYmIHZpZXcucm9vdC5sZW5ndGggPiAxXG4gICAgICAgID8gJ2RpcmVjdG9yaWVzIFwiJyArIHZpZXcucm9vdC5zbGljZSgwLCAtMSkuam9pbignXCIsIFwiJykgKyAnXCIgb3IgXCInICsgdmlldy5yb290W3ZpZXcucm9vdC5sZW5ndGggLSAxXSArICdcIidcbiAgICAgICAgOiAnZGlyZWN0b3J5IFwiJyArIHZpZXcucm9vdCArICdcIidcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb29rdXAgdmlldyBcIicgKyBuYW1lICsgJ1wiIGluIHZpZXdzICcgKyBkaXJzKTtcbiAgICAgIGVyci52aWV3ID0gdmlldztcbiAgICAgIHJldHVybiBkb25lKGVycik7XG4gICAgfVxuXG4gICAgLy8gcHJpbWUgdGhlIGNhY2hlXG4gICAgaWYgKHJlbmRlck9wdGlvbnMuY2FjaGUpIHtcbiAgICAgIGNhY2hlW25hbWVdID0gdmlldztcbiAgICB9XG4gIH1cblxuICAvLyByZW5kZXJcbiAgdHJ5UmVuZGVyKHZpZXcsIHJlbmRlck9wdGlvbnMsIGRvbmUpO1xufTtcblxuLyoqXG4gKiBMaXN0ZW4gZm9yIGNvbm5lY3Rpb25zLlxuICpcbiAqIEEgbm9kZSBgaHR0cC5TZXJ2ZXJgIGlzIHJldHVybmVkLCB3aXRoIHRoaXNcbiAqIGFwcGxpY2F0aW9uICh3aGljaCBpcyBhIGBGdW5jdGlvbmApIGFzIGl0c1xuICogY2FsbGJhY2suIElmIHlvdSB3aXNoIHRvIGNyZWF0ZSBib3RoIGFuIEhUVFBcbiAqIGFuZCBIVFRQUyBzZXJ2ZXIgeW91IG1heSBkbyBzbyB3aXRoIHRoZSBcImh0dHBcIlxuICogYW5kIFwiaHR0cHNcIiBtb2R1bGVzIGFzIHNob3duIGhlcmU6XG4gKlxuICogICAgdmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJylcbiAqICAgICAgLCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJylcbiAqICAgICAgLCBleHByZXNzID0gcmVxdWlyZSgnZXhwcmVzcycpXG4gKiAgICAgICwgYXBwID0gZXhwcmVzcygpO1xuICpcbiAqICAgIGh0dHAuY3JlYXRlU2VydmVyKGFwcCkubGlzdGVuKDgwKTtcbiAqICAgIGh0dHBzLmNyZWF0ZVNlcnZlcih7IC4uLiB9LCBhcHApLmxpc3Rlbig0NDMpO1xuICpcbiAqIEByZXR1cm4ge2h0dHAuU2VydmVyfVxuICogQHB1YmxpY1xuICovXG5cbmFwcC5saXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4oKSB7XG4gIHZhciBzZXJ2ZXIgPSBodHRwLmNyZWF0ZVNlcnZlcih0aGlzKTtcbiAgcmV0dXJuIHNlcnZlci5saXN0ZW4uYXBwbHkoc2VydmVyLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBMb2cgZXJyb3IgdXNpbmcgY29uc29sZS5lcnJvci5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9nZXJyb3IoZXJyKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICh0aGlzLmdldCgnZW52JykgIT09ICd0ZXN0JykgY29uc29sZS5lcnJvcihlcnIuc3RhY2sgfHwgZXJyLnRvU3RyaW5nKCkpO1xufVxuXG4vKipcbiAqIFRyeSByZW5kZXJpbmcgYSB2aWV3LlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiB0cnlSZW5kZXIodmlldywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdHJ5IHtcbiAgICB2aWV3LnJlbmRlcihvcHRpb25zLCBjYWxsYmFjayk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbGxiYWNrKGVycik7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2V4cHJlc3MvbGliL2FwcGxpY2F0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBmaW5hbGhhbmRsZXJcbiAqIENvcHlyaWdodChjKSAyMDE0LTIwMTcgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2ZpbmFsaGFuZGxlcicpXG52YXIgZW5jb2RlVXJsID0gcmVxdWlyZSgnZW5jb2RldXJsJylcbnZhciBlc2NhcGVIdG1sID0gcmVxdWlyZSgnZXNjYXBlLWh0bWwnKVxudmFyIG9uRmluaXNoZWQgPSByZXF1aXJlKCdvbi1maW5pc2hlZCcpXG52YXIgcGFyc2VVcmwgPSByZXF1aXJlKCdwYXJzZXVybCcpXG52YXIgc3RhdHVzZXMgPSByZXF1aXJlKCdzdGF0dXNlcycpXG52YXIgdW5waXBlID0gcmVxdWlyZSgndW5waXBlJylcblxuLyoqXG4gKiBNb2R1bGUgdmFyaWFibGVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgRE9VQkxFX1NQQUNFX1JFR0VYUCA9IC9cXHgyMHsyfS9nXG52YXIgTkVXTElORV9SRUdFWFAgPSAvXFxuL2dcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnZhciBkZWZlciA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbidcbiAgPyBzZXRJbW1lZGlhdGVcbiAgOiBmdW5jdGlvbiAoZm4pIHsgcHJvY2Vzcy5uZXh0VGljayhmbi5iaW5kLmFwcGx5KGZuLCBhcmd1bWVudHMpKSB9XG52YXIgaXNGaW5pc2hlZCA9IG9uRmluaXNoZWQuaXNGaW5pc2hlZFxuXG4vKipcbiAqIENyZWF0ZSBhIG1pbmltYWwgSFRNTCBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVIdG1sRG9jdW1lbnQgKG1lc3NhZ2UpIHtcbiAgdmFyIGJvZHkgPSBlc2NhcGVIdG1sKG1lc3NhZ2UpXG4gICAgLnJlcGxhY2UoTkVXTElORV9SRUdFWFAsICc8YnI+JylcbiAgICAucmVwbGFjZShET1VCTEVfU1BBQ0VfUkVHRVhQLCAnICZuYnNwOycpXG5cbiAgcmV0dXJuICc8IURPQ1RZUEUgaHRtbD5cXG4nICtcbiAgICAnPGh0bWwgbGFuZz1cImVuXCI+XFxuJyArXG4gICAgJzxoZWFkPlxcbicgK1xuICAgICc8bWV0YSBjaGFyc2V0PVwidXRmLThcIj5cXG4nICtcbiAgICAnPHRpdGxlPkVycm9yPC90aXRsZT5cXG4nICtcbiAgICAnPC9oZWFkPlxcbicgK1xuICAgICc8Ym9keT5cXG4nICtcbiAgICAnPHByZT4nICsgYm9keSArICc8L3ByZT5cXG4nICtcbiAgICAnPC9ib2R5PlxcbicgK1xuICAgICc8L2h0bWw+XFxuJ1xufVxuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZmluYWxoYW5kbGVyXG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gdG8gaGFuZGxlIHRoZSBmaW5hbCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge1JlcXVlc3R9IHJlcVxuICogQHBhcmFtIHtSZXNwb25zZX0gcmVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmaW5hbGhhbmRsZXIgKHJlcSwgcmVzLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gb3B0aW9ucyB8fCB7fVxuXG4gIC8vIGdldCBlbnZpcm9ubWVudFxuICB2YXIgZW52ID0gb3B0cy5lbnYgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgfHwgJ2RldmVsb3BtZW50J1xuXG4gIC8vIGdldCBlcnJvciBjYWxsYmFja1xuICB2YXIgb25lcnJvciA9IG9wdHMub25lcnJvclxuXG4gIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdmFyIGhlYWRlcnNcbiAgICB2YXIgbXNnXG4gICAgdmFyIHN0YXR1c1xuXG4gICAgLy8gaWdub3JlIDQwNCBvbiBpbi1mbGlnaHQgcmVzcG9uc2VcbiAgICBpZiAoIWVyciAmJiBoZWFkZXJzU2VudChyZXMpKSB7XG4gICAgICBkZWJ1ZygnY2Fubm90IDQwNCBhZnRlciBoZWFkZXJzIHNlbnQnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gdW5oYW5kbGVkIGVycm9yXG4gICAgaWYgKGVycikge1xuICAgICAgLy8gcmVzcGVjdCBzdGF0dXMgY29kZSBmcm9tIGVycm9yXG4gICAgICBzdGF0dXMgPSBnZXRFcnJvclN0YXR1c0NvZGUoZXJyKVxuXG4gICAgICBpZiAoc3RhdHVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gc3RhdHVzIGNvZGUgb24gcmVzcG9uc2VcbiAgICAgICAgc3RhdHVzID0gZ2V0UmVzcG9uc2VTdGF0dXNDb2RlKHJlcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlc3BlY3QgaGVhZGVycyBmcm9tIGVycm9yXG4gICAgICAgIGhlYWRlcnMgPSBnZXRFcnJvckhlYWRlcnMoZXJyKVxuICAgICAgfVxuXG4gICAgICAvLyBnZXQgZXJyb3IgbWVzc2FnZVxuICAgICAgbXNnID0gZ2V0RXJyb3JNZXNzYWdlKGVyciwgc3RhdHVzLCBlbnYpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vdCBmb3VuZFxuICAgICAgc3RhdHVzID0gNDA0XG4gICAgICBtc2cgPSAnQ2Fubm90ICcgKyByZXEubWV0aG9kICsgJyAnICsgZW5jb2RlVXJsKGdldFJlc291cmNlTmFtZShyZXEpKVxuICAgIH1cblxuICAgIGRlYnVnKCdkZWZhdWx0ICVzJywgc3RhdHVzKVxuXG4gICAgLy8gc2NoZWR1bGUgb25lcnJvciBjYWxsYmFja1xuICAgIGlmIChlcnIgJiYgb25lcnJvcikge1xuICAgICAgZGVmZXIob25lcnJvciwgZXJyLCByZXEsIHJlcylcbiAgICB9XG5cbiAgICAvLyBjYW5ub3QgYWN0dWFsbHkgcmVzcG9uZFxuICAgIGlmIChoZWFkZXJzU2VudChyZXMpKSB7XG4gICAgICBkZWJ1ZygnY2Fubm90ICVkIGFmdGVyIGhlYWRlcnMgc2VudCcsIHN0YXR1cylcbiAgICAgIHJlcS5zb2NrZXQuZGVzdHJveSgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBzZW5kIHJlc3BvbnNlXG4gICAgc2VuZChyZXEsIHJlcywgc3RhdHVzLCBoZWFkZXJzLCBtc2cpXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgaGVhZGVycyBmcm9tIEVycm9yIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXJyb3JIZWFkZXJzIChlcnIpIHtcbiAgaWYgKCFlcnIuaGVhZGVycyB8fCB0eXBlb2YgZXJyLmhlYWRlcnMgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgdmFyIGhlYWRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXJyLmhlYWRlcnMpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV1cbiAgICBoZWFkZXJzW2tleV0gPSBlcnIuaGVhZGVyc1trZXldXG4gIH1cblxuICByZXR1cm4gaGVhZGVyc1xufVxuXG4vKipcbiAqIEdldCBtZXNzYWdlIGZyb20gRXJyb3Igb2JqZWN0LCBmYWxsYmFjayB0byBzdGF0dXMgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbnZcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlIChlcnIsIHN0YXR1cywgZW52KSB7XG4gIHZhciBtc2dcblxuICBpZiAoZW52ICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyB1c2UgZXJyLnN0YWNrLCB3aGljaCB0eXBpY2FsbHkgaW5jbHVkZXMgZXJyLm1lc3NhZ2VcbiAgICBtc2cgPSBlcnIuc3RhY2tcblxuICAgIC8vIGZhbGxiYWNrIHRvIGVyci50b1N0cmluZygpIHdoZW4gcG9zc2libGVcbiAgICBpZiAoIW1zZyAmJiB0eXBlb2YgZXJyLnRvU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBtc2cgPSBlcnIudG9TdHJpbmcoKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtc2cgfHwgc3RhdHVzZXNbc3RhdHVzXVxufVxuXG4vKipcbiAqIEdldCBzdGF0dXMgY29kZSBmcm9tIEVycm9yIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXJyb3JTdGF0dXNDb2RlIChlcnIpIHtcbiAgLy8gY2hlY2sgZXJyLnN0YXR1c1xuICBpZiAodHlwZW9mIGVyci5zdGF0dXMgPT09ICdudW1iZXInICYmIGVyci5zdGF0dXMgPj0gNDAwICYmIGVyci5zdGF0dXMgPCA2MDApIHtcbiAgICByZXR1cm4gZXJyLnN0YXR1c1xuICB9XG5cbiAgLy8gY2hlY2sgZXJyLnN0YXR1c0NvZGVcbiAgaWYgKHR5cGVvZiBlcnIuc3RhdHVzQ29kZSA9PT0gJ251bWJlcicgJiYgZXJyLnN0YXR1c0NvZGUgPj0gNDAwICYmIGVyci5zdGF0dXNDb2RlIDwgNjAwKSB7XG4gICAgcmV0dXJuIGVyci5zdGF0dXNDb2RlXG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkXG59XG5cbi8qKlxuICogR2V0IHJlc291cmNlIG5hbWUgZm9yIHRoZSByZXF1ZXN0LlxuICpcbiAqIFRoaXMgaXMgdHlwaWNhbGx5IGp1c3QgdGhlIG9yaWdpbmFsIHBhdGhuYW1lIG9mIHRoZSByZXF1ZXN0XG4gKiBidXQgd2lsbCBmYWxsYmFjayB0byBcInJlc291cmNlXCIgaXMgdGhhdCBjYW5ub3QgYmUgZGV0ZXJtaW5lZC5cbiAqXG4gKiBAcGFyYW0ge0luY29taW5nTWVzc2FnZX0gcmVxXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGdldFJlc291cmNlTmFtZSAocmVxKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHBhcnNlVXJsLm9yaWdpbmFsKHJlcSkucGF0aG5hbWVcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiAncmVzb3VyY2UnXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgc3RhdHVzIGNvZGUgZnJvbSByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge091dGdvaW5nTWVzc2FnZX0gcmVzXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGdldFJlc3BvbnNlU3RhdHVzQ29kZSAocmVzKSB7XG4gIHZhciBzdGF0dXMgPSByZXMuc3RhdHVzQ29kZVxuXG4gIC8vIGRlZmF1bHQgc3RhdHVzIGNvZGUgdG8gNTAwIGlmIG91dHNpZGUgdmFsaWQgcmFuZ2VcbiAgaWYgKHR5cGVvZiBzdGF0dXMgIT09ICdudW1iZXInIHx8IHN0YXR1cyA8IDQwMCB8fCBzdGF0dXMgPiA1OTkpIHtcbiAgICBzdGF0dXMgPSA1MDBcbiAgfVxuXG4gIHJldHVybiBzdGF0dXNcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIHJlc3BvbnNlIGhlYWRlcnMgaGF2ZSBiZWVuIHNlbnQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHJlc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGhlYWRlcnNTZW50IChyZXMpIHtcbiAgcmV0dXJuIHR5cGVvZiByZXMuaGVhZGVyc1NlbnQgIT09ICdib29sZWFuJ1xuICAgID8gQm9vbGVhbihyZXMuX2hlYWRlcilcbiAgICA6IHJlcy5oZWFkZXJzU2VudFxufVxuXG4vKipcbiAqIFNlbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtJbmNvbWluZ01lc3NhZ2V9IHJlcVxuICogQHBhcmFtIHtPdXRnb2luZ01lc3NhZ2V9IHJlc1xuICogQHBhcmFtIHtudW1iZXJ9IHN0YXR1c1xuICogQHBhcmFtIHtvYmplY3R9IGhlYWRlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbmQgKHJlcSwgcmVzLCBzdGF0dXMsIGhlYWRlcnMsIG1lc3NhZ2UpIHtcbiAgZnVuY3Rpb24gd3JpdGUgKCkge1xuICAgIC8vIHJlc3BvbnNlIGJvZHlcbiAgICB2YXIgYm9keSA9IGNyZWF0ZUh0bWxEb2N1bWVudChtZXNzYWdlKVxuXG4gICAgLy8gcmVzcG9uc2Ugc3RhdHVzXG4gICAgcmVzLnN0YXR1c0NvZGUgPSBzdGF0dXNcbiAgICByZXMuc3RhdHVzTWVzc2FnZSA9IHN0YXR1c2VzW3N0YXR1c11cblxuICAgIC8vIHJlc3BvbnNlIGhlYWRlcnNcbiAgICBzZXRIZWFkZXJzKHJlcywgaGVhZGVycylcblxuICAgIC8vIHNlY3VyaXR5IGhlYWRlcnNcbiAgICByZXMuc2V0SGVhZGVyKCdDb250ZW50LVNlY3VyaXR5LVBvbGljeScsIFwiZGVmYXVsdC1zcmMgJ3NlbGYnXCIpXG4gICAgcmVzLnNldEhlYWRlcignWC1Db250ZW50LVR5cGUtT3B0aW9ucycsICdub3NuaWZmJylcblxuICAgIC8vIHN0YW5kYXJkIGhlYWRlcnNcbiAgICByZXMuc2V0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAndGV4dC9odG1sOyBjaGFyc2V0PXV0Zi04JylcbiAgICByZXMuc2V0SGVhZGVyKCdDb250ZW50LUxlbmd0aCcsIEJ1ZmZlci5ieXRlTGVuZ3RoKGJvZHksICd1dGY4JykpXG5cbiAgICBpZiAocmVxLm1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgICByZXMuZW5kKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHJlcy5lbmQoYm9keSwgJ3V0ZjgnKVxuICB9XG5cbiAgaWYgKGlzRmluaXNoZWQocmVxKSkge1xuICAgIHdyaXRlKClcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIHVucGlwZSBldmVyeXRoaW5nIGZyb20gdGhlIHJlcXVlc3RcbiAgdW5waXBlKHJlcSlcblxuICAvLyBmbHVzaCB0aGUgcmVxdWVzdFxuICBvbkZpbmlzaGVkKHJlcSwgd3JpdGUpXG4gIHJlcS5yZXN1bWUoKVxufVxuXG4vKipcbiAqIFNldCByZXNwb25zZSBoZWFkZXJzIGZyb20gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T3V0Z29pbmdNZXNzYWdlfSByZXNcbiAqIEBwYXJhbSB7b2JqZWN0fSBoZWFkZXJzXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNldEhlYWRlcnMgKHJlcywgaGVhZGVycykge1xuICBpZiAoIWhlYWRlcnMpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoaGVhZGVycylcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV1cbiAgICByZXMuc2V0SGVhZGVyKGtleSwgaGVhZGVyc1trZXldKVxuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9maW5hbGhhbmRsZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEV4cG9zZSBgcGF0aHRvUmVnZXhwYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGh0b1JlZ2V4cDtcblxuLyoqXG4gKiBNYXRjaCBtYXRjaGluZyBncm91cHMgaW4gYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKi9cbnZhciBNQVRDSElOR19HUk9VUF9SRUdFWFAgPSAvXFwoKD8hXFw/KS9nO1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcsXG4gKiByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgc2hvdWxkIGJlIHBhc3NlZCxcbiAqIHdoaWNoIHdpbGwgY29udGFpbiB0aGUgcGxhY2Vob2xkZXJcbiAqIGtleSBuYW1lcy4gRm9yIGV4YW1wbGUgXCIvdXNlci86aWRcIiB3aWxsXG4gKiB0aGVuIGNvbnRhaW4gW1wiaWRcIl0uXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfFJlZ0V4cHxBcnJheX0gcGF0aFxuICogQHBhcmFtICB7QXJyYXl9IGtleXNcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7UmVnRXhwfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGF0aHRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGtleXMgPSBrZXlzIHx8IFtdO1xuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2U7XG4gIHZhciBmbGFncyA9IG9wdGlvbnMuc2Vuc2l0aXZlID8gJycgOiAnaSc7XG4gIHZhciBleHRyYU9mZnNldCA9IDA7XG4gIHZhciBrZXlzT2Zmc2V0ID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpID0gMDtcbiAgdmFyIG5hbWUgPSAwO1xuICB2YXIgbTtcblxuICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHdoaWxlIChtID0gTUFUQ0hJTkdfR1JPVVBfUkVHRVhQLmV4ZWMocGF0aC5zb3VyY2UpKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBuYW1lOiBuYW1lKyssXG4gICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgb2Zmc2V0OiBtLmluZGV4XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgLy8gTWFwIGFycmF5IHBhcnRzIGludG8gcmVnZXhwcyBhbmQgcmV0dXJuIHRoZWlyIHNvdXJjZS4gV2UgYWxzbyBwYXNzXG4gICAgLy8gdGhlIHNhbWUga2V5cyBhbmQgb3B0aW9ucyBpbnN0YW5jZSBpbnRvIGV2ZXJ5IGdlbmVyYXRpb24gdG8gZ2V0XG4gICAgLy8gY29uc2lzdGVudCBtYXRjaGluZyBncm91cHMgYmVmb3JlIHdlIGpvaW4gdGhlIHNvdXJjZXMgdG9nZXRoZXIuXG4gICAgcGF0aCA9IHBhdGgubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHBhdGh0b1JlZ2V4cCh2YWx1ZSwga2V5cywgb3B0aW9ucykuc291cmNlO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoJyg/OicgKyBwYXRoLmpvaW4oJ3wnKSArICcpJywgZmxhZ3MpO1xuICB9XG5cbiAgcGF0aCA9ICgnXicgKyBwYXRoICsgKHN0cmljdCA/ICcnIDogcGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSAnLycgPyAnPycgOiAnLz8nKSlcbiAgICAucmVwbGFjZSgvXFwvXFwoL2csICcvKD86JylcbiAgICAucmVwbGFjZSgvKFtcXC9cXC5dKS9nLCAnXFxcXCQxJylcbiAgICAucmVwbGFjZSgvKFxcXFxcXC8pPyhcXFxcXFwuKT86KFxcdyspKFxcKC4qP1xcKSk/KFxcKik/KFxcPyk/L2csIGZ1bmN0aW9uIChtYXRjaCwgc2xhc2gsIGZvcm1hdCwga2V5LCBjYXB0dXJlLCBzdGFyLCBvcHRpb25hbCwgb2Zmc2V0KSB7XG4gICAgICBzbGFzaCA9IHNsYXNoIHx8ICcnO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgICAgY2FwdHVyZSA9IGNhcHR1cmUgfHwgJyhbXlxcXFwvJyArIGZvcm1hdCArICddKz8pJztcbiAgICAgIG9wdGlvbmFsID0gb3B0aW9uYWwgfHwgJyc7XG5cbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgb3B0aW9uYWw6ICEhb3B0aW9uYWwsXG4gICAgICAgIG9mZnNldDogb2Zmc2V0ICsgZXh0cmFPZmZzZXRcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gJydcbiAgICAgICAgKyAob3B0aW9uYWwgPyAnJyA6IHNsYXNoKVxuICAgICAgICArICcoPzonXG4gICAgICAgICsgZm9ybWF0ICsgKG9wdGlvbmFsID8gc2xhc2ggOiAnJykgKyBjYXB0dXJlXG4gICAgICAgICsgKHN0YXIgPyAnKCg/OltcXFxcLycgKyBmb3JtYXQgKyAnXS4rPyk/KScgOiAnJylcbiAgICAgICAgKyAnKSdcbiAgICAgICAgKyBvcHRpb25hbDtcblxuICAgICAgZXh0cmFPZmZzZXQgKz0gcmVzdWx0Lmxlbmd0aCAtIG1hdGNoLmxlbmd0aDtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KVxuICAgIC5yZXBsYWNlKC9cXCovZywgZnVuY3Rpb24gKHN0YXIsIGluZGV4KSB7XG4gICAgICB2YXIgbGVuID0ga2V5cy5sZW5ndGhcblxuICAgICAgd2hpbGUgKGxlbi0tID4ga2V5c09mZnNldCAmJiBrZXlzW2xlbl0ub2Zmc2V0ID4gaW5kZXgpIHtcbiAgICAgICAga2V5c1tsZW5dLm9mZnNldCArPSAzOyAvLyBSZXBsYWNlbWVudCBsZW5ndGggbWludXMgYXN0ZXJpc2sgbGVuZ3RoLlxuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyguKiknO1xuICAgIH0pO1xuXG4gIC8vIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciBoYW5kbGluZyB1bm5hbWVkIG1hdGNoaW5nIGdyb3Vwcy5cbiAgd2hpbGUgKG0gPSBNQVRDSElOR19HUk9VUF9SRUdFWFAuZXhlYyhwYXRoKSkge1xuICAgIHZhciBlc2NhcGVDb3VudCA9IDA7XG4gICAgdmFyIGluZGV4ID0gbS5pbmRleDtcblxuICAgIHdoaWxlIChwYXRoLmNoYXJBdCgtLWluZGV4KSA9PT0gJ1xcXFwnKSB7XG4gICAgICBlc2NhcGVDb3VudCsrO1xuICAgIH1cblxuICAgIC8vIEl0J3MgcG9zc2libGUgdG8gZXNjYXBlIHRoZSBicmFja2V0LlxuICAgIGlmIChlc2NhcGVDb3VudCAlIDIgPT09IDEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChrZXlzT2Zmc2V0ICsgaSA9PT0ga2V5cy5sZW5ndGggfHwga2V5c1trZXlzT2Zmc2V0ICsgaV0ub2Zmc2V0ID4gbS5pbmRleCkge1xuICAgICAga2V5cy5zcGxpY2Uoa2V5c09mZnNldCArIGksIDAsIHtcbiAgICAgICAgbmFtZTogbmFtZSsrLCAvLyBVbm5hbWVkIG1hdGNoaW5nIGdyb3VwcyBtdXN0IGJlIGNvbnNpc3RlbnRseSBsaW5lYXIuXG4gICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgb2Zmc2V0OiBtLmluZGV4XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpKys7XG4gIH1cblxuICAvLyBJZiB0aGUgcGF0aCBpcyBub24tZW5kaW5nLCBtYXRjaCB1bnRpbCB0aGUgZW5kIG9yIGEgc2xhc2guXG4gIHBhdGggKz0gKGVuZCA/ICckJyA6IChwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICcvJyA/ICcnIDogJyg/PVxcXFwvfCQpJykpO1xuXG4gIHJldHVybiBuZXcgUmVnRXhwKHBhdGgsIGZsYWdzKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogZXhwcmVzc1xuICogQ29weXJpZ2h0KGMpIDIwMDktMjAxMyBUSiBIb2xvd2F5Y2h1a1xuICogQ29weXJpZ2h0KGMpIDIwMTMgUm9tYW4gU2h0eWxtYW5cbiAqIENvcHlyaWdodChjKSAyMDE0LTIwMTUgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdzZXRwcm90b3R5cGVvZicpXG5cbi8qKlxuICogSW5pdGlhbGl6YXRpb24gbWlkZGxld2FyZSwgZXhwb3NpbmcgdGhlXG4gKiByZXF1ZXN0IGFuZCByZXNwb25zZSB0byBlYWNoIG90aGVyLCBhcyB3ZWxsXG4gKiBhcyBkZWZhdWx0aW5nIHRoZSBYLVBvd2VyZWQtQnkgaGVhZGVyIGZpZWxkLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFwcFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbihhcHApe1xuICByZXR1cm4gZnVuY3Rpb24gZXhwcmVzc0luaXQocmVxLCByZXMsIG5leHQpe1xuICAgIGlmIChhcHAuZW5hYmxlZCgneC1wb3dlcmVkLWJ5JykpIHJlcy5zZXRIZWFkZXIoJ1gtUG93ZXJlZC1CeScsICdFeHByZXNzJyk7XG4gICAgcmVxLnJlcyA9IHJlcztcbiAgICByZXMucmVxID0gcmVxO1xuICAgIHJlcS5uZXh0ID0gbmV4dDtcblxuICAgIHNldFByb3RvdHlwZU9mKHJlcSwgYXBwLnJlcXVlc3QpXG4gICAgc2V0UHJvdG90eXBlT2YocmVzLCBhcHAucmVzcG9uc2UpXG5cbiAgICByZXMubG9jYWxzID0gcmVzLmxvY2FscyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgbmV4dCgpO1xuICB9O1xufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZXhwcmVzcy9saWIvbWlkZGxld2FyZS9pbml0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBleHByZXNzXG4gKiBDb3B5cmlnaHQoYykgMjAwOS0yMDEzIFRKIEhvbG93YXljaHVrXG4gKiBDb3B5cmlnaHQoYykgMjAxMyBSb21hbiBTaHR5bG1hblxuICogQ29weXJpZ2h0KGMpIDIwMTQtMjAxNSBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2V4cHJlc3M6dmlldycpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBkaXJuYW1lID0gcGF0aC5kaXJuYW1lO1xudmFyIGJhc2VuYW1lID0gcGF0aC5iYXNlbmFtZTtcbnZhciBleHRuYW1lID0gcGF0aC5leHRuYW1lO1xudmFyIGpvaW4gPSBwYXRoLmpvaW47XG52YXIgcmVzb2x2ZSA9IHBhdGgucmVzb2x2ZTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgVmlld2Agd2l0aCB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogICAtIGBkZWZhdWx0RW5naW5lYCB0aGUgZGVmYXVsdCB0ZW1wbGF0ZSBlbmdpbmUgbmFtZVxuICogICAtIGBlbmdpbmVzYCB0ZW1wbGF0ZSBlbmdpbmUgcmVxdWlyZSgpIGNhY2hlXG4gKiAgIC0gYHJvb3RgIHJvb3QgcGF0aCBmb3IgdmlldyBsb29rdXBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBWaWV3KG5hbWUsIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRoaXMuZGVmYXVsdEVuZ2luZSA9IG9wdHMuZGVmYXVsdEVuZ2luZTtcbiAgdGhpcy5leHQgPSBleHRuYW1lKG5hbWUpO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLnJvb3QgPSBvcHRzLnJvb3Q7XG5cbiAgaWYgKCF0aGlzLmV4dCAmJiAhdGhpcy5kZWZhdWx0RW5naW5lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBkZWZhdWx0IGVuZ2luZSB3YXMgc3BlY2lmaWVkIGFuZCBubyBleHRlbnNpb24gd2FzIHByb3ZpZGVkLicpO1xuICB9XG5cbiAgdmFyIGZpbGVOYW1lID0gbmFtZTtcblxuICBpZiAoIXRoaXMuZXh0KSB7XG4gICAgLy8gZ2V0IGV4dGVuc2lvbiBmcm9tIGRlZmF1bHQgZW5naW5lIG5hbWVcbiAgICB0aGlzLmV4dCA9IHRoaXMuZGVmYXVsdEVuZ2luZVswXSAhPT0gJy4nXG4gICAgICA/ICcuJyArIHRoaXMuZGVmYXVsdEVuZ2luZVxuICAgICAgOiB0aGlzLmRlZmF1bHRFbmdpbmU7XG5cbiAgICBmaWxlTmFtZSArPSB0aGlzLmV4dDtcbiAgfVxuXG4gIGlmICghb3B0cy5lbmdpbmVzW3RoaXMuZXh0XSkge1xuICAgIC8vIGxvYWQgZW5naW5lXG4gICAgdmFyIG1vZCA9IHRoaXMuZXh0LnN1YnN0cigxKVxuICAgIGRlYnVnKCdyZXF1aXJlIFwiJXNcIicsIG1vZClcblxuICAgIC8vIGRlZmF1bHQgZW5naW5lIGV4cG9ydFxuICAgIHZhciBmbiA9IHJlcXVpcmUobW9kKS5fX2V4cHJlc3NcblxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTW9kdWxlIFwiJyArIG1vZCArICdcIiBkb2VzIG5vdCBwcm92aWRlIGEgdmlldyBlbmdpbmUuJylcbiAgICB9XG5cbiAgICBvcHRzLmVuZ2luZXNbdGhpcy5leHRdID0gZm5cbiAgfVxuXG4gIC8vIHN0b3JlIGxvYWRlZCBlbmdpbmVcbiAgdGhpcy5lbmdpbmUgPSBvcHRzLmVuZ2luZXNbdGhpcy5leHRdO1xuXG4gIC8vIGxvb2t1cCBwYXRoXG4gIHRoaXMucGF0aCA9IHRoaXMubG9va3VwKGZpbGVOYW1lKTtcbn1cblxuLyoqXG4gKiBMb29rdXAgdmlldyBieSB0aGUgZ2l2ZW4gYG5hbWVgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwcml2YXRlXG4gKi9cblxuVmlldy5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24gbG9va3VwKG5hbWUpIHtcbiAgdmFyIHBhdGg7XG4gIHZhciByb290cyA9IFtdLmNvbmNhdCh0aGlzLnJvb3QpO1xuXG4gIGRlYnVnKCdsb29rdXAgXCIlc1wiJywgbmFtZSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByb290cy5sZW5ndGggJiYgIXBhdGg7IGkrKykge1xuICAgIHZhciByb290ID0gcm9vdHNbaV07XG5cbiAgICAvLyByZXNvbHZlIHRoZSBwYXRoXG4gICAgdmFyIGxvYyA9IHJlc29sdmUocm9vdCwgbmFtZSk7XG4gICAgdmFyIGRpciA9IGRpcm5hbWUobG9jKTtcbiAgICB2YXIgZmlsZSA9IGJhc2VuYW1lKGxvYyk7XG5cbiAgICAvLyByZXNvbHZlIHRoZSBmaWxlXG4gICAgcGF0aCA9IHRoaXMucmVzb2x2ZShkaXIsIGZpbGUpO1xuICB9XG5cbiAgcmV0dXJuIHBhdGg7XG59O1xuXG4vKipcbiAqIFJlbmRlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuXG5WaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgZGVidWcoJ3JlbmRlciBcIiVzXCInLCB0aGlzLnBhdGgpO1xuICB0aGlzLmVuZ2luZSh0aGlzLnBhdGgsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZSB0aGUgZmlsZSB3aXRoaW4gdGhlIGdpdmVuIGRpcmVjdG9yeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlyXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZVxuICogQHByaXZhdGVcbiAqL1xuXG5WaWV3LnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZShkaXIsIGZpbGUpIHtcbiAgdmFyIGV4dCA9IHRoaXMuZXh0O1xuXG4gIC8vIDxwYXRoPi48ZXh0PlxuICB2YXIgcGF0aCA9IGpvaW4oZGlyLCBmaWxlKTtcbiAgdmFyIHN0YXQgPSB0cnlTdGF0KHBhdGgpO1xuXG4gIGlmIChzdGF0ICYmIHN0YXQuaXNGaWxlKCkpIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuXG4gIC8vIDxwYXRoPi9pbmRleC48ZXh0PlxuICBwYXRoID0gam9pbihkaXIsIGJhc2VuYW1lKGZpbGUsIGV4dCksICdpbmRleCcgKyBleHQpO1xuICBzdGF0ID0gdHJ5U3RhdChwYXRoKTtcblxuICBpZiAoc3RhdCAmJiBzdGF0LmlzRmlsZSgpKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJuIGEgc3RhdCwgbWF5YmUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge2ZzLlN0YXRzfVxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiB0cnlTdGF0KHBhdGgpIHtcbiAgZGVidWcoJ3N0YXQgXCIlc1wiJywgcGF0aCk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZnMuc3RhdFN5bmMocGF0aCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9leHByZXNzL2xpYi92aWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gd2VicGFja0VtcHR5Q29udGV4dChyZXEpIHtcblx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJy5cIik7XG59XG53ZWJwYWNrRW1wdHlDb250ZXh0LmtleXMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9O1xud2VicGFja0VtcHR5Q29udGV4dC5yZXNvbHZlID0gd2VicGFja0VtcHR5Q29udGV4dDtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0VtcHR5Q29udGV4dDtcbndlYnBhY2tFbXB0eUNvbnRleHQuaWQgPSAxMjY7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZXhwcmVzcy9saWJcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGRlc3Ryb3lcbiAqIENvcHlyaWdodChjKSAyMDE0IEpvbmF0aGFuIE9uZ1xuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIFJlYWRTdHJlYW0gPSByZXF1aXJlKCdmcycpLlJlYWRTdHJlYW1cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKVxuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVzdHJveVxuXG4vKipcbiAqIERlc3Ryb3kgYSBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHN0cmVhbVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlc3Ryb3koc3RyZWFtKSB7XG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBSZWFkU3RyZWFtKSB7XG4gICAgcmV0dXJuIGRlc3Ryb3lSZWFkU3RyZWFtKHN0cmVhbSlcbiAgfVxuXG4gIGlmICghKHN0cmVhbSBpbnN0YW5jZW9mIFN0cmVhbSkpIHtcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBpZiAodHlwZW9mIHN0cmVhbS5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3RyZWFtLmRlc3Ryb3koKVxuICB9XG5cbiAgcmV0dXJuIHN0cmVhbVxufVxuXG4vKipcbiAqIERlc3Ryb3kgYSBSZWFkU3RyZWFtLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdHJlYW1cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZGVzdHJveVJlYWRTdHJlYW0oc3RyZWFtKSB7XG4gIHN0cmVhbS5kZXN0cm95KClcblxuICBpZiAodHlwZW9mIHN0cmVhbS5jbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIG5vZGUuanMgY29yZSBidWcgd29yay1hcm91bmRcbiAgICBzdHJlYW0ub24oJ29wZW4nLCBvbk9wZW5DbG9zZSlcbiAgfVxuXG4gIHJldHVybiBzdHJlYW1cbn1cblxuLyoqXG4gKiBPbiBvcGVuIGhhbmRsZXIgdG8gY2xvc2Ugc3RyZWFtLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBvbk9wZW5DbG9zZSgpIHtcbiAgaWYgKHR5cGVvZiB0aGlzLmZkID09PSAnbnVtYmVyJykge1xuICAgIC8vIGFjdHVhbGx5IGNsb3NlIGRvd24gdGhlIGZkXG4gICAgdGhpcy5jbG9zZSgpXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Rlc3Ryb3kvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cbmZ1bmN0aW9uIE1pbWUoKSB7XG4gIC8vIE1hcCBvZiBleHRlbnNpb24gLT4gbWltZSB0eXBlXG4gIHRoaXMudHlwZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vIE1hcCBvZiBtaW1lIHR5cGUgLT4gZXh0ZW5zaW9uXG4gIHRoaXMuZXh0ZW5zaW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cbi8qKlxuICogRGVmaW5lIG1pbWV0eXBlIC0+IGV4dGVuc2lvbiBtYXBwaW5ncy4gIEVhY2gga2V5IGlzIGEgbWltZS10eXBlIHRoYXQgbWFwc1xuICogdG8gYW4gYXJyYXkgb2YgZXh0ZW5zaW9ucyBhc3NvY2lhdGVkIHdpdGggdGhlIHR5cGUuICBUaGUgZmlyc3QgZXh0ZW5zaW9uIGlzXG4gKiB1c2VkIGFzIHRoZSBkZWZhdWx0IGV4dGVuc2lvbiBmb3IgdGhlIHR5cGUuXG4gKlxuICogZS5nLiBtaW1lLmRlZmluZSh7J2F1ZGlvL29nZycsIFsnb2dhJywgJ29nZycsICdzcHgnXX0pO1xuICpcbiAqIEBwYXJhbSBtYXAgKE9iamVjdCkgdHlwZSBkZWZpbml0aW9uc1xuICovXG5NaW1lLnByb3RvdHlwZS5kZWZpbmUgPSBmdW5jdGlvbiAobWFwKSB7XG4gIGZvciAodmFyIHR5cGUgaW4gbWFwKSB7XG4gICAgdmFyIGV4dHMgPSBtYXBbdHlwZV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuREVCVUdfTUlNRSAmJiB0aGlzLnR5cGVzW2V4dHNbaV1dKSB7XG4gICAgICAgIGNvbnNvbGUud2FybigodGhpcy5fbG9hZGluZyB8fCBcImRlZmluZSgpXCIpLnJlcGxhY2UoLy4qXFwvLywgJycpLCAnY2hhbmdlcyBcIicgKyBleHRzW2ldICsgJ1wiIGV4dGVuc2lvbiB0eXBlIGZyb20gJyArXG4gICAgICAgICAgdGhpcy50eXBlc1tleHRzW2ldXSArICcgdG8gJyArIHR5cGUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnR5cGVzW2V4dHNbaV1dID0gdHlwZTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IGV4dGVuc2lvbiBpcyB0aGUgZmlyc3Qgb25lIHdlIGVuY291bnRlclxuICAgIGlmICghdGhpcy5leHRlbnNpb25zW3R5cGVdKSB7XG4gICAgICB0aGlzLmV4dGVuc2lvbnNbdHlwZV0gPSBleHRzWzBdO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBMb2FkIGFuIEFwYWNoZTItc3R5bGUgXCIudHlwZXNcIiBmaWxlXG4gKlxuICogVGhpcyBtYXkgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIChpdCdzIGV4cGVjdGVkKS4gIFdoZXJlIGZpbGVzIGRlY2xhcmVcbiAqIG92ZXJsYXBwaW5nIHR5cGVzL2V4dGVuc2lvbnMsIHRoZSBsYXN0IGZpbGUgd2lucy5cbiAqXG4gKiBAcGFyYW0gZmlsZSAoU3RyaW5nKSBwYXRoIG9mIGZpbGUgdG8gbG9hZC5cbiAqL1xuTWltZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKGZpbGUpIHtcbiAgdGhpcy5fbG9hZGluZyA9IGZpbGU7XG4gIC8vIFJlYWQgZmlsZSBhbmQgc3BsaXQgaW50byBsaW5lc1xuICB2YXIgbWFwID0ge30sXG4gICAgICBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGZpbGUsICdhc2NpaScpLFxuICAgICAgbGluZXMgPSBjb250ZW50LnNwbGl0KC9bXFxyXFxuXSsvKTtcblxuICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAvLyBDbGVhbiB1cCB3aGl0ZXNwYWNlL2NvbW1lbnRzLCBhbmQgc3BsaXQgaW50byBmaWVsZHNcbiAgICB2YXIgZmllbGRzID0gbGluZS5yZXBsYWNlKC9cXHMqIy4qfF5cXHMqfFxccyokL2csICcnKS5zcGxpdCgvXFxzKy8pO1xuICAgIG1hcFtmaWVsZHMuc2hpZnQoKV0gPSBmaWVsZHM7XG4gIH0pO1xuXG4gIHRoaXMuZGVmaW5lKG1hcCk7XG5cbiAgdGhpcy5fbG9hZGluZyA9IG51bGw7XG59O1xuXG4vKipcbiAqIExvb2t1cCBhIG1pbWUgdHlwZSBiYXNlZCBvbiBleHRlbnNpb25cbiAqL1xuTWltZS5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24ocGF0aCwgZmFsbGJhY2spIHtcbiAgdmFyIGV4dCA9IHBhdGgucmVwbGFjZSgvXi4qW1xcLlxcL1xcXFxdLywgJycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIHRoaXMudHlwZXNbZXh0XSB8fCBmYWxsYmFjayB8fCB0aGlzLmRlZmF1bHRfdHlwZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGZpbGUgZXh0ZW5zaW9uIGFzc29jaWF0ZWQgd2l0aCBhIG1pbWUgdHlwZVxuICovXG5NaW1lLnByb3RvdHlwZS5leHRlbnNpb24gPSBmdW5jdGlvbihtaW1lVHlwZSkge1xuICB2YXIgdHlwZSA9IG1pbWVUeXBlLm1hdGNoKC9eXFxzKihbXjtcXHNdKikoPzo7fFxcc3wkKS8pWzFdLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiB0aGlzLmV4dGVuc2lvbnNbdHlwZV07XG59O1xuXG4vLyBEZWZhdWx0IGluc3RhbmNlXG52YXIgbWltZSA9IG5ldyBNaW1lKCk7XG5cbi8vIERlZmluZSBidWlsdC1pbiB0eXBlc1xubWltZS5kZWZpbmUocmVxdWlyZSgnLi90eXBlcy5qc29uJykpO1xuXG4vLyBEZWZhdWx0IHR5cGVcbm1pbWUuZGVmYXVsdF90eXBlID0gbWltZS5sb29rdXAoJ2JpbicpO1xuXG4vL1xuLy8gQWRkaXRpb25hbCBBUEkgc3BlY2lmaWMgdG8gdGhlIGRlZmF1bHQgaW5zdGFuY2Vcbi8vXG5cbm1pbWUuTWltZSA9IE1pbWU7XG5cbi8qKlxuICogTG9va3VwIGEgY2hhcnNldCBiYXNlZCBvbiBtaW1lIHR5cGUuXG4gKi9cbm1pbWUuY2hhcnNldHMgPSB7XG4gIGxvb2t1cDogZnVuY3Rpb24obWltZVR5cGUsIGZhbGxiYWNrKSB7XG4gICAgLy8gQXNzdW1lIHRleHQgdHlwZXMgYXJlIHV0ZjhcbiAgICByZXR1cm4gKC9edGV4dFxcL3xeYXBwbGljYXRpb25cXC8oamF2YXNjcmlwdHxqc29uKS8pLnRlc3QobWltZVR5cGUpID8gJ1VURi04JyA6IGZhbGxiYWNrO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1pbWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9taW1lL21pbWUuanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcImFwcGxpY2F0aW9uL2FuZHJldy1pbnNldFwiOltcImV6XCJdLFwiYXBwbGljYXRpb24vYXBwbGl4d2FyZVwiOltcImF3XCJdLFwiYXBwbGljYXRpb24vYXRvbSt4bWxcIjpbXCJhdG9tXCJdLFwiYXBwbGljYXRpb24vYXRvbWNhdCt4bWxcIjpbXCJhdG9tY2F0XCJdLFwiYXBwbGljYXRpb24vYXRvbXN2Yyt4bWxcIjpbXCJhdG9tc3ZjXCJdLFwiYXBwbGljYXRpb24vYmRvY1wiOltcImJkb2NcIl0sXCJhcHBsaWNhdGlvbi9jY3htbCt4bWxcIjpbXCJjY3htbFwiXSxcImFwcGxpY2F0aW9uL2NkbWktY2FwYWJpbGl0eVwiOltcImNkbWlhXCJdLFwiYXBwbGljYXRpb24vY2RtaS1jb250YWluZXJcIjpbXCJjZG1pY1wiXSxcImFwcGxpY2F0aW9uL2NkbWktZG9tYWluXCI6W1wiY2RtaWRcIl0sXCJhcHBsaWNhdGlvbi9jZG1pLW9iamVjdFwiOltcImNkbWlvXCJdLFwiYXBwbGljYXRpb24vY2RtaS1xdWV1ZVwiOltcImNkbWlxXCJdLFwiYXBwbGljYXRpb24vY3Utc2VlbWVcIjpbXCJjdVwiXSxcImFwcGxpY2F0aW9uL2Rhc2greG1sXCI6W1wibXBkXCJdLFwiYXBwbGljYXRpb24vZGF2bW91bnQreG1sXCI6W1wiZGF2bW91bnRcIl0sXCJhcHBsaWNhdGlvbi9kb2Nib29rK3htbFwiOltcImRia1wiXSxcImFwcGxpY2F0aW9uL2Rzc2MrZGVyXCI6W1wiZHNzY1wiXSxcImFwcGxpY2F0aW9uL2Rzc2MreG1sXCI6W1wieGRzc2NcIl0sXCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0XCI6W1wiZWNtYVwiXSxcImFwcGxpY2F0aW9uL2VtbWEreG1sXCI6W1wiZW1tYVwiXSxcImFwcGxpY2F0aW9uL2VwdWIremlwXCI6W1wiZXB1YlwiXSxcImFwcGxpY2F0aW9uL2V4aVwiOltcImV4aVwiXSxcImFwcGxpY2F0aW9uL2ZvbnQtdGRwZnJcIjpbXCJwZnJcIl0sXCJhcHBsaWNhdGlvbi9mb250LXdvZmZcIjpbXCJ3b2ZmXCJdLFwiYXBwbGljYXRpb24vZm9udC13b2ZmMlwiOltcIndvZmYyXCJdLFwiYXBwbGljYXRpb24vZ2VvK2pzb25cIjpbXCJnZW9qc29uXCJdLFwiYXBwbGljYXRpb24vZ21sK3htbFwiOltcImdtbFwiXSxcImFwcGxpY2F0aW9uL2dweCt4bWxcIjpbXCJncHhcIl0sXCJhcHBsaWNhdGlvbi9neGZcIjpbXCJneGZcIl0sXCJhcHBsaWNhdGlvbi9nemlwXCI6W1wiZ3pcIl0sXCJhcHBsaWNhdGlvbi9oeXBlcnN0dWRpb1wiOltcInN0a1wiXSxcImFwcGxpY2F0aW9uL2lua21sK3htbFwiOltcImlua1wiLFwiaW5rbWxcIl0sXCJhcHBsaWNhdGlvbi9pcGZpeFwiOltcImlwZml4XCJdLFwiYXBwbGljYXRpb24vamF2YS1hcmNoaXZlXCI6W1wiamFyXCIsXCJ3YXJcIixcImVhclwiXSxcImFwcGxpY2F0aW9uL2phdmEtc2VyaWFsaXplZC1vYmplY3RcIjpbXCJzZXJcIl0sXCJhcHBsaWNhdGlvbi9qYXZhLXZtXCI6W1wiY2xhc3NcIl0sXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCI6W1wianNcIixcIm1qc1wiXSxcImFwcGxpY2F0aW9uL2pzb25cIjpbXCJqc29uXCIsXCJtYXBcIl0sXCJhcHBsaWNhdGlvbi9qc29uNVwiOltcImpzb241XCJdLFwiYXBwbGljYXRpb24vanNvbm1sK2pzb25cIjpbXCJqc29ubWxcIl0sXCJhcHBsaWNhdGlvbi9sZCtqc29uXCI6W1wianNvbmxkXCJdLFwiYXBwbGljYXRpb24vbG9zdCt4bWxcIjpbXCJsb3N0eG1sXCJdLFwiYXBwbGljYXRpb24vbWFjLWJpbmhleDQwXCI6W1wiaHF4XCJdLFwiYXBwbGljYXRpb24vbWFjLWNvbXBhY3Rwcm9cIjpbXCJjcHRcIl0sXCJhcHBsaWNhdGlvbi9tYWRzK3htbFwiOltcIm1hZHNcIl0sXCJhcHBsaWNhdGlvbi9tYW5pZmVzdCtqc29uXCI6W1wid2VibWFuaWZlc3RcIl0sXCJhcHBsaWNhdGlvbi9tYXJjXCI6W1wibXJjXCJdLFwiYXBwbGljYXRpb24vbWFyY3htbCt4bWxcIjpbXCJtcmN4XCJdLFwiYXBwbGljYXRpb24vbWF0aGVtYXRpY2FcIjpbXCJtYVwiLFwibmJcIixcIm1iXCJdLFwiYXBwbGljYXRpb24vbWF0aG1sK3htbFwiOltcIm1hdGhtbFwiXSxcImFwcGxpY2F0aW9uL21ib3hcIjpbXCJtYm94XCJdLFwiYXBwbGljYXRpb24vbWVkaWFzZXJ2ZXJjb250cm9sK3htbFwiOltcIm1zY21sXCJdLFwiYXBwbGljYXRpb24vbWV0YWxpbmsreG1sXCI6W1wibWV0YWxpbmtcIl0sXCJhcHBsaWNhdGlvbi9tZXRhbGluazQreG1sXCI6W1wibWV0YTRcIl0sXCJhcHBsaWNhdGlvbi9tZXRzK3htbFwiOltcIm1ldHNcIl0sXCJhcHBsaWNhdGlvbi9tb2RzK3htbFwiOltcIm1vZHNcIl0sXCJhcHBsaWNhdGlvbi9tcDIxXCI6W1wibTIxXCIsXCJtcDIxXCJdLFwiYXBwbGljYXRpb24vbXA0XCI6W1wibXA0c1wiLFwibTRwXCJdLFwiYXBwbGljYXRpb24vbXN3b3JkXCI6W1wiZG9jXCIsXCJkb3RcIl0sXCJhcHBsaWNhdGlvbi9teGZcIjpbXCJteGZcIl0sXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIjpbXCJiaW5cIixcImRtc1wiLFwibHJmXCIsXCJtYXJcIixcInNvXCIsXCJkaXN0XCIsXCJkaXN0elwiLFwicGtnXCIsXCJicGtcIixcImR1bXBcIixcImVsY1wiLFwiZGVwbG95XCIsXCJleGVcIixcImRsbFwiLFwiZGViXCIsXCJkbWdcIixcImlzb1wiLFwiaW1nXCIsXCJtc2lcIixcIm1zcFwiLFwibXNtXCIsXCJidWZmZXJcIl0sXCJhcHBsaWNhdGlvbi9vZGFcIjpbXCJvZGFcIl0sXCJhcHBsaWNhdGlvbi9vZWJwcy1wYWNrYWdlK3htbFwiOltcIm9wZlwiXSxcImFwcGxpY2F0aW9uL29nZ1wiOltcIm9neFwiXSxcImFwcGxpY2F0aW9uL29tZG9jK3htbFwiOltcIm9tZG9jXCJdLFwiYXBwbGljYXRpb24vb25lbm90ZVwiOltcIm9uZXRvY1wiLFwib25ldG9jMlwiLFwib25ldG1wXCIsXCJvbmVwa2dcIl0sXCJhcHBsaWNhdGlvbi9veHBzXCI6W1wib3hwc1wiXSxcImFwcGxpY2F0aW9uL3BhdGNoLW9wcy1lcnJvcit4bWxcIjpbXCJ4ZXJcIl0sXCJhcHBsaWNhdGlvbi9wZGZcIjpbXCJwZGZcIl0sXCJhcHBsaWNhdGlvbi9wZ3AtZW5jcnlwdGVkXCI6W1wicGdwXCJdLFwiYXBwbGljYXRpb24vcGdwLXNpZ25hdHVyZVwiOltcImFzY1wiLFwic2lnXCJdLFwiYXBwbGljYXRpb24vcGljcy1ydWxlc1wiOltcInByZlwiXSxcImFwcGxpY2F0aW9uL3BrY3MxMFwiOltcInAxMFwiXSxcImFwcGxpY2F0aW9uL3BrY3M3LW1pbWVcIjpbXCJwN21cIixcInA3Y1wiXSxcImFwcGxpY2F0aW9uL3BrY3M3LXNpZ25hdHVyZVwiOltcInA3c1wiXSxcImFwcGxpY2F0aW9uL3BrY3M4XCI6W1wicDhcIl0sXCJhcHBsaWNhdGlvbi9wa2l4LWF0dHItY2VydFwiOltcImFjXCJdLFwiYXBwbGljYXRpb24vcGtpeC1jZXJ0XCI6W1wiY2VyXCJdLFwiYXBwbGljYXRpb24vcGtpeC1jcmxcIjpbXCJjcmxcIl0sXCJhcHBsaWNhdGlvbi9wa2l4LXBraXBhdGhcIjpbXCJwa2lwYXRoXCJdLFwiYXBwbGljYXRpb24vcGtpeGNtcFwiOltcInBraVwiXSxcImFwcGxpY2F0aW9uL3Bscyt4bWxcIjpbXCJwbHNcIl0sXCJhcHBsaWNhdGlvbi9wb3N0c2NyaXB0XCI6W1wiYWlcIixcImVwc1wiLFwicHNcIl0sXCJhcHBsaWNhdGlvbi9wcnMuY3d3XCI6W1wiY3d3XCJdLFwiYXBwbGljYXRpb24vcHNrYyt4bWxcIjpbXCJwc2tjeG1sXCJdLFwiYXBwbGljYXRpb24vcmRmK3htbFwiOltcInJkZlwiXSxcImFwcGxpY2F0aW9uL3JlZ2luZm8reG1sXCI6W1wicmlmXCJdLFwiYXBwbGljYXRpb24vcmVsYXgtbmctY29tcGFjdC1zeW50YXhcIjpbXCJybmNcIl0sXCJhcHBsaWNhdGlvbi9yZXNvdXJjZS1saXN0cyt4bWxcIjpbXCJybFwiXSxcImFwcGxpY2F0aW9uL3Jlc291cmNlLWxpc3RzLWRpZmYreG1sXCI6W1wicmxkXCJdLFwiYXBwbGljYXRpb24vcmxzLXNlcnZpY2VzK3htbFwiOltcInJzXCJdLFwiYXBwbGljYXRpb24vcnBraS1naG9zdGJ1c3RlcnNcIjpbXCJnYnJcIl0sXCJhcHBsaWNhdGlvbi9ycGtpLW1hbmlmZXN0XCI6W1wibWZ0XCJdLFwiYXBwbGljYXRpb24vcnBraS1yb2FcIjpbXCJyb2FcIl0sXCJhcHBsaWNhdGlvbi9yc2QreG1sXCI6W1wicnNkXCJdLFwiYXBwbGljYXRpb24vcnNzK3htbFwiOltcInJzc1wiXSxcImFwcGxpY2F0aW9uL3J0ZlwiOltcInJ0ZlwiXSxcImFwcGxpY2F0aW9uL3NibWwreG1sXCI6W1wic2JtbFwiXSxcImFwcGxpY2F0aW9uL3NjdnAtY3YtcmVxdWVzdFwiOltcInNjcVwiXSxcImFwcGxpY2F0aW9uL3NjdnAtY3YtcmVzcG9uc2VcIjpbXCJzY3NcIl0sXCJhcHBsaWNhdGlvbi9zY3ZwLXZwLXJlcXVlc3RcIjpbXCJzcHFcIl0sXCJhcHBsaWNhdGlvbi9zY3ZwLXZwLXJlc3BvbnNlXCI6W1wic3BwXCJdLFwiYXBwbGljYXRpb24vc2RwXCI6W1wic2RwXCJdLFwiYXBwbGljYXRpb24vc2V0LXBheW1lbnQtaW5pdGlhdGlvblwiOltcInNldHBheVwiXSxcImFwcGxpY2F0aW9uL3NldC1yZWdpc3RyYXRpb24taW5pdGlhdGlvblwiOltcInNldHJlZ1wiXSxcImFwcGxpY2F0aW9uL3NoZit4bWxcIjpbXCJzaGZcIl0sXCJhcHBsaWNhdGlvbi9zbWlsK3htbFwiOltcInNtaVwiLFwic21pbFwiXSxcImFwcGxpY2F0aW9uL3NwYXJxbC1xdWVyeVwiOltcInJxXCJdLFwiYXBwbGljYXRpb24vc3BhcnFsLXJlc3VsdHMreG1sXCI6W1wic3J4XCJdLFwiYXBwbGljYXRpb24vc3Jnc1wiOltcImdyYW1cIl0sXCJhcHBsaWNhdGlvbi9zcmdzK3htbFwiOltcImdyeG1sXCJdLFwiYXBwbGljYXRpb24vc3J1K3htbFwiOltcInNydVwiXSxcImFwcGxpY2F0aW9uL3NzZGwreG1sXCI6W1wic3NkbFwiXSxcImFwcGxpY2F0aW9uL3NzbWwreG1sXCI6W1wic3NtbFwiXSxcImFwcGxpY2F0aW9uL3RlaSt4bWxcIjpbXCJ0ZWlcIixcInRlaWNvcnB1c1wiXSxcImFwcGxpY2F0aW9uL3RocmF1ZCt4bWxcIjpbXCJ0ZmlcIl0sXCJhcHBsaWNhdGlvbi90aW1lc3RhbXBlZC1kYXRhXCI6W1widHNkXCJdLFwiYXBwbGljYXRpb24vdm5kLjNncHAucGljLWJ3LWxhcmdlXCI6W1wicGxiXCJdLFwiYXBwbGljYXRpb24vdm5kLjNncHAucGljLWJ3LXNtYWxsXCI6W1wicHNiXCJdLFwiYXBwbGljYXRpb24vdm5kLjNncHAucGljLWJ3LXZhclwiOltcInB2YlwiXSxcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwMi50Y2FwXCI6W1widGNhcFwiXSxcImFwcGxpY2F0aW9uL3ZuZC4zbS5wb3N0LWl0LW5vdGVzXCI6W1wicHduXCJdLFwiYXBwbGljYXRpb24vdm5kLmFjY3BhYy5zaW1wbHkuYXNvXCI6W1wiYXNvXCJdLFwiYXBwbGljYXRpb24vdm5kLmFjY3BhYy5zaW1wbHkuaW1wXCI6W1wiaW1wXCJdLFwiYXBwbGljYXRpb24vdm5kLmFjdWNvYm9sXCI6W1wiYWN1XCJdLFwiYXBwbGljYXRpb24vdm5kLmFjdWNvcnBcIjpbXCJhdGNcIixcImFjdXRjXCJdLFwiYXBwbGljYXRpb24vdm5kLmFkb2JlLmFpci1hcHBsaWNhdGlvbi1pbnN0YWxsZXItcGFja2FnZSt6aXBcIjpbXCJhaXJcIl0sXCJhcHBsaWNhdGlvbi92bmQuYWRvYmUuZm9ybXNjZW50cmFsLmZjZHRcIjpbXCJmY2R0XCJdLFwiYXBwbGljYXRpb24vdm5kLmFkb2JlLmZ4cFwiOltcImZ4cFwiLFwiZnhwbFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5hZG9iZS54ZHAreG1sXCI6W1wieGRwXCJdLFwiYXBwbGljYXRpb24vdm5kLmFkb2JlLnhmZGZcIjpbXCJ4ZmRmXCJdLFwiYXBwbGljYXRpb24vdm5kLmFoZWFkLnNwYWNlXCI6W1wiYWhlYWRcIl0sXCJhcHBsaWNhdGlvbi92bmQuYWlyemlwLmZpbGVzZWN1cmUuYXpmXCI6W1wiYXpmXCJdLFwiYXBwbGljYXRpb24vdm5kLmFpcnppcC5maWxlc2VjdXJlLmF6c1wiOltcImF6c1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5hbWF6b24uZWJvb2tcIjpbXCJhendcIl0sXCJhcHBsaWNhdGlvbi92bmQuYW1lcmljYW5keW5hbWljcy5hY2NcIjpbXCJhY2NcIl0sXCJhcHBsaWNhdGlvbi92bmQuYW1pZ2EuYW1pXCI6W1wiYW1pXCJdLFwiYXBwbGljYXRpb24vdm5kLmFuZHJvaWQucGFja2FnZS1hcmNoaXZlXCI6W1wiYXBrXCJdLFwiYXBwbGljYXRpb24vdm5kLmFuc2VyLXdlYi1jZXJ0aWZpY2F0ZS1pc3N1ZS1pbml0aWF0aW9uXCI6W1wiY2lpXCJdLFwiYXBwbGljYXRpb24vdm5kLmFuc2VyLXdlYi1mdW5kcy10cmFuc2Zlci1pbml0aWF0aW9uXCI6W1wiZnRpXCJdLFwiYXBwbGljYXRpb24vdm5kLmFudGl4LmdhbWUtY29tcG9uZW50XCI6W1wiYXR4XCJdLFwiYXBwbGljYXRpb24vdm5kLmFwcGxlLmluc3RhbGxlcit4bWxcIjpbXCJtcGtnXCJdLFwiYXBwbGljYXRpb24vdm5kLmFwcGxlLm1wZWd1cmxcIjpbXCJtM3U4XCJdLFwiYXBwbGljYXRpb24vdm5kLmFwcGxlLnBrcGFzc1wiOltcInBrcGFzc1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5hcmlzdGFuZXR3b3Jrcy5zd2lcIjpbXCJzd2lcIl0sXCJhcHBsaWNhdGlvbi92bmQuYXN0cmFlYS1zb2Z0d2FyZS5pb3RhXCI6W1wiaW90YVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5hdWRpb2dyYXBoXCI6W1wiYWVwXCJdLFwiYXBwbGljYXRpb24vdm5kLmJsdWVpY2UubXVsdGlwYXNzXCI6W1wibXBtXCJdLFwiYXBwbGljYXRpb24vdm5kLmJtaVwiOltcImJtaVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5idXNpbmVzc29iamVjdHNcIjpbXCJyZXBcIl0sXCJhcHBsaWNhdGlvbi92bmQuY2hlbWRyYXcreG1sXCI6W1wiY2R4bWxcIl0sXCJhcHBsaWNhdGlvbi92bmQuY2hpcG51dHMua2FyYW9rZS1tbWRcIjpbXCJtbWRcIl0sXCJhcHBsaWNhdGlvbi92bmQuY2luZGVyZWxsYVwiOltcImNkeVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5jbGF5bW9yZVwiOltcImNsYVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5jbG9hbnRvLnJwOVwiOltcInJwOVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5jbG9uay5jNGdyb3VwXCI6W1wiYzRnXCIsXCJjNGRcIixcImM0ZlwiLFwiYzRwXCIsXCJjNHVcIl0sXCJhcHBsaWNhdGlvbi92bmQuY2x1ZXRydXN0LmNhcnRvbW9iaWxlLWNvbmZpZ1wiOltcImMxMWFtY1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5jbHVldHJ1c3QuY2FydG9tb2JpbGUtY29uZmlnLXBrZ1wiOltcImMxMWFtelwiXSxcImFwcGxpY2F0aW9uL3ZuZC5jb21tb25zcGFjZVwiOltcImNzcFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5jb250YWN0LmNtc2dcIjpbXCJjZGJjbXNnXCJdLFwiYXBwbGljYXRpb24vdm5kLmNvc21vY2FsbGVyXCI6W1wiY21jXCJdLFwiYXBwbGljYXRpb24vdm5kLmNyaWNrLmNsaWNrZXJcIjpbXCJjbGt4XCJdLFwiYXBwbGljYXRpb24vdm5kLmNyaWNrLmNsaWNrZXIua2V5Ym9hcmRcIjpbXCJjbGtrXCJdLFwiYXBwbGljYXRpb24vdm5kLmNyaWNrLmNsaWNrZXIucGFsZXR0ZVwiOltcImNsa3BcIl0sXCJhcHBsaWNhdGlvbi92bmQuY3JpY2suY2xpY2tlci50ZW1wbGF0ZVwiOltcImNsa3RcIl0sXCJhcHBsaWNhdGlvbi92bmQuY3JpY2suY2xpY2tlci53b3JkYmFua1wiOltcImNsa3dcIl0sXCJhcHBsaWNhdGlvbi92bmQuY3JpdGljYWx0b29scy53YnMreG1sXCI6W1wid2JzXCJdLFwiYXBwbGljYXRpb24vdm5kLmN0Yy1wb3NtbFwiOltcInBtbFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5jdXBzLXBwZFwiOltcInBwZFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5jdXJsLmNhclwiOltcImNhclwiXSxcImFwcGxpY2F0aW9uL3ZuZC5jdXJsLnBjdXJsXCI6W1wicGN1cmxcIl0sXCJhcHBsaWNhdGlvbi92bmQuZGFydFwiOltcImRhcnRcIl0sXCJhcHBsaWNhdGlvbi92bmQuZGF0YS12aXNpb24ucmR6XCI6W1wicmR6XCJdLFwiYXBwbGljYXRpb24vdm5kLmRlY2UuZGF0YVwiOltcInV2ZlwiLFwidXZ2ZlwiLFwidXZkXCIsXCJ1dnZkXCJdLFwiYXBwbGljYXRpb24vdm5kLmRlY2UudHRtbCt4bWxcIjpbXCJ1dnRcIixcInV2dnRcIl0sXCJhcHBsaWNhdGlvbi92bmQuZGVjZS51bnNwZWNpZmllZFwiOltcInV2eFwiLFwidXZ2eFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5kZWNlLnppcFwiOltcInV2elwiLFwidXZ2elwiXSxcImFwcGxpY2F0aW9uL3ZuZC5kZW5vdm8uZmNzZWxheW91dC1saW5rXCI6W1wiZmVfbGF1bmNoXCJdLFwiYXBwbGljYXRpb24vdm5kLmRuYVwiOltcImRuYVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5kb2xieS5tbHBcIjpbXCJtbHBcIl0sXCJhcHBsaWNhdGlvbi92bmQuZHBncmFwaFwiOltcImRwZ1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5kcmVhbWZhY3RvcnlcIjpbXCJkZmFjXCJdLFwiYXBwbGljYXRpb24vdm5kLmRzLWtleXBvaW50XCI6W1wia3B4eFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5kdmIuYWl0XCI6W1wiYWl0XCJdLFwiYXBwbGljYXRpb24vdm5kLmR2Yi5zZXJ2aWNlXCI6W1wic3ZjXCJdLFwiYXBwbGljYXRpb24vdm5kLmR5bmFnZW9cIjpbXCJnZW9cIl0sXCJhcHBsaWNhdGlvbi92bmQuZWNvd2luLmNoYXJ0XCI6W1wibWFnXCJdLFwiYXBwbGljYXRpb24vdm5kLmVubGl2ZW5cIjpbXCJubWxcIl0sXCJhcHBsaWNhdGlvbi92bmQuZXBzb24uZXNmXCI6W1wiZXNmXCJdLFwiYXBwbGljYXRpb24vdm5kLmVwc29uLm1zZlwiOltcIm1zZlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5lcHNvbi5xdWlja2FuaW1lXCI6W1wicWFtXCJdLFwiYXBwbGljYXRpb24vdm5kLmVwc29uLnNhbHRcIjpbXCJzbHRcIl0sXCJhcHBsaWNhdGlvbi92bmQuZXBzb24uc3NmXCI6W1wic3NmXCJdLFwiYXBwbGljYXRpb24vdm5kLmVzemlnbm8zK3htbFwiOltcImVzM1wiLFwiZXQzXCJdLFwiYXBwbGljYXRpb24vdm5kLmV6cGl4LWFsYnVtXCI6W1wiZXoyXCJdLFwiYXBwbGljYXRpb24vdm5kLmV6cGl4LXBhY2thZ2VcIjpbXCJlejNcIl0sXCJhcHBsaWNhdGlvbi92bmQuZmRmXCI6W1wiZmRmXCJdLFwiYXBwbGljYXRpb24vdm5kLmZkc24ubXNlZWRcIjpbXCJtc2VlZFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5mZHNuLnNlZWRcIjpbXCJzZWVkXCIsXCJkYXRhbGVzc1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5mbG9ncmFwaGl0XCI6W1wiZ3BoXCJdLFwiYXBwbGljYXRpb24vdm5kLmZsdXh0aW1lLmNsaXBcIjpbXCJmdGNcIl0sXCJhcHBsaWNhdGlvbi92bmQuZnJhbWVtYWtlclwiOltcImZtXCIsXCJmcmFtZVwiLFwibWFrZXJcIixcImJvb2tcIl0sXCJhcHBsaWNhdGlvbi92bmQuZnJvZ2Fucy5mbmNcIjpbXCJmbmNcIl0sXCJhcHBsaWNhdGlvbi92bmQuZnJvZ2Fucy5sdGZcIjpbXCJsdGZcIl0sXCJhcHBsaWNhdGlvbi92bmQuZnNjLndlYmxhdW5jaFwiOltcImZzY1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5mdWppdHN1Lm9hc3lzXCI6W1wib2FzXCJdLFwiYXBwbGljYXRpb24vdm5kLmZ1aml0c3Uub2FzeXMyXCI6W1wib2EyXCJdLFwiYXBwbGljYXRpb24vdm5kLmZ1aml0c3Uub2FzeXMzXCI6W1wib2EzXCJdLFwiYXBwbGljYXRpb24vdm5kLmZ1aml0c3Uub2FzeXNncFwiOltcImZnNVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5mdWppdHN1Lm9hc3lzcHJzXCI6W1wiYmgyXCJdLFwiYXBwbGljYXRpb24vdm5kLmZ1aml4ZXJveC5kZGRcIjpbXCJkZGRcIl0sXCJhcHBsaWNhdGlvbi92bmQuZnVqaXhlcm94LmRvY3V3b3Jrc1wiOltcInhkd1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5mdWppeGVyb3guZG9jdXdvcmtzLmJpbmRlclwiOltcInhiZFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5mdXp6eXNoZWV0XCI6W1wiZnpzXCJdLFwiYXBwbGljYXRpb24vdm5kLmdlbm9tYXRpeC50dXhlZG9cIjpbXCJ0eGRcIl0sXCJhcHBsaWNhdGlvbi92bmQuZ2VvZ2VicmEuZmlsZVwiOltcImdnYlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5nZW9nZWJyYS50b29sXCI6W1wiZ2d0XCJdLFwiYXBwbGljYXRpb24vdm5kLmdlb21ldHJ5LWV4cGxvcmVyXCI6W1wiZ2V4XCIsXCJncmVcIl0sXCJhcHBsaWNhdGlvbi92bmQuZ2VvbmV4dFwiOltcImd4dFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5nZW9wbGFuXCI6W1wiZzJ3XCJdLFwiYXBwbGljYXRpb24vdm5kLmdlb3NwYWNlXCI6W1wiZzN3XCJdLFwiYXBwbGljYXRpb24vdm5kLmdteFwiOltcImdteFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5nb29nbGUtYXBwcy5kb2N1bWVudFwiOltcImdkb2NcIl0sXCJhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWFwcHMucHJlc2VudGF0aW9uXCI6W1wiZ3NsaWRlc1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5nb29nbGUtYXBwcy5zcHJlYWRzaGVldFwiOltcImdzaGVldFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5nb29nbGUtZWFydGgua21sK3htbFwiOltcImttbFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5nb29nbGUtZWFydGgua216XCI6W1wia216XCJdLFwiYXBwbGljYXRpb24vdm5kLmdyYWZlcVwiOltcImdxZlwiLFwiZ3FzXCJdLFwiYXBwbGljYXRpb24vdm5kLmdyb292ZS1hY2NvdW50XCI6W1wiZ2FjXCJdLFwiYXBwbGljYXRpb24vdm5kLmdyb292ZS1oZWxwXCI6W1wiZ2hmXCJdLFwiYXBwbGljYXRpb24vdm5kLmdyb292ZS1pZGVudGl0eS1tZXNzYWdlXCI6W1wiZ2ltXCJdLFwiYXBwbGljYXRpb24vdm5kLmdyb292ZS1pbmplY3RvclwiOltcImdydlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5ncm9vdmUtdG9vbC1tZXNzYWdlXCI6W1wiZ3RtXCJdLFwiYXBwbGljYXRpb24vdm5kLmdyb292ZS10b29sLXRlbXBsYXRlXCI6W1widHBsXCJdLFwiYXBwbGljYXRpb24vdm5kLmdyb292ZS12Y2FyZFwiOltcInZjZ1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5oYWwreG1sXCI6W1wiaGFsXCJdLFwiYXBwbGljYXRpb24vdm5kLmhhbmRoZWxkLWVudGVydGFpbm1lbnQreG1sXCI6W1wiem1tXCJdLFwiYXBwbGljYXRpb24vdm5kLmhiY2lcIjpbXCJoYmNpXCJdLFwiYXBwbGljYXRpb24vdm5kLmhoZS5sZXNzb24tcGxheWVyXCI6W1wibGVzXCJdLFwiYXBwbGljYXRpb24vdm5kLmhwLWhwZ2xcIjpbXCJocGdsXCJdLFwiYXBwbGljYXRpb24vdm5kLmhwLWhwaWRcIjpbXCJocGlkXCJdLFwiYXBwbGljYXRpb24vdm5kLmhwLWhwc1wiOltcImhwc1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5ocC1qbHl0XCI6W1wiamx0XCJdLFwiYXBwbGljYXRpb24vdm5kLmhwLXBjbFwiOltcInBjbFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5ocC1wY2x4bFwiOltcInBjbHhsXCJdLFwiYXBwbGljYXRpb24vdm5kLmh5ZHJvc3RhdGl4LnNvZi1kYXRhXCI6W1wic2ZkLWhkc3R4XCJdLFwiYXBwbGljYXRpb24vdm5kLmlibS5taW5pcGF5XCI6W1wibXB5XCJdLFwiYXBwbGljYXRpb24vdm5kLmlibS5tb2RjYXBcIjpbXCJhZnBcIixcImxpc3RhZnBcIixcImxpc3QzODIwXCJdLFwiYXBwbGljYXRpb24vdm5kLmlibS5yaWdodHMtbWFuYWdlbWVudFwiOltcImlybVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5pYm0uc2VjdXJlLWNvbnRhaW5lclwiOltcInNjXCJdLFwiYXBwbGljYXRpb24vdm5kLmljY3Byb2ZpbGVcIjpbXCJpY2NcIixcImljbVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5pZ2xvYWRlclwiOltcImlnbFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5pbW1lcnZpc2lvbi1pdnBcIjpbXCJpdnBcIl0sXCJhcHBsaWNhdGlvbi92bmQuaW1tZXJ2aXNpb24taXZ1XCI6W1wiaXZ1XCJdLFwiYXBwbGljYXRpb24vdm5kLmluc29ycy5pZ21cIjpbXCJpZ21cIl0sXCJhcHBsaWNhdGlvbi92bmQuaW50ZXJjb24uZm9ybW5ldFwiOltcInhwd1wiLFwieHB4XCJdLFwiYXBwbGljYXRpb24vdm5kLmludGVyZ2VvXCI6W1wiaTJnXCJdLFwiYXBwbGljYXRpb24vdm5kLmludHUucWJvXCI6W1wicWJvXCJdLFwiYXBwbGljYXRpb24vdm5kLmludHUucWZ4XCI6W1wicWZ4XCJdLFwiYXBwbGljYXRpb24vdm5kLmlwdW5wbHVnZ2VkLnJjcHJvZmlsZVwiOltcInJjcHJvZmlsZVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5pcmVwb3NpdG9yeS5wYWNrYWdlK3htbFwiOltcImlycFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5pcy14cHJcIjpbXCJ4cHJcIl0sXCJhcHBsaWNhdGlvbi92bmQuaXNhYy5mY3NcIjpbXCJmY3NcIl0sXCJhcHBsaWNhdGlvbi92bmQuamFtXCI6W1wiamFtXCJdLFwiYXBwbGljYXRpb24vdm5kLmpjcC5qYXZhbWUubWlkbGV0LXJtc1wiOltcInJtc1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5qaXNwXCI6W1wiamlzcFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5qb29zdC5qb2RhLWFyY2hpdmVcIjpbXCJqb2RhXCJdLFwiYXBwbGljYXRpb24vdm5kLmthaG9vdHpcIjpbXCJrdHpcIixcImt0clwiXSxcImFwcGxpY2F0aW9uL3ZuZC5rZGUua2FyYm9uXCI6W1wia2FyYm9uXCJdLFwiYXBwbGljYXRpb24vdm5kLmtkZS5rY2hhcnRcIjpbXCJjaHJ0XCJdLFwiYXBwbGljYXRpb24vdm5kLmtkZS5rZm9ybXVsYVwiOltcImtmb1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5rZGUua2l2aW9cIjpbXCJmbHdcIl0sXCJhcHBsaWNhdGlvbi92bmQua2RlLmtvbnRvdXJcIjpbXCJrb25cIl0sXCJhcHBsaWNhdGlvbi92bmQua2RlLmtwcmVzZW50ZXJcIjpbXCJrcHJcIixcImtwdFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5rZGUua3NwcmVhZFwiOltcImtzcFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5rZGUua3dvcmRcIjpbXCJrd2RcIixcImt3dFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5rZW5hbWVhYXBwXCI6W1wiaHRrZVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5raWRzcGlyYXRpb25cIjpbXCJraWFcIl0sXCJhcHBsaWNhdGlvbi92bmQua2luYXJcIjpbXCJrbmVcIixcImtucFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5rb2FuXCI6W1wic2twXCIsXCJza2RcIixcInNrdFwiLFwic2ttXCJdLFwiYXBwbGljYXRpb24vdm5kLmtvZGFrLWRlc2NyaXB0b3JcIjpbXCJzc2VcIl0sXCJhcHBsaWNhdGlvbi92bmQubGFzLmxhcyt4bWxcIjpbXCJsYXN4bWxcIl0sXCJhcHBsaWNhdGlvbi92bmQubGxhbWFncmFwaGljcy5saWZlLWJhbGFuY2UuZGVza3RvcFwiOltcImxiZFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5sbGFtYWdyYXBoaWNzLmxpZmUtYmFsYW5jZS5leGNoYW5nZSt4bWxcIjpbXCJsYmVcIl0sXCJhcHBsaWNhdGlvbi92bmQubG90dXMtMS0yLTNcIjpbXCIxMjNcIl0sXCJhcHBsaWNhdGlvbi92bmQubG90dXMtYXBwcm9hY2hcIjpbXCJhcHJcIl0sXCJhcHBsaWNhdGlvbi92bmQubG90dXMtZnJlZWxhbmNlXCI6W1wicHJlXCJdLFwiYXBwbGljYXRpb24vdm5kLmxvdHVzLW5vdGVzXCI6W1wibnNmXCJdLFwiYXBwbGljYXRpb24vdm5kLmxvdHVzLW9yZ2FuaXplclwiOltcIm9yZ1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5sb3R1cy1zY3JlZW5jYW1cIjpbXCJzY21cIl0sXCJhcHBsaWNhdGlvbi92bmQubG90dXMtd29yZHByb1wiOltcImx3cFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tYWNwb3J0cy5wb3J0cGtnXCI6W1wicG9ydHBrZ1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5tY2RcIjpbXCJtY2RcIl0sXCJhcHBsaWNhdGlvbi92bmQubWVkY2FsY2RhdGFcIjpbXCJtYzFcIl0sXCJhcHBsaWNhdGlvbi92bmQubWVkaWFzdGF0aW9uLmNka2V5XCI6W1wiY2RrZXlcIl0sXCJhcHBsaWNhdGlvbi92bmQubWZlclwiOltcIm13ZlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tZm1wXCI6W1wibWZtXCJdLFwiYXBwbGljYXRpb24vdm5kLm1pY3JvZ3JhZnguZmxvXCI6W1wiZmxvXCJdLFwiYXBwbGljYXRpb24vdm5kLm1pY3JvZ3JhZnguaWd4XCI6W1wiaWd4XCJdLFwiYXBwbGljYXRpb24vdm5kLm1pZlwiOltcIm1pZlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tb2JpdXMuZGFmXCI6W1wiZGFmXCJdLFwiYXBwbGljYXRpb24vdm5kLm1vYml1cy5kaXNcIjpbXCJkaXNcIl0sXCJhcHBsaWNhdGlvbi92bmQubW9iaXVzLm1ia1wiOltcIm1ia1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5tb2JpdXMubXF5XCI6W1wibXF5XCJdLFwiYXBwbGljYXRpb24vdm5kLm1vYml1cy5tc2xcIjpbXCJtc2xcIl0sXCJhcHBsaWNhdGlvbi92bmQubW9iaXVzLnBsY1wiOltcInBsY1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5tb2JpdXMudHhmXCI6W1widHhmXCJdLFwiYXBwbGljYXRpb24vdm5kLm1vcGh1bi5hcHBsaWNhdGlvblwiOltcIm1wblwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tb3BodW4uY2VydGlmaWNhdGVcIjpbXCJtcGNcIl0sXCJhcHBsaWNhdGlvbi92bmQubW96aWxsYS54dWwreG1sXCI6W1wieHVsXCJdLFwiYXBwbGljYXRpb24vdm5kLm1zLWFydGdhbHJ5XCI6W1wiY2lsXCJdLFwiYXBwbGljYXRpb24vdm5kLm1zLWNhYi1jb21wcmVzc2VkXCI6W1wiY2FiXCJdLFwiYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsXCI6W1wieGxzXCIsXCJ4bG1cIixcInhsYVwiLFwieGxjXCIsXCJ4bHRcIixcInhsd1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5hZGRpbi5tYWNyb2VuYWJsZWQuMTJcIjpbXCJ4bGFtXCJdLFwiYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLnNoZWV0LmJpbmFyeS5tYWNyb2VuYWJsZWQuMTJcIjpbXCJ4bHNiXCJdLFwiYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLnNoZWV0Lm1hY3JvZW5hYmxlZC4xMlwiOltcInhsc21cIl0sXCJhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwudGVtcGxhdGUubWFjcm9lbmFibGVkLjEyXCI6W1wieGx0bVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1mb250b2JqZWN0XCI6W1wiZW90XCJdLFwiYXBwbGljYXRpb24vdm5kLm1zLWh0bWxoZWxwXCI6W1wiY2htXCJdLFwiYXBwbGljYXRpb24vdm5kLm1zLWltc1wiOltcImltc1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1scm1cIjpbXCJscm1cIl0sXCJhcHBsaWNhdGlvbi92bmQubXMtb2ZmaWNldGhlbWVcIjpbXCJ0aG14XCJdLFwiYXBwbGljYXRpb24vdm5kLm1zLW91dGxvb2tcIjpbXCJtc2dcIl0sXCJhcHBsaWNhdGlvbi92bmQubXMtcGtpLnNlY2NhdFwiOltcImNhdFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1wa2kuc3RsXCI6W1wic3RsXCJdLFwiYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnRcIjpbXCJwcHRcIixcInBwc1wiLFwicG90XCJdLFwiYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQuYWRkaW4ubWFjcm9lbmFibGVkLjEyXCI6W1wicHBhbVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LnByZXNlbnRhdGlvbi5tYWNyb2VuYWJsZWQuMTJcIjpbXCJwcHRtXCJdLFwiYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQuc2xpZGUubWFjcm9lbmFibGVkLjEyXCI6W1wic2xkbVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LnNsaWRlc2hvdy5tYWNyb2VuYWJsZWQuMTJcIjpbXCJwcHNtXCJdLFwiYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQudGVtcGxhdGUubWFjcm9lbmFibGVkLjEyXCI6W1wicG90bVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1wcm9qZWN0XCI6W1wibXBwXCIsXCJtcHRcIl0sXCJhcHBsaWNhdGlvbi92bmQubXMtd29yZC5kb2N1bWVudC5tYWNyb2VuYWJsZWQuMTJcIjpbXCJkb2NtXCJdLFwiYXBwbGljYXRpb24vdm5kLm1zLXdvcmQudGVtcGxhdGUubWFjcm9lbmFibGVkLjEyXCI6W1wiZG90bVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tcy13b3Jrc1wiOltcIndwc1wiLFwid2tzXCIsXCJ3Y21cIixcIndkYlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tcy13cGxcIjpbXCJ3cGxcIl0sXCJhcHBsaWNhdGlvbi92bmQubXMteHBzZG9jdW1lbnRcIjpbXCJ4cHNcIl0sXCJhcHBsaWNhdGlvbi92bmQubXNlcVwiOltcIm1zZXFcIl0sXCJhcHBsaWNhdGlvbi92bmQubXVzaWNpYW5cIjpbXCJtdXNcIl0sXCJhcHBsaWNhdGlvbi92bmQubXV2ZWUuc3R5bGVcIjpbXCJtc3R5XCJdLFwiYXBwbGljYXRpb24vdm5kLm15bmZjXCI6W1widGFnbGV0XCJdLFwiYXBwbGljYXRpb24vdm5kLm5ldXJvbGFuZ3VhZ2Uubmx1XCI6W1wibmx1XCJdLFwiYXBwbGljYXRpb24vdm5kLm5pdGZcIjpbXCJudGZcIixcIm5pdGZcIl0sXCJhcHBsaWNhdGlvbi92bmQubm9ibGVuZXQtZGlyZWN0b3J5XCI6W1wibm5kXCJdLFwiYXBwbGljYXRpb24vdm5kLm5vYmxlbmV0LXNlYWxlclwiOltcIm5uc1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5ub2JsZW5ldC13ZWJcIjpbXCJubndcIl0sXCJhcHBsaWNhdGlvbi92bmQubm9raWEubi1nYWdlLmRhdGFcIjpbXCJuZ2RhdFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5ub2tpYS5uLWdhZ2Uuc3ltYmlhbi5pbnN0YWxsXCI6W1wibi1nYWdlXCJdLFwiYXBwbGljYXRpb24vdm5kLm5va2lhLnJhZGlvLXByZXNldFwiOltcInJwc3RcIl0sXCJhcHBsaWNhdGlvbi92bmQubm9raWEucmFkaW8tcHJlc2V0c1wiOltcInJwc3NcIl0sXCJhcHBsaWNhdGlvbi92bmQubm92YWRpZ20uZWRtXCI6W1wiZWRtXCJdLFwiYXBwbGljYXRpb24vdm5kLm5vdmFkaWdtLmVkeFwiOltcImVkeFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5ub3ZhZGlnbS5leHRcIjpbXCJleHRcIl0sXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmNoYXJ0XCI6W1wib2RjXCJdLFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5jaGFydC10ZW1wbGF0ZVwiOltcIm90Y1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuZGF0YWJhc2VcIjpbXCJvZGJcIl0sXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmZvcm11bGFcIjpbXCJvZGZcIl0sXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmZvcm11bGEtdGVtcGxhdGVcIjpbXCJvZGZ0XCJdLFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5ncmFwaGljc1wiOltcIm9kZ1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuZ3JhcGhpY3MtdGVtcGxhdGVcIjpbXCJvdGdcIl0sXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmltYWdlXCI6W1wib2RpXCJdLFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5pbWFnZS10ZW1wbGF0ZVwiOltcIm90aVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQucHJlc2VudGF0aW9uXCI6W1wib2RwXCJdLFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5wcmVzZW50YXRpb24tdGVtcGxhdGVcIjpbXCJvdHBcIl0sXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnNwcmVhZHNoZWV0XCI6W1wib2RzXCJdLFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5zcHJlYWRzaGVldC10ZW1wbGF0ZVwiOltcIm90c1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQudGV4dFwiOltcIm9kdFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQudGV4dC1tYXN0ZXJcIjpbXCJvZG1cIl0sXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHQtdGVtcGxhdGVcIjpbXCJvdHRcIl0sXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHQtd2ViXCI6W1wib3RoXCJdLFwiYXBwbGljYXRpb24vdm5kLm9scGMtc3VnYXJcIjpbXCJ4b1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5vbWEuZGQyK3htbFwiOltcImRkMlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVub2ZmaWNlb3JnLmV4dGVuc2lvblwiOltcIm94dFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5wcmVzZW50YXRpb25cIjpbXCJwcHR4XCJdLFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnNsaWRlXCI6W1wic2xkeFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5zbGlkZXNob3dcIjpbXCJwcHN4XCJdLFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnRlbXBsYXRlXCI6W1wicG90eFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0XCI6W1wieGxzeFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnRlbXBsYXRlXCI6W1wieGx0eFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmRvY3VtZW50XCI6W1wiZG9jeFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLnRlbXBsYXRlXCI6W1wiZG90eFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5vc2dlby5tYXBndWlkZS5wYWNrYWdlXCI6W1wibWdwXCJdLFwiYXBwbGljYXRpb24vdm5kLm9zZ2kuZHBcIjpbXCJkcFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5vc2dpLnN1YnN5c3RlbVwiOltcImVzYVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5wYWxtXCI6W1wicGRiXCIsXCJwcWFcIixcIm9wcmNcIl0sXCJhcHBsaWNhdGlvbi92bmQucGF3YWFmaWxlXCI6W1wicGF3XCJdLFwiYXBwbGljYXRpb24vdm5kLnBnLmZvcm1hdFwiOltcInN0clwiXSxcImFwcGxpY2F0aW9uL3ZuZC5wZy5vc2FzbGlcIjpbXCJlaTZcIl0sXCJhcHBsaWNhdGlvbi92bmQucGljc2VsXCI6W1wiZWZpZlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5wbWkud2lkZ2V0XCI6W1wid2dcIl0sXCJhcHBsaWNhdGlvbi92bmQucG9ja2V0bGVhcm5cIjpbXCJwbGZcIl0sXCJhcHBsaWNhdGlvbi92bmQucG93ZXJidWlsZGVyNlwiOltcInBiZFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5wcmV2aWV3c3lzdGVtcy5ib3hcIjpbXCJib3hcIl0sXCJhcHBsaWNhdGlvbi92bmQucHJvdGV1cy5tYWdhemluZVwiOltcIm1nelwiXSxcImFwcGxpY2F0aW9uL3ZuZC5wdWJsaXNoYXJlLWRlbHRhLXRyZWVcIjpbXCJxcHNcIl0sXCJhcHBsaWNhdGlvbi92bmQucHZpLnB0aWQxXCI6W1wicHRpZFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5xdWFyay5xdWFya3hwcmVzc1wiOltcInF4ZFwiLFwicXh0XCIsXCJxd2RcIixcInF3dFwiLFwicXhsXCIsXCJxeGJcIl0sXCJhcHBsaWNhdGlvbi92bmQucmVhbHZuYy5iZWRcIjpbXCJiZWRcIl0sXCJhcHBsaWNhdGlvbi92bmQucmVjb3JkYXJlLm11c2ljeG1sXCI6W1wibXhsXCJdLFwiYXBwbGljYXRpb24vdm5kLnJlY29yZGFyZS5tdXNpY3htbCt4bWxcIjpbXCJtdXNpY3htbFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5yaWcuY3J5cHRvbm90ZVwiOltcImNyeXB0b25vdGVcIl0sXCJhcHBsaWNhdGlvbi92bmQucmltLmNvZFwiOltcImNvZFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5ybi1yZWFsbWVkaWFcIjpbXCJybVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5ybi1yZWFsbWVkaWEtdmJyXCI6W1wicm12YlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5yb3V0ZTY2Lmxpbms2Nit4bWxcIjpbXCJsaW5rNjZcIl0sXCJhcHBsaWNhdGlvbi92bmQuc2FpbGluZ3RyYWNrZXIudHJhY2tcIjpbXCJzdFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5zZWVtYWlsXCI6W1wic2VlXCJdLFwiYXBwbGljYXRpb24vdm5kLnNlbWFcIjpbXCJzZW1hXCJdLFwiYXBwbGljYXRpb24vdm5kLnNlbWRcIjpbXCJzZW1kXCJdLFwiYXBwbGljYXRpb24vdm5kLnNlbWZcIjpbXCJzZW1mXCJdLFwiYXBwbGljYXRpb24vdm5kLnNoYW5hLmluZm9ybWVkLmZvcm1kYXRhXCI6W1wiaWZtXCJdLFwiYXBwbGljYXRpb24vdm5kLnNoYW5hLmluZm9ybWVkLmZvcm10ZW1wbGF0ZVwiOltcIml0cFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5zaGFuYS5pbmZvcm1lZC5pbnRlcmNoYW5nZVwiOltcImlpZlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5zaGFuYS5pbmZvcm1lZC5wYWNrYWdlXCI6W1wiaXBrXCJdLFwiYXBwbGljYXRpb24vdm5kLnNpbXRlY2gtbWluZG1hcHBlclwiOltcInR3ZFwiLFwidHdkc1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5zbWFmXCI6W1wibW1mXCJdLFwiYXBwbGljYXRpb24vdm5kLnNtYXJ0LnRlYWNoZXJcIjpbXCJ0ZWFjaGVyXCJdLFwiYXBwbGljYXRpb24vdm5kLnNvbGVudC5zZGttK3htbFwiOltcInNka21cIixcInNka2RcIl0sXCJhcHBsaWNhdGlvbi92bmQuc3BvdGZpcmUuZHhwXCI6W1wiZHhwXCJdLFwiYXBwbGljYXRpb24vdm5kLnNwb3RmaXJlLnNmc1wiOltcInNmc1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5zdGFyZGl2aXNpb24uY2FsY1wiOltcInNkY1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5zdGFyZGl2aXNpb24uZHJhd1wiOltcInNkYVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5zdGFyZGl2aXNpb24uaW1wcmVzc1wiOltcInNkZFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5zdGFyZGl2aXNpb24ubWF0aFwiOltcInNtZlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5zdGFyZGl2aXNpb24ud3JpdGVyXCI6W1wic2R3XCIsXCJ2b3JcIl0sXCJhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLndyaXRlci1nbG9iYWxcIjpbXCJzZ2xcIl0sXCJhcHBsaWNhdGlvbi92bmQuc3RlcG1hbmlhLnBhY2thZ2VcIjpbXCJzbXppcFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5zdGVwbWFuaWEuc3RlcGNoYXJ0XCI6W1wic21cIl0sXCJhcHBsaWNhdGlvbi92bmQuc3VuLndhZGwreG1sXCI6W1wid2FkbFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLmNhbGNcIjpbXCJzeGNcIl0sXCJhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC5jYWxjLnRlbXBsYXRlXCI6W1wic3RjXCJdLFwiYXBwbGljYXRpb24vdm5kLnN1bi54bWwuZHJhd1wiOltcInN4ZFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLmRyYXcudGVtcGxhdGVcIjpbXCJzdGRcIl0sXCJhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC5pbXByZXNzXCI6W1wic3hpXCJdLFwiYXBwbGljYXRpb24vdm5kLnN1bi54bWwuaW1wcmVzcy50ZW1wbGF0ZVwiOltcInN0aVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLm1hdGhcIjpbXCJzeG1cIl0sXCJhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC53cml0ZXJcIjpbXCJzeHdcIl0sXCJhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC53cml0ZXIuZ2xvYmFsXCI6W1wic3hnXCJdLFwiYXBwbGljYXRpb24vdm5kLnN1bi54bWwud3JpdGVyLnRlbXBsYXRlXCI6W1wic3R3XCJdLFwiYXBwbGljYXRpb24vdm5kLnN1cy1jYWxlbmRhclwiOltcInN1c1wiLFwic3VzcFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5zdmRcIjpbXCJzdmRcIl0sXCJhcHBsaWNhdGlvbi92bmQuc3ltYmlhbi5pbnN0YWxsXCI6W1wic2lzXCIsXCJzaXN4XCJdLFwiYXBwbGljYXRpb24vdm5kLnN5bmNtbCt4bWxcIjpbXCJ4c21cIl0sXCJhcHBsaWNhdGlvbi92bmQuc3luY21sLmRtK3dieG1sXCI6W1wiYmRtXCJdLFwiYXBwbGljYXRpb24vdm5kLnN5bmNtbC5kbSt4bWxcIjpbXCJ4ZG1cIl0sXCJhcHBsaWNhdGlvbi92bmQudGFvLmludGVudC1tb2R1bGUtYXJjaGl2ZVwiOltcInRhb1wiXSxcImFwcGxpY2F0aW9uL3ZuZC50Y3BkdW1wLnBjYXBcIjpbXCJwY2FwXCIsXCJjYXBcIixcImRtcFwiXSxcImFwcGxpY2F0aW9uL3ZuZC50bW9iaWxlLWxpdmV0dlwiOltcInRtb1wiXSxcImFwcGxpY2F0aW9uL3ZuZC50cmlkLnRwdFwiOltcInRwdFwiXSxcImFwcGxpY2F0aW9uL3ZuZC50cmlzY2FwZS5teHNcIjpbXCJteHNcIl0sXCJhcHBsaWNhdGlvbi92bmQudHJ1ZWFwcFwiOltcInRyYVwiXSxcImFwcGxpY2F0aW9uL3ZuZC51ZmRsXCI6W1widWZkXCIsXCJ1ZmRsXCJdLFwiYXBwbGljYXRpb24vdm5kLnVpcS50aGVtZVwiOltcInV0elwiXSxcImFwcGxpY2F0aW9uL3ZuZC51bWFqaW5cIjpbXCJ1bWpcIl0sXCJhcHBsaWNhdGlvbi92bmQudW5pdHlcIjpbXCJ1bml0eXdlYlwiXSxcImFwcGxpY2F0aW9uL3ZuZC51b21sK3htbFwiOltcInVvbWxcIl0sXCJhcHBsaWNhdGlvbi92bmQudmN4XCI6W1widmN4XCJdLFwiYXBwbGljYXRpb24vdm5kLnZpc2lvXCI6W1widnNkXCIsXCJ2c3RcIixcInZzc1wiLFwidnN3XCJdLFwiYXBwbGljYXRpb24vdm5kLnZpc2lvbmFyeVwiOltcInZpc1wiXSxcImFwcGxpY2F0aW9uL3ZuZC52c2ZcIjpbXCJ2c2ZcIl0sXCJhcHBsaWNhdGlvbi92bmQud2FwLndieG1sXCI6W1wid2J4bWxcIl0sXCJhcHBsaWNhdGlvbi92bmQud2FwLndtbGNcIjpbXCJ3bWxjXCJdLFwiYXBwbGljYXRpb24vdm5kLndhcC53bWxzY3JpcHRjXCI6W1wid21sc2NcIl0sXCJhcHBsaWNhdGlvbi92bmQud2VidHVyYm9cIjpbXCJ3dGJcIl0sXCJhcHBsaWNhdGlvbi92bmQud29sZnJhbS5wbGF5ZXJcIjpbXCJuYnBcIl0sXCJhcHBsaWNhdGlvbi92bmQud29yZHBlcmZlY3RcIjpbXCJ3cGRcIl0sXCJhcHBsaWNhdGlvbi92bmQud3FkXCI6W1wid3FkXCJdLFwiYXBwbGljYXRpb24vdm5kLnd0LnN0ZlwiOltcInN0ZlwiXSxcImFwcGxpY2F0aW9uL3ZuZC54YXJhXCI6W1wieGFyXCJdLFwiYXBwbGljYXRpb24vdm5kLnhmZGxcIjpbXCJ4ZmRsXCJdLFwiYXBwbGljYXRpb24vdm5kLnlhbWFoYS5odi1kaWNcIjpbXCJodmRcIl0sXCJhcHBsaWNhdGlvbi92bmQueWFtYWhhLmh2LXNjcmlwdFwiOltcImh2c1wiXSxcImFwcGxpY2F0aW9uL3ZuZC55YW1haGEuaHYtdm9pY2VcIjpbXCJodnBcIl0sXCJhcHBsaWNhdGlvbi92bmQueWFtYWhhLm9wZW5zY29yZWZvcm1hdFwiOltcIm9zZlwiXSxcImFwcGxpY2F0aW9uL3ZuZC55YW1haGEub3BlbnNjb3JlZm9ybWF0Lm9zZnB2Zyt4bWxcIjpbXCJvc2ZwdmdcIl0sXCJhcHBsaWNhdGlvbi92bmQueWFtYWhhLnNtYWYtYXVkaW9cIjpbXCJzYWZcIl0sXCJhcHBsaWNhdGlvbi92bmQueWFtYWhhLnNtYWYtcGhyYXNlXCI6W1wic3BmXCJdLFwiYXBwbGljYXRpb24vdm5kLnllbGxvd3JpdmVyLWN1c3RvbS1tZW51XCI6W1wiY21wXCJdLFwiYXBwbGljYXRpb24vdm5kLnp1bFwiOltcInppclwiLFwiemlyelwiXSxcImFwcGxpY2F0aW9uL3ZuZC56emF6ei5kZWNrK3htbFwiOltcInphelwiXSxcImFwcGxpY2F0aW9uL3ZvaWNleG1sK3htbFwiOltcInZ4bWxcIl0sXCJhcHBsaWNhdGlvbi93aWRnZXRcIjpbXCJ3Z3RcIl0sXCJhcHBsaWNhdGlvbi93aW5obHBcIjpbXCJobHBcIl0sXCJhcHBsaWNhdGlvbi93c2RsK3htbFwiOltcIndzZGxcIl0sXCJhcHBsaWNhdGlvbi93c3BvbGljeSt4bWxcIjpbXCJ3c3BvbGljeVwiXSxcImFwcGxpY2F0aW9uL3gtN3otY29tcHJlc3NlZFwiOltcIjd6XCJdLFwiYXBwbGljYXRpb24veC1hYml3b3JkXCI6W1wiYWJ3XCJdLFwiYXBwbGljYXRpb24veC1hY2UtY29tcHJlc3NlZFwiOltcImFjZVwiXSxcImFwcGxpY2F0aW9uL3gtYXBwbGUtZGlza2ltYWdlXCI6W1wiZG1nXCJdLFwiYXBwbGljYXRpb24veC1hcmpcIjpbXCJhcmpcIl0sXCJhcHBsaWNhdGlvbi94LWF1dGhvcndhcmUtYmluXCI6W1wiYWFiXCIsXCJ4MzJcIixcInUzMlwiLFwidm94XCJdLFwiYXBwbGljYXRpb24veC1hdXRob3J3YXJlLW1hcFwiOltcImFhbVwiXSxcImFwcGxpY2F0aW9uL3gtYXV0aG9yd2FyZS1zZWdcIjpbXCJhYXNcIl0sXCJhcHBsaWNhdGlvbi94LWJjcGlvXCI6W1wiYmNwaW9cIl0sXCJhcHBsaWNhdGlvbi94LWJkb2NcIjpbXCJiZG9jXCJdLFwiYXBwbGljYXRpb24veC1iaXR0b3JyZW50XCI6W1widG9ycmVudFwiXSxcImFwcGxpY2F0aW9uL3gtYmxvcmJcIjpbXCJibGJcIixcImJsb3JiXCJdLFwiYXBwbGljYXRpb24veC1iemlwXCI6W1wiYnpcIl0sXCJhcHBsaWNhdGlvbi94LWJ6aXAyXCI6W1wiYnoyXCIsXCJib3pcIl0sXCJhcHBsaWNhdGlvbi94LWNiclwiOltcImNiclwiLFwiY2JhXCIsXCJjYnRcIixcImNielwiLFwiY2I3XCJdLFwiYXBwbGljYXRpb24veC1jZGxpbmtcIjpbXCJ2Y2RcIl0sXCJhcHBsaWNhdGlvbi94LWNmcy1jb21wcmVzc2VkXCI6W1wiY2ZzXCJdLFwiYXBwbGljYXRpb24veC1jaGF0XCI6W1wiY2hhdFwiXSxcImFwcGxpY2F0aW9uL3gtY2hlc3MtcGduXCI6W1wicGduXCJdLFwiYXBwbGljYXRpb24veC1jaHJvbWUtZXh0ZW5zaW9uXCI6W1wiY3J4XCJdLFwiYXBwbGljYXRpb24veC1jb2NvYVwiOltcImNjb1wiXSxcImFwcGxpY2F0aW9uL3gtY29uZmVyZW5jZVwiOltcIm5zY1wiXSxcImFwcGxpY2F0aW9uL3gtY3Bpb1wiOltcImNwaW9cIl0sXCJhcHBsaWNhdGlvbi94LWNzaFwiOltcImNzaFwiXSxcImFwcGxpY2F0aW9uL3gtZGViaWFuLXBhY2thZ2VcIjpbXCJkZWJcIixcInVkZWJcIl0sXCJhcHBsaWNhdGlvbi94LWRnYy1jb21wcmVzc2VkXCI6W1wiZGdjXCJdLFwiYXBwbGljYXRpb24veC1kaXJlY3RvclwiOltcImRpclwiLFwiZGNyXCIsXCJkeHJcIixcImNzdFwiLFwiY2N0XCIsXCJjeHRcIixcInczZFwiLFwiZmdkXCIsXCJzd2FcIl0sXCJhcHBsaWNhdGlvbi94LWRvb21cIjpbXCJ3YWRcIl0sXCJhcHBsaWNhdGlvbi94LWR0Ym5jeCt4bWxcIjpbXCJuY3hcIl0sXCJhcHBsaWNhdGlvbi94LWR0Ym9vayt4bWxcIjpbXCJkdGJcIl0sXCJhcHBsaWNhdGlvbi94LWR0YnJlc291cmNlK3htbFwiOltcInJlc1wiXSxcImFwcGxpY2F0aW9uL3gtZHZpXCI6W1wiZHZpXCJdLFwiYXBwbGljYXRpb24veC1lbnZveVwiOltcImV2eVwiXSxcImFwcGxpY2F0aW9uL3gtZXZhXCI6W1wiZXZhXCJdLFwiYXBwbGljYXRpb24veC1mb250LWJkZlwiOltcImJkZlwiXSxcImFwcGxpY2F0aW9uL3gtZm9udC1naG9zdHNjcmlwdFwiOltcImdzZlwiXSxcImFwcGxpY2F0aW9uL3gtZm9udC1saW51eC1wc2ZcIjpbXCJwc2ZcIl0sXCJhcHBsaWNhdGlvbi94LWZvbnQtb3RmXCI6W1wib3RmXCJdLFwiYXBwbGljYXRpb24veC1mb250LXBjZlwiOltcInBjZlwiXSxcImFwcGxpY2F0aW9uL3gtZm9udC1zbmZcIjpbXCJzbmZcIl0sXCJhcHBsaWNhdGlvbi94LWZvbnQtdHRmXCI6W1widHRmXCIsXCJ0dGNcIl0sXCJhcHBsaWNhdGlvbi94LWZvbnQtdHlwZTFcIjpbXCJwZmFcIixcInBmYlwiLFwicGZtXCIsXCJhZm1cIl0sXCJhcHBsaWNhdGlvbi94LWZyZWVhcmNcIjpbXCJhcmNcIl0sXCJhcHBsaWNhdGlvbi94LWZ1dHVyZXNwbGFzaFwiOltcInNwbFwiXSxcImFwcGxpY2F0aW9uL3gtZ2NhLWNvbXByZXNzZWRcIjpbXCJnY2FcIl0sXCJhcHBsaWNhdGlvbi94LWdsdWx4XCI6W1widWx4XCJdLFwiYXBwbGljYXRpb24veC1nbnVtZXJpY1wiOltcImdudW1lcmljXCJdLFwiYXBwbGljYXRpb24veC1ncmFtcHMteG1sXCI6W1wiZ3JhbXBzXCJdLFwiYXBwbGljYXRpb24veC1ndGFyXCI6W1wiZ3RhclwiXSxcImFwcGxpY2F0aW9uL3gtaGRmXCI6W1wiaGRmXCJdLFwiYXBwbGljYXRpb24veC1odHRwZC1waHBcIjpbXCJwaHBcIl0sXCJhcHBsaWNhdGlvbi94LWluc3RhbGwtaW5zdHJ1Y3Rpb25zXCI6W1wiaW5zdGFsbFwiXSxcImFwcGxpY2F0aW9uL3gtaXNvOTY2MC1pbWFnZVwiOltcImlzb1wiXSxcImFwcGxpY2F0aW9uL3gtamF2YS1hcmNoaXZlLWRpZmZcIjpbXCJqYXJkaWZmXCJdLFwiYXBwbGljYXRpb24veC1qYXZhLWpubHAtZmlsZVwiOltcImpubHBcIl0sXCJhcHBsaWNhdGlvbi94LWxhdGV4XCI6W1wibGF0ZXhcIl0sXCJhcHBsaWNhdGlvbi94LWx1YS1ieXRlY29kZVwiOltcImx1YWNcIl0sXCJhcHBsaWNhdGlvbi94LWx6aC1jb21wcmVzc2VkXCI6W1wibHpoXCIsXCJsaGFcIl0sXCJhcHBsaWNhdGlvbi94LW1ha2VzZWxmXCI6W1wicnVuXCJdLFwiYXBwbGljYXRpb24veC1taWVcIjpbXCJtaWVcIl0sXCJhcHBsaWNhdGlvbi94LW1vYmlwb2NrZXQtZWJvb2tcIjpbXCJwcmNcIixcIm1vYmlcIl0sXCJhcHBsaWNhdGlvbi94LW1zLWFwcGxpY2F0aW9uXCI6W1wiYXBwbGljYXRpb25cIl0sXCJhcHBsaWNhdGlvbi94LW1zLXNob3J0Y3V0XCI6W1wibG5rXCJdLFwiYXBwbGljYXRpb24veC1tcy13bWRcIjpbXCJ3bWRcIl0sXCJhcHBsaWNhdGlvbi94LW1zLXdtelwiOltcIndtelwiXSxcImFwcGxpY2F0aW9uL3gtbXMteGJhcFwiOltcInhiYXBcIl0sXCJhcHBsaWNhdGlvbi94LW1zYWNjZXNzXCI6W1wibWRiXCJdLFwiYXBwbGljYXRpb24veC1tc2JpbmRlclwiOltcIm9iZFwiXSxcImFwcGxpY2F0aW9uL3gtbXNjYXJkZmlsZVwiOltcImNyZFwiXSxcImFwcGxpY2F0aW9uL3gtbXNjbGlwXCI6W1wiY2xwXCJdLFwiYXBwbGljYXRpb24veC1tc2Rvcy1wcm9ncmFtXCI6W1wiZXhlXCJdLFwiYXBwbGljYXRpb24veC1tc2Rvd25sb2FkXCI6W1wiZXhlXCIsXCJkbGxcIixcImNvbVwiLFwiYmF0XCIsXCJtc2lcIl0sXCJhcHBsaWNhdGlvbi94LW1zbWVkaWF2aWV3XCI6W1wibXZiXCIsXCJtMTNcIixcIm0xNFwiXSxcImFwcGxpY2F0aW9uL3gtbXNtZXRhZmlsZVwiOltcIndtZlwiLFwid216XCIsXCJlbWZcIixcImVtelwiXSxcImFwcGxpY2F0aW9uL3gtbXNtb25leVwiOltcIm1ueVwiXSxcImFwcGxpY2F0aW9uL3gtbXNwdWJsaXNoZXJcIjpbXCJwdWJcIl0sXCJhcHBsaWNhdGlvbi94LW1zc2NoZWR1bGVcIjpbXCJzY2RcIl0sXCJhcHBsaWNhdGlvbi94LW1zdGVybWluYWxcIjpbXCJ0cm1cIl0sXCJhcHBsaWNhdGlvbi94LW1zd3JpdGVcIjpbXCJ3cmlcIl0sXCJhcHBsaWNhdGlvbi94LW5ldGNkZlwiOltcIm5jXCIsXCJjZGZcIl0sXCJhcHBsaWNhdGlvbi94LW5zLXByb3h5LWF1dG9jb25maWdcIjpbXCJwYWNcIl0sXCJhcHBsaWNhdGlvbi94LW56YlwiOltcIm56YlwiXSxcImFwcGxpY2F0aW9uL3gtcGVybFwiOltcInBsXCIsXCJwbVwiXSxcImFwcGxpY2F0aW9uL3gtcGlsb3RcIjpbXCJwcmNcIixcInBkYlwiXSxcImFwcGxpY2F0aW9uL3gtcGtjczEyXCI6W1wicDEyXCIsXCJwZnhcIl0sXCJhcHBsaWNhdGlvbi94LXBrY3M3LWNlcnRpZmljYXRlc1wiOltcInA3YlwiLFwic3BjXCJdLFwiYXBwbGljYXRpb24veC1wa2NzNy1jZXJ0cmVxcmVzcFwiOltcInA3clwiXSxcImFwcGxpY2F0aW9uL3gtcmFyLWNvbXByZXNzZWRcIjpbXCJyYXJcIl0sXCJhcHBsaWNhdGlvbi94LXJlZGhhdC1wYWNrYWdlLW1hbmFnZXJcIjpbXCJycG1cIl0sXCJhcHBsaWNhdGlvbi94LXJlc2VhcmNoLWluZm8tc3lzdGVtc1wiOltcInJpc1wiXSxcImFwcGxpY2F0aW9uL3gtc2VhXCI6W1wic2VhXCJdLFwiYXBwbGljYXRpb24veC1zaFwiOltcInNoXCJdLFwiYXBwbGljYXRpb24veC1zaGFyXCI6W1wic2hhclwiXSxcImFwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoXCI6W1wic3dmXCJdLFwiYXBwbGljYXRpb24veC1zaWx2ZXJsaWdodC1hcHBcIjpbXCJ4YXBcIl0sXCJhcHBsaWNhdGlvbi94LXNxbFwiOltcInNxbFwiXSxcImFwcGxpY2F0aW9uL3gtc3R1ZmZpdFwiOltcInNpdFwiXSxcImFwcGxpY2F0aW9uL3gtc3R1ZmZpdHhcIjpbXCJzaXR4XCJdLFwiYXBwbGljYXRpb24veC1zdWJyaXBcIjpbXCJzcnRcIl0sXCJhcHBsaWNhdGlvbi94LXN2NGNwaW9cIjpbXCJzdjRjcGlvXCJdLFwiYXBwbGljYXRpb24veC1zdjRjcmNcIjpbXCJzdjRjcmNcIl0sXCJhcHBsaWNhdGlvbi94LXQzdm0taW1hZ2VcIjpbXCJ0M1wiXSxcImFwcGxpY2F0aW9uL3gtdGFkc1wiOltcImdhbVwiXSxcImFwcGxpY2F0aW9uL3gtdGFyXCI6W1widGFyXCJdLFwiYXBwbGljYXRpb24veC10Y2xcIjpbXCJ0Y2xcIixcInRrXCJdLFwiYXBwbGljYXRpb24veC10ZXhcIjpbXCJ0ZXhcIl0sXCJhcHBsaWNhdGlvbi94LXRleC10Zm1cIjpbXCJ0Zm1cIl0sXCJhcHBsaWNhdGlvbi94LXRleGluZm9cIjpbXCJ0ZXhpbmZvXCIsXCJ0ZXhpXCJdLFwiYXBwbGljYXRpb24veC10Z2lmXCI6W1wib2JqXCJdLFwiYXBwbGljYXRpb24veC11c3RhclwiOltcInVzdGFyXCJdLFwiYXBwbGljYXRpb24veC12aXJ0dWFsYm94LWhkZFwiOltcImhkZFwiXSxcImFwcGxpY2F0aW9uL3gtdmlydHVhbGJveC1vdmFcIjpbXCJvdmFcIl0sXCJhcHBsaWNhdGlvbi94LXZpcnR1YWxib3gtb3ZmXCI6W1wib3ZmXCJdLFwiYXBwbGljYXRpb24veC12aXJ0dWFsYm94LXZib3hcIjpbXCJ2Ym94XCJdLFwiYXBwbGljYXRpb24veC12aXJ0dWFsYm94LXZib3gtZXh0cGFja1wiOltcInZib3gtZXh0cGFja1wiXSxcImFwcGxpY2F0aW9uL3gtdmlydHVhbGJveC12ZGlcIjpbXCJ2ZGlcIl0sXCJhcHBsaWNhdGlvbi94LXZpcnR1YWxib3gtdmhkXCI6W1widmhkXCJdLFwiYXBwbGljYXRpb24veC12aXJ0dWFsYm94LXZtZGtcIjpbXCJ2bWRrXCJdLFwiYXBwbGljYXRpb24veC13YWlzLXNvdXJjZVwiOltcInNyY1wiXSxcImFwcGxpY2F0aW9uL3gtd2ViLWFwcC1tYW5pZmVzdCtqc29uXCI6W1wid2ViYXBwXCJdLFwiYXBwbGljYXRpb24veC14NTA5LWNhLWNlcnRcIjpbXCJkZXJcIixcImNydFwiLFwicGVtXCJdLFwiYXBwbGljYXRpb24veC14ZmlnXCI6W1wiZmlnXCJdLFwiYXBwbGljYXRpb24veC14bGlmZit4bWxcIjpbXCJ4bGZcIl0sXCJhcHBsaWNhdGlvbi94LXhwaW5zdGFsbFwiOltcInhwaVwiXSxcImFwcGxpY2F0aW9uL3gteHpcIjpbXCJ4elwiXSxcImFwcGxpY2F0aW9uL3gtem1hY2hpbmVcIjpbXCJ6MVwiLFwiejJcIixcInozXCIsXCJ6NFwiLFwiejVcIixcIno2XCIsXCJ6N1wiLFwiejhcIl0sXCJhcHBsaWNhdGlvbi94YW1sK3htbFwiOltcInhhbWxcIl0sXCJhcHBsaWNhdGlvbi94Y2FwLWRpZmYreG1sXCI6W1wieGRmXCJdLFwiYXBwbGljYXRpb24veGVuYyt4bWxcIjpbXCJ4ZW5jXCJdLFwiYXBwbGljYXRpb24veGh0bWwreG1sXCI6W1wieGh0bWxcIixcInhodFwiXSxcImFwcGxpY2F0aW9uL3htbFwiOltcInhtbFwiLFwieHNsXCIsXCJ4c2RcIixcInJuZ1wiXSxcImFwcGxpY2F0aW9uL3htbC1kdGRcIjpbXCJkdGRcIl0sXCJhcHBsaWNhdGlvbi94b3AreG1sXCI6W1wieG9wXCJdLFwiYXBwbGljYXRpb24veHByb2MreG1sXCI6W1wieHBsXCJdLFwiYXBwbGljYXRpb24veHNsdCt4bWxcIjpbXCJ4c2x0XCJdLFwiYXBwbGljYXRpb24veHNwZit4bWxcIjpbXCJ4c3BmXCJdLFwiYXBwbGljYXRpb24veHYreG1sXCI6W1wibXhtbFwiLFwieGh2bWxcIixcInh2bWxcIixcInh2bVwiXSxcImFwcGxpY2F0aW9uL3lhbmdcIjpbXCJ5YW5nXCJdLFwiYXBwbGljYXRpb24veWluK3htbFwiOltcInlpblwiXSxcImFwcGxpY2F0aW9uL3ppcFwiOltcInppcFwiXSxcImF1ZGlvLzNncHBcIjpbXCIzZ3BwXCJdLFwiYXVkaW8vYWRwY21cIjpbXCJhZHBcIl0sXCJhdWRpby9iYXNpY1wiOltcImF1XCIsXCJzbmRcIl0sXCJhdWRpby9taWRpXCI6W1wibWlkXCIsXCJtaWRpXCIsXCJrYXJcIixcInJtaVwiXSxcImF1ZGlvL21wM1wiOltcIm1wM1wiXSxcImF1ZGlvL21wNFwiOltcIm00YVwiLFwibXA0YVwiXSxcImF1ZGlvL21wZWdcIjpbXCJtcGdhXCIsXCJtcDJcIixcIm1wMmFcIixcIm1wM1wiLFwibTJhXCIsXCJtM2FcIl0sXCJhdWRpby9vZ2dcIjpbXCJvZ2FcIixcIm9nZ1wiLFwic3B4XCJdLFwiYXVkaW8vczNtXCI6W1wiczNtXCJdLFwiYXVkaW8vc2lsa1wiOltcInNpbFwiXSxcImF1ZGlvL3ZuZC5kZWNlLmF1ZGlvXCI6W1widXZhXCIsXCJ1dnZhXCJdLFwiYXVkaW8vdm5kLmRpZ2l0YWwtd2luZHNcIjpbXCJlb2xcIl0sXCJhdWRpby92bmQuZHJhXCI6W1wiZHJhXCJdLFwiYXVkaW8vdm5kLmR0c1wiOltcImR0c1wiXSxcImF1ZGlvL3ZuZC5kdHMuaGRcIjpbXCJkdHNoZFwiXSxcImF1ZGlvL3ZuZC5sdWNlbnQudm9pY2VcIjpbXCJsdnBcIl0sXCJhdWRpby92bmQubXMtcGxheXJlYWR5Lm1lZGlhLnB5YVwiOltcInB5YVwiXSxcImF1ZGlvL3ZuZC5udWVyYS5lY2VscDQ4MDBcIjpbXCJlY2VscDQ4MDBcIl0sXCJhdWRpby92bmQubnVlcmEuZWNlbHA3NDcwXCI6W1wiZWNlbHA3NDcwXCJdLFwiYXVkaW8vdm5kLm51ZXJhLmVjZWxwOTYwMFwiOltcImVjZWxwOTYwMFwiXSxcImF1ZGlvL3ZuZC5yaXBcIjpbXCJyaXBcIl0sXCJhdWRpby93YXZcIjpbXCJ3YXZcIl0sXCJhdWRpby93YXZlXCI6W1wid2F2XCJdLFwiYXVkaW8vd2VibVwiOltcIndlYmFcIl0sXCJhdWRpby94LWFhY1wiOltcImFhY1wiXSxcImF1ZGlvL3gtYWlmZlwiOltcImFpZlwiLFwiYWlmZlwiLFwiYWlmY1wiXSxcImF1ZGlvL3gtY2FmXCI6W1wiY2FmXCJdLFwiYXVkaW8veC1mbGFjXCI6W1wiZmxhY1wiXSxcImF1ZGlvL3gtbTRhXCI6W1wibTRhXCJdLFwiYXVkaW8veC1tYXRyb3NrYVwiOltcIm1rYVwiXSxcImF1ZGlvL3gtbXBlZ3VybFwiOltcIm0zdVwiXSxcImF1ZGlvL3gtbXMtd2F4XCI6W1wid2F4XCJdLFwiYXVkaW8veC1tcy13bWFcIjpbXCJ3bWFcIl0sXCJhdWRpby94LXBuLXJlYWxhdWRpb1wiOltcInJhbVwiLFwicmFcIl0sXCJhdWRpby94LXBuLXJlYWxhdWRpby1wbHVnaW5cIjpbXCJybXBcIl0sXCJhdWRpby94LXJlYWxhdWRpb1wiOltcInJhXCJdLFwiYXVkaW8veC13YXZcIjpbXCJ3YXZcIl0sXCJhdWRpby94bVwiOltcInhtXCJdLFwiY2hlbWljYWwveC1jZHhcIjpbXCJjZHhcIl0sXCJjaGVtaWNhbC94LWNpZlwiOltcImNpZlwiXSxcImNoZW1pY2FsL3gtY21kZlwiOltcImNtZGZcIl0sXCJjaGVtaWNhbC94LWNtbFwiOltcImNtbFwiXSxcImNoZW1pY2FsL3gtY3NtbFwiOltcImNzbWxcIl0sXCJjaGVtaWNhbC94LXh5elwiOltcInh5elwiXSxcImZvbnQvb3RmXCI6W1wib3RmXCJdLFwiaW1hZ2UvYXBuZ1wiOltcImFwbmdcIl0sXCJpbWFnZS9ibXBcIjpbXCJibXBcIl0sXCJpbWFnZS9jZ21cIjpbXCJjZ21cIl0sXCJpbWFnZS9nM2ZheFwiOltcImczXCJdLFwiaW1hZ2UvZ2lmXCI6W1wiZ2lmXCJdLFwiaW1hZ2UvaWVmXCI6W1wiaWVmXCJdLFwiaW1hZ2UvanBlZ1wiOltcImpwZWdcIixcImpwZ1wiLFwianBlXCJdLFwiaW1hZ2Uva3R4XCI6W1wia3R4XCJdLFwiaW1hZ2UvcG5nXCI6W1wicG5nXCJdLFwiaW1hZ2UvcHJzLmJ0aWZcIjpbXCJidGlmXCJdLFwiaW1hZ2Uvc2dpXCI6W1wic2dpXCJdLFwiaW1hZ2Uvc3ZnK3htbFwiOltcInN2Z1wiLFwic3ZnelwiXSxcImltYWdlL3RpZmZcIjpbXCJ0aWZmXCIsXCJ0aWZcIl0sXCJpbWFnZS92bmQuYWRvYmUucGhvdG9zaG9wXCI6W1wicHNkXCJdLFwiaW1hZ2Uvdm5kLmRlY2UuZ3JhcGhpY1wiOltcInV2aVwiLFwidXZ2aVwiLFwidXZnXCIsXCJ1dnZnXCJdLFwiaW1hZ2Uvdm5kLmRqdnVcIjpbXCJkanZ1XCIsXCJkanZcIl0sXCJpbWFnZS92bmQuZHZiLnN1YnRpdGxlXCI6W1wic3ViXCJdLFwiaW1hZ2Uvdm5kLmR3Z1wiOltcImR3Z1wiXSxcImltYWdlL3ZuZC5keGZcIjpbXCJkeGZcIl0sXCJpbWFnZS92bmQuZmFzdGJpZHNoZWV0XCI6W1wiZmJzXCJdLFwiaW1hZ2Uvdm5kLmZweFwiOltcImZweFwiXSxcImltYWdlL3ZuZC5mc3RcIjpbXCJmc3RcIl0sXCJpbWFnZS92bmQuZnVqaXhlcm94LmVkbWljcy1tbXJcIjpbXCJtbXJcIl0sXCJpbWFnZS92bmQuZnVqaXhlcm94LmVkbWljcy1ybGNcIjpbXCJybGNcIl0sXCJpbWFnZS92bmQubXMtbW9kaVwiOltcIm1kaVwiXSxcImltYWdlL3ZuZC5tcy1waG90b1wiOltcIndkcFwiXSxcImltYWdlL3ZuZC5uZXQtZnB4XCI6W1wibnB4XCJdLFwiaW1hZ2Uvdm5kLndhcC53Ym1wXCI6W1wid2JtcFwiXSxcImltYWdlL3ZuZC54aWZmXCI6W1wieGlmXCJdLFwiaW1hZ2Uvd2VicFwiOltcIndlYnBcIl0sXCJpbWFnZS94LTNkc1wiOltcIjNkc1wiXSxcImltYWdlL3gtY211LXJhc3RlclwiOltcInJhc1wiXSxcImltYWdlL3gtY214XCI6W1wiY214XCJdLFwiaW1hZ2UveC1mcmVlaGFuZFwiOltcImZoXCIsXCJmaGNcIixcImZoNFwiLFwiZmg1XCIsXCJmaDdcIl0sXCJpbWFnZS94LWljb25cIjpbXCJpY29cIl0sXCJpbWFnZS94LWpuZ1wiOltcImpuZ1wiXSxcImltYWdlL3gtbXJzaWQtaW1hZ2VcIjpbXCJzaWRcIl0sXCJpbWFnZS94LW1zLWJtcFwiOltcImJtcFwiXSxcImltYWdlL3gtcGN4XCI6W1wicGN4XCJdLFwiaW1hZ2UveC1waWN0XCI6W1wicGljXCIsXCJwY3RcIl0sXCJpbWFnZS94LXBvcnRhYmxlLWFueW1hcFwiOltcInBubVwiXSxcImltYWdlL3gtcG9ydGFibGUtYml0bWFwXCI6W1wicGJtXCJdLFwiaW1hZ2UveC1wb3J0YWJsZS1ncmF5bWFwXCI6W1wicGdtXCJdLFwiaW1hZ2UveC1wb3J0YWJsZS1waXhtYXBcIjpbXCJwcG1cIl0sXCJpbWFnZS94LXJnYlwiOltcInJnYlwiXSxcImltYWdlL3gtdGdhXCI6W1widGdhXCJdLFwiaW1hZ2UveC14Yml0bWFwXCI6W1wieGJtXCJdLFwiaW1hZ2UveC14cGl4bWFwXCI6W1wieHBtXCJdLFwiaW1hZ2UveC14d2luZG93ZHVtcFwiOltcInh3ZFwiXSxcIm1lc3NhZ2UvcmZjODIyXCI6W1wiZW1sXCIsXCJtaW1lXCJdLFwibW9kZWwvZ2x0Zitqc29uXCI6W1wiZ2x0ZlwiXSxcIm1vZGVsL2dsdGYtYmluYXJ5XCI6W1wiZ2xiXCJdLFwibW9kZWwvaWdlc1wiOltcImlnc1wiLFwiaWdlc1wiXSxcIm1vZGVsL21lc2hcIjpbXCJtc2hcIixcIm1lc2hcIixcInNpbG9cIl0sXCJtb2RlbC92bmQuY29sbGFkYSt4bWxcIjpbXCJkYWVcIl0sXCJtb2RlbC92bmQuZHdmXCI6W1wiZHdmXCJdLFwibW9kZWwvdm5kLmdkbFwiOltcImdkbFwiXSxcIm1vZGVsL3ZuZC5ndHdcIjpbXCJndHdcIl0sXCJtb2RlbC92bmQubXRzXCI6W1wibXRzXCJdLFwibW9kZWwvdm5kLnZ0dVwiOltcInZ0dVwiXSxcIm1vZGVsL3ZybWxcIjpbXCJ3cmxcIixcInZybWxcIl0sXCJtb2RlbC94M2QrYmluYXJ5XCI6W1wieDNkYlwiLFwieDNkYnpcIl0sXCJtb2RlbC94M2QrdnJtbFwiOltcIngzZHZcIixcIngzZHZ6XCJdLFwibW9kZWwveDNkK3htbFwiOltcIngzZFwiLFwieDNkelwiXSxcInRleHQvY2FjaGUtbWFuaWZlc3RcIjpbXCJhcHBjYWNoZVwiLFwibWFuaWZlc3RcIl0sXCJ0ZXh0L2NhbGVuZGFyXCI6W1wiaWNzXCIsXCJpZmJcIl0sXCJ0ZXh0L2NvZmZlZXNjcmlwdFwiOltcImNvZmZlZVwiLFwibGl0Y29mZmVlXCJdLFwidGV4dC9jc3NcIjpbXCJjc3NcIl0sXCJ0ZXh0L2NzdlwiOltcImNzdlwiXSxcInRleHQvaGpzb25cIjpbXCJoanNvblwiXSxcInRleHQvaHRtbFwiOltcImh0bWxcIixcImh0bVwiLFwic2h0bWxcIl0sXCJ0ZXh0L2phZGVcIjpbXCJqYWRlXCJdLFwidGV4dC9qc3hcIjpbXCJqc3hcIl0sXCJ0ZXh0L2xlc3NcIjpbXCJsZXNzXCJdLFwidGV4dC9tYXJrZG93blwiOltcIm1hcmtkb3duXCIsXCJtZFwiXSxcInRleHQvbWF0aG1sXCI6W1wibW1sXCJdLFwidGV4dC9uM1wiOltcIm4zXCJdLFwidGV4dC9wbGFpblwiOltcInR4dFwiLFwidGV4dFwiLFwiY29uZlwiLFwiZGVmXCIsXCJsaXN0XCIsXCJsb2dcIixcImluXCIsXCJpbmlcIl0sXCJ0ZXh0L3Bycy5saW5lcy50YWdcIjpbXCJkc2NcIl0sXCJ0ZXh0L3JpY2h0ZXh0XCI6W1wicnR4XCJdLFwidGV4dC9ydGZcIjpbXCJydGZcIl0sXCJ0ZXh0L3NnbWxcIjpbXCJzZ21sXCIsXCJzZ21cIl0sXCJ0ZXh0L3NsaW1cIjpbXCJzbGltXCIsXCJzbG1cIl0sXCJ0ZXh0L3N0eWx1c1wiOltcInN0eWx1c1wiLFwic3R5bFwiXSxcInRleHQvdGFiLXNlcGFyYXRlZC12YWx1ZXNcIjpbXCJ0c3ZcIl0sXCJ0ZXh0L3Ryb2ZmXCI6W1widFwiLFwidHJcIixcInJvZmZcIixcIm1hblwiLFwibWVcIixcIm1zXCJdLFwidGV4dC90dXJ0bGVcIjpbXCJ0dGxcIl0sXCJ0ZXh0L3VyaS1saXN0XCI6W1widXJpXCIsXCJ1cmlzXCIsXCJ1cmxzXCJdLFwidGV4dC92Y2FyZFwiOltcInZjYXJkXCJdLFwidGV4dC92bmQuY3VybFwiOltcImN1cmxcIl0sXCJ0ZXh0L3ZuZC5jdXJsLmRjdXJsXCI6W1wiZGN1cmxcIl0sXCJ0ZXh0L3ZuZC5jdXJsLm1jdXJsXCI6W1wibWN1cmxcIl0sXCJ0ZXh0L3ZuZC5jdXJsLnNjdXJsXCI6W1wic2N1cmxcIl0sXCJ0ZXh0L3ZuZC5kdmIuc3VidGl0bGVcIjpbXCJzdWJcIl0sXCJ0ZXh0L3ZuZC5mbHlcIjpbXCJmbHlcIl0sXCJ0ZXh0L3ZuZC5mbWkuZmxleHN0b3JcIjpbXCJmbHhcIl0sXCJ0ZXh0L3ZuZC5ncmFwaHZpelwiOltcImd2XCJdLFwidGV4dC92bmQuaW4zZC4zZG1sXCI6W1wiM2RtbFwiXSxcInRleHQvdm5kLmluM2Quc3BvdFwiOltcInNwb3RcIl0sXCJ0ZXh0L3ZuZC5zdW4uajJtZS5hcHAtZGVzY3JpcHRvclwiOltcImphZFwiXSxcInRleHQvdm5kLndhcC53bWxcIjpbXCJ3bWxcIl0sXCJ0ZXh0L3ZuZC53YXAud21sc2NyaXB0XCI6W1wid21sc1wiXSxcInRleHQvdnR0XCI6W1widnR0XCJdLFwidGV4dC94LWFzbVwiOltcInNcIixcImFzbVwiXSxcInRleHQveC1jXCI6W1wiY1wiLFwiY2NcIixcImN4eFwiLFwiY3BwXCIsXCJoXCIsXCJoaFwiLFwiZGljXCJdLFwidGV4dC94LWNvbXBvbmVudFwiOltcImh0Y1wiXSxcInRleHQveC1mb3J0cmFuXCI6W1wiZlwiLFwiZm9yXCIsXCJmNzdcIixcImY5MFwiXSxcInRleHQveC1oYW5kbGViYXJzLXRlbXBsYXRlXCI6W1wiaGJzXCJdLFwidGV4dC94LWphdmEtc291cmNlXCI6W1wiamF2YVwiXSxcInRleHQveC1sdWFcIjpbXCJsdWFcIl0sXCJ0ZXh0L3gtbWFya2Rvd25cIjpbXCJta2RcIl0sXCJ0ZXh0L3gtbmZvXCI6W1wibmZvXCJdLFwidGV4dC94LW9wbWxcIjpbXCJvcG1sXCJdLFwidGV4dC94LW9yZ1wiOltcIm9yZ1wiXSxcInRleHQveC1wYXNjYWxcIjpbXCJwXCIsXCJwYXNcIl0sXCJ0ZXh0L3gtcHJvY2Vzc2luZ1wiOltcInBkZVwiXSxcInRleHQveC1zYXNzXCI6W1wic2Fzc1wiXSxcInRleHQveC1zY3NzXCI6W1wic2Nzc1wiXSxcInRleHQveC1zZXRleHRcIjpbXCJldHhcIl0sXCJ0ZXh0L3gtc2Z2XCI6W1wic2Z2XCJdLFwidGV4dC94LXN1c2UteW1wXCI6W1wieW1wXCJdLFwidGV4dC94LXV1ZW5jb2RlXCI6W1widXVcIl0sXCJ0ZXh0L3gtdmNhbGVuZGFyXCI6W1widmNzXCJdLFwidGV4dC94LXZjYXJkXCI6W1widmNmXCJdLFwidGV4dC94bWxcIjpbXCJ4bWxcIl0sXCJ0ZXh0L3lhbWxcIjpbXCJ5YW1sXCIsXCJ5bWxcIl0sXCJ2aWRlby8zZ3BwXCI6W1wiM2dwXCIsXCIzZ3BwXCJdLFwidmlkZW8vM2dwcDJcIjpbXCIzZzJcIl0sXCJ2aWRlby9oMjYxXCI6W1wiaDI2MVwiXSxcInZpZGVvL2gyNjNcIjpbXCJoMjYzXCJdLFwidmlkZW8vaDI2NFwiOltcImgyNjRcIl0sXCJ2aWRlby9qcGVnXCI6W1wianBndlwiXSxcInZpZGVvL2pwbVwiOltcImpwbVwiLFwianBnbVwiXSxcInZpZGVvL21qMlwiOltcIm1qMlwiLFwibWpwMlwiXSxcInZpZGVvL21wMnRcIjpbXCJ0c1wiXSxcInZpZGVvL21wNFwiOltcIm1wNFwiLFwibXA0dlwiLFwibXBnNFwiXSxcInZpZGVvL21wZWdcIjpbXCJtcGVnXCIsXCJtcGdcIixcIm1wZVwiLFwibTF2XCIsXCJtMnZcIl0sXCJ2aWRlby9vZ2dcIjpbXCJvZ3ZcIl0sXCJ2aWRlby9xdWlja3RpbWVcIjpbXCJxdFwiLFwibW92XCJdLFwidmlkZW8vdm5kLmRlY2UuaGRcIjpbXCJ1dmhcIixcInV2dmhcIl0sXCJ2aWRlby92bmQuZGVjZS5tb2JpbGVcIjpbXCJ1dm1cIixcInV2dm1cIl0sXCJ2aWRlby92bmQuZGVjZS5wZFwiOltcInV2cFwiLFwidXZ2cFwiXSxcInZpZGVvL3ZuZC5kZWNlLnNkXCI6W1widXZzXCIsXCJ1dnZzXCJdLFwidmlkZW8vdm5kLmRlY2UudmlkZW9cIjpbXCJ1dnZcIixcInV2dnZcIl0sXCJ2aWRlby92bmQuZHZiLmZpbGVcIjpbXCJkdmJcIl0sXCJ2aWRlby92bmQuZnZ0XCI6W1wiZnZ0XCJdLFwidmlkZW8vdm5kLm1wZWd1cmxcIjpbXCJteHVcIixcIm00dVwiXSxcInZpZGVvL3ZuZC5tcy1wbGF5cmVhZHkubWVkaWEucHl2XCI6W1wicHl2XCJdLFwidmlkZW8vdm5kLnV2dnUubXA0XCI6W1widXZ1XCIsXCJ1dnZ1XCJdLFwidmlkZW8vdm5kLnZpdm9cIjpbXCJ2aXZcIl0sXCJ2aWRlby93ZWJtXCI6W1wid2VibVwiXSxcInZpZGVvL3gtZjR2XCI6W1wiZjR2XCJdLFwidmlkZW8veC1mbGlcIjpbXCJmbGlcIl0sXCJ2aWRlby94LWZsdlwiOltcImZsdlwiXSxcInZpZGVvL3gtbTR2XCI6W1wibTR2XCJdLFwidmlkZW8veC1tYXRyb3NrYVwiOltcIm1rdlwiLFwibWszZFwiLFwibWtzXCJdLFwidmlkZW8veC1tbmdcIjpbXCJtbmdcIl0sXCJ2aWRlby94LW1zLWFzZlwiOltcImFzZlwiLFwiYXN4XCJdLFwidmlkZW8veC1tcy12b2JcIjpbXCJ2b2JcIl0sXCJ2aWRlby94LW1zLXdtXCI6W1wid21cIl0sXCJ2aWRlby94LW1zLXdtdlwiOltcIndtdlwiXSxcInZpZGVvL3gtbXMtd214XCI6W1wid214XCJdLFwidmlkZW8veC1tcy13dnhcIjpbXCJ3dnhcIl0sXCJ2aWRlby94LW1zdmlkZW9cIjpbXCJhdmlcIl0sXCJ2aWRlby94LXNnaS1tb3ZpZVwiOltcIm1vdmllXCJdLFwidmlkZW8veC1zbXZcIjpbXCJzbXZcIl0sXCJ4LWNvbmZlcmVuY2UveC1jb29sdGFsa1wiOltcImljZVwiXX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9taW1lL3R5cGVzLmpzb25cbi8vIG1vZHVsZSBpZCA9IDEyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGZvcndhcmRlZFxuICogQ29weXJpZ2h0KGMpIDIwMTQtMjAxNyBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmb3J3YXJkZWRcblxuLyoqXG4gKiBHZXQgYWxsIGFkZHJlc3NlcyBpbiB0aGUgcmVxdWVzdCwgdXNpbmcgdGhlIGBYLUZvcndhcmRlZC1Gb3JgIGhlYWRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcmVxXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3J3YXJkZWQgKHJlcSkge1xuICBpZiAoIXJlcSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHJlcSBpcyByZXF1aXJlZCcpXG4gIH1cblxuICAvLyBzaW1wbGUgaGVhZGVyIHBhcnNpbmdcbiAgdmFyIHByb3h5QWRkcnMgPSBwYXJzZShyZXEuaGVhZGVyc1sneC1mb3J3YXJkZWQtZm9yJ10gfHwgJycpXG4gIHZhciBzb2NrZXRBZGRyID0gcmVxLmNvbm5lY3Rpb24ucmVtb3RlQWRkcmVzc1xuICB2YXIgYWRkcnMgPSBbc29ja2V0QWRkcl0uY29uY2F0KHByb3h5QWRkcnMpXG5cbiAgLy8gcmV0dXJuIGFsbCBhZGRyZXNzZXNcbiAgcmV0dXJuIGFkZHJzXG59XG5cbi8qKlxuICogUGFyc2UgdGhlIFgtRm9yd2FyZGVkLUZvciBoZWFkZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGhlYWRlclxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZSAoaGVhZGVyKSB7XG4gIHZhciBlbmQgPSBoZWFkZXIubGVuZ3RoXG4gIHZhciBsaXN0ID0gW11cbiAgdmFyIHN0YXJ0ID0gaGVhZGVyLmxlbmd0aFxuXG4gIC8vIGdhdGhlciBhZGRyZXNzZXMsIGJhY2t3YXJkc1xuICBmb3IgKHZhciBpID0gaGVhZGVyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgc3dpdGNoIChoZWFkZXIuY2hhckNvZGVBdChpKSkge1xuICAgICAgY2FzZSAweDIwOiAvKiAgICovXG4gICAgICAgIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgICAgICAgc3RhcnQgPSBlbmQgPSBpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMHgyYzogLyogLCAqL1xuICAgICAgICBpZiAoc3RhcnQgIT09IGVuZCkge1xuICAgICAgICAgIGxpc3QucHVzaChoZWFkZXIuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpKVxuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gZW5kID0gaVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3RhcnQgPSBpXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gZmluYWwgYWRkcmVzc1xuICBpZiAoc3RhcnQgIT09IGVuZCkge1xuICAgIGxpc3QucHVzaChoZWFkZXIuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpKVxuICB9XG5cbiAgcmV0dXJuIGxpc3Rcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZvcndhcmRlZC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIihmdW5jdGlvbigpIHtcbiAgdmFyIGV4cGFuZElQdjYsIGlwYWRkciwgaXB2NFBhcnQsIGlwdjRSZWdleGVzLCBpcHY2UGFydCwgaXB2NlJlZ2V4ZXMsIG1hdGNoQ0lEUiwgcm9vdCwgem9uZUluZGV4O1xuXG4gIGlwYWRkciA9IHt9O1xuXG4gIHJvb3QgPSB0aGlzO1xuXG4gIGlmICgodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUgIT09IG51bGwpICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpcGFkZHI7XG4gIH0gZWxzZSB7XG4gICAgcm9vdFsnaXBhZGRyJ10gPSBpcGFkZHI7XG4gIH1cblxuICBtYXRjaENJRFIgPSBmdW5jdGlvbihmaXJzdCwgc2Vjb25kLCBwYXJ0U2l6ZSwgY2lkckJpdHMpIHtcbiAgICB2YXIgcGFydCwgc2hpZnQ7XG4gICAgaWYgKGZpcnN0Lmxlbmd0aCAhPT0gc2Vjb25kLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiBjYW5ub3QgbWF0Y2ggQ0lEUiBmb3Igb2JqZWN0cyB3aXRoIGRpZmZlcmVudCBsZW5ndGhzXCIpO1xuICAgIH1cbiAgICBwYXJ0ID0gMDtcbiAgICB3aGlsZSAoY2lkckJpdHMgPiAwKSB7XG4gICAgICBzaGlmdCA9IHBhcnRTaXplIC0gY2lkckJpdHM7XG4gICAgICBpZiAoc2hpZnQgPCAwKSB7XG4gICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdFtwYXJ0XSA+PiBzaGlmdCAhPT0gc2Vjb25kW3BhcnRdID4+IHNoaWZ0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNpZHJCaXRzIC09IHBhcnRTaXplO1xuICAgICAgcGFydCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBpcGFkZHIuc3VibmV0TWF0Y2ggPSBmdW5jdGlvbihhZGRyZXNzLCByYW5nZUxpc3QsIGRlZmF1bHROYW1lKSB7XG4gICAgdmFyIGssIGxlbiwgcmFuZ2VOYW1lLCByYW5nZVN1Ym5ldHMsIHN1Ym5ldDtcbiAgICBpZiAoZGVmYXVsdE5hbWUgPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdE5hbWUgPSAndW5pY2FzdCc7XG4gICAgfVxuICAgIGZvciAocmFuZ2VOYW1lIGluIHJhbmdlTGlzdCkge1xuICAgICAgcmFuZ2VTdWJuZXRzID0gcmFuZ2VMaXN0W3JhbmdlTmFtZV07XG4gICAgICBpZiAocmFuZ2VTdWJuZXRzWzBdICYmICEocmFuZ2VTdWJuZXRzWzBdIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIHJhbmdlU3VibmV0cyA9IFtyYW5nZVN1Ym5ldHNdO1xuICAgICAgfVxuICAgICAgZm9yIChrID0gMCwgbGVuID0gcmFuZ2VTdWJuZXRzLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgIHN1Ym5ldCA9IHJhbmdlU3VibmV0c1trXTtcbiAgICAgICAgaWYgKGFkZHJlc3Mua2luZCgpID09PSBzdWJuZXRbMF0ua2luZCgpKSB7XG4gICAgICAgICAgaWYgKGFkZHJlc3MubWF0Y2guYXBwbHkoYWRkcmVzcywgc3VibmV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlTmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHROYW1lO1xuICB9O1xuXG4gIGlwYWRkci5JUHY0ID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIElQdjQob2N0ZXRzKSB7XG4gICAgICB2YXIgaywgbGVuLCBvY3RldDtcbiAgICAgIGlmIChvY3RldHMubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogaXB2NCBvY3RldCBjb3VudCBzaG91bGQgYmUgNFwiKTtcbiAgICAgIH1cbiAgICAgIGZvciAoayA9IDAsIGxlbiA9IG9jdGV0cy5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICBvY3RldCA9IG9jdGV0c1trXTtcbiAgICAgICAgaWYgKCEoKDAgPD0gb2N0ZXQgJiYgb2N0ZXQgPD0gMjU1KSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpcGFkZHI6IGlwdjQgb2N0ZXQgc2hvdWxkIGZpdCBpbiA4IGJpdHNcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMub2N0ZXRzID0gb2N0ZXRzO1xuICAgIH1cblxuICAgIElQdjQucHJvdG90eXBlLmtpbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnaXB2NCc7XG4gICAgfTtcblxuICAgIElQdjQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5vY3RldHMuam9pbihcIi5cIik7XG4gICAgfTtcblxuICAgIElQdjQucHJvdG90eXBlLnRvTm9ybWFsaXplZFN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgICB9O1xuXG4gICAgSVB2NC5wcm90b3R5cGUudG9CeXRlQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9jdGV0cy5zbGljZSgwKTtcbiAgICB9O1xuXG4gICAgSVB2NC5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbihvdGhlciwgY2lkclJhbmdlKSB7XG4gICAgICB2YXIgcmVmO1xuICAgICAgaWYgKGNpZHJSYW5nZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJlZiA9IG90aGVyLCBvdGhlciA9IHJlZlswXSwgY2lkclJhbmdlID0gcmVmWzFdO1xuICAgICAgfVxuICAgICAgaWYgKG90aGVyLmtpbmQoKSAhPT0gJ2lwdjQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogY2Fubm90IG1hdGNoIGlwdjQgYWRkcmVzcyB3aXRoIG5vbi1pcHY0IG9uZVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaENJRFIodGhpcy5vY3RldHMsIG90aGVyLm9jdGV0cywgOCwgY2lkclJhbmdlKTtcbiAgICB9O1xuXG4gICAgSVB2NC5wcm90b3R5cGUuU3BlY2lhbFJhbmdlcyA9IHtcbiAgICAgIHVuc3BlY2lmaWVkOiBbW25ldyBJUHY0KFswLCAwLCAwLCAwXSksIDhdXSxcbiAgICAgIGJyb2FkY2FzdDogW1tuZXcgSVB2NChbMjU1LCAyNTUsIDI1NSwgMjU1XSksIDMyXV0sXG4gICAgICBtdWx0aWNhc3Q6IFtbbmV3IElQdjQoWzIyNCwgMCwgMCwgMF0pLCA0XV0sXG4gICAgICBsaW5rTG9jYWw6IFtbbmV3IElQdjQoWzE2OSwgMjU0LCAwLCAwXSksIDE2XV0sXG4gICAgICBsb29wYmFjazogW1tuZXcgSVB2NChbMTI3LCAwLCAwLCAwXSksIDhdXSxcbiAgICAgIGNhcnJpZXJHcmFkZU5hdDogW1tuZXcgSVB2NChbMTAwLCA2NCwgMCwgMF0pLCAxMF1dLFxuICAgICAgXCJwcml2YXRlXCI6IFtbbmV3IElQdjQoWzEwLCAwLCAwLCAwXSksIDhdLCBbbmV3IElQdjQoWzE3MiwgMTYsIDAsIDBdKSwgMTJdLCBbbmV3IElQdjQoWzE5MiwgMTY4LCAwLCAwXSksIDE2XV0sXG4gICAgICByZXNlcnZlZDogW1tuZXcgSVB2NChbMTkyLCAwLCAwLCAwXSksIDI0XSwgW25ldyBJUHY0KFsxOTIsIDAsIDIsIDBdKSwgMjRdLCBbbmV3IElQdjQoWzE5MiwgODgsIDk5LCAwXSksIDI0XSwgW25ldyBJUHY0KFsxOTgsIDUxLCAxMDAsIDBdKSwgMjRdLCBbbmV3IElQdjQoWzIwMywgMCwgMTEzLCAwXSksIDI0XSwgW25ldyBJUHY0KFsyNDAsIDAsIDAsIDBdKSwgNF1dXG4gICAgfTtcblxuICAgIElQdjQucHJvdG90eXBlLnJhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXBhZGRyLnN1Ym5ldE1hdGNoKHRoaXMsIHRoaXMuU3BlY2lhbFJhbmdlcyk7XG4gICAgfTtcblxuICAgIElQdjQucHJvdG90eXBlLnRvSVB2NE1hcHBlZEFkZHJlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpcGFkZHIuSVB2Ni5wYXJzZShcIjo6ZmZmZjpcIiArICh0aGlzLnRvU3RyaW5nKCkpKTtcbiAgICB9O1xuXG4gICAgSVB2NC5wcm90b3R5cGUucHJlZml4TGVuZ3RoRnJvbVN1Ym5ldE1hc2sgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjaWRyLCBpLCBrLCBvY3RldCwgc3RvcCwgemVyb3MsIHplcm90YWJsZTtcbiAgICAgIHplcm90YWJsZSA9IHtcbiAgICAgICAgMDogOCxcbiAgICAgICAgMTI4OiA3LFxuICAgICAgICAxOTI6IDYsXG4gICAgICAgIDIyNDogNSxcbiAgICAgICAgMjQwOiA0LFxuICAgICAgICAyNDg6IDMsXG4gICAgICAgIDI1MjogMixcbiAgICAgICAgMjU0OiAxLFxuICAgICAgICAyNTU6IDBcbiAgICAgIH07XG4gICAgICBjaWRyID0gMDtcbiAgICAgIHN0b3AgPSBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGsgPSAzOyBrID49IDA7IGkgPSBrICs9IC0xKSB7XG4gICAgICAgIG9jdGV0ID0gdGhpcy5vY3RldHNbaV07XG4gICAgICAgIGlmIChvY3RldCBpbiB6ZXJvdGFibGUpIHtcbiAgICAgICAgICB6ZXJvcyA9IHplcm90YWJsZVtvY3RldF07XG4gICAgICAgICAgaWYgKHN0b3AgJiYgemVyb3MgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoemVyb3MgIT09IDgpIHtcbiAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaWRyICs9IHplcm9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gMzIgLSBjaWRyO1xuICAgIH07XG5cbiAgICByZXR1cm4gSVB2NDtcblxuICB9KSgpO1xuXG4gIGlwdjRQYXJ0ID0gXCIoMD9cXFxcZCt8MHhbYS1mMC05XSspXCI7XG5cbiAgaXB2NFJlZ2V4ZXMgPSB7XG4gICAgZm91ck9jdGV0OiBuZXcgUmVnRXhwKFwiXlwiICsgaXB2NFBhcnQgKyBcIlxcXFwuXCIgKyBpcHY0UGFydCArIFwiXFxcXC5cIiArIGlwdjRQYXJ0ICsgXCJcXFxcLlwiICsgaXB2NFBhcnQgKyBcIiRcIiwgJ2knKSxcbiAgICBsb25nVmFsdWU6IG5ldyBSZWdFeHAoXCJeXCIgKyBpcHY0UGFydCArIFwiJFwiLCAnaScpXG4gIH07XG5cbiAgaXBhZGRyLklQdjQucGFyc2VyID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIG1hdGNoLCBwYXJzZUludEF1dG8sIHBhcnQsIHNoaWZ0LCB2YWx1ZTtcbiAgICBwYXJzZUludEF1dG8gPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIGlmIChzdHJpbmdbMF0gPT09IFwiMFwiICYmIHN0cmluZ1sxXSAhPT0gXCJ4XCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHN0cmluZywgOCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChpcHY0UmVnZXhlcy5mb3VyT2N0ZXQpKSB7XG4gICAgICByZXR1cm4gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaywgbGVuLCByZWYsIHJlc3VsdHM7XG4gICAgICAgIHJlZiA9IG1hdGNoLnNsaWNlKDEsIDYpO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoayA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgIHBhcnQgPSByZWZba107XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHBhcnNlSW50QXV0byhwYXJ0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9KSgpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goaXB2NFJlZ2V4ZXMubG9uZ1ZhbHVlKSkge1xuICAgICAgdmFsdWUgPSBwYXJzZUludEF1dG8obWF0Y2hbMV0pO1xuICAgICAgaWYgKHZhbHVlID4gMHhmZmZmZmZmZiB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiBhZGRyZXNzIG91dHNpZGUgZGVmaW5lZCByYW5nZVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaywgcmVzdWx0cztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKHNoaWZ0ID0gayA9IDA7IGsgPD0gMjQ7IHNoaWZ0ID0gayArPSA4KSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKCh2YWx1ZSA+PiBzaGlmdCkgJiAweGZmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH0pKCkpLnJldmVyc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIGlwYWRkci5JUHY2ID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIElQdjYocGFydHMsIHpvbmVJZCkge1xuICAgICAgdmFyIGksIGssIGwsIGxlbiwgcGFydCwgcmVmO1xuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMTYpIHtcbiAgICAgICAgdGhpcy5wYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSBrID0gMDsgayA8PSAxNDsgaSA9IGsgKz0gMikge1xuICAgICAgICAgIHRoaXMucGFydHMucHVzaCgocGFydHNbaV0gPDwgOCkgfCBwYXJ0c1tpICsgMV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnRzLmxlbmd0aCA9PT0gOCkge1xuICAgICAgICB0aGlzLnBhcnRzID0gcGFydHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpcGFkZHI6IGlwdjYgcGFydCBjb3VudCBzaG91bGQgYmUgOCBvciAxNlwiKTtcbiAgICAgIH1cbiAgICAgIHJlZiA9IHRoaXMucGFydHM7XG4gICAgICBmb3IgKGwgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBsIDwgbGVuOyBsKyspIHtcbiAgICAgICAgcGFydCA9IHJlZltsXTtcbiAgICAgICAgaWYgKCEoKDAgPD0gcGFydCAmJiBwYXJ0IDw9IDB4ZmZmZikpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiBpcHY2IHBhcnQgc2hvdWxkIGZpdCBpbiAxNiBiaXRzXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoem9uZUlkKSB7XG4gICAgICAgIHRoaXMuem9uZUlkID0gem9uZUlkO1xuICAgICAgfVxuICAgIH1cblxuICAgIElQdjYucHJvdG90eXBlLmtpbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnaXB2Nic7XG4gICAgfTtcblxuICAgIElQdjYucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50b05vcm1hbGl6ZWRTdHJpbmcoKS5yZXBsYWNlKC8oKF58OikoMCg6fCQpKSspLywgJzo6Jyk7XG4gICAgfTtcblxuICAgIElQdjYucHJvdG90eXBlLnRvUkZDNTk1MlN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGJlc3RNYXRjaEluZGV4LCBiZXN0TWF0Y2hMZW5ndGgsIG1hdGNoLCByZWdleCwgc3RyaW5nO1xuICAgICAgcmVnZXggPSAvKChefDopKDAoOnwkKSl7Mix9KS9nO1xuICAgICAgc3RyaW5nID0gdGhpcy50b05vcm1hbGl6ZWRTdHJpbmcoKTtcbiAgICAgIGJlc3RNYXRjaEluZGV4ID0gMDtcbiAgICAgIGJlc3RNYXRjaExlbmd0aCA9IC0xO1xuICAgICAgd2hpbGUgKChtYXRjaCA9IHJlZ2V4LmV4ZWMoc3RyaW5nKSkpIHtcbiAgICAgICAgaWYgKG1hdGNoWzBdLmxlbmd0aCA+IGJlc3RNYXRjaExlbmd0aCkge1xuICAgICAgICAgIGJlc3RNYXRjaEluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgYmVzdE1hdGNoTGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYmVzdE1hdGNoTGVuZ3RoIDwgMCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5zdWJzdHJpbmcoMCwgYmVzdE1hdGNoSW5kZXgpICsgJzo6JyArIHN0cmluZy5zdWJzdHJpbmcoYmVzdE1hdGNoSW5kZXggKyBiZXN0TWF0Y2hMZW5ndGgpO1xuICAgIH07XG5cbiAgICBJUHY2LnByb3RvdHlwZS50b0J5dGVBcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGJ5dGVzLCBrLCBsZW4sIHBhcnQsIHJlZjtcbiAgICAgIGJ5dGVzID0gW107XG4gICAgICByZWYgPSB0aGlzLnBhcnRzO1xuICAgICAgZm9yIChrID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgIHBhcnQgPSByZWZba107XG4gICAgICAgIGJ5dGVzLnB1c2gocGFydCA+PiA4KTtcbiAgICAgICAgYnl0ZXMucHVzaChwYXJ0ICYgMHhmZik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfTtcblxuICAgIElQdjYucHJvdG90eXBlLnRvTm9ybWFsaXplZFN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFkZHIsIHBhcnQsIHN1ZmZpeDtcbiAgICAgIGFkZHIgPSAoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaywgbGVuLCByZWYsIHJlc3VsdHM7XG4gICAgICAgIHJlZiA9IHRoaXMucGFydHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChrID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgICAgcGFydCA9IHJlZltrXTtcbiAgICAgICAgICByZXN1bHRzLnB1c2gocGFydC50b1N0cmluZygxNikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfSkuY2FsbCh0aGlzKSkuam9pbihcIjpcIik7XG4gICAgICBzdWZmaXggPSAnJztcbiAgICAgIGlmICh0aGlzLnpvbmVJZCkge1xuICAgICAgICBzdWZmaXggPSAnJScgKyB0aGlzLnpvbmVJZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhZGRyICsgc3VmZml4O1xuICAgIH07XG5cbiAgICBJUHY2LnByb3RvdHlwZS50b0ZpeGVkTGVuZ3RoU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYWRkciwgcGFydCwgc3VmZml4O1xuICAgICAgYWRkciA9ICgoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBrLCBsZW4sIHJlZiwgcmVzdWx0cztcbiAgICAgICAgcmVmID0gdGhpcy5wYXJ0cztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGsgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICBwYXJ0ID0gcmVmW2tdO1xuICAgICAgICAgIHJlc3VsdHMucHVzaChwYXJ0LnRvU3RyaW5nKDE2KS5wYWRTdGFydCg0LCAnMCcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH0pLmNhbGwodGhpcykpLmpvaW4oXCI6XCIpO1xuICAgICAgc3VmZml4ID0gJyc7XG4gICAgICBpZiAodGhpcy56b25lSWQpIHtcbiAgICAgICAgc3VmZml4ID0gJyUnICsgdGhpcy56b25lSWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWRkciArIHN1ZmZpeDtcbiAgICB9O1xuXG4gICAgSVB2Ni5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbihvdGhlciwgY2lkclJhbmdlKSB7XG4gICAgICB2YXIgcmVmO1xuICAgICAgaWYgKGNpZHJSYW5nZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJlZiA9IG90aGVyLCBvdGhlciA9IHJlZlswXSwgY2lkclJhbmdlID0gcmVmWzFdO1xuICAgICAgfVxuICAgICAgaWYgKG90aGVyLmtpbmQoKSAhPT0gJ2lwdjYnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogY2Fubm90IG1hdGNoIGlwdjYgYWRkcmVzcyB3aXRoIG5vbi1pcHY2IG9uZVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaENJRFIodGhpcy5wYXJ0cywgb3RoZXIucGFydHMsIDE2LCBjaWRyUmFuZ2UpO1xuICAgIH07XG5cbiAgICBJUHY2LnByb3RvdHlwZS5TcGVjaWFsUmFuZ2VzID0ge1xuICAgICAgdW5zcGVjaWZpZWQ6IFtuZXcgSVB2NihbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pLCAxMjhdLFxuICAgICAgbGlua0xvY2FsOiBbbmV3IElQdjYoWzB4ZmU4MCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pLCAxMF0sXG4gICAgICBtdWx0aWNhc3Q6IFtuZXcgSVB2NihbMHhmZjAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSksIDhdLFxuICAgICAgbG9vcGJhY2s6IFtuZXcgSVB2NihbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMV0pLCAxMjhdLFxuICAgICAgdW5pcXVlTG9jYWw6IFtuZXcgSVB2NihbMHhmYzAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSksIDddLFxuICAgICAgaXB2NE1hcHBlZDogW25ldyBJUHY2KFswLCAwLCAwLCAwLCAwLCAweGZmZmYsIDAsIDBdKSwgOTZdLFxuICAgICAgcmZjNjE0NTogW25ldyBJUHY2KFswLCAwLCAwLCAwLCAweGZmZmYsIDAsIDAsIDBdKSwgOTZdLFxuICAgICAgcmZjNjA1MjogW25ldyBJUHY2KFsweDY0LCAweGZmOWIsIDAsIDAsIDAsIDAsIDAsIDBdKSwgOTZdLFxuICAgICAgJzZ0bzQnOiBbbmV3IElQdjYoWzB4MjAwMiwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pLCAxNl0sXG4gICAgICB0ZXJlZG86IFtuZXcgSVB2NihbMHgyMDAxLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSksIDMyXSxcbiAgICAgIHJlc2VydmVkOiBbW25ldyBJUHY2KFsweDIwMDEsIDB4ZGI4LCAwLCAwLCAwLCAwLCAwLCAwXSksIDMyXV1cbiAgICB9O1xuXG4gICAgSVB2Ni5wcm90b3R5cGUucmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpcGFkZHIuc3VibmV0TWF0Y2godGhpcywgdGhpcy5TcGVjaWFsUmFuZ2VzKTtcbiAgICB9O1xuXG4gICAgSVB2Ni5wcm90b3R5cGUuaXNJUHY0TWFwcGVkQWRkcmVzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmFuZ2UoKSA9PT0gJ2lwdjRNYXBwZWQnO1xuICAgIH07XG5cbiAgICBJUHY2LnByb3RvdHlwZS50b0lQdjRBZGRyZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaGlnaCwgbG93LCByZWY7XG4gICAgICBpZiAoIXRoaXMuaXNJUHY0TWFwcGVkQWRkcmVzcygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogdHJ5aW5nIHRvIGNvbnZlcnQgYSBnZW5lcmljIGlwdjYgYWRkcmVzcyB0byBpcHY0XCIpO1xuICAgICAgfVxuICAgICAgcmVmID0gdGhpcy5wYXJ0cy5zbGljZSgtMiksIGhpZ2ggPSByZWZbMF0sIGxvdyA9IHJlZlsxXTtcbiAgICAgIHJldHVybiBuZXcgaXBhZGRyLklQdjQoW2hpZ2ggPj4gOCwgaGlnaCAmIDB4ZmYsIGxvdyA+PiA4LCBsb3cgJiAweGZmXSk7XG4gICAgfTtcblxuICAgIElQdjYucHJvdG90eXBlLnByZWZpeExlbmd0aEZyb21TdWJuZXRNYXNrID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2lkciwgaSwgaywgcGFydCwgc3RvcCwgemVyb3MsIHplcm90YWJsZTtcbiAgICAgIHplcm90YWJsZSA9IHtcbiAgICAgICAgMDogMTYsXG4gICAgICAgIDMyNzY4OiAxNSxcbiAgICAgICAgNDkxNTI6IDE0LFxuICAgICAgICA1NzM0NDogMTMsXG4gICAgICAgIDYxNDQwOiAxMixcbiAgICAgICAgNjM0ODg6IDExLFxuICAgICAgICA2NDUxMjogMTAsXG4gICAgICAgIDY1MDI0OiA5LFxuICAgICAgICA2NTI4MDogOCxcbiAgICAgICAgNjU0MDg6IDcsXG4gICAgICAgIDY1NDcyOiA2LFxuICAgICAgICA2NTUwNDogNSxcbiAgICAgICAgNjU1MjA6IDQsXG4gICAgICAgIDY1NTI4OiAzLFxuICAgICAgICA2NTUzMjogMixcbiAgICAgICAgNjU1MzQ6IDEsXG4gICAgICAgIDY1NTM1OiAwXG4gICAgICB9O1xuICAgICAgY2lkciA9IDA7XG4gICAgICBzdG9wID0gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBrID0gNzsgayA+PSAwOyBpID0gayArPSAtMSkge1xuICAgICAgICBwYXJ0ID0gdGhpcy5wYXJ0c1tpXTtcbiAgICAgICAgaWYgKHBhcnQgaW4gemVyb3RhYmxlKSB7XG4gICAgICAgICAgemVyb3MgPSB6ZXJvdGFibGVbcGFydF07XG4gICAgICAgICAgaWYgKHN0b3AgJiYgemVyb3MgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoemVyb3MgIT09IDE2KSB7XG4gICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2lkciArPSB6ZXJvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDEyOCAtIGNpZHI7XG4gICAgfTtcblxuICAgIHJldHVybiBJUHY2O1xuXG4gIH0pKCk7XG5cbiAgaXB2NlBhcnQgPSBcIig/OlswLTlhLWZdKzo6PykrXCI7XG5cbiAgem9uZUluZGV4ID0gXCIlWzAtOWEtel17MSx9XCI7XG5cbiAgaXB2NlJlZ2V4ZXMgPSB7XG4gICAgem9uZUluZGV4OiBuZXcgUmVnRXhwKHpvbmVJbmRleCwgJ2knKSxcbiAgICBcIm5hdGl2ZVwiOiBuZXcgUmVnRXhwKFwiXig6Oik/KFwiICsgaXB2NlBhcnQgKyBcIik/KFswLTlhLWZdKyk/KDo6KT8oXCIgKyB6b25lSW5kZXggKyBcIik/JFwiLCAnaScpLFxuICAgIHRyYW5zaXRpb25hbDogbmV3IFJlZ0V4cCgoXCJeKCg/OlwiICsgaXB2NlBhcnQgKyBcIil8KD86OjopKD86XCIgKyBpcHY2UGFydCArIFwiKT8pXCIpICsgKGlwdjRQYXJ0ICsgXCJcXFxcLlwiICsgaXB2NFBhcnQgKyBcIlxcXFwuXCIgKyBpcHY0UGFydCArIFwiXFxcXC5cIiArIGlwdjRQYXJ0KSArIChcIihcIiArIHpvbmVJbmRleCArIFwiKT8kXCIpLCAnaScpXG4gIH07XG5cbiAgZXhwYW5kSVB2NiA9IGZ1bmN0aW9uKHN0cmluZywgcGFydHMpIHtcbiAgICB2YXIgY29sb25Db3VudCwgbGFzdENvbG9uLCBwYXJ0LCByZXBsYWNlbWVudCwgcmVwbGFjZW1lbnRDb3VudCwgem9uZUlkO1xuICAgIGlmIChzdHJpbmcuaW5kZXhPZignOjonKSAhPT0gc3RyaW5nLmxhc3RJbmRleE9mKCc6OicpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgem9uZUlkID0gKHN0cmluZy5tYXRjaChpcHY2UmVnZXhlc1snem9uZUluZGV4J10pIHx8IFtdKVswXTtcbiAgICBpZiAoem9uZUlkKSB7XG4gICAgICB6b25lSWQgPSB6b25lSWQuc3Vic3RyaW5nKDEpO1xuICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoLyUuKyQvLCAnJyk7XG4gICAgfVxuICAgIGNvbG9uQ291bnQgPSAwO1xuICAgIGxhc3RDb2xvbiA9IC0xO1xuICAgIHdoaWxlICgobGFzdENvbG9uID0gc3RyaW5nLmluZGV4T2YoJzonLCBsYXN0Q29sb24gKyAxKSkgPj0gMCkge1xuICAgICAgY29sb25Db3VudCsrO1xuICAgIH1cbiAgICBpZiAoc3RyaW5nLnN1YnN0cigwLCAyKSA9PT0gJzo6Jykge1xuICAgICAgY29sb25Db3VudC0tO1xuICAgIH1cbiAgICBpZiAoc3RyaW5nLnN1YnN0cigtMiwgMikgPT09ICc6OicpIHtcbiAgICAgIGNvbG9uQ291bnQtLTtcbiAgICB9XG4gICAgaWYgKGNvbG9uQ291bnQgPiBwYXJ0cykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJlcGxhY2VtZW50Q291bnQgPSBwYXJ0cyAtIGNvbG9uQ291bnQ7XG4gICAgcmVwbGFjZW1lbnQgPSAnOic7XG4gICAgd2hpbGUgKHJlcGxhY2VtZW50Q291bnQtLSkge1xuICAgICAgcmVwbGFjZW1lbnQgKz0gJzA6JztcbiAgICB9XG4gICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoJzo6JywgcmVwbGFjZW1lbnQpO1xuICAgIGlmIChzdHJpbmdbMF0gPT09ICc6Jykge1xuICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKDEpO1xuICAgIH1cbiAgICBpZiAoc3RyaW5nW3N0cmluZy5sZW5ndGggLSAxXSA9PT0gJzonKSB7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICBwYXJ0cyA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrLCBsZW4sIHJlZiwgcmVzdWx0cztcbiAgICAgIHJlZiA9IHN0cmluZy5zcGxpdChcIjpcIik7XG4gICAgICByZXN1bHRzID0gW107XG4gICAgICBmb3IgKGsgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgcGFydCA9IHJlZltrXTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHBhcnNlSW50KHBhcnQsIDE2KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9KSgpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXJ0czogcGFydHMsXG4gICAgICB6b25lSWQ6IHpvbmVJZFxuICAgIH07XG4gIH07XG5cbiAgaXBhZGRyLklQdjYucGFyc2VyID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGFkZHIsIGssIGxlbiwgbWF0Y2gsIG9jdGV0LCBvY3RldHMsIHpvbmVJZDtcbiAgICBpZiAoaXB2NlJlZ2V4ZXNbJ25hdGl2ZSddLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIGV4cGFuZElQdjYoc3RyaW5nLCA4KTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKGlwdjZSZWdleGVzWyd0cmFuc2l0aW9uYWwnXSkpIHtcbiAgICAgIHpvbmVJZCA9IG1hdGNoWzZdIHx8ICcnO1xuICAgICAgYWRkciA9IGV4cGFuZElQdjYobWF0Y2hbMV0uc2xpY2UoMCwgLTEpICsgem9uZUlkLCA2KTtcbiAgICAgIGlmIChhZGRyLnBhcnRzKSB7XG4gICAgICAgIG9jdGV0cyA9IFtwYXJzZUludChtYXRjaFsyXSksIHBhcnNlSW50KG1hdGNoWzNdKSwgcGFyc2VJbnQobWF0Y2hbNF0pLCBwYXJzZUludChtYXRjaFs1XSldO1xuICAgICAgICBmb3IgKGsgPSAwLCBsZW4gPSBvY3RldHMubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICBvY3RldCA9IG9jdGV0c1trXTtcbiAgICAgICAgICBpZiAoISgoMCA8PSBvY3RldCAmJiBvY3RldCA8PSAyNTUpKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFkZHIucGFydHMucHVzaChvY3RldHNbMF0gPDwgOCB8IG9jdGV0c1sxXSk7XG4gICAgICAgIGFkZHIucGFydHMucHVzaChvY3RldHNbMl0gPDwgOCB8IG9jdGV0c1szXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFydHM6IGFkZHIucGFydHMsXG4gICAgICAgICAgem9uZUlkOiBhZGRyLnpvbmVJZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBpcGFkZHIuSVB2NC5pc0lQdjQgPSBpcGFkZHIuSVB2Ni5pc0lQdjYgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZXIoc3RyaW5nKSAhPT0gbnVsbDtcbiAgfTtcblxuICBpcGFkZHIuSVB2NC5pc1ZhbGlkID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGU7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyB0aGlzKHRoaXMucGFyc2VyKHN0cmluZykpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IxKSB7XG4gICAgICBlID0gZXJyb3IxO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBpcGFkZHIuSVB2NC5pc1ZhbGlkRm91clBhcnREZWNpbWFsID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgaWYgKGlwYWRkci5JUHY0LmlzVmFsaWQoc3RyaW5nKSAmJiBzdHJpbmcubWF0Y2goL14oMHxbMS05XVxcZCopKFxcLigwfFsxLTldXFxkKikpezN9JC8pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBpcGFkZHIuSVB2Ni5pc1ZhbGlkID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGFkZHIsIGU7XG4gICAgaWYgKHR5cGVvZiBzdHJpbmcgPT09IFwic3RyaW5nXCIgJiYgc3RyaW5nLmluZGV4T2YoXCI6XCIpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgYWRkciA9IHRoaXMucGFyc2VyKHN0cmluZyk7XG4gICAgICBuZXcgdGhpcyhhZGRyLnBhcnRzLCBhZGRyLnpvbmVJZCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcjEpIHtcbiAgICAgIGUgPSBlcnJvcjE7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIGlwYWRkci5JUHY0LnBhcnNlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIHBhcnRzO1xuICAgIHBhcnRzID0gdGhpcy5wYXJzZXIoc3RyaW5nKTtcbiAgICBpZiAocGFydHMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogc3RyaW5nIGlzIG5vdCBmb3JtYXR0ZWQgbGlrZSBpcCBhZGRyZXNzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHRoaXMocGFydHMpO1xuICB9O1xuXG4gIGlwYWRkci5JUHY2LnBhcnNlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGFkZHI7XG4gICAgYWRkciA9IHRoaXMucGFyc2VyKHN0cmluZyk7XG4gICAgaWYgKGFkZHIucGFydHMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogc3RyaW5nIGlzIG5vdCBmb3JtYXR0ZWQgbGlrZSBpcCBhZGRyZXNzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHRoaXMoYWRkci5wYXJ0cywgYWRkci56b25lSWQpO1xuICB9O1xuXG4gIGlwYWRkci5JUHY0LnBhcnNlQ0lEUiA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBtYXNrTGVuZ3RoLCBtYXRjaCwgcGFyc2VkO1xuICAgIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaCgvXiguKylcXC8oXFxkKykkLykpIHtcbiAgICAgIG1hc2tMZW5ndGggPSBwYXJzZUludChtYXRjaFsyXSk7XG4gICAgICBpZiAobWFza0xlbmd0aCA+PSAwICYmIG1hc2tMZW5ndGggPD0gMzIpIHtcbiAgICAgICAgcGFyc2VkID0gW3RoaXMucGFyc2UobWF0Y2hbMV0pLCBtYXNrTGVuZ3RoXTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcnNlZCwgJ3RvU3RyaW5nJywge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmpvaW4oJy8nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpcGFkZHI6IHN0cmluZyBpcyBub3QgZm9ybWF0dGVkIGxpa2UgYW4gSVB2NCBDSURSIHJhbmdlXCIpO1xuICB9O1xuXG4gIGlwYWRkci5JUHY0LnN1Ym5ldE1hc2tGcm9tUHJlZml4TGVuZ3RoID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgdmFyIGZpbGxlZE9jdGV0Q291bnQsIGosIG9jdGV0cztcbiAgICBwcmVmaXggPSBwYXJzZUludChwcmVmaXgpO1xuICAgIGlmIChwcmVmaXggPCAwIHx8IHByZWZpeCA+IDMyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lwYWRkcjogaW52YWxpZCBJUHY0IHByZWZpeCBsZW5ndGgnKTtcbiAgICB9XG4gICAgb2N0ZXRzID0gWzAsIDAsIDAsIDBdO1xuICAgIGogPSAwO1xuICAgIGZpbGxlZE9jdGV0Q291bnQgPSBNYXRoLmZsb29yKHByZWZpeCAvIDgpO1xuICAgIHdoaWxlIChqIDwgZmlsbGVkT2N0ZXRDb3VudCkge1xuICAgICAgb2N0ZXRzW2pdID0gMjU1O1xuICAgICAgaisrO1xuICAgIH1cbiAgICBpZiAoZmlsbGVkT2N0ZXRDb3VudCA8IDQpIHtcbiAgICAgIG9jdGV0c1tmaWxsZWRPY3RldENvdW50XSA9IE1hdGgucG93KDIsIHByZWZpeCAlIDgpIC0gMSA8PCA4IC0gKHByZWZpeCAlIDgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHRoaXMob2N0ZXRzKTtcbiAgfTtcblxuICBpcGFkZHIuSVB2NC5icm9hZGNhc3RBZGRyZXNzRnJvbUNJRFIgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgY2lkciwgZXJyb3IsIGksIGlwSW50ZXJmYWNlT2N0ZXRzLCBvY3RldHMsIHN1Ym5ldE1hc2tPY3RldHM7XG4gICAgdHJ5IHtcbiAgICAgIGNpZHIgPSB0aGlzLnBhcnNlQ0lEUihzdHJpbmcpO1xuICAgICAgaXBJbnRlcmZhY2VPY3RldHMgPSBjaWRyWzBdLnRvQnl0ZUFycmF5KCk7XG4gICAgICBzdWJuZXRNYXNrT2N0ZXRzID0gdGhpcy5zdWJuZXRNYXNrRnJvbVByZWZpeExlbmd0aChjaWRyWzFdKS50b0J5dGVBcnJheSgpO1xuICAgICAgb2N0ZXRzID0gW107XG4gICAgICBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgNCkge1xuICAgICAgICBvY3RldHMucHVzaChwYXJzZUludChpcEludGVyZmFjZU9jdGV0c1tpXSwgMTApIHwgcGFyc2VJbnQoc3VibmV0TWFza09jdGV0c1tpXSwgMTApIF4gMjU1KTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyB0aGlzKG9jdGV0cyk7XG4gICAgfSBjYXRjaCAoZXJyb3IxKSB7XG4gICAgICBlcnJvciA9IGVycm9yMTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaXBhZGRyOiB0aGUgYWRkcmVzcyBkb2VzIG5vdCBoYXZlIElQdjQgQ0lEUiBmb3JtYXQnKTtcbiAgICB9XG4gIH07XG5cbiAgaXBhZGRyLklQdjQubmV0d29ya0FkZHJlc3NGcm9tQ0lEUiA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBjaWRyLCBlcnJvciwgaSwgaXBJbnRlcmZhY2VPY3RldHMsIG9jdGV0cywgc3VibmV0TWFza09jdGV0cztcbiAgICB0cnkge1xuICAgICAgY2lkciA9IHRoaXMucGFyc2VDSURSKHN0cmluZyk7XG4gICAgICBpcEludGVyZmFjZU9jdGV0cyA9IGNpZHJbMF0udG9CeXRlQXJyYXkoKTtcbiAgICAgIHN1Ym5ldE1hc2tPY3RldHMgPSB0aGlzLnN1Ym5ldE1hc2tGcm9tUHJlZml4TGVuZ3RoKGNpZHJbMV0pLnRvQnl0ZUFycmF5KCk7XG4gICAgICBvY3RldHMgPSBbXTtcbiAgICAgIGkgPSAwO1xuICAgICAgd2hpbGUgKGkgPCA0KSB7XG4gICAgICAgIG9jdGV0cy5wdXNoKHBhcnNlSW50KGlwSW50ZXJmYWNlT2N0ZXRzW2ldLCAxMCkgJiBwYXJzZUludChzdWJuZXRNYXNrT2N0ZXRzW2ldLCAxMCkpO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IHRoaXMob2N0ZXRzKTtcbiAgICB9IGNhdGNoIChlcnJvcjEpIHtcbiAgICAgIGVycm9yID0gZXJyb3IxO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpcGFkZHI6IHRoZSBhZGRyZXNzIGRvZXMgbm90IGhhdmUgSVB2NCBDSURSIGZvcm1hdCcpO1xuICAgIH1cbiAgfTtcblxuICBpcGFkZHIuSVB2Ni5wYXJzZUNJRFIgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgbWFza0xlbmd0aCwgbWF0Y2gsIHBhcnNlZDtcbiAgICBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goL14oLispXFwvKFxcZCspJC8pKSB7XG4gICAgICBtYXNrTGVuZ3RoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgaWYgKG1hc2tMZW5ndGggPj0gMCAmJiBtYXNrTGVuZ3RoIDw9IDEyOCkge1xuICAgICAgICBwYXJzZWQgPSBbdGhpcy5wYXJzZShtYXRjaFsxXSksIG1hc2tMZW5ndGhdO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFyc2VkLCAndG9TdHJpbmcnLCB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuam9pbignLycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogc3RyaW5nIGlzIG5vdCBmb3JtYXR0ZWQgbGlrZSBhbiBJUHY2IENJRFIgcmFuZ2VcIik7XG4gIH07XG5cbiAgaXBhZGRyLmlzVmFsaWQgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gaXBhZGRyLklQdjYuaXNWYWxpZChzdHJpbmcpIHx8IGlwYWRkci5JUHY0LmlzVmFsaWQoc3RyaW5nKTtcbiAgfTtcblxuICBpcGFkZHIucGFyc2UgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICBpZiAoaXBhZGRyLklQdjYuaXNWYWxpZChzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gaXBhZGRyLklQdjYucGFyc2Uoc3RyaW5nKTtcbiAgICB9IGVsc2UgaWYgKGlwYWRkci5JUHY0LmlzVmFsaWQoc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIGlwYWRkci5JUHY0LnBhcnNlKHN0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogdGhlIGFkZHJlc3MgaGFzIG5laXRoZXIgSVB2NiBub3IgSVB2NCBmb3JtYXRcIik7XG4gICAgfVxuICB9O1xuXG4gIGlwYWRkci5wYXJzZUNJRFIgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGlwYWRkci5JUHY2LnBhcnNlQ0lEUihzdHJpbmcpO1xuICAgIH0gY2F0Y2ggKGVycm9yMSkge1xuICAgICAgZSA9IGVycm9yMTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBpcGFkZHIuSVB2NC5wYXJzZUNJRFIoc3RyaW5nKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yMSkge1xuICAgICAgICBlID0gZXJyb3IxO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpcGFkZHI6IHRoZSBhZGRyZXNzIGhhcyBuZWl0aGVyIElQdjYgbm9yIElQdjQgQ0lEUiBmb3JtYXRcIik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGlwYWRkci5mcm9tQnl0ZUFycmF5ID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICB2YXIgbGVuZ3RoO1xuICAgIGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoID09PSA0KSB7XG4gICAgICByZXR1cm4gbmV3IGlwYWRkci5JUHY0KGJ5dGVzKTtcbiAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gMTYpIHtcbiAgICAgIHJldHVybiBuZXcgaXBhZGRyLklQdjYoYnl0ZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpcGFkZHI6IHRoZSBiaW5hcnkgaW5wdXQgaXMgbmVpdGhlciBhbiBJUHY2IG5vciBJUHY0IGFkZHJlc3NcIik7XG4gICAgfVxuICB9O1xuXG4gIGlwYWRkci5wcm9jZXNzID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGFkZHI7XG4gICAgYWRkciA9IHRoaXMucGFyc2Uoc3RyaW5nKTtcbiAgICBpZiAoYWRkci5raW5kKCkgPT09ICdpcHY2JyAmJiBhZGRyLmlzSVB2NE1hcHBlZEFkZHJlc3MoKSkge1xuICAgICAgcmV0dXJuIGFkZHIudG9JUHY0QWRkcmVzcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYWRkcjtcbiAgICB9XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9pcGFkZHIuanMvbGliL2lwYWRkci5qc1xuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDEzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGV4cHJlc3NcbiAqIENvcHlyaWdodChjKSAyMDA5LTIwMTMgVEogSG9sb3dheWNodWtcbiAqIENvcHlyaWdodChjKSAyMDEzIFJvbWFuIFNodHlsbWFuXG4gKiBDb3B5cmlnaHQoYykgMjAxNC0yMDE1IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIGFjY2VwdHMgPSByZXF1aXJlKCdhY2NlcHRzJyk7XG52YXIgZGVwcmVjYXRlID0gcmVxdWlyZSgnZGVwZCcpKCdleHByZXNzJyk7XG52YXIgaXNJUCA9IHJlcXVpcmUoJ25ldCcpLmlzSVA7XG52YXIgdHlwZWlzID0gcmVxdWlyZSgndHlwZS1pcycpO1xudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG52YXIgZnJlc2ggPSByZXF1aXJlKCdmcmVzaCcpO1xudmFyIHBhcnNlUmFuZ2UgPSByZXF1aXJlKCdyYW5nZS1wYXJzZXInKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJ3BhcnNldXJsJyk7XG52YXIgcHJveHlhZGRyID0gcmVxdWlyZSgncHJveHktYWRkcicpO1xuXG4vKipcbiAqIFJlcXVlc3QgcHJvdG90eXBlLlxuICogQHB1YmxpY1xuICovXG5cbnZhciByZXEgPSBPYmplY3QuY3JlYXRlKGh0dHAuSW5jb21pbmdNZXNzYWdlLnByb3RvdHlwZSlcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcVxuXG4vKipcbiAqIFJldHVybiByZXF1ZXN0IGhlYWRlci5cbiAqXG4gKiBUaGUgYFJlZmVycmVyYCBoZWFkZXIgZmllbGQgaXMgc3BlY2lhbC1jYXNlZCxcbiAqIGJvdGggYFJlZmVycmVyYCBhbmQgYFJlZmVyZXJgIGFyZSBpbnRlcmNoYW5nZWFibGUuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgIHJlcS5nZXQoJ0NvbnRlbnQtVHlwZScpO1xuICogICAgIC8vID0+IFwidGV4dC9wbGFpblwiXG4gKlxuICogICAgIHJlcS5nZXQoJ2NvbnRlbnQtdHlwZScpO1xuICogICAgIC8vID0+IFwidGV4dC9wbGFpblwiXG4gKlxuICogICAgIHJlcS5nZXQoJ1NvbWV0aGluZycpO1xuICogICAgIC8vID0+IHVuZGVmaW5lZFxuICpcbiAqIEFsaWFzZWQgYXMgYHJlcS5oZWFkZXIoKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBwdWJsaWNcbiAqL1xuXG5yZXEuZ2V0ID1cbnJlcS5oZWFkZXIgPSBmdW5jdGlvbiBoZWFkZXIobmFtZSkge1xuICBpZiAoIW5hbWUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCduYW1lIGFyZ3VtZW50IGlzIHJlcXVpcmVkIHRvIHJlcS5nZXQnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCduYW1lIG11c3QgYmUgYSBzdHJpbmcgdG8gcmVxLmdldCcpO1xuICB9XG5cbiAgdmFyIGxjID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIHN3aXRjaCAobGMpIHtcbiAgICBjYXNlICdyZWZlcmVyJzpcbiAgICBjYXNlICdyZWZlcnJlcic6XG4gICAgICByZXR1cm4gdGhpcy5oZWFkZXJzLnJlZmVycmVyXG4gICAgICAgIHx8IHRoaXMuaGVhZGVycy5yZWZlcmVyO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdGhpcy5oZWFkZXJzW2xjXTtcbiAgfVxufTtcblxuLyoqXG4gKiBUbyBkbzogdXBkYXRlIGRvY3MuXG4gKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGB0eXBlKHMpYCBpcyBhY2NlcHRhYmxlLCByZXR1cm5pbmdcbiAqIHRoZSBiZXN0IG1hdGNoIHdoZW4gdHJ1ZSwgb3RoZXJ3aXNlIGB1bmRlZmluZWRgLCBpbiB3aGljaFxuICogY2FzZSB5b3Ugc2hvdWxkIHJlc3BvbmQgd2l0aCA0MDYgXCJOb3QgQWNjZXB0YWJsZVwiLlxuICpcbiAqIFRoZSBgdHlwZWAgdmFsdWUgbWF5IGJlIGEgc2luZ2xlIE1JTUUgdHlwZSBzdHJpbmdcbiAqIHN1Y2ggYXMgXCJhcHBsaWNhdGlvbi9qc29uXCIsIGFuIGV4dGVuc2lvbiBuYW1lXG4gKiBzdWNoIGFzIFwianNvblwiLCBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IHN1Y2ggYXMgXCJqc29uLCBodG1sLCB0ZXh0L3BsYWluXCIsXG4gKiBhbiBhcmd1bWVudCBsaXN0IHN1Y2ggYXMgYFwianNvblwiLCBcImh0bWxcIiwgXCJ0ZXh0L3BsYWluXCJgLFxuICogb3IgYW4gYXJyYXkgYFtcImpzb25cIiwgXCJodG1sXCIsIFwidGV4dC9wbGFpblwiXWAuIFdoZW4gYSBsaXN0XG4gKiBvciBhcnJheSBpcyBnaXZlbiwgdGhlIF9iZXN0XyBtYXRjaCwgaWYgYW55IGlzIHJldHVybmVkLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAvLyBBY2NlcHQ6IHRleHQvaHRtbFxuICogICAgIHJlcS5hY2NlcHRzKCdodG1sJyk7XG4gKiAgICAgLy8gPT4gXCJodG1sXCJcbiAqXG4gKiAgICAgLy8gQWNjZXB0OiB0ZXh0LyosIGFwcGxpY2F0aW9uL2pzb25cbiAqICAgICByZXEuYWNjZXB0cygnaHRtbCcpO1xuICogICAgIC8vID0+IFwiaHRtbFwiXG4gKiAgICAgcmVxLmFjY2VwdHMoJ3RleHQvaHRtbCcpO1xuICogICAgIC8vID0+IFwidGV4dC9odG1sXCJcbiAqICAgICByZXEuYWNjZXB0cygnanNvbiwgdGV4dCcpO1xuICogICAgIC8vID0+IFwianNvblwiXG4gKiAgICAgcmVxLmFjY2VwdHMoJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAqICAgICAvLyA9PiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICpcbiAqICAgICAvLyBBY2NlcHQ6IHRleHQvKiwgYXBwbGljYXRpb24vanNvblxuICogICAgIHJlcS5hY2NlcHRzKCdpbWFnZS9wbmcnKTtcbiAqICAgICByZXEuYWNjZXB0cygncG5nJyk7XG4gKiAgICAgLy8gPT4gdW5kZWZpbmVkXG4gKlxuICogICAgIC8vIEFjY2VwdDogdGV4dC8qO3E9LjUsIGFwcGxpY2F0aW9uL2pzb25cbiAqICAgICByZXEuYWNjZXB0cyhbJ2h0bWwnLCAnanNvbiddKTtcbiAqICAgICByZXEuYWNjZXB0cygnaHRtbCcsICdqc29uJyk7XG4gKiAgICAgcmVxLmFjY2VwdHMoJ2h0bWwsIGpzb24nKTtcbiAqICAgICAvLyA9PiBcImpzb25cIlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0eXBlKHMpXG4gKiBAcmV0dXJuIHtTdHJpbmd8QXJyYXl8Qm9vbGVhbn1cbiAqIEBwdWJsaWNcbiAqL1xuXG5yZXEuYWNjZXB0cyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBhY2NlcHQgPSBhY2NlcHRzKHRoaXMpO1xuICByZXR1cm4gYWNjZXB0LnR5cGVzLmFwcGx5KGFjY2VwdCwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGBlbmNvZGluZ2BzIGFyZSBhY2NlcHRlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gLi4uZW5jb2RpbmdcbiAqIEByZXR1cm4ge1N0cmluZ3xBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuXG5yZXEuYWNjZXB0c0VuY29kaW5ncyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBhY2NlcHQgPSBhY2NlcHRzKHRoaXMpO1xuICByZXR1cm4gYWNjZXB0LmVuY29kaW5ncy5hcHBseShhY2NlcHQsIGFyZ3VtZW50cyk7XG59O1xuXG5yZXEuYWNjZXB0c0VuY29kaW5nID0gZGVwcmVjYXRlLmZ1bmN0aW9uKHJlcS5hY2NlcHRzRW5jb2RpbmdzLFxuICAncmVxLmFjY2VwdHNFbmNvZGluZzogVXNlIGFjY2VwdHNFbmNvZGluZ3MgaW5zdGVhZCcpO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBgY2hhcnNldGBzIGFyZSBhY2NlcHRhYmxlLFxuICogb3RoZXJ3aXNlIHlvdSBzaG91bGQgcmVzcG9uZCB3aXRoIDQwNiBcIk5vdCBBY2NlcHRhYmxlXCIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IC4uLmNoYXJzZXRcbiAqIEByZXR1cm4ge1N0cmluZ3xBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuXG5yZXEuYWNjZXB0c0NoYXJzZXRzID0gZnVuY3Rpb24oKXtcbiAgdmFyIGFjY2VwdCA9IGFjY2VwdHModGhpcyk7XG4gIHJldHVybiBhY2NlcHQuY2hhcnNldHMuYXBwbHkoYWNjZXB0LCBhcmd1bWVudHMpO1xufTtcblxucmVxLmFjY2VwdHNDaGFyc2V0ID0gZGVwcmVjYXRlLmZ1bmN0aW9uKHJlcS5hY2NlcHRzQ2hhcnNldHMsXG4gICdyZXEuYWNjZXB0c0NoYXJzZXQ6IFVzZSBhY2NlcHRzQ2hhcnNldHMgaW5zdGVhZCcpO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBgbGFuZ2BzIGFyZSBhY2NlcHRhYmxlLFxuICogb3RoZXJ3aXNlIHlvdSBzaG91bGQgcmVzcG9uZCB3aXRoIDQwNiBcIk5vdCBBY2NlcHRhYmxlXCIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IC4uLmxhbmdcbiAqIEByZXR1cm4ge1N0cmluZ3xBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuXG5yZXEuYWNjZXB0c0xhbmd1YWdlcyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBhY2NlcHQgPSBhY2NlcHRzKHRoaXMpO1xuICByZXR1cm4gYWNjZXB0Lmxhbmd1YWdlcy5hcHBseShhY2NlcHQsIGFyZ3VtZW50cyk7XG59O1xuXG5yZXEuYWNjZXB0c0xhbmd1YWdlID0gZGVwcmVjYXRlLmZ1bmN0aW9uKHJlcS5hY2NlcHRzTGFuZ3VhZ2VzLFxuICAncmVxLmFjY2VwdHNMYW5ndWFnZTogVXNlIGFjY2VwdHNMYW5ndWFnZXMgaW5zdGVhZCcpO1xuXG4vKipcbiAqIFBhcnNlIFJhbmdlIGhlYWRlciBmaWVsZCwgY2FwcGluZyB0byB0aGUgZ2l2ZW4gYHNpemVgLlxuICpcbiAqIFVuc3BlY2lmaWVkIHJhbmdlcyBzdWNoIGFzIFwiMC1cIiByZXF1aXJlIGtub3dsZWRnZSBvZiB5b3VyIHJlc291cmNlIGxlbmd0aC4gSW5cbiAqIHRoZSBjYXNlIG9mIGEgYnl0ZSByYW5nZSB0aGlzIGlzIG9mIGNvdXJzZSB0aGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzLiBJZiB0aGVcbiAqIFJhbmdlIGhlYWRlciBmaWVsZCBpcyBub3QgZ2l2ZW4gYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQsIGAtMWAgd2hlbiB1bnNhdGlzZmlhYmxlLFxuICogYW5kIGAtMmAgd2hlbiBzeW50YWN0aWNhbGx5IGludmFsaWQuXG4gKlxuICogV2hlbiByYW5nZXMgYXJlIHJldHVybmVkLCB0aGUgYXJyYXkgaGFzIGEgXCJ0eXBlXCIgcHJvcGVydHkgd2hpY2ggaXMgdGhlIHR5cGUgb2ZcbiAqIHJhbmdlIHRoYXQgaXMgcmVxdWlyZWQgKG1vc3QgY29tbW9ubHksIFwiYnl0ZXNcIikuIEVhY2ggYXJyYXkgZWxlbWVudCBpcyBhbiBvYmplY3RcbiAqIHdpdGggYSBcInN0YXJ0XCIgYW5kIFwiZW5kXCIgcHJvcGVydHkgZm9yIHRoZSBwb3J0aW9uIG9mIHRoZSByYW5nZS5cbiAqXG4gKiBUaGUgXCJjb21iaW5lXCIgb3B0aW9uIGNhbiBiZSBzZXQgdG8gYHRydWVgIGFuZCBvdmVybGFwcGluZyAmIGFkamFjZW50IHJhbmdlc1xuICogd2lsbCBiZSBjb21iaW5lZCBpbnRvIGEgc2luZ2xlIHJhbmdlLlxuICpcbiAqIE5PVEU6IHJlbWVtYmVyIHRoYXQgcmFuZ2VzIGFyZSBpbmNsdXNpdmUsIHNvIGZvciBleGFtcGxlIFwiUmFuZ2U6IHVzZXJzPTAtM1wiXG4gKiBzaG91bGQgcmVzcG9uZCB3aXRoIDQgdXNlcnMgd2hlbiBhdmFpbGFibGUsIG5vdCAzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNvbWJpbmU9ZmFsc2VdXG4gKiBAcmV0dXJuIHtudW1iZXJ8YXJyYXl9XG4gKiBAcHVibGljXG4gKi9cblxucmVxLnJhbmdlID0gZnVuY3Rpb24gcmFuZ2Uoc2l6ZSwgb3B0aW9ucykge1xuICB2YXIgcmFuZ2UgPSB0aGlzLmdldCgnUmFuZ2UnKTtcbiAgaWYgKCFyYW5nZSkgcmV0dXJuO1xuICByZXR1cm4gcGFyc2VSYW5nZShzaXplLCByYW5nZSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgdmFsdWUgb2YgcGFyYW0gYG5hbWVgIHdoZW4gcHJlc2VudCBvciBgZGVmYXVsdFZhbHVlYC5cbiAqXG4gKiAgLSBDaGVja3Mgcm91dGUgcGxhY2Vob2xkZXJzLCBleDogXy91c2VyLzppZF9cbiAqICAtIENoZWNrcyBib2R5IHBhcmFtcywgZXg6IGlkPTEyLCB7XCJpZFwiOjEyfVxuICogIC0gQ2hlY2tzIHF1ZXJ5IHN0cmluZyBwYXJhbXMsIGV4OiA/aWQ9MTJcbiAqXG4gKiBUbyB1dGlsaXplIHJlcXVlc3QgYm9kaWVzLCBgcmVxLmJvZHlgXG4gKiBzaG91bGQgYmUgYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSBkb25lIGJ5IHVzaW5nXG4gKiB0aGUgYGJvZHlQYXJzZXIoKWAgbWlkZGxld2FyZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtNaXhlZH0gW2RlZmF1bHRWYWx1ZV1cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBwdWJsaWNcbiAqL1xuXG5yZXEucGFyYW0gPSBmdW5jdGlvbiBwYXJhbShuYW1lLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zIHx8IHt9O1xuICB2YXIgYm9keSA9IHRoaXMuYm9keSB8fCB7fTtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcblxuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDFcbiAgICA/ICduYW1lJ1xuICAgIDogJ25hbWUsIGRlZmF1bHQnO1xuICBkZXByZWNhdGUoJ3JlcS5wYXJhbSgnICsgYXJncyArICcpOiBVc2UgcmVxLnBhcmFtcywgcmVxLmJvZHksIG9yIHJlcS5xdWVyeSBpbnN0ZWFkJyk7XG5cbiAgaWYgKG51bGwgIT0gcGFyYW1zW25hbWVdICYmIHBhcmFtcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgcmV0dXJuIHBhcmFtc1tuYW1lXTtcbiAgaWYgKG51bGwgIT0gYm9keVtuYW1lXSkgcmV0dXJuIGJvZHlbbmFtZV07XG4gIGlmIChudWxsICE9IHF1ZXJ5W25hbWVdKSByZXR1cm4gcXVlcnlbbmFtZV07XG5cbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGluY29taW5nIHJlcXVlc3QgY29udGFpbnMgdGhlIFwiQ29udGVudC1UeXBlXCJcbiAqIGhlYWRlciBmaWVsZCwgYW5kIGl0IGNvbnRhaW5zIHRoZSBnaXZlIG1pbWUgYHR5cGVgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgLy8gV2l0aCBDb250ZW50LVR5cGU6IHRleHQvaHRtbDsgY2hhcnNldD11dGYtOFxuICogICAgICByZXEuaXMoJ2h0bWwnKTtcbiAqICAgICAgcmVxLmlzKCd0ZXh0L2h0bWwnKTtcbiAqICAgICAgcmVxLmlzKCd0ZXh0LyonKTtcbiAqICAgICAgLy8gPT4gdHJ1ZVxuICpcbiAqICAgICAgLy8gV2hlbiBDb250ZW50LVR5cGUgaXMgYXBwbGljYXRpb24vanNvblxuICogICAgICByZXEuaXMoJ2pzb24nKTtcbiAqICAgICAgcmVxLmlzKCdhcHBsaWNhdGlvbi9qc29uJyk7XG4gKiAgICAgIHJlcS5pcygnYXBwbGljYXRpb24vKicpO1xuICogICAgICAvLyA9PiB0cnVlXG4gKlxuICogICAgICByZXEuaXMoJ2h0bWwnKTtcbiAqICAgICAgLy8gPT4gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gdHlwZXMuLi5cbiAqIEByZXR1cm4ge1N0cmluZ3xmYWxzZXxudWxsfVxuICogQHB1YmxpY1xuICovXG5cbnJlcS5pcyA9IGZ1bmN0aW9uIGlzKHR5cGVzKSB7XG4gIHZhciBhcnIgPSB0eXBlcztcblxuICAvLyBzdXBwb3J0IGZsYXR0ZW5lZCBhcmd1bWVudHNcbiAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGVzKSkge1xuICAgIGFyciA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0eXBlaXModGhpcywgYXJyKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBwcm90b2NvbCBzdHJpbmcgXCJodHRwXCIgb3IgXCJodHRwc1wiXG4gKiB3aGVuIHJlcXVlc3RlZCB3aXRoIFRMUy4gV2hlbiB0aGUgXCJ0cnVzdCBwcm94eVwiXG4gKiBzZXR0aW5nIHRydXN0cyB0aGUgc29ja2V0IGFkZHJlc3MsIHRoZVxuICogXCJYLUZvcndhcmRlZC1Qcm90b1wiIGhlYWRlciBmaWVsZCB3aWxsIGJlIHRydXN0ZWRcbiAqIGFuZCB1c2VkIGlmIHByZXNlbnQuXG4gKlxuICogSWYgeW91J3JlIHJ1bm5pbmcgYmVoaW5kIGEgcmV2ZXJzZSBwcm94eSB0aGF0XG4gKiBzdXBwbGllcyBodHRwcyBmb3IgeW91IHRoaXMgbWF5IGJlIGVuYWJsZWQuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfVxuICogQHB1YmxpY1xuICovXG5cbmRlZmluZUdldHRlcihyZXEsICdwcm90b2NvbCcsIGZ1bmN0aW9uIHByb3RvY29sKCl7XG4gIHZhciBwcm90byA9IHRoaXMuY29ubmVjdGlvbi5lbmNyeXB0ZWRcbiAgICA/ICdodHRwcydcbiAgICA6ICdodHRwJztcbiAgdmFyIHRydXN0ID0gdGhpcy5hcHAuZ2V0KCd0cnVzdCBwcm94eSBmbicpO1xuXG4gIGlmICghdHJ1c3QodGhpcy5jb25uZWN0aW9uLnJlbW90ZUFkZHJlc3MsIDApKSB7XG4gICAgcmV0dXJuIHByb3RvO1xuICB9XG5cbiAgLy8gTm90ZTogWC1Gb3J3YXJkZWQtUHJvdG8gaXMgbm9ybWFsbHkgb25seSBldmVyIGFcbiAgLy8gICAgICAgc2luZ2xlIHZhbHVlLCBidXQgdGhpcyBpcyB0byBiZSBzYWZlLlxuICB2YXIgaGVhZGVyID0gdGhpcy5nZXQoJ1gtRm9yd2FyZGVkLVByb3RvJykgfHwgcHJvdG9cbiAgdmFyIGluZGV4ID0gaGVhZGVyLmluZGV4T2YoJywnKVxuXG4gIHJldHVybiBpbmRleCAhPT0gLTFcbiAgICA/IGhlYWRlci5zdWJzdHJpbmcoMCwgaW5kZXgpLnRyaW0oKVxuICAgIDogaGVhZGVyLnRyaW0oKVxufSk7XG5cbi8qKlxuICogU2hvcnQtaGFuZCBmb3I6XG4gKlxuICogICAgcmVxLnByb3RvY29sID09PSAnaHR0cHMnXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBwdWJsaWNcbiAqL1xuXG5kZWZpbmVHZXR0ZXIocmVxLCAnc2VjdXJlJywgZnVuY3Rpb24gc2VjdXJlKCl7XG4gIHJldHVybiB0aGlzLnByb3RvY29sID09PSAnaHR0cHMnO1xufSk7XG5cbi8qKlxuICogUmV0dXJuIHRoZSByZW1vdGUgYWRkcmVzcyBmcm9tIHRoZSB0cnVzdGVkIHByb3h5LlxuICpcbiAqIFRoZSBpcyB0aGUgcmVtb3RlIGFkZHJlc3Mgb24gdGhlIHNvY2tldCB1bmxlc3NcbiAqIFwidHJ1c3QgcHJveHlcIiBpcyBzZXQuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfVxuICogQHB1YmxpY1xuICovXG5cbmRlZmluZUdldHRlcihyZXEsICdpcCcsIGZ1bmN0aW9uIGlwKCl7XG4gIHZhciB0cnVzdCA9IHRoaXMuYXBwLmdldCgndHJ1c3QgcHJveHkgZm4nKTtcbiAgcmV0dXJuIHByb3h5YWRkcih0aGlzLCB0cnVzdCk7XG59KTtcblxuLyoqXG4gKiBXaGVuIFwidHJ1c3QgcHJveHlcIiBpcyBzZXQsIHRydXN0ZWQgcHJveHkgYWRkcmVzc2VzICsgY2xpZW50LlxuICpcbiAqIEZvciBleGFtcGxlIGlmIHRoZSB2YWx1ZSB3ZXJlIFwiY2xpZW50LCBwcm94eTEsIHByb3h5MlwiXG4gKiB5b3Ugd291bGQgcmVjZWl2ZSB0aGUgYXJyYXkgYFtcImNsaWVudFwiLCBcInByb3h5MVwiLCBcInByb3h5MlwiXWBcbiAqIHdoZXJlIFwicHJveHkyXCIgaXMgdGhlIGZ1cnRoZXN0IGRvd24tc3RyZWFtIGFuZCBcInByb3h5MVwiIGFuZFxuICogXCJwcm94eTJcIiB3ZXJlIHRydXN0ZWQuXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cblxuZGVmaW5lR2V0dGVyKHJlcSwgJ2lwcycsIGZ1bmN0aW9uIGlwcygpIHtcbiAgdmFyIHRydXN0ID0gdGhpcy5hcHAuZ2V0KCd0cnVzdCBwcm94eSBmbicpO1xuICB2YXIgYWRkcnMgPSBwcm94eWFkZHIuYWxsKHRoaXMsIHRydXN0KTtcblxuICAvLyByZXZlcnNlIHRoZSBvcmRlciAodG8gZmFydGhlc3QgLT4gY2xvc2VzdClcbiAgLy8gYW5kIHJlbW92ZSBzb2NrZXQgYWRkcmVzc1xuICBhZGRycy5yZXZlcnNlKCkucG9wKClcblxuICByZXR1cm4gYWRkcnNcbn0pO1xuXG4vKipcbiAqIFJldHVybiBzdWJkb21haW5zIGFzIGFuIGFycmF5LlxuICpcbiAqIFN1YmRvbWFpbnMgYXJlIHRoZSBkb3Qtc2VwYXJhdGVkIHBhcnRzIG9mIHRoZSBob3N0IGJlZm9yZSB0aGUgbWFpbiBkb21haW4gb2ZcbiAqIHRoZSBhcHAuIEJ5IGRlZmF1bHQsIHRoZSBkb21haW4gb2YgdGhlIGFwcCBpcyBhc3N1bWVkIHRvIGJlIHRoZSBsYXN0IHR3b1xuICogcGFydHMgb2YgdGhlIGhvc3QuIFRoaXMgY2FuIGJlIGNoYW5nZWQgYnkgc2V0dGluZyBcInN1YmRvbWFpbiBvZmZzZXRcIi5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgdGhlIGRvbWFpbiBpcyBcInRvYmkuZmVycmV0cy5leGFtcGxlLmNvbVwiOlxuICogSWYgXCJzdWJkb21haW4gb2Zmc2V0XCIgaXMgbm90IHNldCwgcmVxLnN1YmRvbWFpbnMgaXMgYFtcImZlcnJldHNcIiwgXCJ0b2JpXCJdYC5cbiAqIElmIFwic3ViZG9tYWluIG9mZnNldFwiIGlzIDMsIHJlcS5zdWJkb21haW5zIGlzIGBbXCJ0b2JpXCJdYC5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuXG5kZWZpbmVHZXR0ZXIocmVxLCAnc3ViZG9tYWlucycsIGZ1bmN0aW9uIHN1YmRvbWFpbnMoKSB7XG4gIHZhciBob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWU7XG5cbiAgaWYgKCFob3N0bmFtZSkgcmV0dXJuIFtdO1xuXG4gIHZhciBvZmZzZXQgPSB0aGlzLmFwcC5nZXQoJ3N1YmRvbWFpbiBvZmZzZXQnKTtcbiAgdmFyIHN1YmRvbWFpbnMgPSAhaXNJUChob3N0bmFtZSlcbiAgICA/IGhvc3RuYW1lLnNwbGl0KCcuJykucmV2ZXJzZSgpXG4gICAgOiBbaG9zdG5hbWVdO1xuXG4gIHJldHVybiBzdWJkb21haW5zLnNsaWNlKG9mZnNldCk7XG59KTtcblxuLyoqXG4gKiBTaG9ydC1oYW5kIGZvciBgdXJsLnBhcnNlKHJlcS51cmwpLnBhdGhuYW1lYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZGVmaW5lR2V0dGVyKHJlcSwgJ3BhdGgnLCBmdW5jdGlvbiBwYXRoKCkge1xuICByZXR1cm4gcGFyc2UodGhpcykucGF0aG5hbWU7XG59KTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgXCJIb3N0XCIgaGVhZGVyIGZpZWxkIHRvIGEgaG9zdG5hbWUuXG4gKlxuICogV2hlbiB0aGUgXCJ0cnVzdCBwcm94eVwiIHNldHRpbmcgdHJ1c3RzIHRoZSBzb2NrZXRcbiAqIGFkZHJlc3MsIHRoZSBcIlgtRm9yd2FyZGVkLUhvc3RcIiBoZWFkZXIgZmllbGQgd2lsbFxuICogYmUgdHJ1c3RlZC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZGVmaW5lR2V0dGVyKHJlcSwgJ2hvc3RuYW1lJywgZnVuY3Rpb24gaG9zdG5hbWUoKXtcbiAgdmFyIHRydXN0ID0gdGhpcy5hcHAuZ2V0KCd0cnVzdCBwcm94eSBmbicpO1xuICB2YXIgaG9zdCA9IHRoaXMuZ2V0KCdYLUZvcndhcmRlZC1Ib3N0Jyk7XG5cbiAgaWYgKCFob3N0IHx8ICF0cnVzdCh0aGlzLmNvbm5lY3Rpb24ucmVtb3RlQWRkcmVzcywgMCkpIHtcbiAgICBob3N0ID0gdGhpcy5nZXQoJ0hvc3QnKTtcbiAgfVxuXG4gIGlmICghaG9zdCkgcmV0dXJuO1xuXG4gIC8vIElQdjYgbGl0ZXJhbCBzdXBwb3J0XG4gIHZhciBvZmZzZXQgPSBob3N0WzBdID09PSAnWydcbiAgICA/IGhvc3QuaW5kZXhPZignXScpICsgMVxuICAgIDogMDtcbiAgdmFyIGluZGV4ID0gaG9zdC5pbmRleE9mKCc6Jywgb2Zmc2V0KTtcblxuICByZXR1cm4gaW5kZXggIT09IC0xXG4gICAgPyBob3N0LnN1YnN0cmluZygwLCBpbmRleClcbiAgICA6IGhvc3Q7XG59KTtcblxuLy8gVE9ETzogY2hhbmdlIHJlcS5ob3N0IHRvIHJldHVybiBob3N0IGluIG5leHQgbWFqb3JcblxuZGVmaW5lR2V0dGVyKHJlcSwgJ2hvc3QnLCBkZXByZWNhdGUuZnVuY3Rpb24oZnVuY3Rpb24gaG9zdCgpe1xuICByZXR1cm4gdGhpcy5ob3N0bmFtZTtcbn0sICdyZXEuaG9zdDogVXNlIHJlcS5ob3N0bmFtZSBpbnN0ZWFkJykpO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSByZXF1ZXN0IGlzIGZyZXNoLCBha2FcbiAqIExhc3QtTW9kaWZpZWQgYW5kL29yIHRoZSBFVGFnXG4gKiBzdGlsbCBtYXRjaC5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHB1YmxpY1xuICovXG5cbmRlZmluZUdldHRlcihyZXEsICdmcmVzaCcsIGZ1bmN0aW9uKCl7XG4gIHZhciBtZXRob2QgPSB0aGlzLm1ldGhvZDtcbiAgdmFyIHJlcyA9IHRoaXMucmVzXG4gIHZhciBzdGF0dXMgPSByZXMuc3RhdHVzQ29kZVxuXG4gIC8vIEdFVCBvciBIRUFEIGZvciB3ZWFrIGZyZXNobmVzcyB2YWxpZGF0aW9uIG9ubHlcbiAgaWYgKCdHRVQnICE9PSBtZXRob2QgJiYgJ0hFQUQnICE9PSBtZXRob2QpIHJldHVybiBmYWxzZTtcblxuICAvLyAyeHggb3IgMzA0IGFzIHBlciByZmMyNjE2IDE0LjI2XG4gIGlmICgoc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDApIHx8IDMwNCA9PT0gc3RhdHVzKSB7XG4gICAgcmV0dXJuIGZyZXNoKHRoaXMuaGVhZGVycywge1xuICAgICAgJ2V0YWcnOiByZXMuZ2V0KCdFVGFnJyksXG4gICAgICAnbGFzdC1tb2RpZmllZCc6IHJlcy5nZXQoJ0xhc3QtTW9kaWZpZWQnKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59KTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcmVxdWVzdCBpcyBzdGFsZSwgYWthXG4gKiBcIkxhc3QtTW9kaWZpZWRcIiBhbmQgLyBvciB0aGUgXCJFVGFnXCIgZm9yIHRoZVxuICogcmVzb3VyY2UgaGFzIGNoYW5nZWQuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBwdWJsaWNcbiAqL1xuXG5kZWZpbmVHZXR0ZXIocmVxLCAnc3RhbGUnLCBmdW5jdGlvbiBzdGFsZSgpe1xuICByZXR1cm4gIXRoaXMuZnJlc2g7XG59KTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcmVxdWVzdCB3YXMgYW4gX1hNTEh0dHBSZXF1ZXN0Xy5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHB1YmxpY1xuICovXG5cbmRlZmluZUdldHRlcihyZXEsICd4aHInLCBmdW5jdGlvbiB4aHIoKXtcbiAgdmFyIHZhbCA9IHRoaXMuZ2V0KCdYLVJlcXVlc3RlZC1XaXRoJykgfHwgJyc7XG4gIHJldHVybiB2YWwudG9Mb3dlckNhc2UoKSA9PT0gJ3htbGh0dHByZXF1ZXN0Jztcbn0pO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBnZXR0ZXIgb24gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmluZUdldHRlcihvYmosIG5hbWUsIGdldHRlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBnZXR0ZXJcbiAgfSk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9leHByZXNzL2xpYi9yZXF1ZXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBuZWdvdGlhdG9yXG4gKiBDb3B5cmlnaHQoYykgMjAxMiBGZWRlcmljbyBSb21lcm9cbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSXNhYWMgWi4gU2NobHVldGVyXG4gKiBDb3B5cmlnaHQoYykgMjAxNSBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENhY2hlZCBsb2FkZWQgc3VibW9kdWxlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIG1vZHVsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTmVnb3RpYXRvcjtcbm1vZHVsZS5leHBvcnRzLk5lZ290aWF0b3IgPSBOZWdvdGlhdG9yO1xuXG4vKipcbiAqIENyZWF0ZSBhIE5lZ290aWF0b3IgaW5zdGFuY2UgZnJvbSBhIHJlcXVlc3QuXG4gKiBAcGFyYW0ge29iamVjdH0gcmVxdWVzdFxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIE5lZ290aWF0b3IocmVxdWVzdCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTmVnb3RpYXRvcikpIHtcbiAgICByZXR1cm4gbmV3IE5lZ290aWF0b3IocmVxdWVzdCk7XG4gIH1cblxuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xufVxuXG5OZWdvdGlhdG9yLnByb3RvdHlwZS5jaGFyc2V0ID0gZnVuY3Rpb24gY2hhcnNldChhdmFpbGFibGUpIHtcbiAgdmFyIHNldCA9IHRoaXMuY2hhcnNldHMoYXZhaWxhYmxlKTtcbiAgcmV0dXJuIHNldCAmJiBzZXRbMF07XG59O1xuXG5OZWdvdGlhdG9yLnByb3RvdHlwZS5jaGFyc2V0cyA9IGZ1bmN0aW9uIGNoYXJzZXRzKGF2YWlsYWJsZSkge1xuICB2YXIgcHJlZmVycmVkQ2hhcnNldHMgPSBsb2FkTW9kdWxlKCdjaGFyc2V0JykucHJlZmVycmVkQ2hhcnNldHM7XG4gIHJldHVybiBwcmVmZXJyZWRDaGFyc2V0cyh0aGlzLnJlcXVlc3QuaGVhZGVyc1snYWNjZXB0LWNoYXJzZXQnXSwgYXZhaWxhYmxlKTtcbn07XG5cbk5lZ290aWF0b3IucHJvdG90eXBlLmVuY29kaW5nID0gZnVuY3Rpb24gZW5jb2RpbmcoYXZhaWxhYmxlKSB7XG4gIHZhciBzZXQgPSB0aGlzLmVuY29kaW5ncyhhdmFpbGFibGUpO1xuICByZXR1cm4gc2V0ICYmIHNldFswXTtcbn07XG5cbk5lZ290aWF0b3IucHJvdG90eXBlLmVuY29kaW5ncyA9IGZ1bmN0aW9uIGVuY29kaW5ncyhhdmFpbGFibGUpIHtcbiAgdmFyIHByZWZlcnJlZEVuY29kaW5ncyA9IGxvYWRNb2R1bGUoJ2VuY29kaW5nJykucHJlZmVycmVkRW5jb2RpbmdzO1xuICByZXR1cm4gcHJlZmVycmVkRW5jb2RpbmdzKHRoaXMucmVxdWVzdC5oZWFkZXJzWydhY2NlcHQtZW5jb2RpbmcnXSwgYXZhaWxhYmxlKTtcbn07XG5cbk5lZ290aWF0b3IucHJvdG90eXBlLmxhbmd1YWdlID0gZnVuY3Rpb24gbGFuZ3VhZ2UoYXZhaWxhYmxlKSB7XG4gIHZhciBzZXQgPSB0aGlzLmxhbmd1YWdlcyhhdmFpbGFibGUpO1xuICByZXR1cm4gc2V0ICYmIHNldFswXTtcbn07XG5cbk5lZ290aWF0b3IucHJvdG90eXBlLmxhbmd1YWdlcyA9IGZ1bmN0aW9uIGxhbmd1YWdlcyhhdmFpbGFibGUpIHtcbiAgdmFyIHByZWZlcnJlZExhbmd1YWdlcyA9IGxvYWRNb2R1bGUoJ2xhbmd1YWdlJykucHJlZmVycmVkTGFuZ3VhZ2VzO1xuICByZXR1cm4gcHJlZmVycmVkTGFuZ3VhZ2VzKHRoaXMucmVxdWVzdC5oZWFkZXJzWydhY2NlcHQtbGFuZ3VhZ2UnXSwgYXZhaWxhYmxlKTtcbn07XG5cbk5lZ290aWF0b3IucHJvdG90eXBlLm1lZGlhVHlwZSA9IGZ1bmN0aW9uIG1lZGlhVHlwZShhdmFpbGFibGUpIHtcbiAgdmFyIHNldCA9IHRoaXMubWVkaWFUeXBlcyhhdmFpbGFibGUpO1xuICByZXR1cm4gc2V0ICYmIHNldFswXTtcbn07XG5cbk5lZ290aWF0b3IucHJvdG90eXBlLm1lZGlhVHlwZXMgPSBmdW5jdGlvbiBtZWRpYVR5cGVzKGF2YWlsYWJsZSkge1xuICB2YXIgcHJlZmVycmVkTWVkaWFUeXBlcyA9IGxvYWRNb2R1bGUoJ21lZGlhVHlwZScpLnByZWZlcnJlZE1lZGlhVHlwZXM7XG4gIHJldHVybiBwcmVmZXJyZWRNZWRpYVR5cGVzKHRoaXMucmVxdWVzdC5oZWFkZXJzLmFjY2VwdCwgYXZhaWxhYmxlKTtcbn07XG5cbi8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5OZWdvdGlhdG9yLnByb3RvdHlwZS5wcmVmZXJyZWRDaGFyc2V0ID0gTmVnb3RpYXRvci5wcm90b3R5cGUuY2hhcnNldDtcbk5lZ290aWF0b3IucHJvdG90eXBlLnByZWZlcnJlZENoYXJzZXRzID0gTmVnb3RpYXRvci5wcm90b3R5cGUuY2hhcnNldHM7XG5OZWdvdGlhdG9yLnByb3RvdHlwZS5wcmVmZXJyZWRFbmNvZGluZyA9IE5lZ290aWF0b3IucHJvdG90eXBlLmVuY29kaW5nO1xuTmVnb3RpYXRvci5wcm90b3R5cGUucHJlZmVycmVkRW5jb2RpbmdzID0gTmVnb3RpYXRvci5wcm90b3R5cGUuZW5jb2RpbmdzO1xuTmVnb3RpYXRvci5wcm90b3R5cGUucHJlZmVycmVkTGFuZ3VhZ2UgPSBOZWdvdGlhdG9yLnByb3RvdHlwZS5sYW5ndWFnZTtcbk5lZ290aWF0b3IucHJvdG90eXBlLnByZWZlcnJlZExhbmd1YWdlcyA9IE5lZ290aWF0b3IucHJvdG90eXBlLmxhbmd1YWdlcztcbk5lZ290aWF0b3IucHJvdG90eXBlLnByZWZlcnJlZE1lZGlhVHlwZSA9IE5lZ290aWF0b3IucHJvdG90eXBlLm1lZGlhVHlwZTtcbk5lZ290aWF0b3IucHJvdG90eXBlLnByZWZlcnJlZE1lZGlhVHlwZXMgPSBOZWdvdGlhdG9yLnByb3RvdHlwZS5tZWRpYVR5cGVzO1xuXG4vKipcbiAqIExvYWQgdGhlIGdpdmVuIG1vZHVsZS5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZE1vZHVsZShtb2R1bGVOYW1lKSB7XG4gIHZhciBtb2R1bGUgPSBtb2R1bGVzW21vZHVsZU5hbWVdO1xuXG4gIGlmIChtb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBtb2R1bGU7XG4gIH1cblxuICAvLyBUaGlzIHVzZXMgYSBzd2l0Y2ggZm9yIHN0YXRpYyByZXF1aXJlIGFuYWx5c2lzXG4gIHN3aXRjaCAobW9kdWxlTmFtZSkge1xuICAgIGNhc2UgJ2NoYXJzZXQnOlxuICAgICAgbW9kdWxlID0gcmVxdWlyZSgnLi9saWIvY2hhcnNldCcpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZW5jb2RpbmcnOlxuICAgICAgbW9kdWxlID0gcmVxdWlyZSgnLi9saWIvZW5jb2RpbmcnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xhbmd1YWdlJzpcbiAgICAgIG1vZHVsZSA9IHJlcXVpcmUoJy4vbGliL2xhbmd1YWdlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtZWRpYVR5cGUnOlxuICAgICAgbW9kdWxlID0gcmVxdWlyZSgnLi9saWIvbWVkaWFUeXBlJyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBtb2R1bGUgXFwnJyArIG1vZHVsZU5hbWUgKyAnXFwnJyk7XG4gIH1cblxuICAvLyBTdG9yZSB0byBwcmV2ZW50IGludm9raW5nIHJlcXVpcmUoKVxuICBtb2R1bGVzW21vZHVsZU5hbWVdID0gbW9kdWxlO1xuXG4gIHJldHVybiBtb2R1bGU7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9uZWdvdGlhdG9yL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBuZWdvdGlhdG9yXG4gKiBDb3B5cmlnaHQoYykgMjAxMiBJc2FhYyBaLiBTY2hsdWV0ZXJcbiAqIENvcHlyaWdodChjKSAyMDE0IEZlZGVyaWNvIFJvbWVyb1xuICogQ29weXJpZ2h0KGMpIDIwMTQtMjAxNSBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcHJlZmVycmVkQ2hhcnNldHM7XG5tb2R1bGUuZXhwb3J0cy5wcmVmZXJyZWRDaGFyc2V0cyA9IHByZWZlcnJlZENoYXJzZXRzO1xuXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBzaW1wbGVDaGFyc2V0UmVnRXhwID0gL15cXHMqKFteXFxzO10rKVxccyooPzo7KC4qKSk/JC87XG5cbi8qKlxuICogUGFyc2UgdGhlIEFjY2VwdC1DaGFyc2V0IGhlYWRlci5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VBY2NlcHRDaGFyc2V0KGFjY2VwdCkge1xuICB2YXIgYWNjZXB0cyA9IGFjY2VwdC5zcGxpdCgnLCcpO1xuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IGFjY2VwdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hhcnNldCA9IHBhcnNlQ2hhcnNldChhY2NlcHRzW2ldLnRyaW0oKSwgaSk7XG5cbiAgICBpZiAoY2hhcnNldCkge1xuICAgICAgYWNjZXB0c1tqKytdID0gY2hhcnNldDtcbiAgICB9XG4gIH1cblxuICAvLyB0cmltIGFjY2VwdHNcbiAgYWNjZXB0cy5sZW5ndGggPSBqO1xuXG4gIHJldHVybiBhY2NlcHRzO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgY2hhcnNldCBmcm9tIHRoZSBBY2NlcHQtQ2hhcnNldCBoZWFkZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlQ2hhcnNldChzdHIsIGkpIHtcbiAgdmFyIG1hdGNoID0gc2ltcGxlQ2hhcnNldFJlZ0V4cC5leGVjKHN0cik7XG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuXG4gIHZhciBjaGFyc2V0ID0gbWF0Y2hbMV07XG4gIHZhciBxID0gMTtcbiAgaWYgKG1hdGNoWzJdKSB7XG4gICAgdmFyIHBhcmFtcyA9IG1hdGNoWzJdLnNwbGl0KCc7JylcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcmFtcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHAgPSBwYXJhbXNbal0udHJpbSgpLnNwbGl0KCc9Jyk7XG4gICAgICBpZiAocFswXSA9PT0gJ3EnKSB7XG4gICAgICAgIHEgPSBwYXJzZUZsb2F0KHBbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNoYXJzZXQ6IGNoYXJzZXQsXG4gICAgcTogcSxcbiAgICBpOiBpXG4gIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcmlvcml0eSBvZiBhIGNoYXJzZXQuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGdldENoYXJzZXRQcmlvcml0eShjaGFyc2V0LCBhY2NlcHRlZCwgaW5kZXgpIHtcbiAgdmFyIHByaW9yaXR5ID0ge286IC0xLCBxOiAwLCBzOiAwfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFjY2VwdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNwZWMgPSBzcGVjaWZ5KGNoYXJzZXQsIGFjY2VwdGVkW2ldLCBpbmRleCk7XG5cbiAgICBpZiAoc3BlYyAmJiAocHJpb3JpdHkucyAtIHNwZWMucyB8fCBwcmlvcml0eS5xIC0gc3BlYy5xIHx8IHByaW9yaXR5Lm8gLSBzcGVjLm8pIDwgMCkge1xuICAgICAgcHJpb3JpdHkgPSBzcGVjO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcmlvcml0eTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNwZWNpZmljaXR5IG9mIHRoZSBjaGFyc2V0LlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzcGVjaWZ5KGNoYXJzZXQsIHNwZWMsIGluZGV4KSB7XG4gIHZhciBzID0gMDtcbiAgaWYoc3BlYy5jaGFyc2V0LnRvTG93ZXJDYXNlKCkgPT09IGNoYXJzZXQudG9Mb3dlckNhc2UoKSl7XG4gICAgcyB8PSAxO1xuICB9IGVsc2UgaWYgKHNwZWMuY2hhcnNldCAhPT0gJyonICkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGk6IGluZGV4LFxuICAgIG86IHNwZWMuaSxcbiAgICBxOiBzcGVjLnEsXG4gICAgczogc1xuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcmVmZXJyZWQgY2hhcnNldHMgZnJvbSBhbiBBY2NlcHQtQ2hhcnNldCBoZWFkZXIuXG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gcHJlZmVycmVkQ2hhcnNldHMoYWNjZXB0LCBwcm92aWRlZCkge1xuICAvLyBSRkMgMjYxNiBzZWMgMTQuMjogbm8gaGVhZGVyID0gKlxuICB2YXIgYWNjZXB0cyA9IHBhcnNlQWNjZXB0Q2hhcnNldChhY2NlcHQgPT09IHVuZGVmaW5lZCA/ICcqJyA6IGFjY2VwdCB8fCAnJyk7XG5cbiAgaWYgKCFwcm92aWRlZCkge1xuICAgIC8vIHNvcnRlZCBsaXN0IG9mIGFsbCBjaGFyc2V0c1xuICAgIHJldHVybiBhY2NlcHRzXG4gICAgICAuZmlsdGVyKGlzUXVhbGl0eSlcbiAgICAgIC5zb3J0KGNvbXBhcmVTcGVjcylcbiAgICAgIC5tYXAoZ2V0RnVsbENoYXJzZXQpO1xuICB9XG5cbiAgdmFyIHByaW9yaXRpZXMgPSBwcm92aWRlZC5tYXAoZnVuY3Rpb24gZ2V0UHJpb3JpdHkodHlwZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gZ2V0Q2hhcnNldFByaW9yaXR5KHR5cGUsIGFjY2VwdHMsIGluZGV4KTtcbiAgfSk7XG5cbiAgLy8gc29ydGVkIGxpc3Qgb2YgYWNjZXB0ZWQgY2hhcnNldHNcbiAgcmV0dXJuIHByaW9yaXRpZXMuZmlsdGVyKGlzUXVhbGl0eSkuc29ydChjb21wYXJlU3BlY3MpLm1hcChmdW5jdGlvbiBnZXRDaGFyc2V0KHByaW9yaXR5KSB7XG4gICAgcmV0dXJuIHByb3ZpZGVkW3ByaW9yaXRpZXMuaW5kZXhPZihwcmlvcml0eSldO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb21wYXJlIHR3byBzcGVjcy5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29tcGFyZVNwZWNzKGEsIGIpIHtcbiAgcmV0dXJuIChiLnEgLSBhLnEpIHx8IChiLnMgLSBhLnMpIHx8IChhLm8gLSBiLm8pIHx8IChhLmkgLSBiLmkpIHx8IDA7XG59XG5cbi8qKlxuICogR2V0IGZ1bGwgY2hhcnNldCBzdHJpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGdldEZ1bGxDaGFyc2V0KHNwZWMpIHtcbiAgcmV0dXJuIHNwZWMuY2hhcnNldDtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHNwZWMgaGFzIGFueSBxdWFsaXR5LlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc1F1YWxpdHkoc3BlYykge1xuICByZXR1cm4gc3BlYy5xID4gMDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL25lZ290aWF0b3IvbGliL2NoYXJzZXQuanNcbi8vIG1vZHVsZSBpZCA9IDEzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIG5lZ290aWF0b3JcbiAqIENvcHlyaWdodChjKSAyMDEyIElzYWFjIFouIFNjaGx1ZXRlclxuICogQ29weXJpZ2h0KGMpIDIwMTQgRmVkZXJpY28gUm9tZXJvXG4gKiBDb3B5cmlnaHQoYykgMjAxNC0yMDE1IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBwcmVmZXJyZWRFbmNvZGluZ3M7XG5tb2R1bGUuZXhwb3J0cy5wcmVmZXJyZWRFbmNvZGluZ3MgPSBwcmVmZXJyZWRFbmNvZGluZ3M7XG5cbi8qKlxuICogTW9kdWxlIHZhcmlhYmxlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIHNpbXBsZUVuY29kaW5nUmVnRXhwID0gL15cXHMqKFteXFxzO10rKVxccyooPzo7KC4qKSk/JC87XG5cbi8qKlxuICogUGFyc2UgdGhlIEFjY2VwdC1FbmNvZGluZyBoZWFkZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlQWNjZXB0RW5jb2RpbmcoYWNjZXB0KSB7XG4gIHZhciBhY2NlcHRzID0gYWNjZXB0LnNwbGl0KCcsJyk7XG4gIHZhciBoYXNJZGVudGl0eSA9IGZhbHNlO1xuICB2YXIgbWluUXVhbGl0eSA9IDE7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgYWNjZXB0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbmNvZGluZyA9IHBhcnNlRW5jb2RpbmcoYWNjZXB0c1tpXS50cmltKCksIGkpO1xuXG4gICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICBhY2NlcHRzW2orK10gPSBlbmNvZGluZztcbiAgICAgIGhhc0lkZW50aXR5ID0gaGFzSWRlbnRpdHkgfHwgc3BlY2lmeSgnaWRlbnRpdHknLCBlbmNvZGluZyk7XG4gICAgICBtaW5RdWFsaXR5ID0gTWF0aC5taW4obWluUXVhbGl0eSwgZW5jb2RpbmcucSB8fCAxKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhhc0lkZW50aXR5KSB7XG4gICAgLypcbiAgICAgKiBJZiBpZGVudGl0eSBkb2Vzbid0IGV4cGxpY2l0bHkgYXBwZWFyIGluIHRoZSBhY2NlcHQtZW5jb2RpbmcgaGVhZGVyLFxuICAgICAqIGl0J3MgYWRkZWQgdG8gdGhlIGxpc3Qgb2YgYWNjZXB0YWJsZSBlbmNvZGluZyB3aXRoIHRoZSBsb3dlc3QgcVxuICAgICAqL1xuICAgIGFjY2VwdHNbaisrXSA9IHtcbiAgICAgIGVuY29kaW5nOiAnaWRlbnRpdHknLFxuICAgICAgcTogbWluUXVhbGl0eSxcbiAgICAgIGk6IGlcbiAgICB9O1xuICB9XG5cbiAgLy8gdHJpbSBhY2NlcHRzXG4gIGFjY2VwdHMubGVuZ3RoID0gajtcblxuICByZXR1cm4gYWNjZXB0cztcbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBlbmNvZGluZyBmcm9tIHRoZSBBY2NlcHQtRW5jb2RpbmcgaGVhZGVyLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUVuY29kaW5nKHN0ciwgaSkge1xuICB2YXIgbWF0Y2ggPSBzaW1wbGVFbmNvZGluZ1JlZ0V4cC5leGVjKHN0cik7XG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuXG4gIHZhciBlbmNvZGluZyA9IG1hdGNoWzFdO1xuICB2YXIgcSA9IDE7XG4gIGlmIChtYXRjaFsyXSkge1xuICAgIHZhciBwYXJhbXMgPSBtYXRjaFsyXS5zcGxpdCgnOycpO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFyYW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcCA9IHBhcmFtc1tqXS50cmltKCkuc3BsaXQoJz0nKTtcbiAgICAgIGlmIChwWzBdID09PSAncScpIHtcbiAgICAgICAgcSA9IHBhcnNlRmxvYXQocFsxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgIHE6IHEsXG4gICAgaTogaVxuICB9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJpb3JpdHkgb2YgYW4gZW5jb2RpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGdldEVuY29kaW5nUHJpb3JpdHkoZW5jb2RpbmcsIGFjY2VwdGVkLCBpbmRleCkge1xuICB2YXIgcHJpb3JpdHkgPSB7bzogLTEsIHE6IDAsIHM6IDB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWNjZXB0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3BlYyA9IHNwZWNpZnkoZW5jb2RpbmcsIGFjY2VwdGVkW2ldLCBpbmRleCk7XG5cbiAgICBpZiAoc3BlYyAmJiAocHJpb3JpdHkucyAtIHNwZWMucyB8fCBwcmlvcml0eS5xIC0gc3BlYy5xIHx8IHByaW9yaXR5Lm8gLSBzcGVjLm8pIDwgMCkge1xuICAgICAgcHJpb3JpdHkgPSBzcGVjO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcmlvcml0eTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNwZWNpZmljaXR5IG9mIHRoZSBlbmNvZGluZy5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc3BlY2lmeShlbmNvZGluZywgc3BlYywgaW5kZXgpIHtcbiAgdmFyIHMgPSAwO1xuICBpZihzcGVjLmVuY29kaW5nLnRvTG93ZXJDYXNlKCkgPT09IGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpe1xuICAgIHMgfD0gMTtcbiAgfSBlbHNlIGlmIChzcGVjLmVuY29kaW5nICE9PSAnKicgKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaTogaW5kZXgsXG4gICAgbzogc3BlYy5pLFxuICAgIHE6IHNwZWMucSxcbiAgICBzOiBzXG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBwcmVmZXJyZWQgZW5jb2RpbmdzIGZyb20gYW4gQWNjZXB0LUVuY29kaW5nIGhlYWRlci5cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBwcmVmZXJyZWRFbmNvZGluZ3MoYWNjZXB0LCBwcm92aWRlZCkge1xuICB2YXIgYWNjZXB0cyA9IHBhcnNlQWNjZXB0RW5jb2RpbmcoYWNjZXB0IHx8ICcnKTtcblxuICBpZiAoIXByb3ZpZGVkKSB7XG4gICAgLy8gc29ydGVkIGxpc3Qgb2YgYWxsIGVuY29kaW5nc1xuICAgIHJldHVybiBhY2NlcHRzXG4gICAgICAuZmlsdGVyKGlzUXVhbGl0eSlcbiAgICAgIC5zb3J0KGNvbXBhcmVTcGVjcylcbiAgICAgIC5tYXAoZ2V0RnVsbEVuY29kaW5nKTtcbiAgfVxuXG4gIHZhciBwcmlvcml0aWVzID0gcHJvdmlkZWQubWFwKGZ1bmN0aW9uIGdldFByaW9yaXR5KHR5cGUsIGluZGV4KSB7XG4gICAgcmV0dXJuIGdldEVuY29kaW5nUHJpb3JpdHkodHlwZSwgYWNjZXB0cywgaW5kZXgpO1xuICB9KTtcblxuICAvLyBzb3J0ZWQgbGlzdCBvZiBhY2NlcHRlZCBlbmNvZGluZ3NcbiAgcmV0dXJuIHByaW9yaXRpZXMuZmlsdGVyKGlzUXVhbGl0eSkuc29ydChjb21wYXJlU3BlY3MpLm1hcChmdW5jdGlvbiBnZXRFbmNvZGluZyhwcmlvcml0eSkge1xuICAgIHJldHVybiBwcm92aWRlZFtwcmlvcml0aWVzLmluZGV4T2YocHJpb3JpdHkpXTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29tcGFyZSB0d28gc3BlY3MuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbXBhcmVTcGVjcyhhLCBiKSB7XG4gIHJldHVybiAoYi5xIC0gYS5xKSB8fCAoYi5zIC0gYS5zKSB8fCAoYS5vIC0gYi5vKSB8fCAoYS5pIC0gYi5pKSB8fCAwO1xufVxuXG4vKipcbiAqIEdldCBmdWxsIGVuY29kaW5nIHN0cmluZy5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZ2V0RnVsbEVuY29kaW5nKHNwZWMpIHtcbiAgcmV0dXJuIHNwZWMuZW5jb2Rpbmc7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzcGVjIGhhcyBhbnkgcXVhbGl0eS5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNRdWFsaXR5KHNwZWMpIHtcbiAgcmV0dXJuIHNwZWMucSA+IDA7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9uZWdvdGlhdG9yL2xpYi9lbmNvZGluZy5qc1xuLy8gbW9kdWxlIGlkID0gMTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogbmVnb3RpYXRvclxuICogQ29weXJpZ2h0KGMpIDIwMTIgSXNhYWMgWi4gU2NobHVldGVyXG4gKiBDb3B5cmlnaHQoYykgMjAxNCBGZWRlcmljbyBSb21lcm9cbiAqIENvcHlyaWdodChjKSAyMDE0LTIwMTUgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHByZWZlcnJlZExhbmd1YWdlcztcbm1vZHVsZS5leHBvcnRzLnByZWZlcnJlZExhbmd1YWdlcyA9IHByZWZlcnJlZExhbmd1YWdlcztcblxuLyoqXG4gKiBNb2R1bGUgdmFyaWFibGVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgc2ltcGxlTGFuZ3VhZ2VSZWdFeHAgPSAvXlxccyooW15cXHNcXC07XSspKD86LShbXlxccztdKykpP1xccyooPzo7KC4qKSk/JC87XG5cbi8qKlxuICogUGFyc2UgdGhlIEFjY2VwdC1MYW5ndWFnZSBoZWFkZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlQWNjZXB0TGFuZ3VhZ2UoYWNjZXB0KSB7XG4gIHZhciBhY2NlcHRzID0gYWNjZXB0LnNwbGl0KCcsJyk7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgYWNjZXB0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsYW5ndWFnZSA9IHBhcnNlTGFuZ3VhZ2UoYWNjZXB0c1tpXS50cmltKCksIGkpO1xuXG4gICAgaWYgKGxhbmd1YWdlKSB7XG4gICAgICBhY2NlcHRzW2orK10gPSBsYW5ndWFnZTtcbiAgICB9XG4gIH1cblxuICAvLyB0cmltIGFjY2VwdHNcbiAgYWNjZXB0cy5sZW5ndGggPSBqO1xuXG4gIHJldHVybiBhY2NlcHRzO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgbGFuZ3VhZ2UgZnJvbSB0aGUgQWNjZXB0LUxhbmd1YWdlIGhlYWRlci5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VMYW5ndWFnZShzdHIsIGkpIHtcbiAgdmFyIG1hdGNoID0gc2ltcGxlTGFuZ3VhZ2VSZWdFeHAuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcHJlZml4ID0gbWF0Y2hbMV0sXG4gICAgc3VmZml4ID0gbWF0Y2hbMl0sXG4gICAgZnVsbCA9IHByZWZpeDtcblxuICBpZiAoc3VmZml4KSBmdWxsICs9IFwiLVwiICsgc3VmZml4O1xuXG4gIHZhciBxID0gMTtcbiAgaWYgKG1hdGNoWzNdKSB7XG4gICAgdmFyIHBhcmFtcyA9IG1hdGNoWzNdLnNwbGl0KCc7JylcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcmFtcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHAgPSBwYXJhbXNbal0uc3BsaXQoJz0nKTtcbiAgICAgIGlmIChwWzBdID09PSAncScpIHEgPSBwYXJzZUZsb2F0KHBbMV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcHJlZml4OiBwcmVmaXgsXG4gICAgc3VmZml4OiBzdWZmaXgsXG4gICAgcTogcSxcbiAgICBpOiBpLFxuICAgIGZ1bGw6IGZ1bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByaW9yaXR5IG9mIGEgbGFuZ3VhZ2UuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGdldExhbmd1YWdlUHJpb3JpdHkobGFuZ3VhZ2UsIGFjY2VwdGVkLCBpbmRleCkge1xuICB2YXIgcHJpb3JpdHkgPSB7bzogLTEsIHE6IDAsIHM6IDB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWNjZXB0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3BlYyA9IHNwZWNpZnkobGFuZ3VhZ2UsIGFjY2VwdGVkW2ldLCBpbmRleCk7XG5cbiAgICBpZiAoc3BlYyAmJiAocHJpb3JpdHkucyAtIHNwZWMucyB8fCBwcmlvcml0eS5xIC0gc3BlYy5xIHx8IHByaW9yaXR5Lm8gLSBzcGVjLm8pIDwgMCkge1xuICAgICAgcHJpb3JpdHkgPSBzcGVjO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcmlvcml0eTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNwZWNpZmljaXR5IG9mIHRoZSBsYW5ndWFnZS5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc3BlY2lmeShsYW5ndWFnZSwgc3BlYywgaW5kZXgpIHtcbiAgdmFyIHAgPSBwYXJzZUxhbmd1YWdlKGxhbmd1YWdlKVxuICBpZiAoIXApIHJldHVybiBudWxsO1xuICB2YXIgcyA9IDA7XG4gIGlmKHNwZWMuZnVsbC50b0xvd2VyQ2FzZSgpID09PSBwLmZ1bGwudG9Mb3dlckNhc2UoKSl7XG4gICAgcyB8PSA0O1xuICB9IGVsc2UgaWYgKHNwZWMucHJlZml4LnRvTG93ZXJDYXNlKCkgPT09IHAuZnVsbC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgcyB8PSAyO1xuICB9IGVsc2UgaWYgKHNwZWMuZnVsbC50b0xvd2VyQ2FzZSgpID09PSBwLnByZWZpeC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgcyB8PSAxO1xuICB9IGVsc2UgaWYgKHNwZWMuZnVsbCAhPT0gJyonICkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGk6IGluZGV4LFxuICAgIG86IHNwZWMuaSxcbiAgICBxOiBzcGVjLnEsXG4gICAgczogc1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgcHJlZmVycmVkIGxhbmd1YWdlcyBmcm9tIGFuIEFjY2VwdC1MYW5ndWFnZSBoZWFkZXIuXG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gcHJlZmVycmVkTGFuZ3VhZ2VzKGFjY2VwdCwgcHJvdmlkZWQpIHtcbiAgLy8gUkZDIDI2MTYgc2VjIDE0LjQ6IG5vIGhlYWRlciA9ICpcbiAgdmFyIGFjY2VwdHMgPSBwYXJzZUFjY2VwdExhbmd1YWdlKGFjY2VwdCA9PT0gdW5kZWZpbmVkID8gJyonIDogYWNjZXB0IHx8ICcnKTtcblxuICBpZiAoIXByb3ZpZGVkKSB7XG4gICAgLy8gc29ydGVkIGxpc3Qgb2YgYWxsIGxhbmd1YWdlc1xuICAgIHJldHVybiBhY2NlcHRzXG4gICAgICAuZmlsdGVyKGlzUXVhbGl0eSlcbiAgICAgIC5zb3J0KGNvbXBhcmVTcGVjcylcbiAgICAgIC5tYXAoZ2V0RnVsbExhbmd1YWdlKTtcbiAgfVxuXG4gIHZhciBwcmlvcml0aWVzID0gcHJvdmlkZWQubWFwKGZ1bmN0aW9uIGdldFByaW9yaXR5KHR5cGUsIGluZGV4KSB7XG4gICAgcmV0dXJuIGdldExhbmd1YWdlUHJpb3JpdHkodHlwZSwgYWNjZXB0cywgaW5kZXgpO1xuICB9KTtcblxuICAvLyBzb3J0ZWQgbGlzdCBvZiBhY2NlcHRlZCBsYW5ndWFnZXNcbiAgcmV0dXJuIHByaW9yaXRpZXMuZmlsdGVyKGlzUXVhbGl0eSkuc29ydChjb21wYXJlU3BlY3MpLm1hcChmdW5jdGlvbiBnZXRMYW5ndWFnZShwcmlvcml0eSkge1xuICAgIHJldHVybiBwcm92aWRlZFtwcmlvcml0aWVzLmluZGV4T2YocHJpb3JpdHkpXTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29tcGFyZSB0d28gc3BlY3MuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbXBhcmVTcGVjcyhhLCBiKSB7XG4gIHJldHVybiAoYi5xIC0gYS5xKSB8fCAoYi5zIC0gYS5zKSB8fCAoYS5vIC0gYi5vKSB8fCAoYS5pIC0gYi5pKSB8fCAwO1xufVxuXG4vKipcbiAqIEdldCBmdWxsIGxhbmd1YWdlIHN0cmluZy5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZ2V0RnVsbExhbmd1YWdlKHNwZWMpIHtcbiAgcmV0dXJuIHNwZWMuZnVsbDtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHNwZWMgaGFzIGFueSBxdWFsaXR5LlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc1F1YWxpdHkoc3BlYykge1xuICByZXR1cm4gc3BlYy5xID4gMDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL25lZ290aWF0b3IvbGliL2xhbmd1YWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBuZWdvdGlhdG9yXG4gKiBDb3B5cmlnaHQoYykgMjAxMiBJc2FhYyBaLiBTY2hsdWV0ZXJcbiAqIENvcHlyaWdodChjKSAyMDE0IEZlZGVyaWNvIFJvbWVyb1xuICogQ29weXJpZ2h0KGMpIDIwMTQtMjAxNSBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcHJlZmVycmVkTWVkaWFUeXBlcztcbm1vZHVsZS5leHBvcnRzLnByZWZlcnJlZE1lZGlhVHlwZXMgPSBwcmVmZXJyZWRNZWRpYVR5cGVzO1xuXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBzaW1wbGVNZWRpYVR5cGVSZWdFeHAgPSAvXlxccyooW15cXHNcXC87XSspXFwvKFteO1xcc10rKVxccyooPzo7KC4qKSk/JC87XG5cbi8qKlxuICogUGFyc2UgdGhlIEFjY2VwdCBoZWFkZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlQWNjZXB0KGFjY2VwdCkge1xuICB2YXIgYWNjZXB0cyA9IHNwbGl0TWVkaWFUeXBlcyhhY2NlcHQpO1xuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IGFjY2VwdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWVkaWFUeXBlID0gcGFyc2VNZWRpYVR5cGUoYWNjZXB0c1tpXS50cmltKCksIGkpO1xuXG4gICAgaWYgKG1lZGlhVHlwZSkge1xuICAgICAgYWNjZXB0c1tqKytdID0gbWVkaWFUeXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRyaW0gYWNjZXB0c1xuICBhY2NlcHRzLmxlbmd0aCA9IGo7XG5cbiAgcmV0dXJuIGFjY2VwdHM7XG59XG5cbi8qKlxuICogUGFyc2UgYSBtZWRpYSB0eXBlIGZyb20gdGhlIEFjY2VwdCBoZWFkZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlTWVkaWFUeXBlKHN0ciwgaSkge1xuICB2YXIgbWF0Y2ggPSBzaW1wbGVNZWRpYVR5cGVSZWdFeHAuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIHEgPSAxO1xuICB2YXIgc3VidHlwZSA9IG1hdGNoWzJdO1xuICB2YXIgdHlwZSA9IG1hdGNoWzFdO1xuXG4gIGlmIChtYXRjaFszXSkge1xuICAgIHZhciBrdnBzID0gc3BsaXRQYXJhbWV0ZXJzKG1hdGNoWzNdKS5tYXAoc3BsaXRLZXlWYWx1ZVBhaXIpO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBrdnBzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcGFpciA9IGt2cHNbal07XG4gICAgICB2YXIga2V5ID0gcGFpclswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHZhbCA9IHBhaXJbMV07XG5cbiAgICAgIC8vIGdldCB0aGUgdmFsdWUsIHVud3JhcHBpbmcgcXVvdGVzXG4gICAgICB2YXIgdmFsdWUgPSB2YWwgJiYgdmFsWzBdID09PSAnXCInICYmIHZhbFt2YWwubGVuZ3RoIC0gMV0gPT09ICdcIidcbiAgICAgICAgPyB2YWwuc3Vic3RyKDEsIHZhbC5sZW5ndGggLSAyKVxuICAgICAgICA6IHZhbDtcblxuICAgICAgaWYgKGtleSA9PT0gJ3EnKSB7XG4gICAgICAgIHEgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIHN0b3JlIHBhcmFtZXRlclxuICAgICAgcGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgc3VidHlwZTogc3VidHlwZSxcbiAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICBxOiBxLFxuICAgIGk6IGlcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByaW9yaXR5IG9mIGEgbWVkaWEgdHlwZS5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZ2V0TWVkaWFUeXBlUHJpb3JpdHkodHlwZSwgYWNjZXB0ZWQsIGluZGV4KSB7XG4gIHZhciBwcmlvcml0eSA9IHtvOiAtMSwgcTogMCwgczogMH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY2NlcHRlZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzcGVjID0gc3BlY2lmeSh0eXBlLCBhY2NlcHRlZFtpXSwgaW5kZXgpO1xuXG4gICAgaWYgKHNwZWMgJiYgKHByaW9yaXR5LnMgLSBzcGVjLnMgfHwgcHJpb3JpdHkucSAtIHNwZWMucSB8fCBwcmlvcml0eS5vIC0gc3BlYy5vKSA8IDApIHtcbiAgICAgIHByaW9yaXR5ID0gc3BlYztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJpb3JpdHk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBzcGVjaWZpY2l0eSBvZiB0aGUgbWVkaWEgdHlwZS5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc3BlY2lmeSh0eXBlLCBzcGVjLCBpbmRleCkge1xuICB2YXIgcCA9IHBhcnNlTWVkaWFUeXBlKHR5cGUpO1xuICB2YXIgcyA9IDA7XG5cbiAgaWYgKCFwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZihzcGVjLnR5cGUudG9Mb3dlckNhc2UoKSA9PSBwLnR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgIHMgfD0gNFxuICB9IGVsc2UgaWYoc3BlYy50eXBlICE9ICcqJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYoc3BlYy5zdWJ0eXBlLnRvTG93ZXJDYXNlKCkgPT0gcC5zdWJ0eXBlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBzIHw9IDJcbiAgfSBlbHNlIGlmKHNwZWMuc3VidHlwZSAhPSAnKicpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3BlYy5wYXJhbXMpO1xuICBpZiAoa2V5cy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKGtleXMuZXZlcnkoZnVuY3Rpb24gKGspIHtcbiAgICAgIHJldHVybiBzcGVjLnBhcmFtc1trXSA9PSAnKicgfHwgKHNwZWMucGFyYW1zW2tdIHx8ICcnKS50b0xvd2VyQ2FzZSgpID09IChwLnBhcmFtc1trXSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICB9KSkge1xuICAgICAgcyB8PSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpOiBpbmRleCxcbiAgICBvOiBzcGVjLmksXG4gICAgcTogc3BlYy5xLFxuICAgIHM6IHMsXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByZWZlcnJlZCBtZWRpYSB0eXBlcyBmcm9tIGFuIEFjY2VwdCBoZWFkZXIuXG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gcHJlZmVycmVkTWVkaWFUeXBlcyhhY2NlcHQsIHByb3ZpZGVkKSB7XG4gIC8vIFJGQyAyNjE2IHNlYyAxNC4yOiBubyBoZWFkZXIgPSAqLypcbiAgdmFyIGFjY2VwdHMgPSBwYXJzZUFjY2VwdChhY2NlcHQgPT09IHVuZGVmaW5lZCA/ICcqLyonIDogYWNjZXB0IHx8ICcnKTtcblxuICBpZiAoIXByb3ZpZGVkKSB7XG4gICAgLy8gc29ydGVkIGxpc3Qgb2YgYWxsIHR5cGVzXG4gICAgcmV0dXJuIGFjY2VwdHNcbiAgICAgIC5maWx0ZXIoaXNRdWFsaXR5KVxuICAgICAgLnNvcnQoY29tcGFyZVNwZWNzKVxuICAgICAgLm1hcChnZXRGdWxsVHlwZSk7XG4gIH1cblxuICB2YXIgcHJpb3JpdGllcyA9IHByb3ZpZGVkLm1hcChmdW5jdGlvbiBnZXRQcmlvcml0eSh0eXBlLCBpbmRleCkge1xuICAgIHJldHVybiBnZXRNZWRpYVR5cGVQcmlvcml0eSh0eXBlLCBhY2NlcHRzLCBpbmRleCk7XG4gIH0pO1xuXG4gIC8vIHNvcnRlZCBsaXN0IG9mIGFjY2VwdGVkIHR5cGVzXG4gIHJldHVybiBwcmlvcml0aWVzLmZpbHRlcihpc1F1YWxpdHkpLnNvcnQoY29tcGFyZVNwZWNzKS5tYXAoZnVuY3Rpb24gZ2V0VHlwZShwcmlvcml0eSkge1xuICAgIHJldHVybiBwcm92aWRlZFtwcmlvcml0aWVzLmluZGV4T2YocHJpb3JpdHkpXTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29tcGFyZSB0d28gc3BlY3MuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbXBhcmVTcGVjcyhhLCBiKSB7XG4gIHJldHVybiAoYi5xIC0gYS5xKSB8fCAoYi5zIC0gYS5zKSB8fCAoYS5vIC0gYi5vKSB8fCAoYS5pIC0gYi5pKSB8fCAwO1xufVxuXG4vKipcbiAqIEdldCBmdWxsIHR5cGUgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRGdWxsVHlwZShzcGVjKSB7XG4gIHJldHVybiBzcGVjLnR5cGUgKyAnLycgKyBzcGVjLnN1YnR5cGU7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzcGVjIGhhcyBhbnkgcXVhbGl0eS5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNRdWFsaXR5KHNwZWMpIHtcbiAgcmV0dXJuIHNwZWMucSA+IDA7XG59XG5cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBxdW90ZXMgaW4gYSBzdHJpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHF1b3RlQ291bnQoc3RyaW5nKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgd2hpbGUgKChpbmRleCA9IHN0cmluZy5pbmRleE9mKCdcIicsIGluZGV4KSkgIT09IC0xKSB7XG4gICAgY291bnQrKztcbiAgICBpbmRleCsrO1xuICB9XG5cbiAgcmV0dXJuIGNvdW50O1xufVxuXG4vKipcbiAqIFNwbGl0IGEga2V5IHZhbHVlIHBhaXIuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNwbGl0S2V5VmFsdWVQYWlyKHN0cikge1xuICB2YXIgaW5kZXggPSBzdHIuaW5kZXhPZignPScpO1xuICB2YXIga2V5O1xuICB2YXIgdmFsO1xuXG4gIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICBrZXkgPSBzdHI7XG4gIH0gZWxzZSB7XG4gICAga2V5ID0gc3RyLnN1YnN0cigwLCBpbmRleCk7XG4gICAgdmFsID0gc3RyLnN1YnN0cihpbmRleCArIDEpO1xuICB9XG5cbiAgcmV0dXJuIFtrZXksIHZhbF07XG59XG5cbi8qKlxuICogU3BsaXQgYW4gQWNjZXB0IGhlYWRlciBpbnRvIG1lZGlhIHR5cGVzLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzcGxpdE1lZGlhVHlwZXMoYWNjZXB0KSB7XG4gIHZhciBhY2NlcHRzID0gYWNjZXB0LnNwbGl0KCcsJyk7XG5cbiAgZm9yICh2YXIgaSA9IDEsIGogPSAwOyBpIDwgYWNjZXB0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChxdW90ZUNvdW50KGFjY2VwdHNbal0pICUgMiA9PSAwKSB7XG4gICAgICBhY2NlcHRzWysral0gPSBhY2NlcHRzW2ldO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2NlcHRzW2pdICs9ICcsJyArIGFjY2VwdHNbaV07XG4gICAgfVxuICB9XG5cbiAgLy8gdHJpbSBhY2NlcHRzXG4gIGFjY2VwdHMubGVuZ3RoID0gaiArIDE7XG5cbiAgcmV0dXJuIGFjY2VwdHM7XG59XG5cbi8qKlxuICogU3BsaXQgYSBzdHJpbmcgb2YgcGFyYW1ldGVycy5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc3BsaXRQYXJhbWV0ZXJzKHN0cikge1xuICB2YXIgcGFyYW1ldGVycyA9IHN0ci5zcGxpdCgnOycpO1xuXG4gIGZvciAodmFyIGkgPSAxLCBqID0gMDsgaSA8IHBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocXVvdGVDb3VudChwYXJhbWV0ZXJzW2pdKSAlIDIgPT0gMCkge1xuICAgICAgcGFyYW1ldGVyc1srK2pdID0gcGFyYW1ldGVyc1tpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1ldGVyc1tqXSArPSAnOycgKyBwYXJhbWV0ZXJzW2ldO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRyaW0gcGFyYW1ldGVyc1xuICBwYXJhbWV0ZXJzLmxlbmd0aCA9IGogKyAxO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuICAgIHBhcmFtZXRlcnNbaV0gPSBwYXJhbWV0ZXJzW2ldLnRyaW0oKTtcbiAgfVxuXG4gIHJldHVybiBwYXJhbWV0ZXJzO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbmVnb3RpYXRvci9saWIvbWVkaWFUeXBlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBleHByZXNzXG4gKiBDb3B5cmlnaHQoYykgMjAwOS0yMDEzIFRKIEhvbG93YXljaHVrXG4gKiBDb3B5cmlnaHQoYykgMjAxNC0yMDE1IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgY29udGVudERpc3Bvc2l0aW9uID0gcmVxdWlyZSgnY29udGVudC1kaXNwb3NpdGlvbicpO1xudmFyIGRlcHJlY2F0ZSA9IHJlcXVpcmUoJ2RlcGQnKSgnZXhwcmVzcycpO1xudmFyIGVuY29kZVVybCA9IHJlcXVpcmUoJ2VuY29kZXVybCcpO1xudmFyIGVzY2FwZUh0bWwgPSByZXF1aXJlKCdlc2NhcGUtaHRtbCcpO1xudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG52YXIgaXNBYnNvbHV0ZSA9IHJlcXVpcmUoJy4vdXRpbHMnKS5pc0Fic29sdXRlO1xudmFyIG9uRmluaXNoZWQgPSByZXF1aXJlKCdvbi1maW5pc2hlZCcpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgc3RhdHVzZXMgPSByZXF1aXJlKCdzdGF0dXNlcycpXG52YXIgbWVyZ2UgPSByZXF1aXJlKCd1dGlscy1tZXJnZScpO1xudmFyIHNpZ24gPSByZXF1aXJlKCdjb29raWUtc2lnbmF0dXJlJykuc2lnbjtcbnZhciBub3JtYWxpemVUeXBlID0gcmVxdWlyZSgnLi91dGlscycpLm5vcm1hbGl6ZVR5cGU7XG52YXIgbm9ybWFsaXplVHlwZXMgPSByZXF1aXJlKCcuL3V0aWxzJykubm9ybWFsaXplVHlwZXM7XG52YXIgc2V0Q2hhcnNldCA9IHJlcXVpcmUoJy4vdXRpbHMnKS5zZXRDaGFyc2V0O1xudmFyIGNvb2tpZSA9IHJlcXVpcmUoJ2Nvb2tpZScpO1xudmFyIHNlbmQgPSByZXF1aXJlKCdzZW5kJyk7XG52YXIgZXh0bmFtZSA9IHBhdGguZXh0bmFtZTtcbnZhciBtaW1lID0gc2VuZC5taW1lO1xudmFyIHJlc29sdmUgPSBwYXRoLnJlc29sdmU7XG52YXIgdmFyeSA9IHJlcXVpcmUoJ3ZhcnknKTtcblxuLyoqXG4gKiBSZXNwb25zZSBwcm90b3R5cGUuXG4gKiBAcHVibGljXG4gKi9cblxudmFyIHJlcyA9IE9iamVjdC5jcmVhdGUoaHR0cC5TZXJ2ZXJSZXNwb25zZS5wcm90b3R5cGUpXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXNcblxuLyoqXG4gKiBNb2R1bGUgdmFyaWFibGVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgY2hhcnNldFJlZ0V4cCA9IC87XFxzKmNoYXJzZXRcXHMqPS87XG5cbi8qKlxuICogU2V0IHN0YXR1cyBgY29kZWAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVcbiAqIEByZXR1cm4ge1NlcnZlclJlc3BvbnNlfVxuICogQHB1YmxpY1xuICovXG5cbnJlcy5zdGF0dXMgPSBmdW5jdGlvbiBzdGF0dXMoY29kZSkge1xuICB0aGlzLnN0YXR1c0NvZGUgPSBjb2RlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IExpbmsgaGVhZGVyIGZpZWxkIHdpdGggdGhlIGdpdmVuIGBsaW5rc2AuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgcmVzLmxpbmtzKHtcbiAqICAgICAgbmV4dDogJ2h0dHA6Ly9hcGkuZXhhbXBsZS5jb20vdXNlcnM/cGFnZT0yJyxcbiAqICAgICAgbGFzdDogJ2h0dHA6Ly9hcGkuZXhhbXBsZS5jb20vdXNlcnM/cGFnZT01J1xuICogICAgfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGxpbmtzXG4gKiBAcmV0dXJuIHtTZXJ2ZXJSZXNwb25zZX1cbiAqIEBwdWJsaWNcbiAqL1xuXG5yZXMubGlua3MgPSBmdW5jdGlvbihsaW5rcyl7XG4gIHZhciBsaW5rID0gdGhpcy5nZXQoJ0xpbmsnKSB8fCAnJztcbiAgaWYgKGxpbmspIGxpbmsgKz0gJywgJztcbiAgcmV0dXJuIHRoaXMuc2V0KCdMaW5rJywgbGluayArIE9iamVjdC5rZXlzKGxpbmtzKS5tYXAoZnVuY3Rpb24ocmVsKXtcbiAgICByZXR1cm4gJzwnICsgbGlua3NbcmVsXSArICc+OyByZWw9XCInICsgcmVsICsgJ1wiJztcbiAgfSkuam9pbignLCAnKSk7XG59O1xuXG4vKipcbiAqIFNlbmQgYSByZXNwb25zZS5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgcmVzLnNlbmQoQnVmZmVyLmZyb20oJ3dhaG9vJykpO1xuICogICAgIHJlcy5zZW5kKHsgc29tZTogJ2pzb24nIH0pO1xuICogICAgIHJlcy5zZW5kKCc8cD5zb21lIGh0bWw8L3A+Jyk7XG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfGJvb2xlYW58b2JqZWN0fEJ1ZmZlcn0gYm9keVxuICogQHB1YmxpY1xuICovXG5cbnJlcy5zZW5kID0gZnVuY3Rpb24gc2VuZChib2R5KSB7XG4gIHZhciBjaHVuayA9IGJvZHk7XG4gIHZhciBlbmNvZGluZztcbiAgdmFyIHJlcSA9IHRoaXMucmVxO1xuICB2YXIgdHlwZTtcblxuICAvLyBzZXR0aW5nc1xuICB2YXIgYXBwID0gdGhpcy5hcHA7XG5cbiAgLy8gYWxsb3cgc3RhdHVzIC8gYm9keVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIC8vIHJlcy5zZW5kKGJvZHksIHN0YXR1cykgYmFja3dhcmRzIGNvbXBhdFxuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnbnVtYmVyJykge1xuICAgICAgZGVwcmVjYXRlKCdyZXMuc2VuZChib2R5LCBzdGF0dXMpOiBVc2UgcmVzLnN0YXR1cyhzdGF0dXMpLnNlbmQoYm9keSkgaW5zdGVhZCcpO1xuICAgICAgdGhpcy5zdGF0dXNDb2RlID0gYXJndW1lbnRzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXByZWNhdGUoJ3Jlcy5zZW5kKHN0YXR1cywgYm9keSk6IFVzZSByZXMuc3RhdHVzKHN0YXR1cykuc2VuZChib2R5KSBpbnN0ZWFkJyk7XG4gICAgICB0aGlzLnN0YXR1c0NvZGUgPSBhcmd1bWVudHNbMF07XG4gICAgICBjaHVuayA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG4gIH1cblxuICAvLyBkaXNhbWJpZ3VhdGUgcmVzLnNlbmQoc3RhdHVzKSBhbmQgcmVzLnNlbmQoc3RhdHVzLCBudW0pXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdudW1iZXInICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAvLyByZXMuc2VuZChzdGF0dXMpIHdpbGwgc2V0IHN0YXR1cyBtZXNzYWdlIGFzIHRleHQgc3RyaW5nXG4gICAgaWYgKCF0aGlzLmdldCgnQ29udGVudC1UeXBlJykpIHtcbiAgICAgIHRoaXMudHlwZSgndHh0Jyk7XG4gICAgfVxuXG4gICAgZGVwcmVjYXRlKCdyZXMuc2VuZChzdGF0dXMpOiBVc2UgcmVzLnNlbmRTdGF0dXMoc3RhdHVzKSBpbnN0ZWFkJyk7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gY2h1bms7XG4gICAgY2h1bmsgPSBzdGF0dXNlc1tjaHVua11cbiAgfVxuXG4gIHN3aXRjaCAodHlwZW9mIGNodW5rKSB7XG4gICAgLy8gc3RyaW5nIGRlZmF1bHRpbmcgdG8gaHRtbFxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBpZiAoIXRoaXMuZ2V0KCdDb250ZW50LVR5cGUnKSkge1xuICAgICAgICB0aGlzLnR5cGUoJ2h0bWwnKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgICBjaHVuayA9ICcnO1xuICAgICAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgICAgIGlmICghdGhpcy5nZXQoJ0NvbnRlbnQtVHlwZScpKSB7XG4gICAgICAgICAgdGhpcy50eXBlKCdiaW4nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuanNvbihjaHVuayk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuXG4gIC8vIHdyaXRlIHN0cmluZ3MgaW4gdXRmLThcbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgICB0eXBlID0gdGhpcy5nZXQoJ0NvbnRlbnQtVHlwZScpO1xuXG4gICAgLy8gcmVmbGVjdCB0aGlzIGluIGNvbnRlbnQtdHlwZVxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuc2V0KCdDb250ZW50LVR5cGUnLCBzZXRDaGFyc2V0KHR5cGUsICd1dGYtOCcpKTtcbiAgICB9XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgaWYgRVRhZyBzaG91bGQgYmUgZ2VuZXJhdGVkXG4gIHZhciBldGFnRm4gPSBhcHAuZ2V0KCdldGFnIGZuJylcbiAgdmFyIGdlbmVyYXRlRVRhZyA9ICF0aGlzLmdldCgnRVRhZycpICYmIHR5cGVvZiBldGFnRm4gPT09ICdmdW5jdGlvbidcblxuICAvLyBwb3B1bGF0ZSBDb250ZW50LUxlbmd0aFxuICB2YXIgbGVuXG4gIGlmIChjaHVuayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICAgIC8vIGdldCBsZW5ndGggb2YgQnVmZmVyXG4gICAgICBsZW4gPSBjaHVuay5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKCFnZW5lcmF0ZUVUYWcgJiYgY2h1bmsubGVuZ3RoIDwgMTAwMCkge1xuICAgICAgLy8ganVzdCBjYWxjdWxhdGUgbGVuZ3RoIHdoZW4gbm8gRVRhZyArIHNtYWxsIGNodW5rXG4gICAgICBsZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChjaHVuaywgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbnZlcnQgY2h1bmsgdG8gQnVmZmVyIGFuZCBjYWxjdWxhdGVcbiAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKVxuICAgICAgZW5jb2RpbmcgPSB1bmRlZmluZWQ7XG4gICAgICBsZW4gPSBjaHVuay5sZW5ndGhcbiAgICB9XG5cbiAgICB0aGlzLnNldCgnQ29udGVudC1MZW5ndGgnLCBsZW4pO1xuICB9XG5cbiAgLy8gcG9wdWxhdGUgRVRhZ1xuICB2YXIgZXRhZztcbiAgaWYgKGdlbmVyYXRlRVRhZyAmJiBsZW4gIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICgoZXRhZyA9IGV0YWdGbihjaHVuaywgZW5jb2RpbmcpKSkge1xuICAgICAgdGhpcy5zZXQoJ0VUYWcnLCBldGFnKTtcbiAgICB9XG4gIH1cblxuICAvLyBmcmVzaG5lc3NcbiAgaWYgKHJlcS5mcmVzaCkgdGhpcy5zdGF0dXNDb2RlID0gMzA0O1xuXG4gIC8vIHN0cmlwIGlycmVsZXZhbnQgaGVhZGVyc1xuICBpZiAoMjA0ID09PSB0aGlzLnN0YXR1c0NvZGUgfHwgMzA0ID09PSB0aGlzLnN0YXR1c0NvZGUpIHtcbiAgICB0aGlzLnJlbW92ZUhlYWRlcignQ29udGVudC1UeXBlJyk7XG4gICAgdGhpcy5yZW1vdmVIZWFkZXIoJ0NvbnRlbnQtTGVuZ3RoJyk7XG4gICAgdGhpcy5yZW1vdmVIZWFkZXIoJ1RyYW5zZmVyLUVuY29kaW5nJyk7XG4gICAgY2h1bmsgPSAnJztcbiAgfVxuXG4gIGlmIChyZXEubWV0aG9kID09PSAnSEVBRCcpIHtcbiAgICAvLyBza2lwIGJvZHkgZm9yIEhFQURcbiAgICB0aGlzLmVuZCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3BvbmRcbiAgICB0aGlzLmVuZChjaHVuaywgZW5jb2RpbmcpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmQgSlNPTiByZXNwb25zZS5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgcmVzLmpzb24obnVsbCk7XG4gKiAgICAgcmVzLmpzb24oeyB1c2VyOiAndGonIH0pO1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxib29sZWFufG9iamVjdH0gb2JqXG4gKiBAcHVibGljXG4gKi9cblxucmVzLmpzb24gPSBmdW5jdGlvbiBqc29uKG9iaikge1xuICB2YXIgdmFsID0gb2JqO1xuXG4gIC8vIGFsbG93IHN0YXR1cyAvIGJvZHlcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAvLyByZXMuanNvbihib2R5LCBzdGF0dXMpIGJhY2t3YXJkcyBjb21wYXRcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGRlcHJlY2F0ZSgncmVzLmpzb24ob2JqLCBzdGF0dXMpOiBVc2UgcmVzLnN0YXR1cyhzdGF0dXMpLmpzb24ob2JqKSBpbnN0ZWFkJyk7XG4gICAgICB0aGlzLnN0YXR1c0NvZGUgPSBhcmd1bWVudHNbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlcHJlY2F0ZSgncmVzLmpzb24oc3RhdHVzLCBvYmopOiBVc2UgcmVzLnN0YXR1cyhzdGF0dXMpLmpzb24ob2JqKSBpbnN0ZWFkJyk7XG4gICAgICB0aGlzLnN0YXR1c0NvZGUgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YWwgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0dGluZ3NcbiAgdmFyIGFwcCA9IHRoaXMuYXBwO1xuICB2YXIgZXNjYXBlID0gYXBwLmdldCgnanNvbiBlc2NhcGUnKVxuICB2YXIgcmVwbGFjZXIgPSBhcHAuZ2V0KCdqc29uIHJlcGxhY2VyJyk7XG4gIHZhciBzcGFjZXMgPSBhcHAuZ2V0KCdqc29uIHNwYWNlcycpO1xuICB2YXIgYm9keSA9IHN0cmluZ2lmeSh2YWwsIHJlcGxhY2VyLCBzcGFjZXMsIGVzY2FwZSlcblxuICAvLyBjb250ZW50LXR5cGVcbiAgaWYgKCF0aGlzLmdldCgnQ29udGVudC1UeXBlJykpIHtcbiAgICB0aGlzLnNldCgnQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnNlbmQoYm9keSk7XG59O1xuXG4vKipcbiAqIFNlbmQgSlNPTiByZXNwb25zZSB3aXRoIEpTT05QIGNhbGxiYWNrIHN1cHBvcnQuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgIHJlcy5qc29ucChudWxsKTtcbiAqICAgICByZXMuanNvbnAoeyB1c2VyOiAndGonIH0pO1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxib29sZWFufG9iamVjdH0gb2JqXG4gKiBAcHVibGljXG4gKi9cblxucmVzLmpzb25wID0gZnVuY3Rpb24ganNvbnAob2JqKSB7XG4gIHZhciB2YWwgPSBvYmo7XG5cbiAgLy8gYWxsb3cgc3RhdHVzIC8gYm9keVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIC8vIHJlcy5qc29uKGJvZHksIHN0YXR1cykgYmFja3dhcmRzIGNvbXBhdFxuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnbnVtYmVyJykge1xuICAgICAgZGVwcmVjYXRlKCdyZXMuanNvbnAob2JqLCBzdGF0dXMpOiBVc2UgcmVzLnN0YXR1cyhzdGF0dXMpLmpzb24ob2JqKSBpbnN0ZWFkJyk7XG4gICAgICB0aGlzLnN0YXR1c0NvZGUgPSBhcmd1bWVudHNbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlcHJlY2F0ZSgncmVzLmpzb25wKHN0YXR1cywgb2JqKTogVXNlIHJlcy5zdGF0dXMoc3RhdHVzKS5qc29ucChvYmopIGluc3RlYWQnKTtcbiAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhbCA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG4gIH1cblxuICAvLyBzZXR0aW5nc1xuICB2YXIgYXBwID0gdGhpcy5hcHA7XG4gIHZhciBlc2NhcGUgPSBhcHAuZ2V0KCdqc29uIGVzY2FwZScpXG4gIHZhciByZXBsYWNlciA9IGFwcC5nZXQoJ2pzb24gcmVwbGFjZXInKTtcbiAgdmFyIHNwYWNlcyA9IGFwcC5nZXQoJ2pzb24gc3BhY2VzJyk7XG4gIHZhciBib2R5ID0gc3RyaW5naWZ5KHZhbCwgcmVwbGFjZXIsIHNwYWNlcywgZXNjYXBlKVxuICB2YXIgY2FsbGJhY2sgPSB0aGlzLnJlcS5xdWVyeVthcHAuZ2V0KCdqc29ucCBjYWxsYmFjayBuYW1lJyldO1xuXG4gIC8vIGNvbnRlbnQtdHlwZVxuICBpZiAoIXRoaXMuZ2V0KCdDb250ZW50LVR5cGUnKSkge1xuICAgIHRoaXMuc2V0KCdYLUNvbnRlbnQtVHlwZS1PcHRpb25zJywgJ25vc25pZmYnKTtcbiAgICB0aGlzLnNldCgnQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgfVxuXG4gIC8vIGZpeHVwIGNhbGxiYWNrXG4gIGlmIChBcnJheS5pc0FycmF5KGNhbGxiYWNrKSkge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2tbMF07XG4gIH1cblxuICAvLyBqc29ucFxuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJyAmJiBjYWxsYmFjay5sZW5ndGggIT09IDApIHtcbiAgICB0aGlzLnNldCgnWC1Db250ZW50LVR5cGUtT3B0aW9ucycsICdub3NuaWZmJyk7XG4gICAgdGhpcy5zZXQoJ0NvbnRlbnQtVHlwZScsICd0ZXh0L2phdmFzY3JpcHQnKTtcblxuICAgIC8vIHJlc3RyaWN0IGNhbGxiYWNrIGNoYXJzZXRcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrLnJlcGxhY2UoL1teXFxbXFxdXFx3JC5dL2csICcnKTtcblxuICAgIC8vIHJlcGxhY2UgY2hhcnMgbm90IGFsbG93ZWQgaW4gSmF2YVNjcmlwdCB0aGF0IGFyZSBpbiBKU09OXG4gICAgYm9keSA9IGJvZHlcbiAgICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpO1xuXG4gICAgLy8gdGhlIC8qKi8gaXMgYSBzcGVjaWZpYyBzZWN1cml0eSBtaXRpZ2F0aW9uIGZvciBcIlJvc2V0dGEgRmxhc2ggSlNPTlAgYWJ1c2VcIlxuICAgIC8vIHRoZSB0eXBlb2YgY2hlY2sgaXMganVzdCB0byByZWR1Y2UgY2xpZW50IGVycm9yIG5vaXNlXG4gICAgYm9keSA9ICcvKiovIHR5cGVvZiAnICsgY2FsbGJhY2sgKyAnID09PSBcXCdmdW5jdGlvblxcJyAmJiAnICsgY2FsbGJhY2sgKyAnKCcgKyBib2R5ICsgJyk7JztcbiAgfVxuXG4gIHJldHVybiB0aGlzLnNlbmQoYm9keSk7XG59O1xuXG4vKipcbiAqIFNlbmQgZ2l2ZW4gSFRUUCBzdGF0dXMgY29kZS5cbiAqXG4gKiBTZXRzIHRoZSByZXNwb25zZSBzdGF0dXMgdG8gYHN0YXR1c0NvZGVgIGFuZCB0aGUgYm9keSBvZiB0aGVcbiAqIHJlc3BvbnNlIHRvIHRoZSBzdGFuZGFyZCBkZXNjcmlwdGlvbiBmcm9tIG5vZGUncyBodHRwLlNUQVRVU19DT0RFU1xuICogb3IgdGhlIHN0YXR1c0NvZGUgbnVtYmVyIGlmIG5vIGRlc2NyaXB0aW9uLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICByZXMuc2VuZFN0YXR1cygyMDApO1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXNDb2RlXG4gKiBAcHVibGljXG4gKi9cblxucmVzLnNlbmRTdGF0dXMgPSBmdW5jdGlvbiBzZW5kU3RhdHVzKHN0YXR1c0NvZGUpIHtcbiAgdmFyIGJvZHkgPSBzdGF0dXNlc1tzdGF0dXNDb2RlXSB8fCBTdHJpbmcoc3RhdHVzQ29kZSlcblxuICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICB0aGlzLnR5cGUoJ3R4dCcpO1xuXG4gIHJldHVybiB0aGlzLnNlbmQoYm9keSk7XG59O1xuXG4vKipcbiAqIFRyYW5zZmVyIHRoZSBmaWxlIGF0IHRoZSBnaXZlbiBgcGF0aGAuXG4gKlxuICogQXV0b21hdGljYWxseSBzZXRzIHRoZSBfQ29udGVudC1UeXBlXyByZXNwb25zZSBoZWFkZXIgZmllbGQuXG4gKiBUaGUgY2FsbGJhY2sgYGNhbGxiYWNrKGVycilgIGlzIGludm9rZWQgd2hlbiB0aGUgdHJhbnNmZXIgaXMgY29tcGxldGVcbiAqIG9yIHdoZW4gYW4gZXJyb3Igb2NjdXJzLiBCZSBzdXJlIHRvIGNoZWNrIGByZXMuc2VudEhlYWRlcmBcbiAqIGlmIHlvdSB3aXNoIHRvIGF0dGVtcHQgcmVzcG9uZGluZywgYXMgdGhlIGhlYWRlciBhbmQgc29tZSBkYXRhXG4gKiBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gdHJhbnNmZXJyZWQuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgIC0gYG1heEFnZWAgICBkZWZhdWx0aW5nIHRvIDAgKGNhbiBiZSBzdHJpbmcgY29udmVydGVkIGJ5IGBtc2ApXG4gKiAgIC0gYHJvb3RgICAgICByb290IGRpcmVjdG9yeSBmb3IgcmVsYXRpdmUgZmlsZW5hbWVzXG4gKiAgIC0gYGhlYWRlcnNgICBvYmplY3Qgb2YgaGVhZGVycyB0byBzZXJ2ZSB3aXRoIGZpbGVcbiAqICAgLSBgZG90ZmlsZXNgIHNlcnZlIGRvdGZpbGVzLCBkZWZhdWx0aW5nIHRvIGZhbHNlOyBjYW4gYmUgYFwiYWxsb3dcImAgdG8gc2VuZCB0aGVtXG4gKlxuICogT3RoZXIgb3B0aW9ucyBhcmUgcGFzc2VkIGFsb25nIHRvIGBzZW5kYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgVGhlIGZvbGxvd2luZyBleGFtcGxlIGlsbHVzdHJhdGVzIGhvdyBgcmVzLnNlbmRGaWxlKClgIG1heVxuICogIGJlIHVzZWQgYXMgYW4gYWx0ZXJuYXRpdmUgZm9yIHRoZSBgc3RhdGljKClgIG1pZGRsZXdhcmUgZm9yXG4gKiAgZHluYW1pYyBzaXR1YXRpb25zLiBUaGUgY29kZSBiYWNraW5nIGByZXMuc2VuZEZpbGUoKWAgaXMgYWN0dWFsbHlcbiAqICB0aGUgc2FtZSBjb2RlLCBzbyBIVFRQIGNhY2hlIHN1cHBvcnQgZXRjIGlzIGlkZW50aWNhbC5cbiAqXG4gKiAgICAgYXBwLmdldCgnL3VzZXIvOnVpZC9waG90b3MvOmZpbGUnLCBmdW5jdGlvbihyZXEsIHJlcyl7XG4gKiAgICAgICB2YXIgdWlkID0gcmVxLnBhcmFtcy51aWRcbiAqICAgICAgICAgLCBmaWxlID0gcmVxLnBhcmFtcy5maWxlO1xuICpcbiAqICAgICAgIHJlcS51c2VyLm1heVZpZXdGaWxlc0Zyb20odWlkLCBmdW5jdGlvbih5ZXMpe1xuICogICAgICAgICBpZiAoeWVzKSB7XG4gKiAgICAgICAgICAgcmVzLnNlbmRGaWxlKCcvdXBsb2Fkcy8nICsgdWlkICsgJy8nICsgZmlsZSk7XG4gKiAgICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgICAgcmVzLnNlbmQoNDAzLCAnU29ycnkhIHlvdSBjYW50IHNlZSB0aGF0LicpO1xuICogICAgICAgICB9XG4gKiAgICAgICB9KTtcbiAqICAgICB9KTtcbiAqXG4gKiBAcHVibGljXG4gKi9cblxucmVzLnNlbmRGaWxlID0gZnVuY3Rpb24gc2VuZEZpbGUocGF0aCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIGRvbmUgPSBjYWxsYmFjaztcbiAgdmFyIHJlcSA9IHRoaXMucmVxO1xuICB2YXIgcmVzID0gdGhpcztcbiAgdmFyIG5leHQgPSByZXEubmV4dDtcbiAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmICghcGF0aCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhdGggYXJndW1lbnQgaXMgcmVxdWlyZWQgdG8gcmVzLnNlbmRGaWxlJyk7XG4gIH1cblxuICAvLyBzdXBwb3J0IGZ1bmN0aW9uIGFzIHNlY29uZCBhcmdcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZG9uZSA9IG9wdGlvbnM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgaWYgKCFvcHRzLnJvb3QgJiYgIWlzQWJzb2x1dGUocGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXRoIG11c3QgYmUgYWJzb2x1dGUgb3Igc3BlY2lmeSByb290IHRvIHJlcy5zZW5kRmlsZScpO1xuICB9XG5cbiAgLy8gY3JlYXRlIGZpbGUgc3RyZWFtXG4gIHZhciBwYXRobmFtZSA9IGVuY29kZVVSSShwYXRoKTtcbiAgdmFyIGZpbGUgPSBzZW5kKHJlcSwgcGF0aG5hbWUsIG9wdHMpO1xuXG4gIC8vIHRyYW5zZmVyXG4gIHNlbmRmaWxlKHJlcywgZmlsZSwgb3B0cywgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChkb25lKSByZXR1cm4gZG9uZShlcnIpO1xuICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09ICdFSVNESVInKSByZXR1cm4gbmV4dCgpO1xuXG4gICAgLy8gbmV4dCgpIGFsbCBidXQgd3JpdGUgZXJyb3JzXG4gICAgaWYgKGVyciAmJiBlcnIuY29kZSAhPT0gJ0VDT05OQUJPUlRFRCcgJiYgZXJyLnN5c2NhbGwgIT09ICd3cml0ZScpIHtcbiAgICAgIG5leHQoZXJyKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBUcmFuc2ZlciB0aGUgZmlsZSBhdCB0aGUgZ2l2ZW4gYHBhdGhgLlxuICpcbiAqIEF1dG9tYXRpY2FsbHkgc2V0cyB0aGUgX0NvbnRlbnQtVHlwZV8gcmVzcG9uc2UgaGVhZGVyIGZpZWxkLlxuICogVGhlIGNhbGxiYWNrIGBjYWxsYmFjayhlcnIpYCBpcyBpbnZva2VkIHdoZW4gdGhlIHRyYW5zZmVyIGlzIGNvbXBsZXRlXG4gKiBvciB3aGVuIGFuIGVycm9yIG9jY3Vycy4gQmUgc3VyZSB0byBjaGVjayBgcmVzLnNlbnRIZWFkZXJgXG4gKiBpZiB5b3Ugd2lzaCB0byBhdHRlbXB0IHJlc3BvbmRpbmcsIGFzIHRoZSBoZWFkZXIgYW5kIHNvbWUgZGF0YVxuICogbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHRyYW5zZmVycmVkLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogICAtIGBtYXhBZ2VgICAgZGVmYXVsdGluZyB0byAwIChjYW4gYmUgc3RyaW5nIGNvbnZlcnRlZCBieSBgbXNgKVxuICogICAtIGByb290YCAgICAgcm9vdCBkaXJlY3RvcnkgZm9yIHJlbGF0aXZlIGZpbGVuYW1lc1xuICogICAtIGBoZWFkZXJzYCAgb2JqZWN0IG9mIGhlYWRlcnMgdG8gc2VydmUgd2l0aCBmaWxlXG4gKiAgIC0gYGRvdGZpbGVzYCBzZXJ2ZSBkb3RmaWxlcywgZGVmYXVsdGluZyB0byBmYWxzZTsgY2FuIGJlIGBcImFsbG93XCJgIHRvIHNlbmQgdGhlbVxuICpcbiAqIE90aGVyIG9wdGlvbnMgYXJlIHBhc3NlZCBhbG9uZyB0byBgc2VuZGAuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBpbGx1c3RyYXRlcyBob3cgYHJlcy5zZW5kZmlsZSgpYCBtYXlcbiAqICBiZSB1c2VkIGFzIGFuIGFsdGVybmF0aXZlIGZvciB0aGUgYHN0YXRpYygpYCBtaWRkbGV3YXJlIGZvclxuICogIGR5bmFtaWMgc2l0dWF0aW9ucy4gVGhlIGNvZGUgYmFja2luZyBgcmVzLnNlbmRmaWxlKClgIGlzIGFjdHVhbGx5XG4gKiAgdGhlIHNhbWUgY29kZSwgc28gSFRUUCBjYWNoZSBzdXBwb3J0IGV0YyBpcyBpZGVudGljYWwuXG4gKlxuICogICAgIGFwcC5nZXQoJy91c2VyLzp1aWQvcGhvdG9zLzpmaWxlJywgZnVuY3Rpb24ocmVxLCByZXMpe1xuICogICAgICAgdmFyIHVpZCA9IHJlcS5wYXJhbXMudWlkXG4gKiAgICAgICAgICwgZmlsZSA9IHJlcS5wYXJhbXMuZmlsZTtcbiAqXG4gKiAgICAgICByZXEudXNlci5tYXlWaWV3RmlsZXNGcm9tKHVpZCwgZnVuY3Rpb24oeWVzKXtcbiAqICAgICAgICAgaWYgKHllcykge1xuICogICAgICAgICAgIHJlcy5zZW5kZmlsZSgnL3VwbG9hZHMvJyArIHVpZCArICcvJyArIGZpbGUpO1xuICogICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgIHJlcy5zZW5kKDQwMywgJ1NvcnJ5ISB5b3UgY2FudCBzZWUgdGhhdC4nKTtcbiAqICAgICAgICAgfVxuICogICAgICAgfSk7XG4gKiAgICAgfSk7XG4gKlxuICogQHB1YmxpY1xuICovXG5cbnJlcy5zZW5kZmlsZSA9IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgZG9uZSA9IGNhbGxiYWNrO1xuICB2YXIgcmVxID0gdGhpcy5yZXE7XG4gIHZhciByZXMgPSB0aGlzO1xuICB2YXIgbmV4dCA9IHJlcS5uZXh0O1xuICB2YXIgb3B0cyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gc3VwcG9ydCBmdW5jdGlvbiBhcyBzZWNvbmQgYXJnXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRvbmUgPSBvcHRpb25zO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBmaWxlIHN0cmVhbVxuICB2YXIgZmlsZSA9IHNlbmQocmVxLCBwYXRoLCBvcHRzKTtcblxuICAvLyB0cmFuc2ZlclxuICBzZW5kZmlsZShyZXMsIGZpbGUsIG9wdHMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZG9uZSkgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSAnRUlTRElSJykgcmV0dXJuIG5leHQoKTtcblxuICAgIC8vIG5leHQoKSBhbGwgYnV0IHdyaXRlIGVycm9yc1xuICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgIT09ICdFQ09OTkFCT1JURUQnICYmIGVyci5zeXNjYWxsICE9PSAnd3JpdGUnKSB7XG4gICAgICBuZXh0KGVycik7XG4gICAgfVxuICB9KTtcbn07XG5cbnJlcy5zZW5kZmlsZSA9IGRlcHJlY2F0ZS5mdW5jdGlvbihyZXMuc2VuZGZpbGUsXG4gICdyZXMuc2VuZGZpbGU6IFVzZSByZXMuc2VuZEZpbGUgaW5zdGVhZCcpO1xuXG4vKipcbiAqIFRyYW5zZmVyIHRoZSBmaWxlIGF0IHRoZSBnaXZlbiBgcGF0aGAgYXMgYW4gYXR0YWNobWVudC5cbiAqXG4gKiBPcHRpb25hbGx5IHByb3ZpZGluZyBhbiBhbHRlcm5hdGUgYXR0YWNobWVudCBgZmlsZW5hbWVgLFxuICogYW5kIG9wdGlvbmFsIGNhbGxiYWNrIGBjYWxsYmFjayhlcnIpYC4gVGhlIGNhbGxiYWNrIGlzIGludm9rZWRcbiAqIHdoZW4gdGhlIGRhdGEgdHJhbnNmZXIgaXMgY29tcGxldGUsIG9yIHdoZW4gYW4gZXJyb3IgaGFzXG4gKiBvY3VycmVkLiBCZSBzdXJlIHRvIGNoZWNrIGByZXMuaGVhZGVyc1NlbnRgIGlmIHlvdSBwbGFuIHRvIHJlc3BvbmQuXG4gKlxuICogT3B0aW9uYWxseSBwcm92aWRpbmcgYW4gYG9wdGlvbnNgIG9iamVjdCB0byB1c2Ugd2l0aCBgcmVzLnNlbmRGaWxlKClgLlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIHNldCB0aGUgYENvbnRlbnQtRGlzcG9zaXRpb25gIGhlYWRlciwgb3ZlcnJpZGluZ1xuICogYW55IGBDb250ZW50LURpc3Bvc2l0aW9uYCBoZWFkZXIgcGFzc2VkIGFzIGhlYWRlciBvcHRpb25zIGluIG9yZGVyXG4gKiB0byBzZXQgdGhlIGF0dGFjaG1lbnQgYW5kIGZpbGVuYW1lLlxuICpcbiAqIFRoaXMgbWV0aG9kIHVzZXMgYHJlcy5zZW5kRmlsZSgpYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cblxucmVzLmRvd25sb2FkID0gZnVuY3Rpb24gZG93bmxvYWQgKHBhdGgsIGZpbGVuYW1lLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgZG9uZSA9IGNhbGxiYWNrO1xuICB2YXIgbmFtZSA9IGZpbGVuYW1lO1xuICB2YXIgb3B0cyA9IG9wdGlvbnMgfHwgbnVsbFxuXG4gIC8vIHN1cHBvcnQgZnVuY3Rpb24gYXMgc2Vjb25kIG9yIHRoaXJkIGFyZ1xuICBpZiAodHlwZW9mIGZpbGVuYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZG9uZSA9IGZpbGVuYW1lO1xuICAgIG5hbWUgPSBudWxsO1xuICAgIG9wdHMgPSBudWxsXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBkb25lID0gb3B0aW9uc1xuICAgIG9wdHMgPSBudWxsXG4gIH1cblxuICAvLyBzZXQgQ29udGVudC1EaXNwb3NpdGlvbiB3aGVuIGZpbGUgaXMgc2VudFxuICB2YXIgaGVhZGVycyA9IHtcbiAgICAnQ29udGVudC1EaXNwb3NpdGlvbic6IGNvbnRlbnREaXNwb3NpdGlvbihuYW1lIHx8IHBhdGgpXG4gIH07XG5cbiAgLy8gbWVyZ2UgdXNlci1wcm92aWRlZCBoZWFkZXJzXG4gIGlmIChvcHRzICYmIG9wdHMuaGVhZGVycykge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3B0cy5oZWFkZXJzKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV1cbiAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKSAhPT0gJ2NvbnRlbnQtZGlzcG9zaXRpb24nKSB7XG4gICAgICAgIGhlYWRlcnNba2V5XSA9IG9wdHMuaGVhZGVyc1trZXldXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbWVyZ2UgdXNlci1wcm92aWRlZCBvcHRpb25zXG4gIG9wdHMgPSBPYmplY3QuY3JlYXRlKG9wdHMpXG4gIG9wdHMuaGVhZGVycyA9IGhlYWRlcnNcblxuICAvLyBSZXNvbHZlIHRoZSBmdWxsIHBhdGggZm9yIHNlbmRGaWxlXG4gIHZhciBmdWxsUGF0aCA9IHJlc29sdmUocGF0aCk7XG5cbiAgLy8gc2VuZCBmaWxlXG4gIHJldHVybiB0aGlzLnNlbmRGaWxlKGZ1bGxQYXRoLCBvcHRzLCBkb25lKVxufTtcblxuLyoqXG4gKiBTZXQgX0NvbnRlbnQtVHlwZV8gcmVzcG9uc2UgaGVhZGVyIHdpdGggYHR5cGVgIHRocm91Z2ggYG1pbWUubG9va3VwKClgXG4gKiB3aGVuIGl0IGRvZXMgbm90IGNvbnRhaW4gXCIvXCIsIG9yIHNldCB0aGUgQ29udGVudC1UeXBlIHRvIGB0eXBlYCBvdGhlcndpc2UuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgIHJlcy50eXBlKCcuaHRtbCcpO1xuICogICAgIHJlcy50eXBlKCdodG1sJyk7XG4gKiAgICAgcmVzLnR5cGUoJ2pzb24nKTtcbiAqICAgICByZXMudHlwZSgnYXBwbGljYXRpb24vanNvbicpO1xuICogICAgIHJlcy50eXBlKCdwbmcnKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7U2VydmVyUmVzcG9uc2V9IGZvciBjaGFpbmluZ1xuICogQHB1YmxpY1xuICovXG5cbnJlcy5jb250ZW50VHlwZSA9XG5yZXMudHlwZSA9IGZ1bmN0aW9uIGNvbnRlbnRUeXBlKHR5cGUpIHtcbiAgdmFyIGN0ID0gdHlwZS5pbmRleE9mKCcvJykgPT09IC0xXG4gICAgPyBtaW1lLmxvb2t1cCh0eXBlKVxuICAgIDogdHlwZTtcblxuICByZXR1cm4gdGhpcy5zZXQoJ0NvbnRlbnQtVHlwZScsIGN0KTtcbn07XG5cbi8qKlxuICogUmVzcG9uZCB0byB0aGUgQWNjZXB0YWJsZSBmb3JtYXRzIHVzaW5nIGFuIGBvYmpgXG4gKiBvZiBtaW1lLXR5cGUgY2FsbGJhY2tzLlxuICpcbiAqIFRoaXMgbWV0aG9kIHVzZXMgYHJlcS5hY2NlcHRlZGAsIGFuIGFycmF5IG9mXG4gKiBhY2NlcHRhYmxlIHR5cGVzIG9yZGVyZWQgYnkgdGhlaXIgcXVhbGl0eSB2YWx1ZXMuXG4gKiBXaGVuIFwiQWNjZXB0XCIgaXMgbm90IHByZXNlbnQgdGhlIF9maXJzdF8gY2FsbGJhY2tcbiAqIGlzIGludm9rZWQsIG90aGVyd2lzZSB0aGUgZmlyc3QgbWF0Y2ggaXMgdXNlZC4gV2hlblxuICogbm8gbWF0Y2ggaXMgcGVyZm9ybWVkIHRoZSBzZXJ2ZXIgcmVzcG9uZHMgd2l0aFxuICogNDA2IFwiTm90IEFjY2VwdGFibGVcIi5cbiAqXG4gKiBDb250ZW50LVR5cGUgaXMgc2V0IGZvciB5b3UsIGhvd2V2ZXIgaWYgeW91IGNob29zZVxuICogeW91IG1heSBhbHRlciB0aGlzIHdpdGhpbiB0aGUgY2FsbGJhY2sgdXNpbmcgYHJlcy50eXBlKClgXG4gKiBvciBgcmVzLnNldCgnQ29udGVudC1UeXBlJywgLi4uKWAuXG4gKlxuICogICAgcmVzLmZvcm1hdCh7XG4gKiAgICAgICd0ZXh0L3BsYWluJzogZnVuY3Rpb24oKXtcbiAqICAgICAgICByZXMuc2VuZCgnaGV5Jyk7XG4gKiAgICAgIH0sXG4gKlxuICogICAgICAndGV4dC9odG1sJzogZnVuY3Rpb24oKXtcbiAqICAgICAgICByZXMuc2VuZCgnPHA+aGV5PC9wPicpO1xuICogICAgICB9LFxuICpcbiAqICAgICAgJ2FwcGxpYXRpb24vanNvbic6IGZ1bmN0aW9uKCl7XG4gKiAgICAgICAgcmVzLnNlbmQoeyBtZXNzYWdlOiAnaGV5JyB9KTtcbiAqICAgICAgfVxuICogICAgfSk7XG4gKlxuICogSW4gYWRkaXRpb24gdG8gY2Fub25pY2FsaXplZCBNSU1FIHR5cGVzIHlvdSBtYXlcbiAqIGFsc28gdXNlIGV4dG5hbWVzIG1hcHBlZCB0byB0aGVzZSB0eXBlczpcbiAqXG4gKiAgICByZXMuZm9ybWF0KHtcbiAqICAgICAgdGV4dDogZnVuY3Rpb24oKXtcbiAqICAgICAgICByZXMuc2VuZCgnaGV5Jyk7XG4gKiAgICAgIH0sXG4gKlxuICogICAgICBodG1sOiBmdW5jdGlvbigpe1xuICogICAgICAgIHJlcy5zZW5kKCc8cD5oZXk8L3A+Jyk7XG4gKiAgICAgIH0sXG4gKlxuICogICAgICBqc29uOiBmdW5jdGlvbigpe1xuICogICAgICAgIHJlcy5zZW5kKHsgbWVzc2FnZTogJ2hleScgfSk7XG4gKiAgICAgIH1cbiAqICAgIH0pO1xuICpcbiAqIEJ5IGRlZmF1bHQgRXhwcmVzcyBwYXNzZXMgYW4gYEVycm9yYFxuICogd2l0aCBhIGAuc3RhdHVzYCBvZiA0MDYgdG8gYG5leHQoZXJyKWBcbiAqIGlmIGEgbWF0Y2ggaXMgbm90IG1hZGUuIElmIHlvdSBwcm92aWRlXG4gKiBhIGAuZGVmYXVsdGAgY2FsbGJhY2sgaXQgd2lsbCBiZSBpbnZva2VkXG4gKiBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge1NlcnZlclJlc3BvbnNlfSBmb3IgY2hhaW5pbmdcbiAqIEBwdWJsaWNcbiAqL1xuXG5yZXMuZm9ybWF0ID0gZnVuY3Rpb24ob2JqKXtcbiAgdmFyIHJlcSA9IHRoaXMucmVxO1xuICB2YXIgbmV4dCA9IHJlcS5uZXh0O1xuXG4gIHZhciBmbiA9IG9iai5kZWZhdWx0O1xuICBpZiAoZm4pIGRlbGV0ZSBvYmouZGVmYXVsdDtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXG4gIHZhciBrZXkgPSBrZXlzLmxlbmd0aCA+IDBcbiAgICA/IHJlcS5hY2NlcHRzKGtleXMpXG4gICAgOiBmYWxzZTtcblxuICB0aGlzLnZhcnkoXCJBY2NlcHRcIik7XG5cbiAgaWYgKGtleSkge1xuICAgIHRoaXMuc2V0KCdDb250ZW50LVR5cGUnLCBub3JtYWxpemVUeXBlKGtleSkudmFsdWUpO1xuICAgIG9ialtrZXldKHJlcSwgdGhpcywgbmV4dCk7XG4gIH0gZWxzZSBpZiAoZm4pIHtcbiAgICBmbigpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ05vdCBBY2NlcHRhYmxlJyk7XG4gICAgZXJyLnN0YXR1cyA9IGVyci5zdGF0dXNDb2RlID0gNDA2O1xuICAgIGVyci50eXBlcyA9IG5vcm1hbGl6ZVR5cGVzKGtleXMpLm1hcChmdW5jdGlvbihvKXsgcmV0dXJuIG8udmFsdWUgfSk7XG4gICAgbmV4dChlcnIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBfQ29udGVudC1EaXNwb3NpdGlvbl8gaGVhZGVyIHRvIF9hdHRhY2htZW50XyB3aXRoIG9wdGlvbmFsIGBmaWxlbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lXG4gKiBAcmV0dXJuIHtTZXJ2ZXJSZXNwb25zZX1cbiAqIEBwdWJsaWNcbiAqL1xuXG5yZXMuYXR0YWNobWVudCA9IGZ1bmN0aW9uIGF0dGFjaG1lbnQoZmlsZW5hbWUpIHtcbiAgaWYgKGZpbGVuYW1lKSB7XG4gICAgdGhpcy50eXBlKGV4dG5hbWUoZmlsZW5hbWUpKTtcbiAgfVxuXG4gIHRoaXMuc2V0KCdDb250ZW50LURpc3Bvc2l0aW9uJywgY29udGVudERpc3Bvc2l0aW9uKGZpbGVuYW1lKSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFwcGVuZCBhZGRpdGlvbmFsIGhlYWRlciBgZmllbGRgIHdpdGggdmFsdWUgYHZhbGAuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICByZXMuYXBwZW5kKCdMaW5rJywgWyc8aHR0cDovL2xvY2FsaG9zdC8+JywgJzxodHRwOi8vbG9jYWxob3N0OjMwMDAvPiddKTtcbiAqICAgIHJlcy5hcHBlbmQoJ1NldC1Db29raWUnLCAnZm9vPWJhcjsgUGF0aD0vOyBIdHRwT25seScpO1xuICogICAgcmVzLmFwcGVuZCgnV2FybmluZycsICcxOTkgTWlzY2VsbGFuZW91cyB3YXJuaW5nJyk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gdmFsXG4gKiBAcmV0dXJuIHtTZXJ2ZXJSZXNwb25zZX0gZm9yIGNoYWluaW5nXG4gKiBAcHVibGljXG4gKi9cblxucmVzLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChmaWVsZCwgdmFsKSB7XG4gIHZhciBwcmV2ID0gdGhpcy5nZXQoZmllbGQpO1xuICB2YXIgdmFsdWUgPSB2YWw7XG5cbiAgaWYgKHByZXYpIHtcbiAgICAvLyBjb25jYXQgdGhlIG5ldyBhbmQgcHJldiB2YWxzXG4gICAgdmFsdWUgPSBBcnJheS5pc0FycmF5KHByZXYpID8gcHJldi5jb25jYXQodmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KHZhbCkgPyBbcHJldl0uY29uY2F0KHZhbClcbiAgICAgIDogW3ByZXYsIHZhbF07XG4gIH1cblxuICByZXR1cm4gdGhpcy5zZXQoZmllbGQsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogU2V0IGhlYWRlciBgZmllbGRgIHRvIGB2YWxgLCBvciBwYXNzXG4gKiBhbiBvYmplY3Qgb2YgaGVhZGVyIGZpZWxkcy5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICByZXMuc2V0KCdGb28nLCBbJ2JhcicsICdiYXonXSk7XG4gKiAgICByZXMuc2V0KCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICogICAgcmVzLnNldCh7IEFjY2VwdDogJ3RleHQvcGxhaW4nLCAnWC1BUEktS2V5JzogJ3RvYmknIH0pO1xuICpcbiAqIEFsaWFzZWQgYXMgYHJlcy5oZWFkZXIoKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBmaWVsZFxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHZhbFxuICogQHJldHVybiB7U2VydmVyUmVzcG9uc2V9IGZvciBjaGFpbmluZ1xuICogQHB1YmxpY1xuICovXG5cbnJlcy5zZXQgPVxucmVzLmhlYWRlciA9IGZ1bmN0aW9uIGhlYWRlcihmaWVsZCwgdmFsKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHZhbHVlID0gQXJyYXkuaXNBcnJheSh2YWwpXG4gICAgICA/IHZhbC5tYXAoU3RyaW5nKVxuICAgICAgOiBTdHJpbmcodmFsKTtcblxuICAgIC8vIGFkZCBjaGFyc2V0IHRvIGNvbnRlbnQtdHlwZVxuICAgIGlmIChmaWVsZC50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbnRlbnQtVHlwZSBjYW5ub3QgYmUgc2V0IHRvIGFuIEFycmF5Jyk7XG4gICAgICB9XG4gICAgICBpZiAoIWNoYXJzZXRSZWdFeHAudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGNoYXJzZXQgPSBtaW1lLmNoYXJzZXRzLmxvb2t1cCh2YWx1ZS5zcGxpdCgnOycpWzBdKTtcbiAgICAgICAgaWYgKGNoYXJzZXQpIHZhbHVlICs9ICc7IGNoYXJzZXQ9JyArIGNoYXJzZXQudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldEhlYWRlcihmaWVsZCwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGtleSBpbiBmaWVsZCkge1xuICAgICAgdGhpcy5zZXQoa2V5LCBmaWVsZFtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldCB2YWx1ZSBmb3IgaGVhZGVyIGBmaWVsZGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxucmVzLmdldCA9IGZ1bmN0aW9uKGZpZWxkKXtcbiAgcmV0dXJuIHRoaXMuZ2V0SGVhZGVyKGZpZWxkKTtcbn07XG5cbi8qKlxuICogQ2xlYXIgY29va2llIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7U2VydmVyUmVzcG9uc2V9IGZvciBjaGFpbmluZ1xuICogQHB1YmxpY1xuICovXG5cbnJlcy5jbGVhckNvb2tpZSA9IGZ1bmN0aW9uIGNsZWFyQ29va2llKG5hbWUsIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSBtZXJnZSh7IGV4cGlyZXM6IG5ldyBEYXRlKDEpLCBwYXRoOiAnLycgfSwgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXMuY29va2llKG5hbWUsICcnLCBvcHRzKTtcbn07XG5cbi8qKlxuICogU2V0IGNvb2tpZSBgbmFtZWAgdG8gYHZhbHVlYCwgd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogICAgLSBgbWF4QWdlYCAgIG1heC1hZ2UgaW4gbWlsbGlzZWNvbmRzLCBjb252ZXJ0ZWQgdG8gYGV4cGlyZXNgXG4gKiAgICAtIGBzaWduZWRgICAgc2lnbiB0aGUgY29va2llXG4gKiAgICAtIGBwYXRoYCAgICAgZGVmYXVsdHMgdG8gXCIvXCJcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAvLyBcIlJlbWVtYmVyIE1lXCIgZm9yIDE1IG1pbnV0ZXNcbiAqICAgIHJlcy5jb29raWUoJ3JlbWVtYmVybWUnLCAnMScsIHsgZXhwaXJlczogbmV3IERhdGUoRGF0ZS5ub3coKSArIDkwMDAwMCksIGh0dHBPbmx5OiB0cnVlIH0pO1xuICpcbiAqICAgIC8vIHNhdmUgYXMgYWJvdmVcbiAqICAgIHJlcy5jb29raWUoJ3JlbWVtYmVybWUnLCAnMScsIHsgbWF4QWdlOiA5MDAwMDAsIGh0dHBPbmx5OiB0cnVlIH0pXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge1NlcnZlclJlc3BvbnNlfSBmb3IgY2hhaW5pbmdcbiAqIEBwdWJsaWNcbiAqL1xuXG5yZXMuY29va2llID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gbWVyZ2Uoe30sIG9wdGlvbnMpO1xuICB2YXIgc2VjcmV0ID0gdGhpcy5yZXEuc2VjcmV0O1xuICB2YXIgc2lnbmVkID0gb3B0cy5zaWduZWQ7XG5cbiAgaWYgKHNpZ25lZCAmJiAhc2VjcmV0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb29raWVQYXJzZXIoXCJzZWNyZXRcIikgcmVxdWlyZWQgZm9yIHNpZ25lZCBjb29raWVzJyk7XG4gIH1cblxuICB2YXIgdmFsID0gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xuICAgID8gJ2o6JyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKVxuICAgIDogU3RyaW5nKHZhbHVlKTtcblxuICBpZiAoc2lnbmVkKSB7XG4gICAgdmFsID0gJ3M6JyArIHNpZ24odmFsLCBzZWNyZXQpO1xuICB9XG5cbiAgaWYgKCdtYXhBZ2UnIGluIG9wdHMpIHtcbiAgICBvcHRzLmV4cGlyZXMgPSBuZXcgRGF0ZShEYXRlLm5vdygpICsgb3B0cy5tYXhBZ2UpO1xuICAgIG9wdHMubWF4QWdlIC89IDEwMDA7XG4gIH1cblxuICBpZiAob3B0cy5wYXRoID09IG51bGwpIHtcbiAgICBvcHRzLnBhdGggPSAnLyc7XG4gIH1cblxuICB0aGlzLmFwcGVuZCgnU2V0LUNvb2tpZScsIGNvb2tpZS5zZXJpYWxpemUobmFtZSwgU3RyaW5nKHZhbCksIG9wdHMpKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBsb2NhdGlvbiBoZWFkZXIgdG8gYHVybGAuXG4gKlxuICogVGhlIGdpdmVuIGB1cmxgIGNhbiBhbHNvIGJlIFwiYmFja1wiLCB3aGljaCByZWRpcmVjdHNcbiAqIHRvIHRoZSBfUmVmZXJyZXJfIG9yIF9SZWZlcmVyXyBoZWFkZXJzIG9yIFwiL1wiLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgIHJlcy5sb2NhdGlvbignL2Zvby9iYXInKS47XG4gKiAgICByZXMubG9jYXRpb24oJ2h0dHA6Ly9leGFtcGxlLmNvbScpO1xuICogICAgcmVzLmxvY2F0aW9uKCcuLi9sb2dpbicpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEByZXR1cm4ge1NlcnZlclJlc3BvbnNlfSBmb3IgY2hhaW5pbmdcbiAqIEBwdWJsaWNcbiAqL1xuXG5yZXMubG9jYXRpb24gPSBmdW5jdGlvbiBsb2NhdGlvbih1cmwpIHtcbiAgdmFyIGxvYyA9IHVybDtcblxuICAvLyBcImJhY2tcIiBpcyBhbiBhbGlhcyBmb3IgdGhlIHJlZmVycmVyXG4gIGlmICh1cmwgPT09ICdiYWNrJykge1xuICAgIGxvYyA9IHRoaXMucmVxLmdldCgnUmVmZXJyZXInKSB8fCAnLyc7XG4gIH1cblxuICAvLyBzZXQgbG9jYXRpb25cbiAgcmV0dXJuIHRoaXMuc2V0KCdMb2NhdGlvbicsIGVuY29kZVVybChsb2MpKTtcbn07XG5cbi8qKlxuICogUmVkaXJlY3QgdG8gdGhlIGdpdmVuIGB1cmxgIHdpdGggb3B0aW9uYWwgcmVzcG9uc2UgYHN0YXR1c2BcbiAqIGRlZmF1bHRpbmcgdG8gMzAyLlxuICpcbiAqIFRoZSByZXN1bHRpbmcgYHVybGAgaXMgZGV0ZXJtaW5lZCBieSBgcmVzLmxvY2F0aW9uKClgLCBzb1xuICogaXQgd2lsbCBwbGF5IG5pY2VseSB3aXRoIG1vdW50ZWQgYXBwcywgcmVsYXRpdmUgcGF0aHMsXG4gKiBgXCJiYWNrXCJgIGV0Yy5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICByZXMucmVkaXJlY3QoJy9mb28vYmFyJyk7XG4gKiAgICByZXMucmVkaXJlY3QoJ2h0dHA6Ly9leGFtcGxlLmNvbScpO1xuICogICAgcmVzLnJlZGlyZWN0KDMwMSwgJ2h0dHA6Ly9leGFtcGxlLmNvbScpO1xuICogICAgcmVzLnJlZGlyZWN0KCcuLi9sb2dpbicpOyAvLyAvYmxvZy9wb3N0LzEgLT4gL2Jsb2cvbG9naW5cbiAqXG4gKiBAcHVibGljXG4gKi9cblxucmVzLnJlZGlyZWN0ID0gZnVuY3Rpb24gcmVkaXJlY3QodXJsKSB7XG4gIHZhciBhZGRyZXNzID0gdXJsO1xuICB2YXIgYm9keTtcbiAgdmFyIHN0YXR1cyA9IDMwMjtcblxuICAvLyBhbGxvdyBzdGF0dXMgLyB1cmxcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHN0YXR1cyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGFkZHJlc3MgPSBhcmd1bWVudHNbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlcHJlY2F0ZSgncmVzLnJlZGlyZWN0KHVybCwgc3RhdHVzKTogVXNlIHJlcy5yZWRpcmVjdChzdGF0dXMsIHVybCkgaW5zdGVhZCcpO1xuICAgICAgc3RhdHVzID0gYXJndW1lbnRzWzFdO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNldCBsb2NhdGlvbiBoZWFkZXJcbiAgYWRkcmVzcyA9IHRoaXMubG9jYXRpb24oYWRkcmVzcykuZ2V0KCdMb2NhdGlvbicpO1xuXG4gIC8vIFN1cHBvcnQgdGV4dC97cGxhaW4saHRtbH0gYnkgZGVmYXVsdFxuICB0aGlzLmZvcm1hdCh7XG4gICAgdGV4dDogZnVuY3Rpb24oKXtcbiAgICAgIGJvZHkgPSBzdGF0dXNlc1tzdGF0dXNdICsgJy4gUmVkaXJlY3RpbmcgdG8gJyArIGFkZHJlc3NcbiAgICB9LFxuXG4gICAgaHRtbDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciB1ID0gZXNjYXBlSHRtbChhZGRyZXNzKTtcbiAgICAgIGJvZHkgPSAnPHA+JyArIHN0YXR1c2VzW3N0YXR1c10gKyAnLiBSZWRpcmVjdGluZyB0byA8YSBocmVmPVwiJyArIHUgKyAnXCI+JyArIHUgKyAnPC9hPjwvcD4nXG4gICAgfSxcblxuICAgIGRlZmF1bHQ6IGZ1bmN0aW9uKCl7XG4gICAgICBib2R5ID0gJyc7XG4gICAgfVxuICB9KTtcblxuICAvLyBSZXNwb25kXG4gIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1cztcbiAgdGhpcy5zZXQoJ0NvbnRlbnQtTGVuZ3RoJywgQnVmZmVyLmJ5dGVMZW5ndGgoYm9keSkpO1xuXG4gIGlmICh0aGlzLnJlcS5tZXRob2QgPT09ICdIRUFEJykge1xuICAgIHRoaXMuZW5kKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5lbmQoYm9keSk7XG4gIH1cbn07XG5cbi8qKlxuICogQWRkIGBmaWVsZGAgdG8gVmFyeS4gSWYgYWxyZWFkeSBwcmVzZW50IGluIHRoZSBWYXJ5IHNldCwgdGhlblxuICogdGhpcyBjYWxsIGlzIHNpbXBseSBpZ25vcmVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U2VydmVyUmVzcG9uc2V9IGZvciBjaGFpbmluZ1xuICogQHB1YmxpY1xuICovXG5cbnJlcy52YXJ5ID0gZnVuY3Rpb24oZmllbGQpe1xuICAvLyBjaGVja3MgZm9yIGJhY2stY29tcGF0XG4gIGlmICghZmllbGQgfHwgKEFycmF5LmlzQXJyYXkoZmllbGQpICYmICFmaWVsZC5sZW5ndGgpKSB7XG4gICAgZGVwcmVjYXRlKCdyZXMudmFyeSgpOiBQcm92aWRlIGEgZmllbGQgbmFtZScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyeSh0aGlzLCBmaWVsZCk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbmRlciBgdmlld2Agd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgIGFuZCBvcHRpb25hbCBjYWxsYmFjayBgZm5gLlxuICogV2hlbiBhIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGdpdmVuIGEgcmVzcG9uc2Ugd2lsbCBfbm90XyBiZSBtYWRlXG4gKiBhdXRvbWF0aWNhbGx5LCBvdGhlcndpc2UgYSByZXNwb25zZSBvZiBfMjAwXyBhbmQgX3RleHQvaHRtbF8gaXMgZ2l2ZW4uXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgY2FjaGVgICAgICBib29sZWFuIGhpbnRpbmcgdG8gdGhlIGVuZ2luZSBpdCBzaG91bGQgY2FjaGVcbiAqICAtIGBmaWxlbmFtZWAgIGZpbGVuYW1lIG9mIHRoZSB2aWV3IGJlaW5nIHJlbmRlcmVkXG4gKlxuICogQHB1YmxpY1xuICovXG5cbnJlcy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIodmlldywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIGFwcCA9IHRoaXMucmVxLmFwcDtcbiAgdmFyIGRvbmUgPSBjYWxsYmFjaztcbiAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcmVxID0gdGhpcy5yZXE7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBzdXBwb3J0IGNhbGxiYWNrIGZ1bmN0aW9uIGFzIHNlY29uZCBhcmdcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZG9uZSA9IG9wdGlvbnM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgLy8gbWVyZ2UgcmVzLmxvY2Fsc1xuICBvcHRzLl9sb2NhbHMgPSBzZWxmLmxvY2FscztcblxuICAvLyBkZWZhdWx0IGNhbGxiYWNrIHRvIHJlc3BvbmRcbiAgZG9uZSA9IGRvbmUgfHwgZnVuY3Rpb24gKGVyciwgc3RyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIHJlcS5uZXh0KGVycik7XG4gICAgc2VsZi5zZW5kKHN0cik7XG4gIH07XG5cbiAgLy8gcmVuZGVyXG4gIGFwcC5yZW5kZXIodmlldywgb3B0cywgZG9uZSk7XG59O1xuXG4vLyBwaXBlIHRoZSBzZW5kIGZpbGUgc3RyZWFtXG5mdW5jdGlvbiBzZW5kZmlsZShyZXMsIGZpbGUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBkb25lID0gZmFsc2U7XG4gIHZhciBzdHJlYW1pbmc7XG5cbiAgLy8gcmVxdWVzdCBhYm9ydGVkXG4gIGZ1bmN0aW9uIG9uYWJvcnRlZCgpIHtcbiAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgIGRvbmUgPSB0cnVlO1xuXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignUmVxdWVzdCBhYm9ydGVkJyk7XG4gICAgZXJyLmNvZGUgPSAnRUNPTk5BQk9SVEVEJztcbiAgICBjYWxsYmFjayhlcnIpO1xuICB9XG5cbiAgLy8gZGlyZWN0b3J5XG4gIGZ1bmN0aW9uIG9uZGlyZWN0b3J5KCkge1xuICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgZG9uZSA9IHRydWU7XG5cbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdFSVNESVIsIHJlYWQnKTtcbiAgICBlcnIuY29kZSA9ICdFSVNESVInO1xuICAgIGNhbGxiYWNrKGVycik7XG4gIH1cblxuICAvLyBlcnJvcnNcbiAgZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgIGRvbmUgPSB0cnVlO1xuICAgIGNhbGxiYWNrKGVycik7XG4gIH1cblxuICAvLyBlbmRlZFxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgIGRvbmUgPSB0cnVlO1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICAvLyBmaWxlXG4gIGZ1bmN0aW9uIG9uZmlsZSgpIHtcbiAgICBzdHJlYW1pbmcgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIGZpbmlzaGVkXG4gIGZ1bmN0aW9uIG9uZmluaXNoKGVycikge1xuICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09ICdFQ09OTlJFU0VUJykgcmV0dXJuIG9uYWJvcnRlZCgpO1xuICAgIGlmIChlcnIpIHJldHVybiBvbmVycm9yKGVycik7XG4gICAgaWYgKGRvbmUpIHJldHVybjtcblxuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc3RyZWFtaW5nICE9PSBmYWxzZSAmJiAhZG9uZSkge1xuICAgICAgICBvbmFib3J0ZWQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RyZWFtaW5nXG4gIGZ1bmN0aW9uIG9uc3RyZWFtKCkge1xuICAgIHN0cmVhbWluZyA9IHRydWU7XG4gIH1cblxuICBmaWxlLm9uKCdkaXJlY3RvcnknLCBvbmRpcmVjdG9yeSk7XG4gIGZpbGUub24oJ2VuZCcsIG9uZW5kKTtcbiAgZmlsZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZmlsZS5vbignZmlsZScsIG9uZmlsZSk7XG4gIGZpbGUub24oJ3N0cmVhbScsIG9uc3RyZWFtKTtcbiAgb25GaW5pc2hlZChyZXMsIG9uZmluaXNoKTtcblxuICBpZiAob3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgLy8gc2V0IGhlYWRlcnMgb24gc3VjY2Vzc2Z1bCB0cmFuc2ZlclxuICAgIGZpbGUub24oJ2hlYWRlcnMnLCBmdW5jdGlvbiBoZWFkZXJzKHJlcykge1xuICAgICAgdmFyIG9iaiA9IG9wdGlvbnMuaGVhZGVycztcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1tpXTtcbiAgICAgICAgcmVzLnNldEhlYWRlcihrLCBvYmpba10pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gcGlwZVxuICBmaWxlLnBpcGUocmVzKTtcbn1cblxuLyoqXG4gKiBTdHJpbmdpZnkgSlNPTiwgbGlrZSBKU09OLnN0cmluZ2lmeSwgYnV0IHY4IG9wdGltaXplZCwgd2l0aCB0aGVcbiAqIGFiaWxpdHkgdG8gZXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW4gdHJpZ2dlciBIVE1MIHNuaWZmaW5nLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlcGxhY2VzXG4gKiBAcGFyYW0ge251bWJlcn0gc3BhY2VzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVzY2FwZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc3RyaW5naWZ5ICh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlcywgZXNjYXBlKSB7XG4gIC8vIHY4IGNoZWNrcyBhcmd1bWVudHMubGVuZ3RoIGZvciBvcHRpbWl6aW5nIHNpbXBsZSBjYWxsXG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQ3MzBcbiAgdmFyIGpzb24gPSByZXBsYWNlciB8fCBzcGFjZXNcbiAgICA/IEpTT04uc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgc3BhY2VzKVxuICAgIDogSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuXG4gIGlmIChlc2NhcGUpIHtcbiAgICBqc29uID0ganNvbi5yZXBsYWNlKC9bPD4mXS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgc3dpdGNoIChjLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgY2FzZSAweDNjOlxuICAgICAgICAgIHJldHVybiAnXFxcXHUwMDNjJ1xuICAgICAgICBjYXNlIDB4M2U6XG4gICAgICAgICAgcmV0dXJuICdcXFxcdTAwM2UnXG4gICAgICAgIGNhc2UgMHgyNjpcbiAgICAgICAgICByZXR1cm4gJ1xcXFx1MDAyNidcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gY1xuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4ganNvblxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZXhwcmVzcy9saWIvcmVzcG9uc2UuanNcbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG4vKipcbiAqIFNpZ24gdGhlIGdpdmVuIGB2YWxgIHdpdGggYHNlY3JldGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHBhcmFtIHtTdHJpbmd9IHNlY3JldFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5zaWduID0gZnVuY3Rpb24odmFsLCBzZWNyZXQpe1xuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIHZhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvb2tpZSB2YWx1ZSBtdXN0IGJlIHByb3ZpZGVkIGFzIGEgc3RyaW5nLlwiKTtcbiAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiBzZWNyZXQpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTZWNyZXQgc3RyaW5nIG11c3QgYmUgcHJvdmlkZWQuXCIpO1xuICByZXR1cm4gdmFsICsgJy4nICsgY3J5cHRvXG4gICAgLmNyZWF0ZUhtYWMoJ3NoYTI1NicsIHNlY3JldClcbiAgICAudXBkYXRlKHZhbClcbiAgICAuZGlnZXN0KCdiYXNlNjQnKVxuICAgIC5yZXBsYWNlKC9cXD0rJC8sICcnKTtcbn07XG5cbi8qKlxuICogVW5zaWduIGFuZCBkZWNvZGUgdGhlIGdpdmVuIGB2YWxgIHdpdGggYHNlY3JldGAsXG4gKiByZXR1cm5pbmcgYGZhbHNlYCBpZiB0aGUgc2lnbmF0dXJlIGlzIGludmFsaWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHBhcmFtIHtTdHJpbmd9IHNlY3JldFxuICogQHJldHVybiB7U3RyaW5nfEJvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnVuc2lnbiA9IGZ1bmN0aW9uKHZhbCwgc2VjcmV0KXtcbiAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiB2YWwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTaWduZWQgY29va2llIHN0cmluZyBtdXN0IGJlIHByb3ZpZGVkLlwiKTtcbiAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiBzZWNyZXQpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTZWNyZXQgc3RyaW5nIG11c3QgYmUgcHJvdmlkZWQuXCIpO1xuICB2YXIgc3RyID0gdmFsLnNsaWNlKDAsIHZhbC5sYXN0SW5kZXhPZignLicpKVxuICAgICwgbWFjID0gZXhwb3J0cy5zaWduKHN0ciwgc2VjcmV0KTtcbiAgXG4gIHJldHVybiBzaGExKG1hYykgPT0gc2hhMSh2YWwpID8gc3RyIDogZmFsc2U7XG59O1xuXG4vKipcbiAqIFByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzaGExKHN0cil7XG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShzdHIpLmRpZ2VzdCgnaGV4Jyk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb29raWUtc2lnbmF0dXJlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiB2YXJ5XG4gKiBDb3B5cmlnaHQoYykgMjAxNC0yMDE3IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZhcnlcbm1vZHVsZS5leHBvcnRzLmFwcGVuZCA9IGFwcGVuZFxuXG4vKipcbiAqIFJlZ0V4cCB0byBtYXRjaCBmaWVsZC1uYW1lIGluIFJGQyA3MjMwIHNlYyAzLjJcbiAqXG4gKiBmaWVsZC1uYW1lICAgID0gdG9rZW5cbiAqIHRva2VuICAgICAgICAgPSAxKnRjaGFyXG4gKiB0Y2hhciAgICAgICAgID0gXCIhXCIgLyBcIiNcIiAvIFwiJFwiIC8gXCIlXCIgLyBcIiZcIiAvIFwiJ1wiIC8gXCIqXCJcbiAqICAgICAgICAgICAgICAgLyBcIitcIiAvIFwiLVwiIC8gXCIuXCIgLyBcIl5cIiAvIFwiX1wiIC8gXCJgXCIgLyBcInxcIiAvIFwiflwiXG4gKiAgICAgICAgICAgICAgIC8gRElHSVQgLyBBTFBIQVxuICogICAgICAgICAgICAgICA7IGFueSBWQ0hBUiwgZXhjZXB0IGRlbGltaXRlcnNcbiAqL1xuXG52YXIgRklFTERfTkFNRV9SRUdFWFAgPSAvXlshIyQlJicqK1xcLS5eX2B8fjAtOUEtWmEtel0rJC9cblxuLyoqXG4gKiBBcHBlbmQgYSBmaWVsZCB0byBhIHZhcnkgaGVhZGVyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGFwcGVuZCAoaGVhZGVyLCBmaWVsZCkge1xuICBpZiAodHlwZW9mIGhlYWRlciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoZWFkZXIgYXJndW1lbnQgaXMgcmVxdWlyZWQnKVxuICB9XG5cbiAgaWYgKCFmaWVsZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZpZWxkIGFyZ3VtZW50IGlzIHJlcXVpcmVkJylcbiAgfVxuXG4gIC8vIGdldCBmaWVsZHMgYXJyYXlcbiAgdmFyIGZpZWxkcyA9ICFBcnJheS5pc0FycmF5KGZpZWxkKVxuICAgID8gcGFyc2UoU3RyaW5nKGZpZWxkKSlcbiAgICA6IGZpZWxkXG5cbiAgLy8gYXNzZXJ0IG9uIGludmFsaWQgZmllbGQgbmFtZXNcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBmaWVsZHMubGVuZ3RoOyBqKyspIHtcbiAgICBpZiAoIUZJRUxEX05BTUVfUkVHRVhQLnRlc3QoZmllbGRzW2pdKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmllbGQgYXJndW1lbnQgY29udGFpbnMgYW4gaW52YWxpZCBoZWFkZXIgbmFtZScpXG4gICAgfVxuICB9XG5cbiAgLy8gZXhpc3RpbmcsIHVuc3BlY2lmaWVkIHZhcnlcbiAgaWYgKGhlYWRlciA9PT0gJyonKSB7XG4gICAgcmV0dXJuIGhlYWRlclxuICB9XG5cbiAgLy8gZW51bWVyYXRlIGN1cnJlbnQgdmFsdWVzXG4gIHZhciB2YWwgPSBoZWFkZXJcbiAgdmFyIHZhbHMgPSBwYXJzZShoZWFkZXIudG9Mb3dlckNhc2UoKSlcblxuICAvLyB1bnNwZWNpZmllZCB2YXJ5XG4gIGlmIChmaWVsZHMuaW5kZXhPZignKicpICE9PSAtMSB8fCB2YWxzLmluZGV4T2YoJyonKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gJyonXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmbGQgPSBmaWVsZHNbaV0udG9Mb3dlckNhc2UoKVxuXG4gICAgLy8gYXBwZW5kIHZhbHVlIChjYXNlLXByZXNlcnZpbmcpXG4gICAgaWYgKHZhbHMuaW5kZXhPZihmbGQpID09PSAtMSkge1xuICAgICAgdmFscy5wdXNoKGZsZClcbiAgICAgIHZhbCA9IHZhbFxuICAgICAgICA/IHZhbCArICcsICcgKyBmaWVsZHNbaV1cbiAgICAgICAgOiBmaWVsZHNbaV1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogUGFyc2UgYSB2YXJ5IGhlYWRlciBpbnRvIGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZSAoaGVhZGVyKSB7XG4gIHZhciBlbmQgPSAwXG4gIHZhciBsaXN0ID0gW11cbiAgdmFyIHN0YXJ0ID0gMFxuXG4gIC8vIGdhdGhlciB0b2tlbnNcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGhlYWRlci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHN3aXRjaCAoaGVhZGVyLmNoYXJDb2RlQXQoaSkpIHtcbiAgICAgIGNhc2UgMHgyMDogLyogICAqL1xuICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgICAgICAgIHN0YXJ0ID0gZW5kID0gaSArIDFcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAweDJjOiAvKiAsICovXG4gICAgICAgIGxpc3QucHVzaChoZWFkZXIuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpKVxuICAgICAgICBzdGFydCA9IGVuZCA9IGkgKyAxXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBlbmQgPSBpICsgMVxuICAgICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpbmFsIHRva2VuXG4gIGxpc3QucHVzaChoZWFkZXIuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpKVxuXG4gIHJldHVybiBsaXN0XG59XG5cbi8qKlxuICogTWFyayB0aGF0IGEgcmVxdWVzdCBpcyB2YXJpZWQgb24gYSBoZWFkZXIgZmllbGQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlc1xuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGZpZWxkXG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gdmFyeSAocmVzLCBmaWVsZCkge1xuICBpZiAoIXJlcyB8fCAhcmVzLmdldEhlYWRlciB8fCAhcmVzLnNldEhlYWRlcikge1xuICAgIC8vIHF1YWNrIHF1YWNrXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVzIGFyZ3VtZW50IGlzIHJlcXVpcmVkJylcbiAgfVxuXG4gIC8vIGdldCBleGlzdGluZyBoZWFkZXJcbiAgdmFyIHZhbCA9IHJlcy5nZXRIZWFkZXIoJ1ZhcnknKSB8fCAnJ1xuICB2YXIgaGVhZGVyID0gQXJyYXkuaXNBcnJheSh2YWwpXG4gICAgPyB2YWwuam9pbignLCAnKVxuICAgIDogU3RyaW5nKHZhbClcblxuICAvLyBzZXQgbmV3IGhlYWRlclxuICBpZiAoKHZhbCA9IGFwcGVuZChoZWFkZXIsIGZpZWxkKSkpIHtcbiAgICByZXMuc2V0SGVhZGVyKCdWYXJ5JywgdmFsKVxuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92YXJ5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBzZXJ2ZS1zdGF0aWNcbiAqIENvcHlyaWdodChjKSAyMDEwIFNlbmNoYSBJbmMuXG4gKiBDb3B5cmlnaHQoYykgMjAxMSBUSiBIb2xvd2F5Y2h1a1xuICogQ29weXJpZ2h0KGMpIDIwMTQtMjAxNiBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIGVuY29kZVVybCA9IHJlcXVpcmUoJ2VuY29kZXVybCcpXG52YXIgZXNjYXBlSHRtbCA9IHJlcXVpcmUoJ2VzY2FwZS1odG1sJylcbnZhciBwYXJzZVVybCA9IHJlcXVpcmUoJ3BhcnNldXJsJylcbnZhciByZXNvbHZlID0gcmVxdWlyZSgncGF0aCcpLnJlc29sdmVcbnZhciBzZW5kID0gcmVxdWlyZSgnc2VuZCcpXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJylcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNlcnZlU3RhdGljXG5tb2R1bGUuZXhwb3J0cy5taW1lID0gc2VuZC5taW1lXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHJvb3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHNlcnZlU3RhdGljIChyb290LCBvcHRpb25zKSB7XG4gIGlmICghcm9vdCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Jvb3QgcGF0aCByZXF1aXJlZCcpXG4gIH1cblxuICBpZiAodHlwZW9mIHJvb3QgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncm9vdCBwYXRoIG11c3QgYmUgYSBzdHJpbmcnKVxuICB9XG5cbiAgLy8gY29weSBvcHRpb25zIG9iamVjdFxuICB2YXIgb3B0cyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyB8fCBudWxsKVxuXG4gIC8vIGZhbGwtdGhvdWdoXG4gIHZhciBmYWxsdGhyb3VnaCA9IG9wdHMuZmFsbHRocm91Z2ggIT09IGZhbHNlXG5cbiAgLy8gZGVmYXVsdCByZWRpcmVjdFxuICB2YXIgcmVkaXJlY3QgPSBvcHRzLnJlZGlyZWN0ICE9PSBmYWxzZVxuXG4gIC8vIGhlYWRlcnMgbGlzdGVuZXJcbiAgdmFyIHNldEhlYWRlcnMgPSBvcHRzLnNldEhlYWRlcnNcblxuICBpZiAoc2V0SGVhZGVycyAmJiB0eXBlb2Ygc2V0SGVhZGVycyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBzZXRIZWFkZXJzIG11c3QgYmUgZnVuY3Rpb24nKVxuICB9XG5cbiAgLy8gc2V0dXAgb3B0aW9ucyBmb3Igc2VuZFxuICBvcHRzLm1heGFnZSA9IG9wdHMubWF4YWdlIHx8IG9wdHMubWF4QWdlIHx8IDBcbiAgb3B0cy5yb290ID0gcmVzb2x2ZShyb290KVxuXG4gIC8vIGNvbnN0cnVjdCBkaXJlY3RvcnkgbGlzdGVuZXJcbiAgdmFyIG9uRGlyZWN0b3J5ID0gcmVkaXJlY3RcbiAgICA/IGNyZWF0ZVJlZGlyZWN0RGlyZWN0b3J5TGlzdGVuZXIoKVxuICAgIDogY3JlYXRlTm90Rm91bmREaXJlY3RvcnlMaXN0ZW5lcigpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHNlcnZlU3RhdGljIChyZXEsIHJlcywgbmV4dCkge1xuICAgIGlmIChyZXEubWV0aG9kICE9PSAnR0VUJyAmJiByZXEubWV0aG9kICE9PSAnSEVBRCcpIHtcbiAgICAgIGlmIChmYWxsdGhyb3VnaCkge1xuICAgICAgICByZXR1cm4gbmV4dCgpXG4gICAgICB9XG5cbiAgICAgIC8vIG1ldGhvZCBub3QgYWxsb3dlZFxuICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDVcbiAgICAgIHJlcy5zZXRIZWFkZXIoJ0FsbG93JywgJ0dFVCwgSEVBRCcpXG4gICAgICByZXMuc2V0SGVhZGVyKCdDb250ZW50LUxlbmd0aCcsICcwJylcbiAgICAgIHJlcy5lbmQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGZvcndhcmRFcnJvciA9ICFmYWxsdGhyb3VnaFxuICAgIHZhciBvcmlnaW5hbFVybCA9IHBhcnNlVXJsLm9yaWdpbmFsKHJlcSlcbiAgICB2YXIgcGF0aCA9IHBhcnNlVXJsKHJlcSkucGF0aG5hbWVcblxuICAgIC8vIG1ha2Ugc3VyZSByZWRpcmVjdCBvY2N1cnMgYXQgbW91bnRcbiAgICBpZiAocGF0aCA9PT0gJy8nICYmIG9yaWdpbmFsVXJsLnBhdGhuYW1lLnN1YnN0cigtMSkgIT09ICcvJykge1xuICAgICAgcGF0aCA9ICcnXG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIHNlbmQgc3RyZWFtXG4gICAgdmFyIHN0cmVhbSA9IHNlbmQocmVxLCBwYXRoLCBvcHRzKVxuXG4gICAgLy8gYWRkIGRpcmVjdG9yeSBoYW5kbGVyXG4gICAgc3RyZWFtLm9uKCdkaXJlY3RvcnknLCBvbkRpcmVjdG9yeSlcblxuICAgIC8vIGFkZCBoZWFkZXJzIGxpc3RlbmVyXG4gICAgaWYgKHNldEhlYWRlcnMpIHtcbiAgICAgIHN0cmVhbS5vbignaGVhZGVycycsIHNldEhlYWRlcnMpXG4gICAgfVxuXG4gICAgLy8gYWRkIGZpbGUgbGlzdGVuZXIgZm9yIGZhbGx0aHJvdWdoXG4gICAgaWYgKGZhbGx0aHJvdWdoKSB7XG4gICAgICBzdHJlYW0ub24oJ2ZpbGUnLCBmdW5jdGlvbiBvbkZpbGUgKCkge1xuICAgICAgICAvLyBvbmNlIGZpbGUgaXMgZGV0ZXJtaW5lZCwgYWx3YXlzIGZvcndhcmQgZXJyb3JcbiAgICAgICAgZm9yd2FyZEVycm9yID0gdHJ1ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBmb3J3YXJkIGVycm9yc1xuICAgIHN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbiBlcnJvciAoZXJyKSB7XG4gICAgICBpZiAoZm9yd2FyZEVycm9yIHx8ICEoZXJyLnN0YXR1c0NvZGUgPCA1MDApKSB7XG4gICAgICAgIG5leHQoZXJyKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgbmV4dCgpXG4gICAgfSlcblxuICAgIC8vIHBpcGVcbiAgICBzdHJlYW0ucGlwZShyZXMpXG4gIH1cbn1cblxuLyoqXG4gKiBDb2xsYXBzZSBhbGwgbGVhZGluZyBzbGFzaGVzIGludG8gYSBzaW5nbGUgc2xhc2hcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbGxhcHNlTGVhZGluZ1NsYXNoZXMgKHN0cikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHIuY2hhckNvZGVBdChpKSAhPT0gMHgyZiAvKiAvICovKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpID4gMVxuICAgID8gJy8nICsgc3RyLnN1YnN0cihpKVxuICAgIDogc3RyXG59XG5cbiAvKipcbiAqIENyZWF0ZSBhIG1pbmltYWwgSFRNTCBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBib2R5XG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUh0bWxEb2N1bWVudCAodGl0bGUsIGJvZHkpIHtcbiAgcmV0dXJuICc8IURPQ1RZUEUgaHRtbD5cXG4nICtcbiAgICAnPGh0bWwgbGFuZz1cImVuXCI+XFxuJyArXG4gICAgJzxoZWFkPlxcbicgK1xuICAgICc8bWV0YSBjaGFyc2V0PVwidXRmLThcIj5cXG4nICtcbiAgICAnPHRpdGxlPicgKyB0aXRsZSArICc8L3RpdGxlPlxcbicgK1xuICAgICc8L2hlYWQ+XFxuJyArXG4gICAgJzxib2R5PlxcbicgK1xuICAgICc8cHJlPicgKyBib2R5ICsgJzwvcHJlPlxcbicgK1xuICAgICc8L2JvZHk+XFxuJyArXG4gICAgJzwvaHRtbD5cXG4nXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGlyZWN0b3J5IGxpc3RlbmVyIHRoYXQganVzdCA0MDRzLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVOb3RGb3VuZERpcmVjdG9yeUxpc3RlbmVyICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG5vdEZvdW5kICgpIHtcbiAgICB0aGlzLmVycm9yKDQwNClcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRpcmVjdG9yeSBsaXN0ZW5lciB0aGF0IHBlcmZvcm1zIGEgcmVkaXJlY3QuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVJlZGlyZWN0RGlyZWN0b3J5TGlzdGVuZXIgKCkge1xuICByZXR1cm4gZnVuY3Rpb24gcmVkaXJlY3QgKHJlcykge1xuICAgIGlmICh0aGlzLmhhc1RyYWlsaW5nU2xhc2goKSkge1xuICAgICAgdGhpcy5lcnJvcig0MDQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBnZXQgb3JpZ2luYWwgVVJMXG4gICAgdmFyIG9yaWdpbmFsVXJsID0gcGFyc2VVcmwub3JpZ2luYWwodGhpcy5yZXEpXG5cbiAgICAvLyBhcHBlbmQgdHJhaWxpbmcgc2xhc2hcbiAgICBvcmlnaW5hbFVybC5wYXRoID0gbnVsbFxuICAgIG9yaWdpbmFsVXJsLnBhdGhuYW1lID0gY29sbGFwc2VMZWFkaW5nU2xhc2hlcyhvcmlnaW5hbFVybC5wYXRobmFtZSArICcvJylcblxuICAgIC8vIHJlZm9ybWF0IHRoZSBVUkxcbiAgICB2YXIgbG9jID0gZW5jb2RlVXJsKHVybC5mb3JtYXQob3JpZ2luYWxVcmwpKVxuICAgIHZhciBkb2MgPSBjcmVhdGVIdG1sRG9jdW1lbnQoJ1JlZGlyZWN0aW5nJywgJ1JlZGlyZWN0aW5nIHRvIDxhIGhyZWY9XCInICsgZXNjYXBlSHRtbChsb2MpICsgJ1wiPicgK1xuICAgICAgZXNjYXBlSHRtbChsb2MpICsgJzwvYT4nKVxuXG4gICAgLy8gc2VuZCByZWRpcmVjdCByZXNwb25zZVxuICAgIHJlcy5zdGF0dXNDb2RlID0gMzAxXG4gICAgcmVzLnNldEhlYWRlcignQ29udGVudC1UeXBlJywgJ3RleHQvaHRtbDsgY2hhcnNldD1VVEYtOCcpXG4gICAgcmVzLnNldEhlYWRlcignQ29udGVudC1MZW5ndGgnLCBCdWZmZXIuYnl0ZUxlbmd0aChkb2MpKVxuICAgIHJlcy5zZXRIZWFkZXIoJ0NvbnRlbnQtU2VjdXJpdHktUG9saWN5JywgXCJkZWZhdWx0LXNyYyAnc2VsZidcIilcbiAgICByZXMuc2V0SGVhZGVyKCdYLUNvbnRlbnQtVHlwZS1PcHRpb25zJywgJ25vc25pZmYnKVxuICAgIHJlcy5zZXRIZWFkZXIoJ0xvY2F0aW9uJywgbG9jKVxuICAgIHJlcy5lbmQoZG9jKVxuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zZXJ2ZS1zdGF0aWMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuaW1wb3J0IHtqb2luTG9iYnlNZXNzYWdlLCBQbGF5ZXIsIExvYmJ5LCBjcmVhdGVMb2JieU1lc3NhZ2UsIEl0ZW19IGZyb20gJy4vdHlwZXMnO1xyXG5pbXBvcnQgeyBlbWl0IH0gZnJvbSAnY2x1c3Rlcic7XHJcblxyXG5leHBvcnQgY2xhc3MgU29ja2V0U2VydmVyIHsgXHJcbiAgICBwcml2YXRlIGlvOiBTb2NrZXRJTy5TZXJ2ZXI7XHJcbiAgICBwcml2YXRlIGxvYmJpZXM6IEFycmF5PExvYmJ5PjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihzZXJ2ZXI6IGFueSkge1xyXG4gICAgICAgIHRoaXMuaW8gPSByZXF1aXJlKCdzb2NrZXQuaW8nKShzZXJ2ZXIsIHtcclxuICAgICAgICAgICAgc2VydmVDbGllbnQ6IGZhbHNlLFxyXG4gICAgICAgICAgICB3c0VuZ2luZTogJ3dzJyAvLyB1d3MgaXMgbm90IHN1cHBvcnRlZCBzaW5jZSBpdCBpcyBhIG5hdGl2ZSBtb2R1bGVcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmxvYmJpZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmxpc3RlbigpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBraWNrcyBwbGF5ZXIgZnJvbSBnYXBlIHBhZ2UgYmFjayB0byBsb2dpbiBwYWdlIHdpdGggb3B0aW9uYWwgbWVzc2FnZVxyXG5cclxuICAgIGtpY2tDbGllbnQgPSAoc29ja2V0OiBhbnksIG1lc3NhZ2U/OiBzdHJpbmcpOiB2b2lkID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygna2lja2luZycpXHJcbiAgICAgICAgc29ja2V0LmVtaXQoJ2tpY2tDbGllbnQnLCBtZXNzYWdlKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gc2VuZHMgbWVzc2FnZSB0byBjbGllbnRcclxuXHJcbiAgICBzZW5kTWVzc2FnZVRvQ2xpZW50ID0gKHNvY2tldDogYW55LCBtZXNzYWdlOiBzdHJpbmcpOiB2b2lkID0+IHtcclxuICAgICAgICBzb2NrZXQuZW1pdCgnZGlzcGxheU1lc3NhZ2UnLCBtZXNzYWdlKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gcmVtb3ZlcyBsb2JiaWVzIHRoYXQgYXJlIGVtcHR5IFxyXG5cclxuICAgIGNoZWNrTG9iYmllcyA9ICgpOiB2b2lkID0+IHtcclxuICAgICAgICBsZXQgbmV3TG9iYmllczogQXJyYXk8TG9iYnk+ID0gW107XHJcbiAgICAgICAgdGhpcy5sb2JiaWVzLm1hcChsID0+IHtcclxuICAgICAgICAgICAgaWYobC5wbGF5ZXJzLmxlbmd0aCA+IDApIG5ld0xvYmJpZXMucHVzaChsKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmxvYmJpZXMgPSBuZXdMb2JiaWVzO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBnZXRTdGFuZGFydEl0ZW1zQnlSb2xlID0gKHJvbGU6IHN0cmluZyk6IEFycmF5PEl0ZW0+ID0+IHtcclxuICAgICAgICBsZXQgaXRlbXM6IEFycmF5PEl0ZW0+O1xyXG5cclxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgNTsgaSsrICkge1xyXG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdpdGVtbmFtZScsXHJcbiAgICAgICAgICAgICAgICBpbmZvOiAndXNlbGVzcycsXHJcbiAgICAgICAgICAgICAgICBjc3NDbGFzczogJ3Rlc3RpdGVtJyxcclxuICAgICAgICAgICAgICAgIGRhdGE6ICdub25lJyxcclxuICAgICAgICAgICAgICAgIGFjdGlvbjoge30sXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpdGVtcztcclxuICAgIH1cclxuICAgIFxyXG5cclxuICAgIHByaXZhdGUgbGlzdGVuKCk6IHZvaWQge1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgdGhpcy5pby5vbignY29ubmVjdCcsIChzb2NrZXQ6IGFueSkgPT4ge1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIHNlbmRzIGF2YWlibGUgbG9iYmllcyB0byBjbGllbnRcclxuXHJcbiAgICAgICAgICAgIHNvY2tldC5vbignZ2V0TG9iYmllcycsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tMb2JiaWVzKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzOiBhbnkgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9iYmllcy5tYXAoIGwgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbC5uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5ZXJDb3VudDogbC5wbGF5ZXJzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4UGxheWVyczogbC5tYXhQbGF5ZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbC5sb2JieUlkLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIHNvY2tldC5lbWl0KFwibG9iYmllc0luZm9cIiwgcmVzKVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuXHJcbiAgICAgICAgICAgIHNvY2tldC5vbignZ2V0TG9iYnlTdGF0dXMnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbG9iYnk6IExvYmJ5O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2JiaWVzLm1hcChsID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsLnBsYXllcnMubWFwKHAgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwLmlkID0gc29ja2V0LmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2JieSA9IGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoIWxvYmJ5KSB0aGlzLmtpY2tDbGllbnQoc29ja2V0LCAnVW5leHBlY3RlZCBlcnJvci4nKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgc29ja2V0LmVtaXQoJ3VwZGF0ZUxvYmJ5U3RhdHVzJywgbG9iYnkpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG5cclxuICAgICAgICAgICAgLy8gYXNzaWducyBjbGllbnQgdG8gbG9iYnlcclxuXHJcbiAgICAgICAgICAgIHNvY2tldC5vbignam9pbkxvYmJ5JywgKGRhdGE6IGpvaW5Mb2JieU1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBraWNrZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9iYmllcy5tYXAobCA9PiBsLnBsYXllcnMubWFwKChwKSA9PiB7IFxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHAuaWQgPT0gc29ja2V0LmlkKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5raWNrQ2xpZW50KHAuc29ja2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2lja2VkID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH19KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGxvYmJ5OiBMb2JieSA9IHRoaXMubG9iYmllcy5maW5kKCBsID0+IGwubG9iYnlJZCA9PSBkYXRhLmxvYmJ5SWQpO1xyXG4gICAgICAgICAgICAgICAgaWYobG9iYnkgJiYgIWtpY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYobG9iYnkubWF4UGxheWVycyA+IGxvYmJ5LnBsYXllcnMubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByb2xlcyA9IFsndXNlcjEnLCAndXNlcjInLCAnaGFja2VyJ107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYmJ5LnBsYXllcnMubWFwKHAgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5yb2xlID09IHJvbGVzW2ldID8gaSsrIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3UGxheWVyOiBQbGF5ZXIgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogc29ja2V0LmlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0OiBzb2NrZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VybmFtZTogZGF0YS5jbGllbnQudXNlcm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlOiByb2xlc1tpXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiB0aGlzLmdldFN0YW5kYXJ0SXRlbXNCeVJvbGUocm9sZXNbaV0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9iYnkucGxheWVycy5wdXNoKG5ld1BsYXllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYmJ5LnBsYXllcnMubWFwKChwbGF5ZXI6IFBsYXllcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocGxheWVyLmlkICE9PSBuZXdQbGF5ZXIuaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRNZXNzYWdlVG9DbGllbnQocGxheWVyLnNvY2tldCwgZGF0YS5jbGllbnQudXNlcm5hbWUgKyBcIiBoYXMgam9pbiB0aGUgbG9iYnkhXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2lja0NsaWVudChzb2NrZXQsIFwiTG9iYnkgaXMgZnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmtpY2tDbGllbnQoc29ja2V0LCBcIkxvYmJ5IHdhcyBub3QgZm91bmQuXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgICAgICAvLyBjcmVhdGVzIG5ldyBsb2JieVxyXG5cclxuICAgICAgICAgICAgc29ja2V0Lm9uKCdjcmVhdGVMb2JieScsIChkYXRhOiBjcmVhdGVMb2JieU1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjcmVhdGluZyBsb2JieSAnICsgZGF0YS5sb2JieU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgbGV0IG5ld0xvYmJ5OiBMb2JieSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBwbGF5ZXJzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICByb3VuZDogMCxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBkYXRhLmxvYmJ5TmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBsb2JieUlkOiB0aGlzLmxvYmJpZXMubGVuZ3RoID4gMCA/IHRoaXMubG9iYmllc1t0aGlzLmxvYmJpZXMubGVuZ3RoLTFdLmxvYmJ5SWQgKyAxIDogMCxcclxuICAgICAgICAgICAgICAgICAgICBtYXhQbGF5ZXJzOiAzLFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc29ja2V0LmVtaXQoJ2NyZWF0ZWRMb2JieScsIG5ld0xvYmJ5LmxvYmJ5SWQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2JiaWVzLnB1c2gobmV3TG9iYnkpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIGRldGFjaGVzIGNsaWVudCBmcm9tIGxvYmJ5IGFuZCBkZWxldGVzIGxvYmJ5IGlmIGl0IHJlbWFpbnMgZW1wdHlcclxuXHJcbiAgICAgICAgICAgIHNvY2tldC5vbignY2xpZW50TGVhdmluZycsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9iYmllcy5tYXAoIChsb2JieTogTG9iYnkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsb2JieS5wbGF5ZXJzLm1hcCgocGxheWVyOiBQbGF5ZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBsYXllcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRpc2Nvbm5lY3RlZFVzZXJuYW1lOiBzdHJpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHBsYXllci5pZCAhPSBzb2NrZXQuaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllcnMucHVzaChwbGF5ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzY29ubmVjdGVkVXNlcm5hbWUgPSBwbGF5ZXIudXNlcm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZGlzY29ubmVjdGVkVXNlcm5hbWUgKyBcIiBoYXMgbGVmdC4gXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgbG9iYnkucGxheWVycyA9IHBsYXllcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgbG9iYnkucGxheWVycy5tYXAoIHAgPT4gdGhpcy5zZW5kTWVzc2FnZVRvQ2xpZW50KHAuc29ja2V0LCBkaXNjb25uZWN0ZWRVc2VybmFtZSArIFwiIGhhcyBkaXNjb25lY3RlZC5cIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0xvYmJpZXMoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc29ja2V0U2VydmVyLnRzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG52YXIgcmVhZCA9IHJlcXVpcmUoJ2ZzJykucmVhZEZpbGVTeW5jO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgZXhpc3RzID0gcmVxdWlyZSgnZnMnKS5leGlzdHNTeW5jO1xudmFyIGVuZ2luZSA9IHJlcXVpcmUoJ2VuZ2luZS5pbycpO1xudmFyIGNsaWVudFZlcnNpb24gPSByZXF1aXJlKCdzb2NrZXQuaW8tY2xpZW50L3BhY2thZ2UuanNvbicpLnZlcnNpb247XG52YXIgQ2xpZW50ID0gcmVxdWlyZSgnLi9jbGllbnQnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIE5hbWVzcGFjZSA9IHJlcXVpcmUoJy4vbmFtZXNwYWNlJyk7XG52YXIgUGFyZW50TmFtZXNwYWNlID0gcmVxdWlyZSgnLi9wYXJlbnQtbmFtZXNwYWNlJyk7XG52YXIgQWRhcHRlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1hZGFwdGVyJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvOnNlcnZlcicpO1xudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU2VydmVyO1xuXG4vKipcbiAqIFNvY2tldC5JTyBjbGllbnQgc291cmNlLlxuICovXG5cbnZhciBjbGllbnRTb3VyY2UgPSB1bmRlZmluZWQ7XG52YXIgY2xpZW50U291cmNlTWFwID0gdW5kZWZpbmVkO1xuXG4vKipcbiAqIFNlcnZlciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge2h0dHAuU2VydmVyfE51bWJlcnxPYmplY3R9IHNydiBodHRwIHNlcnZlciwgcG9ydCBvciBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNlcnZlcihzcnYsIG9wdHMpe1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2VydmVyKSkgcmV0dXJuIG5ldyBTZXJ2ZXIoc3J2LCBvcHRzKTtcbiAgaWYgKCdvYmplY3QnID09IHR5cGVvZiBzcnYgJiYgc3J2IGluc3RhbmNlb2YgT2JqZWN0ICYmICFzcnYubGlzdGVuKSB7XG4gICAgb3B0cyA9IHNydjtcbiAgICBzcnYgPSBudWxsO1xuICB9XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB0aGlzLm5zcHMgPSB7fTtcbiAgdGhpcy5wYXJlbnROc3BzID0gbmV3IE1hcCgpO1xuICB0aGlzLnBhdGgob3B0cy5wYXRoIHx8ICcvc29ja2V0LmlvJyk7XG4gIHRoaXMuc2VydmVDbGllbnQoZmFsc2UgIT09IG9wdHMuc2VydmVDbGllbnQpO1xuICB0aGlzLnBhcnNlciA9IG9wdHMucGFyc2VyIHx8IHBhcnNlcjtcbiAgdGhpcy5lbmNvZGVyID0gbmV3IHRoaXMucGFyc2VyLkVuY29kZXIoKTtcbiAgdGhpcy5hZGFwdGVyKG9wdHMuYWRhcHRlciB8fCBBZGFwdGVyKTtcbiAgdGhpcy5vcmlnaW5zKG9wdHMub3JpZ2lucyB8fCAnKjoqJyk7XG4gIHRoaXMuc29ja2V0cyA9IHRoaXMub2YoJy8nKTtcbiAgaWYgKHNydikgdGhpcy5hdHRhY2goc3J2LCBvcHRzKTtcbn1cblxuLyoqXG4gKiBTZXJ2ZXIgcmVxdWVzdCB2ZXJpZmljYXRpb24gZnVuY3Rpb24sIHRoYXQgY2hlY2tzIGZvciBhbGxvd2VkIG9yaWdpbnNcbiAqXG4gKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgcmVxdWVzdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdpdGggdGhlIHJlc3VsdDogYGZuKGVyciwgc3VjY2VzcylgXG4gKi9cblxuU2VydmVyLnByb3RvdHlwZS5jaGVja1JlcXVlc3QgPSBmdW5jdGlvbihyZXEsIGZuKSB7XG4gIHZhciBvcmlnaW4gPSByZXEuaGVhZGVycy5vcmlnaW4gfHwgcmVxLmhlYWRlcnMucmVmZXJlcjtcblxuICAvLyBmaWxlOi8vIFVSTHMgcHJvZHVjZSBhIG51bGwgT3JpZ2luIHdoaWNoIGNhbid0IGJlIGF1dGhvcml6ZWQgdmlhIGVjaG8tYmFja1xuICBpZiAoJ251bGwnID09IG9yaWdpbiB8fCBudWxsID09IG9yaWdpbikgb3JpZ2luID0gJyonO1xuXG4gIGlmICghIW9yaWdpbiAmJiB0eXBlb2YodGhpcy5fb3JpZ2lucykgPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuX29yaWdpbnMob3JpZ2luLCBmbik7XG4gIGlmICh0aGlzLl9vcmlnaW5zLmluZGV4T2YoJyo6KicpICE9PSAtMSkgcmV0dXJuIGZuKG51bGwsIHRydWUpO1xuICBpZiAob3JpZ2luKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBwYXJ0cyA9IHVybC5wYXJzZShvcmlnaW4pO1xuICAgICAgdmFyIGRlZmF1bHRQb3J0ID0gJ2h0dHBzOicgPT0gcGFydHMucHJvdG9jb2wgPyA0NDMgOiA4MDtcbiAgICAgIHBhcnRzLnBvcnQgPSBwYXJ0cy5wb3J0ICE9IG51bGxcbiAgICAgICAgPyBwYXJ0cy5wb3J0XG4gICAgICAgIDogZGVmYXVsdFBvcnQ7XG4gICAgICB2YXIgb2sgPVxuICAgICAgICB+dGhpcy5fb3JpZ2lucy5pbmRleE9mKHBhcnRzLnByb3RvY29sICsgJy8vJyArIHBhcnRzLmhvc3RuYW1lICsgJzonICsgcGFydHMucG9ydCkgfHxcbiAgICAgICAgfnRoaXMuX29yaWdpbnMuaW5kZXhPZihwYXJ0cy5ob3N0bmFtZSArICc6JyArIHBhcnRzLnBvcnQpIHx8XG4gICAgICAgIH50aGlzLl9vcmlnaW5zLmluZGV4T2YocGFydHMuaG9zdG5hbWUgKyAnOionKSB8fFxuICAgICAgICB+dGhpcy5fb3JpZ2lucy5pbmRleE9mKCcqOicgKyBwYXJ0cy5wb3J0KTtcbiAgICAgIGRlYnVnKCdvcmlnaW4gJXMgaXMgJXN2YWxpZCcsIG9yaWdpbiwgISFvayA/ICcnIDogJ25vdCAnKTtcbiAgICAgIHJldHVybiBmbihudWxsLCAhIW9rKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgIH1cbiAgfVxuICBmbihudWxsLCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIFNldHMvZ2V0cyB3aGV0aGVyIGNsaWVudCBjb2RlIGlzIGJlaW5nIHNlcnZlZC5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHYgd2hldGhlciB0byBzZXJ2ZSBjbGllbnQgY29kZVxuICogQHJldHVybiB7U2VydmVyfEJvb2xlYW59IHNlbGYgd2hlbiBzZXR0aW5nIG9yIHZhbHVlIHdoZW4gZ2V0dGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TZXJ2ZXIucHJvdG90eXBlLnNlcnZlQ2xpZW50ID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3NlcnZlQ2xpZW50O1xuICB0aGlzLl9zZXJ2ZUNsaWVudCA9IHY7XG4gIHZhciByZXNvbHZlUGF0aCA9IGZ1bmN0aW9uKGZpbGUpe1xuICAgIHZhciBmaWxlcGF0aCA9IHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuLy4uLy4uLycsIGZpbGUpO1xuICAgIGlmIChleGlzdHMoZmlsZXBhdGgpKSB7XG4gICAgICByZXR1cm4gZmlsZXBhdGg7XG4gICAgfVxuICAgIHJldHVybiByZXF1aXJlLnJlc29sdmUoZmlsZSk7XG4gIH07XG4gIGlmICh2ICYmICFjbGllbnRTb3VyY2UpIHtcbiAgICBjbGllbnRTb3VyY2UgPSByZWFkKHJlc29sdmVQYXRoKCAnc29ja2V0LmlvLWNsaWVudC9kaXN0L3NvY2tldC5pby5qcycpLCAndXRmLTgnKTtcbiAgICB0cnkge1xuICAgICAgY2xpZW50U291cmNlTWFwID0gcmVhZChyZXNvbHZlUGF0aCggJ3NvY2tldC5pby1jbGllbnQvZGlzdC9zb2NrZXQuaW8uanMubWFwJyksICd1dGYtOCcpO1xuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICBkZWJ1ZygnY291bGQgbm90IGxvYWQgc291cmNlbWFwIGZpbGUnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE9sZCBzZXR0aW5ncyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAqL1xuXG52YXIgb2xkU2V0dGluZ3MgPSB7XG4gIFwidHJhbnNwb3J0c1wiOiBcInRyYW5zcG9ydHNcIixcbiAgXCJoZWFydGJlYXQgdGltZW91dFwiOiBcInBpbmdUaW1lb3V0XCIsXG4gIFwiaGVhcnRiZWF0IGludGVydmFsXCI6IFwicGluZ0ludGVydmFsXCIsXG4gIFwiZGVzdHJveSBidWZmZXIgc2l6ZVwiOiBcIm1heEh0dHBCdWZmZXJTaXplXCJcbn07XG5cbi8qKlxuICogQmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TZXJ2ZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsKXtcbiAgaWYgKCdhdXRob3JpemF0aW9uJyA9PSBrZXkgJiYgdmFsKSB7XG4gICAgdGhpcy51c2UoZnVuY3Rpb24oc29ja2V0LCBuZXh0KSB7XG4gICAgICB2YWwoc29ja2V0LnJlcXVlc3QsIGZ1bmN0aW9uKGVyciwgYXV0aG9yaXplZCkge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gbmV4dChuZXcgRXJyb3IoZXJyKSk7XG4gICAgICAgIGlmICghYXV0aG9yaXplZCkgcmV0dXJuIG5leHQobmV3IEVycm9yKCdOb3QgYXV0aG9yaXplZCcpKTtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoJ29yaWdpbnMnID09IGtleSAmJiB2YWwpIHtcbiAgICB0aGlzLm9yaWdpbnModmFsKTtcbiAgfSBlbHNlIGlmICgncmVzb3VyY2UnID09IGtleSkge1xuICAgIHRoaXMucGF0aCh2YWwpO1xuICB9IGVsc2UgaWYgKG9sZFNldHRpbmdzW2tleV0gJiYgdGhpcy5laW9bb2xkU2V0dGluZ3Nba2V5XV0pIHtcbiAgICB0aGlzLmVpb1tvbGRTZXR0aW5nc1trZXldXSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKCdPcHRpb24gJXMgaXMgbm90IHZhbGlkLiBQbGVhc2UgcmVmZXIgdG8gdGhlIFJFQURNRS4nLCBrZXkpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBtaWRkbGV3YXJlIGZvciBhbiBpbmNvbWluZyBuYW1lc3BhY2Ugbm90IGFscmVhZHkgY3JlYXRlZCBvbiB0aGUgc2VydmVyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWUgb2YgaW5jb21pbmcgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge09iamVjdH0gcXVlcnkgdGhlIHF1ZXJ5IHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TZXJ2ZXIucHJvdG90eXBlLmNoZWNrTmFtZXNwYWNlID0gZnVuY3Rpb24obmFtZSwgcXVlcnksIGZuKXtcbiAgaWYgKHRoaXMucGFyZW50TnNwcy5zaXplID09PSAwKSByZXR1cm4gZm4oZmFsc2UpO1xuXG4gIGNvbnN0IGtleXNJdGVyYXRvciA9IHRoaXMucGFyZW50TnNwcy5rZXlzKCk7XG5cbiAgY29uc3QgcnVuID0gKCkgPT4ge1xuICAgIGxldCBuZXh0Rm4gPSBrZXlzSXRlcmF0b3IubmV4dCgpO1xuICAgIGlmIChuZXh0Rm4uZG9uZSkge1xuICAgICAgcmV0dXJuIGZuKGZhbHNlKTtcbiAgICB9XG4gICAgbmV4dEZuLnZhbHVlKG5hbWUsIHF1ZXJ5LCAoZXJyLCBhbGxvdykgPT4ge1xuICAgICAgaWYgKGVyciB8fMKgIWFsbG93KSB7XG4gICAgICAgIHJ1bigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4odGhpcy5wYXJlbnROc3BzLmdldChuZXh0Rm4udmFsdWUpLmNyZWF0ZUNoaWxkKG5hbWUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBydW4oKTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY2xpZW50IHNlcnZpbmcgcGF0aC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdiBwYXRobmFtZVxuICogQHJldHVybiB7U2VydmVyfFN0cmluZ30gc2VsZiB3aGVuIHNldHRpbmcgb3IgdmFsdWUgd2hlbiBnZXR0aW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNlcnZlci5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9wYXRoO1xuICB0aGlzLl9wYXRoID0gdi5yZXBsYWNlKC9cXC8kLywgJycpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgYWRhcHRlciBmb3Igcm9vbXMuXG4gKlxuICogQHBhcmFtIHtBZGFwdGVyfSB2IHBhdGhuYW1lXG4gKiBAcmV0dXJuIHtTZXJ2ZXJ8QWRhcHRlcn0gc2VsZiB3aGVuIHNldHRpbmcgb3IgdmFsdWUgd2hlbiBnZXR0aW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNlcnZlci5wcm90b3R5cGUuYWRhcHRlciA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9hZGFwdGVyO1xuICB0aGlzLl9hZGFwdGVyID0gdjtcbiAgZm9yICh2YXIgaSBpbiB0aGlzLm5zcHMpIHtcbiAgICBpZiAodGhpcy5uc3BzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICB0aGlzLm5zcHNbaV0uaW5pdEFkYXB0ZXIoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGFsbG93ZWQgb3JpZ2lucyBmb3IgcmVxdWVzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IHYgb3JpZ2luc1xuICogQHJldHVybiB7U2VydmVyfEFkYXB0ZXJ9IHNlbGYgd2hlbiBzZXR0aW5nIG9yIHZhbHVlIHdoZW4gZ2V0dGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TZXJ2ZXIucHJvdG90eXBlLm9yaWdpbnMgPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fb3JpZ2lucztcblxuICB0aGlzLl9vcmlnaW5zID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEF0dGFjaGVzIHNvY2tldC5pbyB0byBhIHNlcnZlciBvciBwb3J0LlxuICpcbiAqIEBwYXJhbSB7aHR0cC5TZXJ2ZXJ8TnVtYmVyfSBzZXJ2ZXIgb3IgcG9ydFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgcGFzc2VkIHRvIGVuZ2luZS5pb1xuICogQHJldHVybiB7U2VydmVyfSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNlcnZlci5wcm90b3R5cGUubGlzdGVuID1cblNlcnZlci5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24oc3J2LCBvcHRzKXtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHNydikge1xuICAgIHZhciBtc2cgPSAnWW91IGFyZSB0cnlpbmcgdG8gYXR0YWNoIHNvY2tldC5pbyB0byBhbiBleHByZXNzICcgK1xuICAgICdyZXF1ZXN0IGhhbmRsZXIgZnVuY3Rpb24uIFBsZWFzZSBwYXNzIGEgaHR0cC5TZXJ2ZXIgaW5zdGFuY2UuJztcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBhIHBvcnQgYXMgYSBzdHJpbmdcbiAgaWYgKE51bWJlcihzcnYpID09IHNydikge1xuICAgIHNydiA9IE51bWJlcihzcnYpO1xuICB9XG5cbiAgaWYgKCdudW1iZXInID09IHR5cGVvZiBzcnYpIHtcbiAgICBkZWJ1ZygnY3JlYXRpbmcgaHR0cCBzZXJ2ZXIgYW5kIGJpbmRpbmcgdG8gJWQnLCBzcnYpO1xuICAgIHZhciBwb3J0ID0gc3J2O1xuICAgIHNydiA9IGh0dHAuU2VydmVyKGZ1bmN0aW9uKHJlcSwgcmVzKXtcbiAgICAgIHJlcy53cml0ZUhlYWQoNDA0KTtcbiAgICAgIHJlcy5lbmQoKTtcbiAgICB9KTtcbiAgICBzcnYubGlzdGVuKHBvcnQpO1xuXG4gIH1cblxuICAvLyBzZXQgZW5naW5lLmlvIHBhdGggdG8gYC9zb2NrZXQuaW9gXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBvcHRzLnBhdGggPSBvcHRzLnBhdGggfHwgdGhpcy5wYXRoKCk7XG4gIC8vIHNldCBvcmlnaW5zIHZlcmlmaWNhdGlvblxuICBvcHRzLmFsbG93UmVxdWVzdCA9IG9wdHMuYWxsb3dSZXF1ZXN0IHx8IHRoaXMuY2hlY2tSZXF1ZXN0LmJpbmQodGhpcyk7XG5cbiAgaWYgKHRoaXMuc29ja2V0cy5mbnMubGVuZ3RoID4gMCkge1xuICAgIHRoaXMuaW5pdEVuZ2luZShzcnYsIG9wdHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY29ubmVjdFBhY2tldCA9IHsgdHlwZTogcGFyc2VyLkNPTk5FQ1QsIG5zcDogJy8nIH07XG4gIHRoaXMuZW5jb2Rlci5lbmNvZGUoY29ubmVjdFBhY2tldCwgZnVuY3Rpb24gKGVuY29kZWRQYWNrZXQpe1xuICAgIC8vIHRoZSBDT05ORUNUIHBhY2tldCB3aWxsIGJlIG1lcmdlZCB3aXRoIEVuZ2luZS5JTyBoYW5kc2hha2UsXG4gICAgLy8gdG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygcm91bmQgdHJpcHNcbiAgICBvcHRzLmluaXRpYWxQYWNrZXQgPSBlbmNvZGVkUGFja2V0O1xuXG4gICAgc2VsZi5pbml0RW5naW5lKHNydiwgb3B0cyk7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBlbmdpbmVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBwYXNzZWQgdG8gZW5naW5lLmlvXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TZXJ2ZXIucHJvdG90eXBlLmluaXRFbmdpbmUgPSBmdW5jdGlvbihzcnYsIG9wdHMpe1xuICAvLyBpbml0aWFsaXplIGVuZ2luZVxuICBkZWJ1ZygnY3JlYXRpbmcgZW5naW5lLmlvIGluc3RhbmNlIHdpdGggb3B0cyAlaicsIG9wdHMpO1xuICB0aGlzLmVpbyA9IGVuZ2luZS5hdHRhY2goc3J2LCBvcHRzKTtcblxuICAvLyBhdHRhY2ggc3RhdGljIGZpbGUgc2VydmluZ1xuICBpZiAodGhpcy5fc2VydmVDbGllbnQpIHRoaXMuYXR0YWNoU2VydmUoc3J2KTtcblxuICAvLyBFeHBvcnQgaHR0cCBzZXJ2ZXJcbiAgdGhpcy5odHRwU2VydmVyID0gc3J2O1xuXG4gIC8vIGJpbmQgdG8gZW5naW5lIGV2ZW50c1xuICB0aGlzLmJpbmQodGhpcy5laW8pO1xufTtcblxuLyoqXG4gKiBBdHRhY2hlcyB0aGUgc3RhdGljIGZpbGUgc2VydmluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufGh0dHAuU2VydmVyfSBzcnYgaHR0cCBzZXJ2ZXJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNlcnZlci5wcm90b3R5cGUuYXR0YWNoU2VydmUgPSBmdW5jdGlvbihzcnYpe1xuICBkZWJ1ZygnYXR0YWNoaW5nIGNsaWVudCBzZXJ2aW5nIHJlcSBoYW5kbGVyJyk7XG4gIHZhciB1cmwgPSB0aGlzLl9wYXRoICsgJy9zb2NrZXQuaW8uanMnO1xuICB2YXIgdXJsTWFwID0gdGhpcy5fcGF0aCArICcvc29ja2V0LmlvLmpzLm1hcCc7XG4gIHZhciBldnMgPSBzcnYubGlzdGVuZXJzKCdyZXF1ZXN0Jykuc2xpY2UoMCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3J2LnJlbW92ZUFsbExpc3RlbmVycygncmVxdWVzdCcpO1xuICBzcnYub24oJ3JlcXVlc3QnLCBmdW5jdGlvbihyZXEsIHJlcykge1xuICAgIGlmICgwID09PSByZXEudXJsLmluZGV4T2YodXJsTWFwKSkge1xuICAgICAgc2VsZi5zZXJ2ZU1hcChyZXEsIHJlcyk7XG4gICAgfSBlbHNlIGlmICgwID09PSByZXEudXJsLmluZGV4T2YodXJsKSkge1xuICAgICAgc2VsZi5zZXJ2ZShyZXEsIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGV2c1tpXS5jYWxsKHNydiwgcmVxLCByZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgYSByZXF1ZXN0IHNlcnZpbmcgYC9zb2NrZXQuaW8uanNgXG4gKlxuICogQHBhcmFtIHtodHRwLlJlcXVlc3R9IHJlcVxuICogQHBhcmFtIHtodHRwLlJlc3BvbnNlfSByZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNlcnZlci5wcm90b3R5cGUuc2VydmUgPSBmdW5jdGlvbihyZXEsIHJlcyl7XG4gIC8vIFBlciB0aGUgc3RhbmRhcmQsIEVUYWdzIG11c3QgYmUgcXVvdGVkOlxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMiNzZWN0aW9uLTIuM1xuICB2YXIgZXhwZWN0ZWRFdGFnID0gJ1wiJyArIGNsaWVudFZlcnNpb24gKyAnXCInO1xuXG4gIHZhciBldGFnID0gcmVxLmhlYWRlcnNbJ2lmLW5vbmUtbWF0Y2gnXTtcbiAgaWYgKGV0YWcpIHtcbiAgICBpZiAoZXhwZWN0ZWRFdGFnID09IGV0YWcpIHtcbiAgICAgIGRlYnVnKCdzZXJ2ZSBjbGllbnQgMzA0Jyk7XG4gICAgICByZXMud3JpdGVIZWFkKDMwNCk7XG4gICAgICByZXMuZW5kKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgZGVidWcoJ3NlcnZlIGNsaWVudCBzb3VyY2UnKTtcbiAgcmVzLnNldEhlYWRlcihcIkNhY2hlLUNvbnRyb2xcIiwgXCJwdWJsaWMsIG1heC1hZ2U9MFwiKTtcbiAgcmVzLnNldEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnKTtcbiAgcmVzLnNldEhlYWRlcignRVRhZycsIGV4cGVjdGVkRXRhZyk7XG4gIHJlcy53cml0ZUhlYWQoMjAwKTtcbiAgcmVzLmVuZChjbGllbnRTb3VyY2UpO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIGEgcmVxdWVzdCBzZXJ2aW5nIGAvc29ja2V0LmlvLmpzLm1hcGBcbiAqXG4gKiBAcGFyYW0ge2h0dHAuUmVxdWVzdH0gcmVxXG4gKiBAcGFyYW0ge2h0dHAuUmVzcG9uc2V9IHJlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2VydmVyLnByb3RvdHlwZS5zZXJ2ZU1hcCA9IGZ1bmN0aW9uKHJlcSwgcmVzKXtcbiAgLy8gUGVyIHRoZSBzdGFuZGFyZCwgRVRhZ3MgbXVzdCBiZSBxdW90ZWQ6XG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMyI3NlY3Rpb24tMi4zXG4gIHZhciBleHBlY3RlZEV0YWcgPSAnXCInICsgY2xpZW50VmVyc2lvbiArICdcIic7XG5cbiAgdmFyIGV0YWcgPSByZXEuaGVhZGVyc1snaWYtbm9uZS1tYXRjaCddO1xuICBpZiAoZXRhZykge1xuICAgIGlmIChleHBlY3RlZEV0YWcgPT0gZXRhZykge1xuICAgICAgZGVidWcoJ3NlcnZlIGNsaWVudCAzMDQnKTtcbiAgICAgIHJlcy53cml0ZUhlYWQoMzA0KTtcbiAgICAgIHJlcy5lbmQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBkZWJ1Zygnc2VydmUgY2xpZW50IHNvdXJjZW1hcCcpO1xuICByZXMuc2V0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICByZXMuc2V0SGVhZGVyKCdFVGFnJywgZXhwZWN0ZWRFdGFnKTtcbiAgcmVzLndyaXRlSGVhZCgyMDApO1xuICByZXMuZW5kKGNsaWVudFNvdXJjZU1hcCk7XG59O1xuXG4vKipcbiAqIEJpbmRzIHNvY2tldC5pbyB0byBhbiBlbmdpbmUuaW8gaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtlbmdpbmUuU2VydmVyfSBlbmdpbmUgZW5naW5lLmlvIChvciBjb21wYXRpYmxlKSBzZXJ2ZXJcbiAqIEByZXR1cm4ge1NlcnZlcn0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TZXJ2ZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihlbmdpbmUpe1xuICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgdGhpcy5lbmdpbmUub24oJ2Nvbm5lY3Rpb24nLCB0aGlzLm9uY29ubmVjdGlvbi5iaW5kKHRoaXMpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGVhY2ggaW5jb21pbmcgdHJhbnNwb3J0IGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtlbmdpbmUuU29ja2V0fSBjb25uXG4gKiBAcmV0dXJuIHtTZXJ2ZXJ9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2VydmVyLnByb3RvdHlwZS5vbmNvbm5lY3Rpb24gPSBmdW5jdGlvbihjb25uKXtcbiAgZGVidWcoJ2luY29taW5nIGNvbm5lY3Rpb24gd2l0aCBpZCAlcycsIGNvbm4uaWQpO1xuICB2YXIgY2xpZW50ID0gbmV3IENsaWVudCh0aGlzLCBjb25uKTtcbiAgY2xpZW50LmNvbm5lY3QoJy8nKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIExvb2tzIHVwIGEgbmFtZXNwYWNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cHxGdW5jdGlvbn0gbmFtZSBuc3AgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXSBvcHRpb25hbCwgbnNwIGBjb25uZWN0aW9uYCBldiBoYW5kbGVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNlcnZlci5wcm90b3R5cGUub2YgPSBmdW5jdGlvbihuYW1lLCBmbil7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ2Z1bmN0aW9uJyB8fMKgbmFtZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIGNvbnN0IHBhcmVudE5zcCA9IG5ldyBQYXJlbnROYW1lc3BhY2UodGhpcyk7XG4gICAgZGVidWcoJ2luaXRpYWxpemluZyBwYXJlbnQgbmFtZXNwYWNlICVzJywgcGFyZW50TnNwLm5hbWUpO1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5wYXJlbnROc3BzLnNldChuYW1lLCBwYXJlbnROc3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhcmVudE5zcHMuc2V0KChuc3AsIGNvbm4sIG5leHQpID0+IG5leHQobnVsbCwgbmFtZS50ZXN0KG5zcCkpLCBwYXJlbnROc3ApO1xuICAgIH1cbiAgICBpZiAoZm4pIHBhcmVudE5zcC5vbignY29ubmVjdCcsIGZuKTtcbiAgICByZXR1cm4gcGFyZW50TnNwO1xuICB9XG5cbiAgaWYgKFN0cmluZyhuYW1lKVswXSAhPT0gJy8nKSBuYW1lID0gJy8nICsgbmFtZTtcblxuICB2YXIgbnNwID0gdGhpcy5uc3BzW25hbWVdO1xuICBpZiAoIW5zcCkge1xuICAgIGRlYnVnKCdpbml0aWFsaXppbmcgbmFtZXNwYWNlICVzJywgbmFtZSk7XG4gICAgbnNwID0gbmV3IE5hbWVzcGFjZSh0aGlzLCBuYW1lKTtcbiAgICB0aGlzLm5zcHNbbmFtZV0gPSBuc3A7XG4gIH1cbiAgaWYgKGZuKSBuc3Aub24oJ2Nvbm5lY3QnLCBmbik7XG4gIHJldHVybiBuc3A7XG59O1xuXG4vKipcbiAqIENsb3NlcyBzZXJ2ZXIgY29ubmVjdGlvblxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl0gb3B0aW9uYWwsIGNhbGxlZCBhcyBgZm4oW2Vycl0pYCBvbiBlcnJvciBPUiBhbGwgY29ubnMgY2xvc2VkXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNlcnZlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihmbil7XG4gIGZvciAodmFyIGlkIGluIHRoaXMubnNwc1snLyddLnNvY2tldHMpIHtcbiAgICBpZiAodGhpcy5uc3BzWycvJ10uc29ja2V0cy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIHRoaXMubnNwc1snLyddLnNvY2tldHNbaWRdLm9uY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVuZ2luZS5jbG9zZSgpO1xuXG4gIGlmICh0aGlzLmh0dHBTZXJ2ZXIpIHtcbiAgICB0aGlzLmh0dHBTZXJ2ZXIuY2xvc2UoZm4pO1xuICB9IGVsc2Uge1xuICAgIGZuICYmIGZuKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRXhwb3NlIG1haW4gbmFtZXNwYWNlICgvKS5cbiAqL1xuXG52YXIgZW1pdHRlck1ldGhvZHMgPSBPYmplY3Qua2V5cyhFbWl0dGVyLnByb3RvdHlwZSkuZmlsdGVyKGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiB0eXBlb2YgRW1pdHRlci5wcm90b3R5cGVba2V5XSA9PT0gJ2Z1bmN0aW9uJztcbn0pO1xuXG5lbWl0dGVyTWV0aG9kcy5jb25jYXQoWyd0bycsICdpbicsICd1c2UnLCAnc2VuZCcsICd3cml0ZScsICdjbGllbnRzJywgJ2NvbXByZXNzJywgJ2JpbmFyeSddKS5mb3JFYWNoKGZ1bmN0aW9uKGZuKXtcbiAgU2VydmVyLnByb3RvdHlwZVtmbl0gPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLnNvY2tldHNbZm5dLmFwcGx5KHRoaXMuc29ja2V0cywgYXJndW1lbnRzKTtcbiAgfTtcbn0pO1xuXG5OYW1lc3BhY2UuZmxhZ3MuZm9yRWFjaChmdW5jdGlvbihmbGFnKXtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZlci5wcm90b3R5cGUsIGZsYWcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zb2NrZXRzLmZsYWdzID0gdGhpcy5zb2NrZXRzLmZsYWdzIHx8IHt9O1xuICAgICAgdGhpcy5zb2NrZXRzLmZsYWdzW2ZsYWddID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG59KTtcblxuLyoqXG4gKiBCQyB3aXRoIGBpby5saXN0ZW5gXG4gKi9cblxuU2VydmVyLmxpc3RlbiA9IFNlcnZlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5cbi8qKlxuICogSW52b2tpbmcgdGhlIGxpYnJhcnkgYXMgYSBmdW5jdGlvbiBkZWxlZ2F0ZXMgdG8gYXR0YWNoIGlmIHRoZSBmaXJzdCBhcmd1bWVudFxuICogaXMgYW4gYGh0dHAuU2VydmVyYC5cbiAqXG4gKiBJZiB0aGVyZSBhcmUgbm8gYXJndW1lbnRzIG9yIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBvcHRpb25zIG9iamVjdCwgdGhlblxuICogYSBuZXcgU2VydmVyIGluc3RhbmNlIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB7aHR0cC5TZXJ2ZXJ9IHNlcnZlciAoaWYgc3BlY2lmaWVkLCB3aWxsIGJlIGF0dGFjaGVkIHRvIGJ5IHRoZSBuZXcgU2VydmVyIGluc3RhbmNlKVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1NlcnZlcn0gZW5naW5lIHNlcnZlclxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGJhY2t3YXJkcyBjb21wYXRpYmxlIHVzZSBhcyBgLmF0dGFjaGBcbiAgLy8gaWYgZmlyc3QgYXJndW1lbnQgaXMgYW4gaHR0cCBzZXJ2ZXJcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgaHR0cC5TZXJ2ZXIpIHtcbiAgICByZXR1cm4gYXR0YWNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAvLyBpZiBmaXJzdCBhcmd1bWVudCBpcyBub3QgYW4gaHR0cCBzZXJ2ZXIsIHRoZW4ganVzdCBtYWtlIGEgcmVndWxhciBlaW8gc2VydmVyXG4gIHJldHVybiBleHBvcnRzLlNlcnZlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBQcm90b2NvbCByZXZpc2lvbiBudW1iZXIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gMTtcblxuLyoqXG4gKiBFeHBvc2UgU2VydmVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5TZXJ2ZXIgPSByZXF1aXJlKCcuL3NlcnZlcicpO1xuXG4vKipcbiAqIEV4cG9zZSBTb2NrZXQgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLlNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG5cbi8qKlxuICogRXhwb3NlIFRyYW5zcG9ydCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQnKTtcblxuLyoqXG4gKiBFeHBvc2UgbXV0YWJsZSBsaXN0IG9mIGF2YWlsYWJsZSB0cmFuc3BvcnRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy50cmFuc3BvcnRzID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzJyk7XG5cbi8qKlxuICogRXhwb3J0cyBwYXJzZXIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGh0dHAuU2VydmVyIGV4Y2x1c2l2ZWx5IHVzZWQgZm9yIFdTIHVwZ3JhZGVzLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBwb3J0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1NlcnZlcn0gd2Vic29ja2V0LmlvIHNlcnZlclxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmxpc3RlbiA9IGxpc3RlbjtcblxuZnVuY3Rpb24gbGlzdGVuIChwb3J0LCBvcHRpb25zLCBmbikge1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICBmbiA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIHNlcnZlciA9IGh0dHAuY3JlYXRlU2VydmVyKGZ1bmN0aW9uIChyZXEsIHJlcykge1xuICAgIHJlcy53cml0ZUhlYWQoNTAxKTtcbiAgICByZXMuZW5kKCdOb3QgSW1wbGVtZW50ZWQnKTtcbiAgfSk7XG5cbiAgLy8gY3JlYXRlIGVuZ2luZSBzZXJ2ZXJcbiAgdmFyIGVuZ2luZSA9IGV4cG9ydHMuYXR0YWNoKHNlcnZlciwgb3B0aW9ucyk7XG4gIGVuZ2luZS5odHRwU2VydmVyID0gc2VydmVyO1xuXG4gIHNlcnZlci5saXN0ZW4ocG9ydCwgZm4pO1xuXG4gIHJldHVybiBlbmdpbmU7XG59XG5cbi8qKlxuICogQ2FwdHVyZXMgdXBncmFkZSByZXF1ZXN0cyBmb3IgYSBodHRwLlNlcnZlci5cbiAqXG4gKiBAcGFyYW0ge2h0dHAuU2VydmVyfSBzZXJ2ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTZXJ2ZXJ9IGVuZ2luZSBzZXJ2ZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5hdHRhY2ggPSBhdHRhY2g7XG5cbmZ1bmN0aW9uIGF0dGFjaCAoc2VydmVyLCBvcHRpb25zKSB7XG4gIHZhciBlbmdpbmUgPSBuZXcgZXhwb3J0cy5TZXJ2ZXIob3B0aW9ucyk7XG4gIGVuZ2luZS5hdHRhY2goc2VydmVyLCBvcHRpb25zKTtcbiAgcmV0dXJuIGVuZ2luZTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9saWIvZW5naW5lLmlvLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJ3VybCcpLnBhcnNlO1xudmFyIGJhc2U2NGlkID0gcmVxdWlyZSgnYmFzZTY0aWQnKTtcbnZhciB0cmFuc3BvcnRzID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIFNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZScpO1xudmFyIGNvb2tpZU1vZCA9IHJlcXVpcmUoJ2Nvb2tpZScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU2VydmVyO1xuXG4vKipcbiAqIFNlcnZlciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTZXJ2ZXIgKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNlcnZlcikpIHtcbiAgICByZXR1cm4gbmV3IFNlcnZlcihvcHRzKTtcbiAgfVxuXG4gIHRoaXMuY2xpZW50cyA9IHt9O1xuICB0aGlzLmNsaWVudHNDb3VudCA9IDA7XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdGhpcy53c0VuZ2luZSA9IG9wdHMud3NFbmdpbmUgfHwgcHJvY2Vzcy5lbnYuRUlPX1dTX0VOR0lORSB8fCAnd3MnO1xuICB0aGlzLnBpbmdUaW1lb3V0ID0gb3B0cy5waW5nVGltZW91dCB8fCA1MDAwO1xuICB0aGlzLnBpbmdJbnRlcnZhbCA9IG9wdHMucGluZ0ludGVydmFsIHx8IDI1MDAwO1xuICB0aGlzLnVwZ3JhZGVUaW1lb3V0ID0gb3B0cy51cGdyYWRlVGltZW91dCB8fCAxMDAwMDtcbiAgdGhpcy5tYXhIdHRwQnVmZmVyU2l6ZSA9IG9wdHMubWF4SHR0cEJ1ZmZlclNpemUgfHwgMTBFNztcbiAgdGhpcy50cmFuc3BvcnRzID0gb3B0cy50cmFuc3BvcnRzIHx8IE9iamVjdC5rZXlzKHRyYW5zcG9ydHMpO1xuICB0aGlzLmFsbG93VXBncmFkZXMgPSBmYWxzZSAhPT0gb3B0cy5hbGxvd1VwZ3JhZGVzO1xuICB0aGlzLmFsbG93UmVxdWVzdCA9IG9wdHMuYWxsb3dSZXF1ZXN0O1xuICB0aGlzLmNvb2tpZSA9IGZhbHNlICE9PSBvcHRzLmNvb2tpZSA/IChvcHRzLmNvb2tpZSB8fCAnaW8nKSA6IGZhbHNlO1xuICB0aGlzLmNvb2tpZVBhdGggPSBmYWxzZSAhPT0gb3B0cy5jb29raWVQYXRoID8gKG9wdHMuY29va2llUGF0aCB8fCAnLycpIDogZmFsc2U7XG4gIHRoaXMuY29va2llSHR0cE9ubHkgPSBmYWxzZSAhPT0gb3B0cy5jb29raWVIdHRwT25seTtcbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IGZhbHNlICE9PSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlID8gKG9wdHMucGVyTWVzc2FnZURlZmxhdGUgfHwgdHJ1ZSkgOiBmYWxzZTtcbiAgdGhpcy5odHRwQ29tcHJlc3Npb24gPSBmYWxzZSAhPT0gb3B0cy5odHRwQ29tcHJlc3Npb24gPyAob3B0cy5odHRwQ29tcHJlc3Npb24gfHwge30pIDogZmFsc2U7XG4gIHRoaXMuaW5pdGlhbFBhY2tldCA9IG9wdHMuaW5pdGlhbFBhY2tldDtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gaW5pdGlhbGl6ZSBjb21wcmVzc2lvbiBvcHRpb25zXG4gIFsncGVyTWVzc2FnZURlZmxhdGUnLCAnaHR0cENvbXByZXNzaW9uJ10uZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciBjb21wcmVzc2lvbiA9IHNlbGZbdHlwZV07XG4gICAgaWYgKHRydWUgPT09IGNvbXByZXNzaW9uKSBzZWxmW3R5cGVdID0gY29tcHJlc3Npb24gPSB7fTtcbiAgICBpZiAoY29tcHJlc3Npb24gJiYgbnVsbCA9PSBjb21wcmVzc2lvbi50aHJlc2hvbGQpIHtcbiAgICAgIGNvbXByZXNzaW9uLnRocmVzaG9sZCA9IDEwMjQ7XG4gICAgfVxuICB9KTtcblxuICB0aGlzLmluaXQoKTtcbn1cblxuLyoqXG4gKiBQcm90b2NvbCBlcnJvcnMgbWFwcGluZ3MuXG4gKi9cblxuU2VydmVyLmVycm9ycyA9IHtcbiAgVU5LTk9XTl9UUkFOU1BPUlQ6IDAsXG4gIFVOS05PV05fU0lEOiAxLFxuICBCQURfSEFORFNIQUtFX01FVEhPRDogMixcbiAgQkFEX1JFUVVFU1Q6IDMsXG4gIEZPUkJJRERFTjogNFxufTtcblxuU2VydmVyLmVycm9yTWVzc2FnZXMgPSB7XG4gIDA6ICdUcmFuc3BvcnQgdW5rbm93bicsXG4gIDE6ICdTZXNzaW9uIElEIHVua25vd24nLFxuICAyOiAnQmFkIGhhbmRzaGFrZSBtZXRob2QnLFxuICAzOiAnQmFkIHJlcXVlc3QnLFxuICA0OiAnRm9yYmlkZGVuJ1xufTtcblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIEV2ZW50RW1pdHRlci5cbiAqL1xuXG51dGlsLmluaGVyaXRzKFNlcnZlciwgRXZlbnRFbWl0dGVyKTtcblxuLyoqXG4gKiBJbml0aWFsaXplIHdlYnNvY2tldCBzZXJ2ZXJcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TZXJ2ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghfnRoaXMudHJhbnNwb3J0cy5pbmRleE9mKCd3ZWJzb2NrZXQnKSkgcmV0dXJuO1xuXG4gIGlmICh0aGlzLndzKSB0aGlzLndzLmNsb3NlKCk7XG5cbiAgdmFyIHdzTW9kdWxlO1xuICBzd2l0Y2ggKHRoaXMud3NFbmdpbmUpIHtcbiAgICBjYXNlICd1d3MnOiB3c01vZHVsZSA9IHJlcXVpcmUoJ3V3cycpOyBicmVhaztcbiAgICBjYXNlICd3cyc6IHdzTW9kdWxlID0gcmVxdWlyZSgnd3MnKTsgYnJlYWs7XG4gICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHdzRW5naW5lJyk7XG4gIH1cbiAgdGhpcy53cyA9IG5ldyB3c01vZHVsZS5TZXJ2ZXIoe1xuICAgIG5vU2VydmVyOiB0cnVlLFxuICAgIGNsaWVudFRyYWNraW5nOiBmYWxzZSxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSxcbiAgICBtYXhQYXlsb2FkOiB0aGlzLm1heEh0dHBCdWZmZXJTaXplXG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBhdmFpbGFibGUgdHJhbnNwb3J0cyBmb3IgdXBncmFkZSBnaXZlbiBhIGNlcnRhaW4gdHJhbnNwb3J0LlxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TZXJ2ZXIucHJvdG90eXBlLnVwZ3JhZGVzID0gZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICBpZiAoIXRoaXMuYWxsb3dVcGdyYWRlcykgcmV0dXJuIFtdO1xuICByZXR1cm4gdHJhbnNwb3J0c1t0cmFuc3BvcnRdLnVwZ3JhZGVzVG8gfHwgW107XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIGEgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfVxuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciB0aGUgcmVxdWVzdCBpcyB2YWxpZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2VydmVyLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiAocmVxLCB1cGdyYWRlLCBmbikge1xuICAvLyB0cmFuc3BvcnQgY2hlY2tcbiAgdmFyIHRyYW5zcG9ydCA9IHJlcS5fcXVlcnkudHJhbnNwb3J0O1xuICBpZiAoIX50aGlzLnRyYW5zcG9ydHMuaW5kZXhPZih0cmFuc3BvcnQpKSB7XG4gICAgZGVidWcoJ3Vua25vd24gdHJhbnNwb3J0IFwiJXNcIicsIHRyYW5zcG9ydCk7XG4gICAgcmV0dXJuIGZuKFNlcnZlci5lcnJvcnMuVU5LTk9XTl9UUkFOU1BPUlQsIGZhbHNlKTtcbiAgfVxuXG4gIC8vICdPcmlnaW4nIGhlYWRlciBjaGVja1xuICB2YXIgaXNPcmlnaW5JbnZhbGlkID0gY2hlY2tJbnZhbGlkSGVhZGVyQ2hhcihyZXEuaGVhZGVycy5vcmlnaW4pO1xuICBpZiAoaXNPcmlnaW5JbnZhbGlkKSB7XG4gICAgcmVxLmhlYWRlcnMub3JpZ2luID0gbnVsbDtcbiAgICByZXR1cm4gZm4oU2VydmVyLmVycm9ycy5CQURfUkVRVUVTVCwgZmFsc2UpO1xuICB9XG5cbiAgLy8gc2lkIGNoZWNrXG4gIHZhciBzaWQgPSByZXEuX3F1ZXJ5LnNpZDtcbiAgaWYgKHNpZCkge1xuICAgIGlmICghdGhpcy5jbGllbnRzLmhhc093blByb3BlcnR5KHNpZCkpIHtcbiAgICAgIHJldHVybiBmbihTZXJ2ZXIuZXJyb3JzLlVOS05PV05fU0lELCBmYWxzZSk7XG4gICAgfVxuICAgIGlmICghdXBncmFkZSAmJiB0aGlzLmNsaWVudHNbc2lkXS50cmFuc3BvcnQubmFtZSAhPT0gdHJhbnNwb3J0KSB7XG4gICAgICBkZWJ1ZygnYmFkIHJlcXVlc3Q6IHVuZXhwZWN0ZWQgdHJhbnNwb3J0IHdpdGhvdXQgdXBncmFkZScpO1xuICAgICAgcmV0dXJuIGZuKFNlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1QsIGZhbHNlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gaGFuZHNoYWtlIGlzIEdFVCBvbmx5XG4gICAgaWYgKCdHRVQnICE9PSByZXEubWV0aG9kKSByZXR1cm4gZm4oU2VydmVyLmVycm9ycy5CQURfSEFORFNIQUtFX01FVEhPRCwgZmFsc2UpO1xuICAgIGlmICghdGhpcy5hbGxvd1JlcXVlc3QpIHJldHVybiBmbihudWxsLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5hbGxvd1JlcXVlc3QocmVxLCBmbik7XG4gIH1cblxuICBmbihudWxsLCB0cnVlKTtcbn07XG5cbi8qKlxuICogUHJlcGFyZXMgYSByZXF1ZXN0IGJ5IHByb2Nlc3NpbmcgdGhlIHF1ZXJ5IHN0cmluZy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TZXJ2ZXIucHJvdG90eXBlLnByZXBhcmUgPSBmdW5jdGlvbiAocmVxKSB7XG4gIC8vIHRyeSB0byBsZXZlcmFnZSBwcmUtZXhpc3RpbmcgYHJlcS5fcXVlcnlgIChlLmc6IGZyb20gY29ubmVjdClcbiAgaWYgKCFyZXEuX3F1ZXJ5KSB7XG4gICAgcmVxLl9xdWVyeSA9IH5yZXEudXJsLmluZGV4T2YoJz8nKSA/IHFzLnBhcnNlKHBhcnNlKHJlcS51cmwpLnF1ZXJ5KSA6IHt9O1xuICB9XG59O1xuXG4vKipcbiAqIENsb3NlcyBhbGwgY2xpZW50cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNlcnZlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjbG9zaW5nIGFsbCBvcGVuIGNsaWVudHMnKTtcbiAgZm9yICh2YXIgaSBpbiB0aGlzLmNsaWVudHMpIHtcbiAgICBpZiAodGhpcy5jbGllbnRzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICB0aGlzLmNsaWVudHNbaV0uY2xvc2UodHJ1ZSk7XG4gICAgfVxuICB9XG4gIGlmICh0aGlzLndzKSB7XG4gICAgZGVidWcoJ2Nsb3Npbmcgd2ViU29ja2V0U2VydmVyJyk7XG4gICAgdGhpcy53cy5jbG9zZSgpO1xuICAgIC8vIGRvbid0IGRlbGV0ZSB0aGlzLndzIGJlY2F1c2UgaXQgY2FuIGJlIHVzZWQgYWdhaW4gaWYgdGhlIGh0dHAgc2VydmVyIHN0YXJ0cyBsaXN0ZW5pbmcgYWdhaW5cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSGFuZGxlcyBhbiBFbmdpbmUuSU8gSFRUUCByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcXVlc3RcbiAqIEBwYXJhbSB7aHR0cC5TZXJ2ZXJSZXNwb25zZXxodHRwLk91dGdvaW5nTWVzc2FnZX0gcmVzcG9uc2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2VydmVyLnByb3RvdHlwZS5oYW5kbGVSZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7XG4gIGRlYnVnKCdoYW5kbGluZyBcIiVzXCIgaHR0cCByZXF1ZXN0IFwiJXNcIicsIHJlcS5tZXRob2QsIHJlcS51cmwpO1xuICB0aGlzLnByZXBhcmUocmVxKTtcbiAgcmVxLnJlcyA9IHJlcztcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMudmVyaWZ5KHJlcSwgZmFsc2UsIGZ1bmN0aW9uIChlcnIsIHN1Y2Nlc3MpIHtcbiAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgIHNlbmRFcnJvck1lc3NhZ2UocmVxLCByZXMsIGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHJlcS5fcXVlcnkuc2lkKSB7XG4gICAgICBkZWJ1Zygnc2V0dGluZyBuZXcgcmVxdWVzdCBmb3IgZXhpc3RpbmcgY2xpZW50Jyk7XG4gICAgICBzZWxmLmNsaWVudHNbcmVxLl9xdWVyeS5zaWRdLnRyYW5zcG9ydC5vblJlcXVlc3QocmVxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5oYW5kc2hha2UocmVxLl9xdWVyeS50cmFuc3BvcnQsIHJlcSk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogU2VuZHMgYW4gRW5naW5lLklPIEVycm9yIE1lc3NhZ2VcbiAqXG4gKiBAcGFyYW0ge2h0dHAuU2VydmVyUmVzcG9uc2V9IHJlc3BvbnNlXG4gKiBAcGFyYW0ge2NvZGV9IGVycm9yIGNvZGVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbmRFcnJvck1lc3NhZ2UgKHJlcSwgcmVzLCBjb2RlKSB7XG4gIHZhciBoZWFkZXJzID0geyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH07XG5cbiAgdmFyIGlzRm9yYmlkZGVuID0gIVNlcnZlci5lcnJvck1lc3NhZ2VzLmhhc093blByb3BlcnR5KGNvZGUpO1xuICBpZiAoaXNGb3JiaWRkZW4pIHtcbiAgICByZXMud3JpdGVIZWFkKDQwMywgaGVhZGVycyk7XG4gICAgcmVzLmVuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICBjb2RlOiBTZXJ2ZXIuZXJyb3JzLkZPUkJJRERFTixcbiAgICAgIG1lc3NhZ2U6IGNvZGUgfHwgU2VydmVyLmVycm9yTWVzc2FnZXNbU2VydmVyLmVycm9ycy5GT1JCSURERU5dXG4gICAgfSkpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocmVxLmhlYWRlcnMub3JpZ2luKSB7XG4gICAgaGVhZGVyc1snQWNjZXNzLUNvbnRyb2wtQWxsb3ctQ3JlZGVudGlhbHMnXSA9ICd0cnVlJztcbiAgICBoZWFkZXJzWydBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4nXSA9IHJlcS5oZWFkZXJzLm9yaWdpbjtcbiAgfSBlbHNlIHtcbiAgICBoZWFkZXJzWydBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4nXSA9ICcqJztcbiAgfVxuICBpZiAocmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXMud3JpdGVIZWFkKDQwMCwgaGVhZGVycyk7XG4gICAgcmVzLmVuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICBjb2RlOiBjb2RlLFxuICAgICAgbWVzc2FnZTogU2VydmVyLmVycm9yTWVzc2FnZXNbY29kZV1cbiAgICB9KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBnZW5lcmF0ZSBhIHNvY2tldCBpZC5cbiAqIE92ZXJ3cml0ZSB0aGlzIG1ldGhvZCB0byBnZW5lcmF0ZSB5b3VyIGN1c3RvbSBzb2NrZXQgaWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdCBvYmplY3RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2VydmVyLnByb3RvdHlwZS5nZW5lcmF0ZUlkID0gZnVuY3Rpb24gKHJlcSkge1xuICByZXR1cm4gYmFzZTY0aWQuZ2VuZXJhdGVJZCgpO1xufTtcblxuLyoqXG4gKiBIYW5kc2hha2VzIGEgbmV3IGNsaWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0IG9iamVjdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2VydmVyLnByb3RvdHlwZS5oYW5kc2hha2UgPSBmdW5jdGlvbiAodHJhbnNwb3J0TmFtZSwgcmVxKSB7XG4gIHZhciBpZCA9IHRoaXMuZ2VuZXJhdGVJZChyZXEpO1xuXG4gIGRlYnVnKCdoYW5kc2hha2luZyBjbGllbnQgXCIlc1wiJywgaWQpO1xuXG4gIHRyeSB7XG4gICAgdmFyIHRyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRzW3RyYW5zcG9ydE5hbWVdKHJlcSk7XG4gICAgaWYgKCdwb2xsaW5nJyA9PT0gdHJhbnNwb3J0TmFtZSkge1xuICAgICAgdHJhbnNwb3J0Lm1heEh0dHBCdWZmZXJTaXplID0gdGhpcy5tYXhIdHRwQnVmZmVyU2l6ZTtcbiAgICAgIHRyYW5zcG9ydC5odHRwQ29tcHJlc3Npb24gPSB0aGlzLmh0dHBDb21wcmVzc2lvbjtcbiAgICB9IGVsc2UgaWYgKCd3ZWJzb2NrZXQnID09PSB0cmFuc3BvcnROYW1lKSB7XG4gICAgICB0cmFuc3BvcnQucGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlO1xuICAgIH1cblxuICAgIGlmIChyZXEuX3F1ZXJ5ICYmIHJlcS5fcXVlcnkuYjY0KSB7XG4gICAgICB0cmFuc3BvcnQuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNwb3J0LnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzZW5kRXJyb3JNZXNzYWdlKHJlcSwgcmVxLnJlcywgU2VydmVyLmVycm9ycy5CQURfUkVRVUVTVCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBzb2NrZXQgPSBuZXcgU29ja2V0KGlkLCB0aGlzLCB0cmFuc3BvcnQsIHJlcSk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoZmFsc2UgIT09IHRoaXMuY29va2llKSB7XG4gICAgdHJhbnNwb3J0Lm9uKCdoZWFkZXJzJywgZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnNbJ1NldC1Db29raWUnXSA9IGNvb2tpZU1vZC5zZXJpYWxpemUoc2VsZi5jb29raWUsIGlkLFxuICAgICAgICB7XG4gICAgICAgICAgcGF0aDogc2VsZi5jb29raWVQYXRoLFxuICAgICAgICAgIGh0dHBPbmx5OiBzZWxmLmNvb2tpZVBhdGggPyBzZWxmLmNvb2tpZUh0dHBPbmx5IDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICB0cmFuc3BvcnQub25SZXF1ZXN0KHJlcSk7XG5cbiAgdGhpcy5jbGllbnRzW2lkXSA9IHNvY2tldDtcbiAgdGhpcy5jbGllbnRzQ291bnQrKztcblxuICBzb2NrZXQub25jZSgnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVsZXRlIHNlbGYuY2xpZW50c1tpZF07XG4gICAgc2VsZi5jbGllbnRzQ291bnQtLTtcbiAgfSk7XG5cbiAgdGhpcy5lbWl0KCdjb25uZWN0aW9uJywgc29ja2V0KTtcbn07XG5cbi8qKlxuICogSGFuZGxlcyBhbiBFbmdpbmUuSU8gSFRUUCBVcGdyYWRlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2VydmVyLnByb3RvdHlwZS5oYW5kbGVVcGdyYWRlID0gZnVuY3Rpb24gKHJlcSwgc29ja2V0LCB1cGdyYWRlSGVhZCkge1xuICB0aGlzLnByZXBhcmUocmVxKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMudmVyaWZ5KHJlcSwgdHJ1ZSwgZnVuY3Rpb24gKGVyciwgc3VjY2Vzcykge1xuICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgYWJvcnRDb25uZWN0aW9uKHNvY2tldCwgZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaGVhZCA9IEJ1ZmZlci5mcm9tKHVwZ3JhZGVIZWFkKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpXG4gICAgdXBncmFkZUhlYWQgPSBudWxsO1xuXG4gICAgLy8gZGVsZWdhdGUgdG8gd3NcbiAgICBzZWxmLndzLmhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQsIGZ1bmN0aW9uIChjb25uKSB7XG4gICAgICBzZWxmLm9uV2ViU29ja2V0KHJlcSwgY29ubik7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHdzLmlvIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHt3cy5Tb2NrZXR9IHdlYnNvY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2VydmVyLnByb3RvdHlwZS5vbldlYlNvY2tldCA9IGZ1bmN0aW9uIChyZXEsIHNvY2tldCkge1xuICBzb2NrZXQub24oJ2Vycm9yJywgb25VcGdyYWRlRXJyb3IpO1xuXG4gIGlmICh0cmFuc3BvcnRzW3JlcS5fcXVlcnkudHJhbnNwb3J0XSAhPT0gdW5kZWZpbmVkICYmICF0cmFuc3BvcnRzW3JlcS5fcXVlcnkudHJhbnNwb3J0XS5wcm90b3R5cGUuaGFuZGxlc1VwZ3JhZGVzKSB7XG4gICAgZGVidWcoJ3RyYW5zcG9ydCBkb2VzbnQgaGFuZGxlIHVwZ3JhZGVkIHJlcXVlc3RzJyk7XG4gICAgc29ja2V0LmNsb3NlKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZ2V0IGNsaWVudCBpZFxuICB2YXIgaWQgPSByZXEuX3F1ZXJ5LnNpZDtcblxuICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSB3cy5Tb2NrZXRcbiAgcmVxLndlYnNvY2tldCA9IHNvY2tldDtcblxuICBpZiAoaWQpIHtcbiAgICB2YXIgY2xpZW50ID0gdGhpcy5jbGllbnRzW2lkXTtcbiAgICBpZiAoIWNsaWVudCkge1xuICAgICAgZGVidWcoJ3VwZ3JhZGUgYXR0ZW1wdCBmb3IgY2xvc2VkIGNsaWVudCcpO1xuICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgfSBlbHNlIGlmIChjbGllbnQudXBncmFkaW5nKSB7XG4gICAgICBkZWJ1ZygndHJhbnNwb3J0IGhhcyBhbHJlYWR5IGJlZW4gdHJ5aW5nIHRvIHVwZ3JhZGUnKTtcbiAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgIH0gZWxzZSBpZiAoY2xpZW50LnVwZ3JhZGVkKSB7XG4gICAgICBkZWJ1ZygndHJhbnNwb3J0IGhhZCBhbHJlYWR5IGJlZW4gdXBncmFkZWQnKTtcbiAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygndXBncmFkaW5nIGV4aXN0aW5nIHRyYW5zcG9ydCcpO1xuXG4gICAgICAvLyB0cmFuc3BvcnQgZXJyb3IgaGFuZGxpbmcgdGFrZXMgb3ZlclxuICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uVXBncmFkZUVycm9yKTtcblxuICAgICAgdmFyIHRyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRzW3JlcS5fcXVlcnkudHJhbnNwb3J0XShyZXEpO1xuICAgICAgaWYgKHJlcS5fcXVlcnkgJiYgcmVxLl9xdWVyeS5iNjQpIHtcbiAgICAgICAgdHJhbnNwb3J0LnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc3BvcnQuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdHJhbnNwb3J0LnBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICAgIGNsaWVudC5tYXliZVVwZ3JhZGUodHJhbnNwb3J0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gdHJhbnNwb3J0IGVycm9yIGhhbmRsaW5nIHRha2VzIG92ZXJcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25VcGdyYWRlRXJyb3IpO1xuXG4gICAgdGhpcy5oYW5kc2hha2UocmVxLl9xdWVyeS50cmFuc3BvcnQsIHJlcSk7XG4gIH1cblxuICBmdW5jdGlvbiBvblVwZ3JhZGVFcnJvciAoKSB7XG4gICAgZGVidWcoJ3dlYnNvY2tldCBlcnJvciBiZWZvcmUgdXBncmFkZScpO1xuICAgIC8vIHNvY2tldC5jbG9zZSgpIG5vdCBuZWVkZWRcbiAgfVxufTtcblxuLyoqXG4gKiBDYXB0dXJlcyB1cGdyYWRlIHJlcXVlc3RzIGZvciBhIGh0dHAuU2VydmVyLlxuICpcbiAqIEBwYXJhbSB7aHR0cC5TZXJ2ZXJ9IHNlcnZlclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2VydmVyLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAoc2VydmVyLCBvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBwYXRoID0gKG9wdGlvbnMucGF0aCB8fCAnL2VuZ2luZS5pbycpLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cbiAgdmFyIGRlc3Ryb3lVcGdyYWRlVGltZW91dCA9IG9wdGlvbnMuZGVzdHJveVVwZ3JhZGVUaW1lb3V0IHx8IDEwMDA7XG5cbiAgLy8gbm9ybWFsaXplIHBhdGhcbiAgcGF0aCArPSAnLyc7XG5cbiAgZnVuY3Rpb24gY2hlY2sgKHJlcSkge1xuICAgIGlmICgnT1BUSU9OUycgPT09IHJlcS5tZXRob2QgJiYgZmFsc2UgPT09IG9wdGlvbnMuaGFuZGxlUHJlZmxpZ2h0UmVxdWVzdCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aCA9PT0gcmVxLnVybC5zdWJzdHIoMCwgcGF0aC5sZW5ndGgpO1xuICB9XG5cbiAgLy8gY2FjaGUgYW5kIGNsZWFuIHVwIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gc2VydmVyLmxpc3RlbmVycygncmVxdWVzdCcpLnNsaWNlKDApO1xuICBzZXJ2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZXF1ZXN0Jyk7XG4gIHNlcnZlci5vbignY2xvc2UnLCBzZWxmLmNsb3NlLmJpbmQoc2VsZikpO1xuICBzZXJ2ZXIub24oJ2xpc3RlbmluZycsIHNlbGYuaW5pdC5iaW5kKHNlbGYpKTtcblxuICAvLyBhZGQgcmVxdWVzdCBoYW5kbGVyXG4gIHNlcnZlci5vbigncmVxdWVzdCcsIGZ1bmN0aW9uIChyZXEsIHJlcykge1xuICAgIGlmIChjaGVjayhyZXEpKSB7XG4gICAgICBkZWJ1ZygnaW50ZXJjZXB0aW5nIHJlcXVlc3QgZm9yIHBhdGggXCIlc1wiJywgcGF0aCk7XG4gICAgICBpZiAoJ09QVElPTlMnID09PSByZXEubWV0aG9kICYmICdmdW5jdGlvbicgPT09IHR5cGVvZiBvcHRpb25zLmhhbmRsZVByZWZsaWdodFJlcXVlc3QpIHtcbiAgICAgICAgb3B0aW9ucy5oYW5kbGVQcmVmbGlnaHRSZXF1ZXN0LmNhbGwoc2VydmVyLCByZXEsIHJlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmhhbmRsZVJlcXVlc3QocmVxLCByZXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VydmVyLCByZXEsIHJlcyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAofnNlbGYudHJhbnNwb3J0cy5pbmRleE9mKCd3ZWJzb2NrZXQnKSkge1xuICAgIHNlcnZlci5vbigndXBncmFkZScsIGZ1bmN0aW9uIChyZXEsIHNvY2tldCwgaGVhZCkge1xuICAgICAgaWYgKGNoZWNrKHJlcSkpIHtcbiAgICAgICAgc2VsZi5oYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCBoZWFkKTtcbiAgICAgIH0gZWxzZSBpZiAoZmFsc2UgIT09IG9wdGlvbnMuZGVzdHJveVVwZ3JhZGUpIHtcbiAgICAgICAgLy8gZGVmYXVsdCBub2RlIGJlaGF2aW9yIGlzIHRvIGRpc2Nvbm5lY3Qgd2hlbiBubyBoYW5kbGVyc1xuICAgICAgICAvLyBidXQgYnkgYWRkaW5nIGEgaGFuZGxlciwgd2UgcHJldmVudCB0aGF0XG4gICAgICAgIC8vIGFuZCBpZiBubyBlaW8gdGhpbmcgaGFuZGxlcyB0aGUgdXBncmFkZVxuICAgICAgICAvLyB0aGVuIHRoZSBzb2NrZXQgbmVlZHMgdG8gZGllIVxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoc29ja2V0LndyaXRhYmxlICYmIHNvY2tldC5ieXRlc1dyaXR0ZW4gPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHNvY2tldC5lbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGRlc3Ryb3lVcGdyYWRlVGltZW91dCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uXG4gKlxuICogQHBhcmFtIHtuZXQuU29ja2V0fSBzb2NrZXRcbiAqIEBwYXJhbSB7Y29kZX0gZXJyb3IgY29kZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gYWJvcnRDb25uZWN0aW9uIChzb2NrZXQsIGNvZGUpIHtcbiAgaWYgKHNvY2tldC53cml0YWJsZSkge1xuICAgIHZhciBtZXNzYWdlID0gU2VydmVyLmVycm9yTWVzc2FnZXMuaGFzT3duUHJvcGVydHkoY29kZSkgPyBTZXJ2ZXIuZXJyb3JNZXNzYWdlc1tjb2RlXSA6IFN0cmluZyhjb2RlIHx8ICcnKTtcbiAgICB2YXIgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgobWVzc2FnZSk7XG4gICAgc29ja2V0LndyaXRlKFxuICAgICAgJ0hUVFAvMS4xIDQwMCBCYWQgUmVxdWVzdFxcclxcbicgK1xuICAgICAgJ0Nvbm5lY3Rpb246IGNsb3NlXFxyXFxuJyArXG4gICAgICAnQ29udGVudC10eXBlOiB0ZXh0L2h0bWxcXHJcXG4nICtcbiAgICAgICdDb250ZW50LUxlbmd0aDogJyArIGxlbmd0aCArICdcXHJcXG4nICtcbiAgICAgICdcXHJcXG4nICtcbiAgICAgIG1lc3NhZ2VcbiAgICApO1xuICB9XG4gIHNvY2tldC5kZXN0cm95KCk7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbi8qKlxuICogRnJvbSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92OC40LjAvbGliL19odHRwX2NvbW1vbi5qcyNMMzAzLUwzNTRcbiAqXG4gKiBUcnVlIGlmIHZhbCBjb250YWlucyBhbiBpbnZhbGlkIGZpZWxkLXZjaGFyXG4gKiAgZmllbGQtdmFsdWUgICAgPSAqKCBmaWVsZC1jb250ZW50IC8gb2JzLWZvbGQgKVxuICogIGZpZWxkLWNvbnRlbnQgID0gZmllbGQtdmNoYXIgWyAxKiggU1AgLyBIVEFCICkgZmllbGQtdmNoYXIgXVxuICogIGZpZWxkLXZjaGFyICAgID0gVkNIQVIgLyBvYnMtdGV4dFxuICpcbiAqIGNoZWNrSW52YWxpZEhlYWRlckNoYXIoKSBpcyBjdXJyZW50bHkgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlIGJ5IHY4LFxuICogc28gdGFrZSBjYXJlIHdoZW4gbWFraW5nIGNoYW5nZXMgdG8gdGhlIGltcGxlbWVudGF0aW9uIHNvIHRoYXQgdGhlIHNvdXJjZVxuICogY29kZSBzaXplIGRvZXMgbm90IGV4Y2VlZCB2OCdzIGRlZmF1bHQgbWF4X2lubGluZWRfc291cmNlX3NpemUgc2V0dGluZy5cbiAqKi9cbnZhciB2YWxpZEhkckNoYXJzID0gW1xuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAwIC0gMTVcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMTYgLSAzMVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyAzMiAtIDQ3XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDQ4IC0gNjNcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gNjQgLSA3OVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA4MCAtIDk1XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDk2IC0gMTExXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIC8vIDExMiAtIDEyN1xuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyAxMjggLi4uXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEgIC8vIC4uLiAyNTVcbl07XG5cbmZ1bmN0aW9uIGNoZWNrSW52YWxpZEhlYWRlckNoYXIodmFsKSB7XG4gIHZhbCArPSAnJztcbiAgaWYgKHZhbC5sZW5ndGggPCAxKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKCF2YWxpZEhkckNoYXJzW3ZhbC5jaGFyQ29kZUF0KDApXSlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKHZhbC5sZW5ndGggPCAyKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKCF2YWxpZEhkckNoYXJzW3ZhbC5jaGFyQ29kZUF0KDEpXSlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKHZhbC5sZW5ndGggPCAzKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKCF2YWxpZEhkckNoYXJzW3ZhbC5jaGFyQ29kZUF0KDIpXSlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKHZhbC5sZW5ndGggPCA0KVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKCF2YWxpZEhkckNoYXJzW3ZhbC5jaGFyQ29kZUF0KDMpXSlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgZm9yICh2YXIgaSA9IDQ7IGkgPCB2YWwubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoIXZhbGlkSGRyQ2hhcnNbdmFsLmNoYXJDb2RlQXQoaSldKVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2xpYi9zZXJ2ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGJhc2U2NGlkIHYwLjEuMFxuICovXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RvclxuICovXG5cbnZhciBCYXNlNjRJZCA9IGZ1bmN0aW9uKCkgeyB9O1xuXG4vKipcbiAqIEdldCByYW5kb20gYnl0ZXNcbiAqXG4gKiBVc2VzIGEgYnVmZmVyIGlmIGF2YWlsYWJsZSwgZmFsbHMgYmFjayB0byBjcnlwdG8ucmFuZG9tQnl0ZXNcbiAqL1xuXG5CYXNlNjRJZC5wcm90b3R5cGUuZ2V0UmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihieXRlcykge1xuXG4gIHZhciBCVUZGRVJfU0laRSA9IDQwOTZcbiAgdmFyIHNlbGYgPSB0aGlzOyAgXG4gIFxuICBieXRlcyA9IGJ5dGVzIHx8IDEyO1xuXG4gIGlmIChieXRlcyA+IEJVRkZFUl9TSVpFKSB7XG4gICAgcmV0dXJuIGNyeXB0by5yYW5kb21CeXRlcyhieXRlcyk7XG4gIH1cbiAgXG4gIHZhciBieXRlc0luQnVmZmVyID0gcGFyc2VJbnQoQlVGRkVSX1NJWkUvYnl0ZXMpO1xuICB2YXIgdGhyZXNob2xkID0gcGFyc2VJbnQoYnl0ZXNJbkJ1ZmZlciowLjg1KTtcblxuICBpZiAoIXRocmVzaG9sZCkge1xuICAgIHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMoYnl0ZXMpO1xuICB9XG5cbiAgaWYgKHRoaXMuYnl0ZXNCdWZmZXJJbmRleCA9PSBudWxsKSB7XG4gICAgIHRoaXMuYnl0ZXNCdWZmZXJJbmRleCA9IC0xO1xuICB9XG5cbiAgaWYgKHRoaXMuYnl0ZXNCdWZmZXJJbmRleCA9PSBieXRlc0luQnVmZmVyKSB7XG4gICAgdGhpcy5ieXRlc0J1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5ieXRlc0J1ZmZlckluZGV4ID0gLTE7XG4gIH1cblxuICAvLyBObyBidWZmZXJlZCBieXRlcyBhdmFpbGFibGUgb3IgaW5kZXggYWJvdmUgdGhyZXNob2xkXG4gIGlmICh0aGlzLmJ5dGVzQnVmZmVySW5kZXggPT0gLTEgfHwgdGhpcy5ieXRlc0J1ZmZlckluZGV4ID4gdGhyZXNob2xkKSB7XG4gICAgIFxuICAgIGlmICghdGhpcy5pc0dlbmVyYXRpbmdCeXRlcykge1xuICAgICAgdGhpcy5pc0dlbmVyYXRpbmdCeXRlcyA9IHRydWU7XG4gICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMoQlVGRkVSX1NJWkUsIGZ1bmN0aW9uKGVyciwgYnl0ZXMpIHtcbiAgICAgICAgc2VsZi5ieXRlc0J1ZmZlciA9IGJ5dGVzO1xuICAgICAgICBzZWxmLmJ5dGVzQnVmZmVySW5kZXggPSAwO1xuICAgICAgICBzZWxmLmlzR2VuZXJhdGluZ0J5dGVzID0gZmFsc2U7XG4gICAgICB9KTsgXG4gICAgfVxuICAgIFxuICAgIC8vIEZhbGwgYmFjayB0byBzeW5jIGNhbGwgd2hlbiBubyBidWZmZXJlZCBieXRlcyBhcmUgYXZhaWxhYmxlXG4gICAgaWYgKHRoaXMuYnl0ZXNCdWZmZXJJbmRleCA9PSAtMSkge1xuICAgICAgcmV0dXJuIGNyeXB0by5yYW5kb21CeXRlcyhieXRlcyk7XG4gICAgfVxuICB9XG4gIFxuICB2YXIgcmVzdWx0ID0gdGhpcy5ieXRlc0J1ZmZlci5zbGljZShieXRlcyp0aGlzLmJ5dGVzQnVmZmVySW5kZXgsIGJ5dGVzKih0aGlzLmJ5dGVzQnVmZmVySW5kZXgrMSkpOyBcbiAgdGhpcy5ieXRlc0J1ZmZlckluZGV4Kys7IFxuICBcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBiYXNlNjQgaWRcbiAqXG4gKiAoT3JpZ2luYWwgdmVyc2lvbiBmcm9tIHNvY2tldC5pbyA8aHR0cDovL3NvY2tldC5pbz4pXG4gKi9cblxuQmFzZTY0SWQucHJvdG90eXBlLmdlbmVyYXRlSWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByYW5kID0gbmV3IEJ1ZmZlcigxNSk7IC8vIG11bHRpcGxlIG9mIDMgZm9yIGJhc2U2NFxuICBpZiAoIXJhbmQud3JpdGVJbnQzMkJFKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKE1hdGgucmFuZG9tKCkgKiBNYXRoLnJhbmRvbSgpICogRGF0ZS5ub3coKSB8IDApLnRvU3RyaW5nKClcbiAgICAgICsgTWF0aC5hYnMoTWF0aC5yYW5kb20oKSAqIE1hdGgucmFuZG9tKCkgKiBEYXRlLm5vdygpIHwgMCkudG9TdHJpbmcoKTtcbiAgfVxuICB0aGlzLnNlcXVlbmNlTnVtYmVyID0gKHRoaXMuc2VxdWVuY2VOdW1iZXIgKyAxKSB8IDA7XG4gIHJhbmQud3JpdGVJbnQzMkJFKHRoaXMuc2VxdWVuY2VOdW1iZXIsIDExKTtcbiAgaWYgKGNyeXB0by5yYW5kb21CeXRlcykge1xuICAgIHRoaXMuZ2V0UmFuZG9tQnl0ZXMoMTIpLmNvcHkocmFuZCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbm90IHNlY3VyZSBmb3Igbm9kZSAwLjRcbiAgICBbMCwgNCwgOF0uZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICByYW5kLndyaXRlSW50MzJCRShNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMiwgMzIpIHwgMCwgaSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJhbmQudG9TdHJpbmcoJ2Jhc2U2NCcpLnJlcGxhY2UoL1xcLy9nLCAnXycpLnJlcGxhY2UoL1xcKy9nLCAnLScpO1xufTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBuZXcgQmFzZTY0SWQoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Jhc2U2NGlkL2xpYi9iYXNlNjRpZC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUjtcblxuLyoqXG4gKiBBamF4IHBvbGxpbmcgdHJhbnNwb3J0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gWEhSIChyZXEpIHtcbiAgUG9sbGluZy5jYWxsKHRoaXMsIHJlcSk7XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuICovXG5cbnV0aWwuaW5oZXJpdHMoWEhSLCBQb2xsaW5nKTtcblxuLyoqXG4gKiBPdmVycmlkZXMgYG9uUmVxdWVzdGAgdG8gaGFuZGxlIGBPUFRJT05TYC4uXG4gKlxuICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUub25SZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcSkge1xuICBpZiAoJ09QVElPTlMnID09PSByZXEubWV0aG9kKSB7XG4gICAgdmFyIHJlcyA9IHJlcS5yZXM7XG4gICAgdmFyIGhlYWRlcnMgPSB0aGlzLmhlYWRlcnMocmVxKTtcbiAgICBoZWFkZXJzWydBY2Nlc3MtQ29udHJvbC1BbGxvdy1IZWFkZXJzJ10gPSAnQ29udGVudC1UeXBlJztcbiAgICByZXMud3JpdGVIZWFkKDIwMCwgaGVhZGVycyk7XG4gICAgcmVzLmVuZCgpO1xuICB9IGVsc2Uge1xuICAgIFBvbGxpbmcucHJvdG90eXBlLm9uUmVxdWVzdC5jYWxsKHRoaXMsIHJlcSk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBoZWFkZXJzIGZvciBhIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcXVlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRyYSBoZWFkZXJzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLmhlYWRlcnMgPSBmdW5jdGlvbiAocmVxLCBoZWFkZXJzKSB7XG4gIGhlYWRlcnMgPSBoZWFkZXJzIHx8IHt9O1xuXG4gIGlmIChyZXEuaGVhZGVycy5vcmlnaW4pIHtcbiAgICBoZWFkZXJzWydBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFscyddID0gJ3RydWUnO1xuICAgIGhlYWRlcnNbJ0FjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbiddID0gcmVxLmhlYWRlcnMub3JpZ2luO1xuICB9IGVsc2Uge1xuICAgIGhlYWRlcnNbJ0FjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbiddID0gJyonO1xuICB9XG5cbiAgcmV0dXJuIFBvbGxpbmcucHJvdG90eXBlLmhlYWRlcnMuY2FsbCh0aGlzLCByZXEsIGhlYWRlcnMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLXhoci5qc1xuLy8gbW9kdWxlIGlkID0gMTQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qISBodHRwczovL210aHMuYmUvdXRmOGpzIHYyLjEuMiBieSBAbWF0aGlhcyAqL1xuXG52YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuLy8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcbmZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdHZhciBvdXRwdXQgPSBbXTtcblx0dmFyIGNvdW50ZXIgPSAwO1xuXHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0dmFyIHZhbHVlO1xuXHR2YXIgZXh0cmE7XG5cdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb3V0cHV0O1xufVxuXG4vLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHR2YXIgaW5kZXggPSAtMTtcblx0dmFyIHZhbHVlO1xuXHR2YXIgb3V0cHV0ID0gJyc7XG5cdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0dmFsdWUgPSBhcnJheVtpbmRleF07XG5cdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0fVxuXHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHR9XG5cdHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50LCBzdHJpY3QpIHtcblx0aWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikge1xuXHRcdGlmIChzdHJpY3QpIHtcblx0XHRcdHRocm93IEVycm9yKFxuXHRcdFx0XHQnTG9uZSBzdXJyb2dhdGUgVSsnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICtcblx0XHRcdFx0JyBpcyBub3QgYSBzY2FsYXIgdmFsdWUnXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuIHRydWU7XG59XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuZnVuY3Rpb24gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIHNoaWZ0KSB7XG5cdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gc2hpZnQpICYgMHgzRikgfCAweDgwKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCwgc3RyaWN0KSB7XG5cdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRkY4MCkgPT0gMCkgeyAvLyAxLWJ5dGUgc2VxdWVuY2Vcblx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdH1cblx0dmFyIHN5bWJvbCA9ICcnO1xuXHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkY4MDApID09IDApIHsgLy8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweEMwKTtcblx0fVxuXHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkZGMDAwMCkgPT0gMCkgeyAvLyAzLWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoIWNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50LCBzdHJpY3QpKSB7XG5cdFx0XHRjb2RlUG9pbnQgPSAweEZGRkQ7XG5cdFx0fVxuXHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTApO1xuXHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdH1cblx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZFMDAwMDApID09IDApIHsgLy8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDE4KSAmIDB4MDcpIHwgMHhGMCk7XG5cdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCAxMik7XG5cdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0fVxuXHRzeW1ib2wgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKChjb2RlUG9pbnQgJiAweDNGKSB8IDB4ODApO1xuXHRyZXR1cm4gc3ltYm9sO1xufVxuXG5mdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cmluZywgb3B0cykge1xuXHRvcHRzID0gb3B0cyB8fCB7fTtcblx0dmFyIHN0cmljdCA9IGZhbHNlICE9PSBvcHRzLnN0cmljdDtcblxuXHR2YXIgY29kZVBvaW50cyA9IHVjczJkZWNvZGUoc3RyaW5nKTtcblx0dmFyIGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoO1xuXHR2YXIgaW5kZXggPSAtMTtcblx0dmFyIGNvZGVQb2ludDtcblx0dmFyIGJ5dGVTdHJpbmcgPSAnJztcblx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRjb2RlUG9pbnQgPSBjb2RlUG9pbnRzW2luZGV4XTtcblx0XHRieXRlU3RyaW5nICs9IGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQsIHN0cmljdCk7XG5cdH1cblx0cmV0dXJuIGJ5dGVTdHJpbmc7XG59XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5mdW5jdGlvbiByZWFkQ29udGludWF0aW9uQnl0ZSgpIHtcblx0aWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdH1cblxuXHR2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0Ynl0ZUluZGV4Kys7XG5cblx0aWYgKChjb250aW51YXRpb25CeXRlICYgMHhDMCkgPT0gMHg4MCkge1xuXHRcdHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcblx0fVxuXG5cdC8vIElmIHdlIGVuZCB1cCBoZXJlLCBpdOKAmXMgbm90IGEgY29udGludWF0aW9uIGJ5dGVcblx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcbn1cblxuZnVuY3Rpb24gZGVjb2RlU3ltYm9sKHN0cmljdCkge1xuXHR2YXIgYnl0ZTE7XG5cdHZhciBieXRlMjtcblx0dmFyIGJ5dGUzO1xuXHR2YXIgYnl0ZTQ7XG5cdHZhciBjb2RlUG9pbnQ7XG5cblx0aWYgKGJ5dGVJbmRleCA+IGJ5dGVDb3VudCkge1xuXHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0fVxuXG5cdGlmIChieXRlSW5kZXggPT0gYnl0ZUNvdW50KSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gUmVhZCBmaXJzdCBieXRlXG5cdGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRieXRlSW5kZXgrKztcblxuXHQvLyAxLWJ5dGUgc2VxdWVuY2UgKG5vIGNvbnRpbnVhdGlvbiBieXRlcylcblx0aWYgKChieXRlMSAmIDB4ODApID09IDApIHtcblx0XHRyZXR1cm4gYnl0ZTE7XG5cdH1cblxuXHQvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0aWYgKChieXRlMSAmIDB4RTApID09IDB4QzApIHtcblx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MUYpIDw8IDYpIHwgYnl0ZTI7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweDgwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdH1cblx0fVxuXG5cdC8vIDMtYnl0ZSBzZXF1ZW5jZSAobWF5IGluY2x1ZGUgdW5wYWlyZWQgc3Vycm9nYXRlcylcblx0aWYgKChieXRlMSAmIDB4RjApID09IDB4RTApIHtcblx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAxMikgfCAoYnl0ZTIgPDwgNikgfCBieXRlMztcblx0XHRpZiAoY29kZVBvaW50ID49IDB4MDgwMCkge1xuXHRcdFx0cmV0dXJuIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50LCBzdHJpY3QpID8gY29kZVBvaW50IDogMHhGRkZEO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdH1cblx0fVxuXG5cdC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRpZiAoKGJ5dGUxICYgMHhGOCkgPT0gMHhGMCkge1xuXHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0Ynl0ZTQgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDA3KSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBDKSB8XG5cdFx0XHQoYnl0ZTMgPDwgMHgwNikgfCBieXRlNDtcblx0XHRpZiAoY29kZVBvaW50ID49IDB4MDEwMDAwICYmIGNvZGVQb2ludCA8PSAweDEwRkZGRikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHR9XG5cdH1cblxuXHR0aHJvdyBFcnJvcignSW52YWxpZCBVVEYtOCBkZXRlY3RlZCcpO1xufVxuXG52YXIgYnl0ZUFycmF5O1xudmFyIGJ5dGVDb3VudDtcbnZhciBieXRlSW5kZXg7XG5mdW5jdGlvbiB1dGY4ZGVjb2RlKGJ5dGVTdHJpbmcsIG9wdHMpIHtcblx0b3B0cyA9IG9wdHMgfHwge307XG5cdHZhciBzdHJpY3QgPSBmYWxzZSAhPT0gb3B0cy5zdHJpY3Q7XG5cblx0Ynl0ZUFycmF5ID0gdWNzMmRlY29kZShieXRlU3RyaW5nKTtcblx0Ynl0ZUNvdW50ID0gYnl0ZUFycmF5Lmxlbmd0aDtcblx0Ynl0ZUluZGV4ID0gMDtcblx0dmFyIGNvZGVQb2ludHMgPSBbXTtcblx0dmFyIHRtcDtcblx0d2hpbGUgKCh0bXAgPSBkZWNvZGVTeW1ib2woc3RyaWN0KSkgIT09IGZhbHNlKSB7XG5cdFx0Y29kZVBvaW50cy5wdXNoKHRtcCk7XG5cdH1cblx0cmV0dXJuIHVjczJlbmNvZGUoY29kZVBvaW50cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHR2ZXJzaW9uOiAnMi4xLjInLFxuXHRlbmNvZGU6IHV0ZjhlbmNvZGUsXG5cdGRlY29kZTogdXRmOGRlY29kZVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbGliL3V0ZjguanNcbi8vIG1vZHVsZSBpZCA9IDE0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2hhcy1iaW5hcnkyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBhZnRlclxuXG5mdW5jdGlvbiBhZnRlcihjb3VudCwgY2FsbGJhY2ssIGVycl9jYikge1xuICAgIHZhciBiYWlsID0gZmFsc2VcbiAgICBlcnJfY2IgPSBlcnJfY2IgfHwgbm9vcFxuICAgIHByb3h5LmNvdW50ID0gY291bnRcblxuICAgIHJldHVybiAoY291bnQgPT09IDApID8gY2FsbGJhY2soKSA6IHByb3h5XG5cbiAgICBmdW5jdGlvbiBwcm94eShlcnIsIHJlc3VsdCkge1xuICAgICAgICBpZiAocHJveHkuY291bnQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZnRlciBjYWxsZWQgdG9vIG1hbnkgdGltZXMnKVxuICAgICAgICB9XG4gICAgICAgIC0tcHJveHkuY291bnRcblxuICAgICAgICAvLyBhZnRlciBmaXJzdCBlcnJvciwgcmVzdCBhcmUgcGFzc2VkIHRvIGVycl9jYlxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBiYWlsID0gdHJ1ZVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgLy8gZnV0dXJlIGVycm9yIGNhbGxiYWNrcyB3aWxsIGdvIHRvIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyX2NiXG4gICAgICAgIH0gZWxzZSBpZiAocHJveHkuY291bnQgPT09IDAgJiYgIWJhaWwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hZnRlci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBHZXRzIHRoZSBrZXlzIGZvciBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGtleXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyAob2JqKXtcbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGkpKSB7XG4gICAgICBhcnIucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsXG4gICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJyxcbiAgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLFxuICAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsXG4gICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJyxcbiAgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLFxuICAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsXG4gICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJyxcbiAgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLFxuICAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsXG4gICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgTm9kZS5qcyBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFsgNiwgMiwgMywgNCwgNSwgMSBdO1xuXG50cnkge1xuICB2YXIgc3VwcG9ydHNDb2xvciA9IHJlcXVpcmUoJ3N1cHBvcnRzLWNvbG9yJyk7XG4gIGlmIChzdXBwb3J0c0NvbG9yICYmIHN1cHBvcnRzQ29sb3IubGV2ZWwgPj0gMikge1xuICAgIGV4cG9ydHMuY29sb3JzID0gW1xuICAgICAgMjAsIDIxLCAyNiwgMjcsIDMyLCAzMywgMzgsIDM5LCA0MCwgNDEsIDQyLCA0MywgNDQsIDQ1LCA1NiwgNTcsIDYyLCA2MywgNjgsXG4gICAgICA2OSwgNzQsIDc1LCA3NiwgNzcsIDc4LCA3OSwgODAsIDgxLCA5MiwgOTMsIDk4LCA5OSwgMTEyLCAxMTMsIDEyOCwgMTI5LCAxMzQsXG4gICAgICAxMzUsIDE0OCwgMTQ5LCAxNjAsIDE2MSwgMTYyLCAxNjMsIDE2NCwgMTY1LCAxNjYsIDE2NywgMTY4LCAxNjksIDE3MCwgMTcxLFxuICAgICAgMTcyLCAxNzMsIDE3OCwgMTc5LCAxODQsIDE4NSwgMTk2LCAxOTcsIDE5OCwgMTk5LCAyMDAsIDIwMSwgMjAyLCAyMDMsIDIwNCxcbiAgICAgIDIwNSwgMjA2LCAyMDcsIDIwOCwgMjA5LCAyMTQsIDIxNSwgMjIwLCAyMjFcbiAgICBdO1xuICB9XG59IGNhdGNoIChlcnIpIHtcbiAgLy8gc3dhbGxvdyAtIHdlIG9ubHkgY2FyZSBpZiBgc3VwcG9ydHMtY29sb3JgIGlzIGF2YWlsYWJsZTsgaXQgZG9lc24ndCBoYXZlIHRvIGJlLlxufVxuXG4vKipcbiAqIEJ1aWxkIHVwIHRoZSBkZWZhdWx0IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiAgICQgREVCVUdfQ09MT1JTPW5vIERFQlVHX0RFUFRIPTEwIERFQlVHX1NIT1dfSElEREVOPWVuYWJsZWQgbm9kZSBzY3JpcHQuanNcbiAqL1xuXG5leHBvcnRzLmluc3BlY3RPcHRzID0gT2JqZWN0LmtleXMocHJvY2Vzcy5lbnYpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAvXmRlYnVnXy9pLnRlc3Qoa2V5KTtcbn0pLnJlZHVjZShmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgLy8gY2FtZWwtY2FzZVxuICB2YXIgcHJvcCA9IGtleVxuICAgIC5zdWJzdHJpbmcoNilcbiAgICAudG9Mb3dlckNhc2UoKVxuICAgIC5yZXBsYWNlKC9fKFthLXpdKS9nLCBmdW5jdGlvbiAoXywgaykgeyByZXR1cm4gay50b1VwcGVyQ2FzZSgpIH0pO1xuXG4gIC8vIGNvZXJjZSBzdHJpbmcgdmFsdWUgaW50byBKUyB2YWx1ZVxuICB2YXIgdmFsID0gcHJvY2Vzcy5lbnZba2V5XTtcbiAgaWYgKC9eKHllc3xvbnx0cnVlfGVuYWJsZWQpJC9pLnRlc3QodmFsKSkgdmFsID0gdHJ1ZTtcbiAgZWxzZSBpZiAoL14obm98b2ZmfGZhbHNlfGRpc2FibGVkKSQvaS50ZXN0KHZhbCkpIHZhbCA9IGZhbHNlO1xuICBlbHNlIGlmICh2YWwgPT09ICdudWxsJykgdmFsID0gbnVsbDtcbiAgZWxzZSB2YWwgPSBOdW1iZXIodmFsKTtcblxuICBvYmpbcHJvcF0gPSB2YWw7XG4gIHJldHVybiBvYmo7XG59LCB7fSk7XG5cbi8qKlxuICogSXMgc3Rkb3V0IGEgVFRZPyBDb2xvcmVkIG91dHB1dCBpcyBlbmFibGVkIHdoZW4gYHRydWVgLlxuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgcmV0dXJuICdjb2xvcnMnIGluIGV4cG9ydHMuaW5zcGVjdE9wdHNcbiAgICA/IEJvb2xlYW4oZXhwb3J0cy5pbnNwZWN0T3B0cy5jb2xvcnMpXG4gICAgOiB0dHkuaXNhdHR5KHByb2Nlc3Muc3RkZXJyLmZkKTtcbn1cblxuLyoqXG4gKiBNYXAgJW8gdG8gYHV0aWwuaW5zcGVjdCgpYCwgYWxsIG9uIGEgc2luZ2xlIGxpbmUuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLm8gPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMuaW5zcGVjdE9wdHMuY29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG4gIHJldHVybiB1dGlsLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cylcbiAgICAuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihzdHIpIHtcbiAgICAgIHJldHVybiBzdHIudHJpbSgpXG4gICAgfSkuam9pbignICcpO1xufTtcblxuLyoqXG4gKiBNYXAgJW8gdG8gYHV0aWwuaW5zcGVjdCgpYCwgYWxsb3dpbmcgbXVsdGlwbGUgbGluZXMgaWYgbmVlZGVkLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5PID0gZnVuY3Rpb24odikge1xuICB0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuICByZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpO1xufTtcblxuLyoqXG4gKiBBZGRzIEFOU0kgY29sb3IgZXNjYXBlIGNvZGVzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLm5hbWVzcGFjZTtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGlmICh1c2VDb2xvcnMpIHtcbiAgICB2YXIgYyA9IHRoaXMuY29sb3I7XG4gICAgdmFyIGNvbG9yQ29kZSA9ICdcXHUwMDFiWzMnICsgKGMgPCA4ID8gYyA6ICc4OzU7JyArIGMpO1xuICAgIHZhciBwcmVmaXggPSAnICAnICsgY29sb3JDb2RlICsgJzsxbScgKyBuYW1lICsgJyAnICsgJ1xcdTAwMWJbMG0nO1xuXG4gICAgYXJnc1swXSA9IHByZWZpeCArIGFyZ3NbMF0uc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbicgKyBwcmVmaXgpO1xuICAgIGFyZ3MucHVzaChjb2xvckNvZGUgKyAnbSsnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpICsgJ1xcdTAwMWJbMG0nKTtcbiAgfSBlbHNlIHtcbiAgICBhcmdzWzBdID0gZ2V0RGF0ZSgpICsgbmFtZSArICcgJyArIGFyZ3NbMF07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGF0ZSgpIHtcbiAgaWYgKGV4cG9ydHMuaW5zcGVjdE9wdHMuaGlkZURhdGUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSArICcgJztcbiAgfVxufVxuXG4vKipcbiAqIEludm9rZXMgYHV0aWwuZm9ybWF0KClgIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMgYW5kIHdyaXRlcyB0byBzdGRlcnIuXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICByZXR1cm4gcHJvY2Vzcy5zdGRlcnIud3JpdGUodXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgYXJndW1lbnRzKSArICdcXG4nKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAvLyBJZiB5b3Ugc2V0IGEgcHJvY2Vzcy5lbnYgZmllbGQgdG8gbnVsbCBvciB1bmRlZmluZWQsIGl0IGdldHMgY2FzdCB0byB0aGVcbiAgICAvLyBzdHJpbmcgJ251bGwnIG9yICd1bmRlZmluZWQnLiBKdXN0IGRlbGV0ZSBpbnN0ZWFkLlxuICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLmVudi5ERUJVRyA9IG5hbWVzcGFjZXM7XG4gIH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuREVCVUc7XG59XG5cbi8qKlxuICogSW5pdCBsb2dpYyBmb3IgYGRlYnVnYCBpbnN0YW5jZXMuXG4gKlxuICogQ3JlYXRlIGEgbmV3IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGluIGNhc2UgYHVzZUNvbG9yc2AgaXMgc2V0XG4gKiBkaWZmZXJlbnRseSBmb3IgYSBwYXJ0aWN1bGFyIGBkZWJ1Z2AgaW5zdGFuY2UuXG4gKi9cblxuZnVuY3Rpb24gaW5pdCAoZGVidWcpIHtcbiAgZGVidWcuaW5zcGVjdE9wdHMgPSB7fTtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV4cG9ydHMuaW5zcGVjdE9wdHMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWJ1Zy5pbnNwZWN0T3B0c1trZXlzW2ldXSA9IGV4cG9ydHMuaW5zcGVjdE9wdHNba2V5c1tpXV07XG4gIH1cbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYHByb2Nlc3MuZW52LkRFQlVHYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9ub2RlX21vZHVsZXMvZGVidWcvc3JjL25vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDE1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJvc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcIm9zXCJcbi8vIG1vZHVsZSBpZCA9IDE1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IChmbGFnLCBhcmd2KSA9PiB7XG5cdGFyZ3YgPSBhcmd2IHx8IHByb2Nlc3MuYXJndjtcblx0Y29uc3QgcHJlZml4ID0gZmxhZy5zdGFydHNXaXRoKCctJykgPyAnJyA6IChmbGFnLmxlbmd0aCA9PT0gMSA/ICctJyA6ICctLScpO1xuXHRjb25zdCBwb3MgPSBhcmd2LmluZGV4T2YocHJlZml4ICsgZmxhZyk7XG5cdGNvbnN0IHRlcm1pbmF0b3JQb3MgPSBhcmd2LmluZGV4T2YoJy0tJyk7XG5cdHJldHVybiBwb3MgIT09IC0xICYmICh0ZXJtaW5hdG9yUG9zID09PSAtMSA/IHRydWUgOiBwb3MgPCB0ZXJtaW5hdG9yUG9zKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9oYXMtZmxhZy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xudmFyIHJEb3VibGVTbGFzaGVzID0gL1xcXFxcXFxcbi9nO1xudmFyIHJTbGFzaGVzID0gLyhcXFxcKT9cXFxcbi9nO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBKU09OUDtcblxuLyoqXG4gKiBKU09OLVAgcG9sbGluZyB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBKU09OUCAocmVxKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCByZXEpO1xuXG4gIHRoaXMuaGVhZCA9ICdfX19laW9bJyArIChyZXEuX3F1ZXJ5LmogfHwgJycpLnJlcGxhY2UoL1teMC05XS9nLCAnJykgKyAnXSgnO1xuICB0aGlzLmZvb3QgPSAnKTsnO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG51dGlsLmluaGVyaXRzKEpTT05QLCBQb2xsaW5nKTtcblxuLyoqXG4gKiBIYW5kbGVzIGluY29taW5nIGRhdGEuXG4gKiBEdWUgdG8gYSBidWcgaW4gXFxuIGhhbmRsaW5nIGJ5IGJyb3dzZXJzLCB3ZSBleHBlY3QgYSBlc2NhcGVkIHN0cmluZy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgLy8gd2UgbGV2ZXJhZ2UgdGhlIHFzIG1vZHVsZSBzbyB0aGF0IHdlIGdldCBidWlsdC1pbiBEb1MgcHJvdGVjdGlvblxuICAvLyBhbmQgdGhlIGZhc3QgYWx0ZXJuYXRpdmUgdG8gZGVjb2RlVVJJQ29tcG9uZW50XG4gIGRhdGEgPSBxcy5wYXJzZShkYXRhKS5kO1xuICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBkYXRhKSB7XG4gICAgLy8gY2xpZW50IHdpbGwgc2VuZCBhbHJlYWR5IGVzY2FwZWQgbmV3bGluZXMgYXMgXFxcXFxcXFxuIGFuZCBuZXdsaW5lcyBhcyBcXFxcblxuICAgIC8vIFxcXFxuIG11c3QgYmUgcmVwbGFjZWQgd2l0aCBcXG4gYW5kIFxcXFxcXFxcbiB3aXRoIFxcXFxuXG4gICAgZGF0YSA9IGRhdGEucmVwbGFjZShyU2xhc2hlcywgZnVuY3Rpb24gKG1hdGNoLCBzbGFzaGVzKSB7XG4gICAgICByZXR1cm4gc2xhc2hlcyA/IG1hdGNoIDogJ1xcbic7XG4gICAgfSk7XG4gICAgUG9sbGluZy5wcm90b3R5cGUub25EYXRhLmNhbGwodGhpcywgZGF0YS5yZXBsYWNlKHJEb3VibGVTbGFzaGVzLCAnXFxcXG4nKSk7XG4gIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybXMgdGhlIHdyaXRlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIC8vIHdlIG11c3Qgb3V0cHV0IHZhbGlkIGphdmFzY3JpcHQsIG5vdCB2YWxpZCBqc29uXG4gIC8vIHNlZTogaHR0cDovL3RpbWVsZXNzcmVwby5jb20vanNvbi1pc250LWEtamF2YXNjcmlwdC1zdWJzZXRcbiAgdmFyIGpzID0gSlNPTi5zdHJpbmdpZnkoZGF0YSlcbiAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JylcbiAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5Jyk7XG5cbiAgLy8gcHJlcGFyZSByZXNwb25zZVxuICBkYXRhID0gdGhpcy5oZWFkICsganMgKyB0aGlzLmZvb3Q7XG5cbiAgUG9sbGluZy5wcm90b3R5cGUuZG9Xcml0ZS5jYWxsKHRoaXMsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vbGliL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qc1xuLy8gbW9kdWxlIGlkID0gMTU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi90cmFuc3BvcnQnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZTp3cycpO1xuXG4vKipcbiAqIEV4cG9ydCB0aGUgY29uc3RydWN0b3IuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XG5cbi8qKlxuICogV2ViU29ja2V0IHRyYW5zcG9ydFxuICpcbiAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFdlYlNvY2tldCAocmVxKSB7XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIHJlcSk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5zb2NrZXQgPSByZXEud2Vic29ja2V0O1xuICB0aGlzLnNvY2tldC5vbignbWVzc2FnZScsIHRoaXMub25EYXRhLmJpbmQodGhpcykpO1xuICB0aGlzLnNvY2tldC5vbmNlKCdjbG9zZScsIHRoaXMub25DbG9zZS5iaW5kKHRoaXMpKTtcbiAgdGhpcy5zb2NrZXQub24oJ2Vycm9yJywgdGhpcy5vbkVycm9yLmJpbmQodGhpcykpO1xuICB0aGlzLnNvY2tldC5vbignaGVhZGVycycsIG9uSGVhZGVycyk7XG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gbnVsbDtcblxuICBmdW5jdGlvbiBvbkhlYWRlcnMgKGhlYWRlcnMpIHtcbiAgICBzZWxmLmVtaXQoJ2hlYWRlcnMnLCBoZWFkZXJzKTtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbnV0aWwuaW5oZXJpdHMoV2ViU29ja2V0LCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XZWJTb2NrZXQucHJvdG90eXBlLm5hbWUgPSAnd2Vic29ja2V0JztcblxuLyoqXG4gKiBBZHZlcnRpc2UgdXBncmFkZSBzdXBwb3J0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV2ViU29ja2V0LnByb3RvdHlwZS5oYW5kbGVzVXBncmFkZXMgPSB0cnVlO1xuXG4vKipcbiAqIEFkdmVydGlzZSBmcmFtaW5nIHN1cHBvcnQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XZWJTb2NrZXQucHJvdG90eXBlLnN1cHBvcnRzRnJhbWluZyA9IHRydWU7XG5cbi8qKlxuICogUHJvY2Vzc2VzIHRoZSBpbmNvbWluZyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGVkIHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV2ViU29ja2V0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICBkZWJ1ZygncmVjZWl2ZWQgXCIlc1wiJywgZGF0YSk7XG4gIFRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhLmNhbGwodGhpcywgZGF0YSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldCBwYXlsb2FkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldlYlNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChwYWNrZXRzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGFja2V0ID0gcGFja2V0c1tpXTtcbiAgICBwYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldCwgc2VsZi5zdXBwb3J0c0JpbmFyeSwgc2VuZCk7XG4gIH1cblxuICBmdW5jdGlvbiBzZW5kIChkYXRhKSB7XG4gICAgZGVidWcoJ3dyaXRpbmcgXCIlc1wiJywgZGF0YSk7XG5cbiAgICAvLyBhbHdheXMgY3JlYXRlcyBhIG5ldyBvYmplY3Qgc2luY2Ugd3MgbW9kaWZpZXMgaXRcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIGlmIChwYWNrZXQub3B0aW9ucykge1xuICAgICAgb3B0cy5jb21wcmVzcyA9IHBhY2tldC5vcHRpb25zLmNvbXByZXNzO1xuICAgIH1cblxuICAgIGlmIChzZWxmLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICB2YXIgbGVuID0gJ3N0cmluZycgPT09IHR5cGVvZiBkYXRhID8gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgOiBkYXRhLmxlbmd0aDtcbiAgICAgIGlmIChsZW4gPCBzZWxmLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuICAgICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZi53cml0YWJsZSA9IGZhbHNlO1xuICAgIHNlbGYuc29ja2V0LnNlbmQoZGF0YSwgb3B0cywgb25FbmQpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25FbmQgKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBzZWxmLm9uRXJyb3IoJ3dyaXRlIGVycm9yJywgZXJyLnN0YWNrKTtcbiAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV2ViU29ja2V0LnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKGZuKSB7XG4gIGRlYnVnKCdjbG9zaW5nJyk7XG4gIHRoaXMuc29ja2V0LmNsb3NlKCk7XG4gIGZuICYmIGZuKCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2xpYi90cmFuc3BvcnRzL3dlYnNvY2tldC5qc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgRUVfRVJST1IgPSAnUmVnaXN0ZXJpbmcgbW9yZSB0aGFuIG9uZSBsaXN0ZW5lciB0byBhIFdlYlNvY2tldCBpcyBub3Qgc3VwcG9ydGVkLic7XG5jb25zdCBERUZBVUxUX1BBWUxPQURfTElNSVQgPSAxNjc3NzIxNjtcblxubGV0IF91cGdyYWRlUmVxID0gbnVsbDtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGFib3J0Q29ubmVjdGlvbihzb2NrZXQsIGNvZGUsIG5hbWUpIHtcbiAgICBzb2NrZXQuZW5kKCdIVFRQLzEuMSAnICsgY29kZSArICcgJyArIG5hbWUgKyAnXFxyXFxuXFxyXFxuJyk7XG59XG5cbmZ1bmN0aW9uIGVtaXRDb25uZWN0aW9uKHdzKSB7XG4gICAgdGhpcy5lbWl0KCdjb25uZWN0aW9uJywgd3MsIF91cGdyYWRlUmVxKTtcbn1cblxuZnVuY3Rpb24gb25TZXJ2ZXJNZXNzYWdlKG1lc3NhZ2UsIHdlYlNvY2tldCkge1xuICAgIHdlYlNvY2tldC5pbnRlcm5hbE9uTWVzc2FnZShtZXNzYWdlKTtcbn1cblxuY29uc3QgbmF0aXZlID0gKCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3MuYmluZGluZygndXdzX2J1aWx0aW4nKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVpcmUoYC4vdXdzXyR7cHJvY2Vzcy5wbGF0Zm9ybX1fJHtwcm9jZXNzLnZlcnNpb25zLm1vZHVsZXN9YCk7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBwcm9jZXNzLnZlcnNpb24uc3Vic3RyaW5nKDEpLnNwbGl0KCcuJykubWFwKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGxlc3NUaGFuU2l4Rm91ciA9IHZlcnNpb25bMF0gPCA2IHx8ICh2ZXJzaW9uWzBdID09PSA2ICYmIHZlcnNpb25bMV0gPCA0KTtcblxuICAgICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyAmJiBsZXNzVGhhblNpeEZvdXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignwrVXZWJTb2NrZXRzIHJlcXVpcmVzIE5vZGUuanMgNi40LjAgb3IgZ3JlYXRlciBvbiBXaW5kb3dzLicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21waWxhdGlvbiBvZiDCtVdlYlNvY2tldHMgaGFzIGZhaWxlZCBhbmQgdGhlcmUgaXMgbm8gcHJlLWNvbXBpbGVkIGJpbmFyeSAnICtcbiAgICAgICAgICAgICdhdmFpbGFibGUgZm9yIHlvdXIgc3lzdGVtLiBQbGVhc2UgaW5zdGFsbCBhIHN1cHBvcnRlZCBDKysxMSBjb21waWxlciBhbmQgcmVpbnN0YWxsIHRoZSBtb2R1bGUgXFwndXdzXFwnLicpO1xuICAgICAgICB9XG4gICAgfVxufSkoKTtcblxubmF0aXZlLnNldE5vb3Aobm9vcCk7XG5cbmNvbnN0IGNsaWVudEdyb3VwID0gbmF0aXZlLmNsaWVudC5ncm91cC5jcmVhdGUoMCwgREVGQVVMVF9QQVlMT0FEX0xJTUlUKTtcblxubmF0aXZlLmNsaWVudC5ncm91cC5vbkNvbm5lY3Rpb24oY2xpZW50R3JvdXAsIChleHRlcm5hbCkgPT4ge1xuICAgIGNvbnN0IHdlYlNvY2tldCA9IG5hdGl2ZS5nZXRVc2VyRGF0YShleHRlcm5hbCk7XG4gICAgd2ViU29ja2V0LmV4dGVybmFsID0gZXh0ZXJuYWw7XG4gICAgd2ViU29ja2V0LmludGVybmFsT25PcGVuKCk7XG59KTtcblxubmF0aXZlLmNsaWVudC5ncm91cC5vbk1lc3NhZ2UoY2xpZW50R3JvdXAsIChtZXNzYWdlLCB3ZWJTb2NrZXQpID0+IHtcbiAgICB3ZWJTb2NrZXQuaW50ZXJuYWxPbk1lc3NhZ2UobWVzc2FnZSk7XG59KTtcblxubmF0aXZlLmNsaWVudC5ncm91cC5vbkRpc2Nvbm5lY3Rpb24oY2xpZW50R3JvdXAsIChleHRlcm5hbCwgY29kZSwgbWVzc2FnZSwgd2ViU29ja2V0KSA9PiB7XG4gICAgd2ViU29ja2V0LmV4dGVybmFsID0gbnVsbDtcblxuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICB3ZWJTb2NrZXQuaW50ZXJuYWxPbkNsb3NlKGNvZGUsIG1lc3NhZ2UpO1xuICAgIH0pO1xuXG4gICAgbmF0aXZlLmNsZWFyVXNlckRhdGEoZXh0ZXJuYWwpO1xufSk7XG5cbm5hdGl2ZS5jbGllbnQuZ3JvdXAub25QaW5nKGNsaWVudEdyb3VwLCAobWVzc2FnZSwgd2ViU29ja2V0KSA9PiB7XG4gICAgd2ViU29ja2V0Lm9ucGluZyhtZXNzYWdlKTtcbn0pO1xuXG5uYXRpdmUuY2xpZW50Lmdyb3VwLm9uUG9uZyhjbGllbnRHcm91cCwgKG1lc3NhZ2UsIHdlYlNvY2tldCkgPT4ge1xuICAgIHdlYlNvY2tldC5vbnBvbmcobWVzc2FnZSk7XG59KTtcblxubmF0aXZlLmNsaWVudC5ncm91cC5vbkVycm9yKGNsaWVudEdyb3VwLCAod2ViU29ja2V0KSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHdlYlNvY2tldC5pbnRlcm5hbE9uRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogJ3VXcyBjbGllbnQgY29ubmVjdGlvbiBlcnJvcicsXG4gICAgICAgICAgICBzdGFjazogJ3VXcyBjbGllbnQgY29ubmVjdGlvbiBlcnJvcidcbiAgICAgICAgfSk7XG4gICAgfSk7XG59KTtcblxuY2xhc3MgV2ViU29ja2V0IHtcbiAgICBjb25zdHJ1Y3RvcihleHRlcm5hbCkge1xuICAgICAgICB0aGlzLmV4dGVybmFsID0gZXh0ZXJuYWw7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxPbk1lc3NhZ2UgPSBub29wO1xuICAgICAgICB0aGlzLmludGVybmFsT25DbG9zZSA9IG5vb3A7XG4gICAgICAgIHRoaXMub25waW5nID0gbm9vcDtcbiAgICAgICAgdGhpcy5vbnBvbmcgPSBub29wO1xuICAgIH1cblxuICAgIGdldCB1cGdyYWRlUmVxKCkge1xuICAgICAgICByZXR1cm4gX3VwZ3JhZGVSZXE7XG4gICAgfVxuXG4gICAgc2V0IG9ubWVzc2FnZShmKSB7XG4gICAgICAgIGlmIChmKSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsT25NZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICBmKHtkYXRhOiBtZXNzYWdlfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbE9uTWVzc2FnZSA9IG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgb25vcGVuKGYpIHtcbiAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxPbk9wZW4gPSBmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbE9uT3BlbiA9IG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgb25jbG9zZShmKSB7XG4gICAgICAgIGlmIChmKSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsT25DbG9zZSA9IChjb2RlLCBtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgZih7Y29kZTogY29kZSwgcmVhc29uOiBtZXNzYWdlfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbE9uQ2xvc2UgPSBub29wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0IG9uZXJyb3IoZikge1xuICAgICAgICBpZiAoZiAmJiB0aGlzIGluc3RhbmNlb2YgV2ViU29ja2V0Q2xpZW50KSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsT25FcnJvciA9IGY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsT25FcnJvciA9IG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlbWl0KGV2ZW50TmFtZSwgYXJnMSwgYXJnMikge1xuICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnbWVzc2FnZScpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxPbk1lc3NhZ2UoYXJnMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnROYW1lID09PSAnY2xvc2UnKSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsT25DbG9zZShhcmcxLCBhcmcyKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudE5hbWUgPT09ICdwaW5nJykge1xuICAgICAgICAgICAgdGhpcy5vbnBpbmcoYXJnMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnROYW1lID09PSAncG9uZycpIHtcbiAgICAgICAgICAgIHRoaXMub25wb25nKGFyZzEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIG9uKGV2ZW50TmFtZSwgZikge1xuICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnbWVzc2FnZScpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmludGVybmFsT25NZXNzYWdlICE9PSBub29wKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoRUVfRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbE9uTWVzc2FnZSA9IGY7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnROYW1lID09PSAnY2xvc2UnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnRlcm5hbE9uQ2xvc2UgIT09IG5vb3ApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihFRV9FUlJPUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmludGVybmFsT25DbG9zZSA9IGY7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnROYW1lID09PSAncGluZycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9ucGluZyAhPT0gbm9vcCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKEVFX0VSUk9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub25waW5nID0gZjtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudE5hbWUgPT09ICdwb25nJykge1xuICAgICAgICAgICAgaWYgKHRoaXMub25wb25nICE9PSBub29wKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoRUVfRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vbnBvbmcgPSBmO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ29wZW4nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnRlcm5hbE9uT3BlbiAhPT0gbm9vcCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKEVFX0VSUk9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxPbk9wZW4gPSBmO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ2Vycm9yJyAmJiB0aGlzIGluc3RhbmNlb2YgV2ViU29ja2V0Q2xpZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnRlcm5hbE9uRXJyb3IgIT09IG5vb3ApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihFRV9FUlJPUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmludGVybmFsT25FcnJvciA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgb25jZShldmVudE5hbWUsIGYpIHtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ21lc3NhZ2UnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnRlcm5hbE9uTWVzc2FnZSAhPT0gbm9vcCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKEVFX0VSUk9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxPbk1lc3NhZ2UgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxPbk1lc3NhZ2UgPSBub29wO1xuICAgICAgICAgICAgICAgIGYobWVzc2FnZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ29wZW4nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnRlcm5hbE9uT3BlbiAhPT0gbm9vcCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKEVFX0VSUk9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxPbk9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcm5hbE9uT3BlbiA9IG5vb3A7XG4gICAgICAgICAgICAgICAgZigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudE5hbWUgPT09ICdjbG9zZScpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmludGVybmFsT25DbG9zZSAhPT0gbm9vcCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKEVFX0VSUk9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxPbkNsb3NlID0gKGNvZGUsIG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVybmFsT25DbG9zZSA9IG5vb3A7XG4gICAgICAgICAgICAgICAgZihjb2RlLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnROYW1lID09PSAncGluZycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9ucGluZyAhPT0gbm9vcCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKEVFX0VSUk9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub25waW5nID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25waW5nID0gbm9vcDtcbiAgICAgICAgICAgICAgICBmKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ3BvbmcnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vbnBvbmcgIT09IG5vb3ApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihFRV9FUlJPUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9ucG9uZyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ucG9uZyA9IG5vb3A7XG4gICAgICAgICAgICAgICAgZigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgICAgIGlmICghZXZlbnROYW1lIHx8IGV2ZW50TmFtZSA9PT0gJ21lc3NhZ2UnKSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsT25NZXNzYWdlID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV2ZW50TmFtZSB8fCBldmVudE5hbWUgPT09ICdvcGVuJykge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbE9uT3BlbiA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFldmVudE5hbWUgfHwgZXZlbnROYW1lID09PSAnY2xvc2UnKSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsT25DbG9zZSA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFldmVudE5hbWUgfHwgZXZlbnROYW1lID09PSAncGluZycpIHtcbiAgICAgICAgICAgIHRoaXMub25waW5nID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV2ZW50TmFtZSB8fCBldmVudE5hbWUgPT09ICdwb25nJykge1xuICAgICAgICAgICAgdGhpcy5vbnBvbmcgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgY2IpIHtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ21lc3NhZ2UnICYmIHRoaXMuaW50ZXJuYWxPbk1lc3NhZ2UgPT09IGNiKSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsT25NZXNzYWdlID0gbm9vcDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudE5hbWUgPT09ICdvcGVuJyAmJiB0aGlzLmludGVybmFsT25PcGVuID09PSBjYikge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbE9uT3BlbiA9IG5vb3A7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnROYW1lID09PSAnY2xvc2UnICYmIHRoaXMuaW50ZXJuYWxPbkNsb3NlID09PSBjYikge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbE9uQ2xvc2UgPSBub29wO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ3BpbmcnICYmIHRoaXMub25waW5nID09PSBjYikge1xuICAgICAgICAgICAgdGhpcy5vbnBpbmcgPSBub29wO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ3BvbmcnICYmIHRoaXMub25wb25nID09PSBjYikge1xuICAgICAgICAgICAgdGhpcy5vbnBvbmcgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldCBPUEVOKCkge1xuICAgICAgICByZXR1cm4gV2ViU29ja2V0Q2xpZW50Lk9QRU47XG4gICAgfVxuXG4gICAgZ2V0IENMT1NFRCgpIHtcbiAgICAgICAgcmV0dXJuIFdlYlNvY2tldENsaWVudC5DTE9TRUQ7XG4gICAgfVxuXG4gICAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsID8gV2ViU29ja2V0Q2xpZW50Lk9QRU4gOiBXZWJTb2NrZXRDbGllbnQuQ0xPU0VEO1xuICAgIH1cblxuICAgIGdldCBfc29ja2V0KCkge1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gdGhpcy5leHRlcm5hbCA/IG5hdGl2ZS5nZXRBZGRyZXNzKHRoaXMuZXh0ZXJuYWwpIDogbmV3IEFycmF5KDMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVtb3RlUG9ydDogYWRkcmVzc1swXSxcbiAgICAgICAgICAgIHJlbW90ZUFkZHJlc3M6IGFkZHJlc3NbMV0sXG4gICAgICAgICAgICByZW1vdGVGYW1pbHk6IGFkZHJlc3NbMl1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBmcm9tIGhlcmUgZG93biwgZnVuY3Rpb25zIGFyZSBub3QgY29tbW9uIGJldHdlZW4gY2xpZW50IGFuZCBzZXJ2ZXJcblxuICAgIHBpbmcobWVzc2FnZSwgb3B0aW9ucywgZG9udEZhaWxXaGVuQ2xvc2VkKSB7XG4gICAgICAgIGlmICh0aGlzLmV4dGVybmFsKSB7XG4gICAgICAgICAgICBuYXRpdmUuc2VydmVyLnNlbmQodGhpcy5leHRlcm5hbCwgbWVzc2FnZSwgV2ViU29ja2V0Q2xpZW50Lk9QQ09ERV9QSU5HLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0ZXJtaW5hdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmV4dGVybmFsKSB7XG4gICAgICAgICAgICBuYXRpdmUuc2VydmVyLnRlcm1pbmF0ZSh0aGlzLmV4dGVybmFsKTtcbiAgICAgICAgICAgIHRoaXMuZXh0ZXJuYWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VuZChtZXNzYWdlLCBvcHRpb25zLCBjYiwgY29tcHJlc3MpIHtcbiAgICAgICAgaWYgKHRoaXMuZXh0ZXJuYWwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgYmluYXJ5ID0gb3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5iaW5hcnkgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuYmluYXJ5IDogdHlwZW9mIG1lc3NhZ2UgIT09ICdzdHJpbmcnO1xuXG4gICAgICAgICAgICBuYXRpdmUuc2VydmVyLnNlbmQodGhpcy5leHRlcm5hbCwgbWVzc2FnZSwgYmluYXJ5ID8gV2ViU29ja2V0Q2xpZW50Lk9QQ09ERV9CSU5BUlkgOiBXZWJTb2NrZXRDbGllbnQuT1BDT0RFX1RFWFQsIGNiID8gKCgpID0+IHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKTtcbiAgICAgICAgICAgIH0pIDogdW5kZWZpbmVkLCBjb21wcmVzcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgICAgICAgIGNiKG5ldyBFcnJvcignbm90IG9wZW5lZCcpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsb3NlKGNvZGUsIGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuZXh0ZXJuYWwpIHtcbiAgICAgICAgICAgIG5hdGl2ZS5zZXJ2ZXIuY2xvc2UodGhpcy5leHRlcm5hbCwgY29kZSwgZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmV4dGVybmFsID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgV2ViU29ja2V0Q2xpZW50IGV4dGVuZHMgV2ViU29ja2V0IHtcbiAgICBjb25zdHJ1Y3Rvcih1cmkpIHtcbiAgICAgICAgc3VwZXIobnVsbCk7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxPbk9wZW4gPSBub29wO1xuICAgICAgICB0aGlzLmludGVybmFsT25FcnJvciA9IG5vb3A7XG4gICAgICAgIG5hdGl2ZS5jb25uZWN0KGNsaWVudEdyb3VwLCB1cmksIHRoaXMpO1xuICAgIH1cblxuICAgIHBpbmcobWVzc2FnZSwgb3B0aW9ucywgZG9udEZhaWxXaGVuQ2xvc2VkKSB7XG4gICAgICAgIGlmICh0aGlzLmV4dGVybmFsKSB7XG4gICAgICAgICAgICBuYXRpdmUuY2xpZW50LnNlbmQodGhpcy5leHRlcm5hbCwgbWVzc2FnZSwgV2ViU29ja2V0Q2xpZW50Lk9QQ09ERV9QSU5HLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0ZXJtaW5hdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmV4dGVybmFsKSB7XG4gICAgICAgICAgICBuYXRpdmUuY2xpZW50LnRlcm1pbmF0ZSh0aGlzLmV4dGVybmFsKTtcbiAgICAgICAgICAgIHRoaXMuZXh0ZXJuYWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VuZChtZXNzYWdlLCBvcHRpb25zLCBjYiwgY29tcHJlc3MpIHtcbiAgICAgICAgaWYgKHRoaXMuZXh0ZXJuYWwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgYmluYXJ5ID0gb3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5iaW5hcnkgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuYmluYXJ5IDogdHlwZW9mIG1lc3NhZ2UgIT09ICdzdHJpbmcnO1xuXG4gICAgICAgICAgICBuYXRpdmUuY2xpZW50LnNlbmQodGhpcy5leHRlcm5hbCwgbWVzc2FnZSwgYmluYXJ5ID8gV2ViU29ja2V0Q2xpZW50Lk9QQ09ERV9CSU5BUlkgOiBXZWJTb2NrZXRDbGllbnQuT1BDT0RFX1RFWFQsIGNiID8gKCgpID0+IHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKTtcbiAgICAgICAgICAgIH0pIDogdW5kZWZpbmVkLCBjb21wcmVzcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgICAgICAgIGNiKG5ldyBFcnJvcignbm90IG9wZW5lZCcpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsb3NlKGNvZGUsIGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuZXh0ZXJuYWwpIHtcbiAgICAgICAgICAgIG5hdGl2ZS5jbGllbnQuY2xvc2UodGhpcy5leHRlcm5hbCwgY29kZSwgZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmV4dGVybmFsID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgU2VydmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBvcHRpb25zJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5wb3J0ID09PSB1bmRlZmluZWQgJiYgIW9wdGlvbnMuc2VydmVyICYmICFvcHRpb25zLm5vU2VydmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIG9wdGlvbnMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuYXRpdmVPcHRpb25zID0gMDtcbiAgICAgICAgaWYgKG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgbmF0aXZlT3B0aW9ucyB8PSBXZWJTb2NrZXRDbGllbnQuUEVSTUVTU0FHRV9ERUZMQVRFO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZS5zZXJ2ZXJOb0NvbnRleHRUYWtlb3ZlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBuYXRpdmVPcHRpb25zIHw9IFdlYlNvY2tldENsaWVudC5TTElESU5HX0RFRkxBVEVfV0lORE9XO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXJ2ZXJHcm91cCA9IG5hdGl2ZS5zZXJ2ZXIuZ3JvdXAuY3JlYXRlKG5hdGl2ZU9wdGlvbnMsIG9wdGlvbnMubWF4UGF5bG9hZCA9PT0gdW5kZWZpbmVkID8gREVGQVVMVF9QQVlMT0FEX0xJTUlUIDogb3B0aW9ucy5tYXhQYXlsb2FkKTtcblxuICAgICAgICAvLyBjYW4gdGhlc2UgYmUgbWFkZSBwcml2YXRlP1xuICAgICAgICB0aGlzLl91cGdyYWRlQ2FsbGJhY2sgPSBub29wO1xuICAgICAgICB0aGlzLl91cGdyYWRlTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9ub0RlbGF5ID0gb3B0aW9ucy5ub0RlbGF5ID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5ub0RlbGF5O1xuICAgICAgICB0aGlzLl9sYXN0VXBncmFkZUxpc3RlbmVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcGFzc2VkSHR0cFNlcnZlciA9IG9wdGlvbnMuc2VydmVyO1xuXG4gICAgICAgIGlmICghb3B0aW9ucy5ub1NlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5odHRwU2VydmVyID0gb3B0aW9ucy5zZXJ2ZXIgPyBvcHRpb25zLnNlcnZlciA6IGh0dHAuY3JlYXRlU2VydmVyKChyZXF1ZXN0LCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHRvZG86IGRlZmF1bHQgSFRUUCByZXNwb25zZVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmVuZCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBhdGggJiYgKCFvcHRpb25zLnBhdGgubGVuZ3RoIHx8IG9wdGlvbnMucGF0aFswXSAhPT0gJy8nKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucGF0aCA9ICcvJyArIG9wdGlvbnMucGF0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5odHRwU2VydmVyLm9uKCd1cGdyYWRlJywgdGhpcy5fdXBncmFkZUxpc3RlbmVyID0gKChyZXF1ZXN0LCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMucGF0aCB8fCBvcHRpb25zLnBhdGggPT0gcmVxdWVzdC51cmwuc3BsaXQoJz8nKVswXS5zcGxpdCgnIycpWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnZlcmlmeUNsaWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IHJlcXVlc3QuaGVhZGVycy5vcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VjdXJlOiByZXF1ZXN0LmNvbm5lY3Rpb24uYXV0aG9yaXplZCAhPT0gdW5kZWZpbmVkIHx8IHJlcXVlc3QuY29ubmVjdGlvbi5lbmNyeXB0ZWQgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXE6IHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnZlcmlmeUNsaWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnZlcmlmeUNsaWVudChpbmZvLCAocmVzdWx0LCBjb2RlLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVXBncmFkZShyZXF1ZXN0LCBzb2NrZXQsIGhlYWQsIGVtaXRDb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0Q29ubmVjdGlvbihzb2NrZXQsIGNvZGUsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnZlcmlmeUNsaWVudChpbmZvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVVwZ3JhZGUocmVxdWVzdCwgc29ja2V0LCBoZWFkLCBlbWl0Q29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRDb25uZWN0aW9uKHNvY2tldCwgNDAwLCAnQ2xpZW50IHZlcmlmaWNhdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVVwZ3JhZGUocmVxdWVzdCwgc29ja2V0LCBoZWFkLCBlbWl0Q29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGFzdFVwZ3JhZGVMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRDb25uZWN0aW9uKHNvY2tldCwgNDAwLCAnVVJMIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgdGhpcy5odHRwU2VydmVyLm9uKCduZXdMaXN0ZW5lcicsIChldmVudE5hbWUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3VwZ3JhZGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RVcGdyYWRlTGlzdGVuZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5odHRwU2VydmVyLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbmF0aXZlLnNlcnZlci5ncm91cC5vbkRpc2Nvbm5lY3Rpb24odGhpcy5zZXJ2ZXJHcm91cCwgKGV4dGVybmFsLCBjb2RlLCBtZXNzYWdlLCB3ZWJTb2NrZXQpID0+IHtcbiAgICAgICAgICAgIHdlYlNvY2tldC5leHRlcm5hbCA9IG51bGw7XG5cbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHdlYlNvY2tldC5pbnRlcm5hbE9uQ2xvc2UoY29kZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbmF0aXZlLmNsZWFyVXNlckRhdGEoZXh0ZXJuYWwpO1xuICAgICAgICB9KTtcblxuICAgICAgICBuYXRpdmUuc2VydmVyLmdyb3VwLm9uTWVzc2FnZSh0aGlzLnNlcnZlckdyb3VwLCBvblNlcnZlck1lc3NhZ2UpO1xuXG4gICAgICAgIG5hdGl2ZS5zZXJ2ZXIuZ3JvdXAub25QaW5nKHRoaXMuc2VydmVyR3JvdXAsIChtZXNzYWdlLCB3ZWJTb2NrZXQpID0+IHtcbiAgICAgICAgICAgIHdlYlNvY2tldC5vbnBpbmcobWVzc2FnZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG5hdGl2ZS5zZXJ2ZXIuZ3JvdXAub25Qb25nKHRoaXMuc2VydmVyR3JvdXAsIChtZXNzYWdlLCB3ZWJTb2NrZXQpID0+IHtcbiAgICAgICAgICAgIHdlYlNvY2tldC5vbnBvbmcobWVzc2FnZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG5hdGl2ZS5zZXJ2ZXIuZ3JvdXAub25Db25uZWN0aW9uKHRoaXMuc2VydmVyR3JvdXAsIChleHRlcm5hbCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgd2ViU29ja2V0ID0gbmV3IFdlYlNvY2tldChleHRlcm5hbCk7XG5cbiAgICAgICAgICAgIG5hdGl2ZS5zZXRVc2VyRGF0YShleHRlcm5hbCwgd2ViU29ja2V0KTtcbiAgICAgICAgICAgIHRoaXMuX3VwZ3JhZGVDYWxsYmFjayh3ZWJTb2NrZXQpO1xuICAgICAgICAgICAgX3VwZ3JhZGVSZXEgPSBudWxsO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5wb3J0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhvc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmh0dHBTZXJ2ZXIubGlzdGVuKG9wdGlvbnMucG9ydCwgb3B0aW9ucy5ob3N0LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbGlzdGVuaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaHR0cFNlcnZlci5saXN0ZW4ob3B0aW9ucy5wb3J0LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbGlzdGVuaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVVcGdyYWRlKHJlcXVlc3QsIHNvY2tldCwgdXBncmFkZUhlYWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChzb2NrZXQuX2lzTmF0aXZlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXJ2ZXJHcm91cCkge1xuICAgICAgICAgICAgICAgIF91cGdyYWRlUmVxID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGdyYWRlQ2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogbm9vcDtcbiAgICAgICAgICAgICAgICBuYXRpdmUudXBncmFkZSh0aGlzLnNlcnZlckdyb3VwLCBzb2NrZXQuZXh0ZXJuYWwsIHNlY0tleSwgcmVxdWVzdC5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnXSwgcmVxdWVzdC5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXByb3RvY29sJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2VjS2V5ID0gcmVxdWVzdC5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWtleSddO1xuICAgICAgICAgICAgY29uc3Qgc29ja2V0SGFuZGxlID0gc29ja2V0LnNzbCA/IHNvY2tldC5fcGFyZW50Ll9oYW5kbGUgOiBzb2NrZXQuX2hhbmRsZTtcbiAgICAgICAgICAgIGNvbnN0IHNzbFN0YXRlID0gc29ja2V0LnNzbCA/IHNvY2tldC5zc2wuX2V4dGVybmFsIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChzb2NrZXRIYW5kbGUgJiYgc2VjS2V5ICYmIHNlY0tleS5sZW5ndGggPT0gMjQpIHtcbiAgICAgICAgICAgICAgICBzb2NrZXQuc2V0Tm9EZWxheSh0aGlzLl9ub0RlbGF5KTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aWNrZXQgPSBuYXRpdmUudHJhbnNmZXIoc29ja2V0SGFuZGxlLmZkID09PSAtMSA/IHNvY2tldEhhbmRsZSA6IHNvY2tldEhhbmRsZS5mZCwgc3NsU3RhdGUpO1xuICAgICAgICAgICAgICAgIHNvY2tldC5vbignY2xvc2UnLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VydmVyR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF91cGdyYWRlUmVxID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZ3JhZGVDYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBub29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlLnVwZ3JhZGUodGhpcy5zZXJ2ZXJHcm91cCwgdGlja2V0LCBzZWNLZXksIHJlcXVlc3QuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ10sIHJlcXVlc3QuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJyb2FkY2FzdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLnNlcnZlckdyb3VwKSB7XG4gICAgICAgICAgICBuYXRpdmUuc2VydmVyLmdyb3VwLmJyb2FkY2FzdCh0aGlzLnNlcnZlckdyb3VwLCBtZXNzYWdlLCBvcHRpb25zICYmIG9wdGlvbnMuYmluYXJ5IHx8IGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXJ0QXV0b1BpbmcoaW50ZXJ2YWwsIHVzZXJNZXNzYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLnNlcnZlckdyb3VwKSB7XG4gICAgICAgICAgICBuYXRpdmUuc2VydmVyLmdyb3VwLnN0YXJ0QXV0b1BpbmcodGhpcy5zZXJ2ZXJHcm91cCwgaW50ZXJ2YWwsIHVzZXJNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsb3NlKGNiKSB7XG4gICAgICAgIGlmICh0aGlzLl91cGdyYWRlTGlzdGVuZXIgJiYgdGhpcy5odHRwU2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLmh0dHBTZXJ2ZXIucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGUnLCB0aGlzLl91cGdyYWRlTGlzdGVuZXIpO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3Bhc3NlZEh0dHBTZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmh0dHBTZXJ2ZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNlcnZlckdyb3VwKSB7XG4gICAgICAgICAgICBuYXRpdmUuc2VydmVyLmdyb3VwLmNsb3NlKHRoaXMuc2VydmVyR3JvdXApO1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJHcm91cCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBjb21wYXRpYmlsaXR5IGhhY2ssIDE1IHNlY29uZHMgdGltZW91dFxuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgMjAwMDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGNsaWVudHMoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlcnZlckdyb3VwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxlbmd0aDogbmF0aXZlLnNlcnZlci5ncm91cC5nZXRTaXplKHRoaXMuc2VydmVyR3JvdXApLFxuICAgICAgICAgICAgICAgIGZvckVhY2g6ICgoY2IpID0+IHtuYXRpdmUuc2VydmVyLmdyb3VwLmZvckVhY2godGhpcy5zZXJ2ZXJHcm91cCwgY2IpfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbldlYlNvY2tldENsaWVudC5QRVJNRVNTQUdFX0RFRkxBVEUgPSAxO1xuV2ViU29ja2V0Q2xpZW50LlNMSURJTkdfREVGTEFURV9XSU5ET1cgPSAxNjtcbi8vV2ViU29ja2V0Q2xpZW50LlNFUlZFUl9OT19DT05URVhUX1RBS0VPVkVSID0gMjtcbi8vV2ViU29ja2V0Q2xpZW50LkNMSUVOVF9OT19DT05URVhUX1RBS0VPVkVSID0gNDtcbldlYlNvY2tldENsaWVudC5PUENPREVfVEVYVCA9IDE7XG5XZWJTb2NrZXRDbGllbnQuT1BDT0RFX0JJTkFSWSA9IDI7XG5XZWJTb2NrZXRDbGllbnQuT1BDT0RFX1BJTkcgPSA5O1xuV2ViU29ja2V0Q2xpZW50Lk9QRU4gPSAxO1xuV2ViU29ja2V0Q2xpZW50LkNMT1NFRCA9IDA7XG5XZWJTb2NrZXRDbGllbnQuU2VydmVyID0gU2VydmVyO1xuV2ViU29ja2V0Q2xpZW50Lmh0dHAgPSBuYXRpdmUuaHR0cFNlcnZlcjtcbldlYlNvY2tldENsaWVudC5uYXRpdmUgPSBuYXRpdmU7XG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldENsaWVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3V3cy91d3MuanNcbi8vIG1vZHVsZSBpZCA9IDE1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWFwID0ge1xuXHRcIi4vdXdzX2Rhcndpbl81Ny5ub2RlXCI6IDE2MSxcblx0XCIuL3V3c19kYXJ3aW5fNTkubm9kZVwiOiAxNjIsXG5cdFwiLi91d3NfZGFyd2luXzY0Lm5vZGVcIjogMTYzLFxuXHRcIi4vdXdzX2xpbnV4XzU3Lm5vZGVcIjogMTY0LFxuXHRcIi4vdXdzX2xpbnV4XzU5Lm5vZGVcIjogMTY1LFxuXHRcIi4vdXdzX2xpbnV4XzY0Lm5vZGVcIjogMTY2LFxuXHRcIi4vdXdzX3dpbjMyXzU3Lm5vZGVcIjogMTY3LFxuXHRcIi4vdXdzX3dpbjMyXzU5Lm5vZGVcIjogMTY4LFxuXHRcIi4vdXdzX3dpbjMyXzY0Lm5vZGVcIjogMTY5XG59O1xuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpKTtcbn07XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdHZhciBpZCA9IG1hcFtyZXFdO1xuXHRpZighKGlkICsgMSkpIC8vIGNoZWNrIGZvciBudW1iZXIgb3Igc3RyaW5nXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJy5cIik7XG5cdHJldHVybiBpZDtcbn07XG53ZWJwYWNrQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0NvbnRleHRLZXlzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn07XG53ZWJwYWNrQ29udGV4dC5yZXNvbHZlID0gd2VicGFja0NvbnRleHRSZXNvbHZlO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbndlYnBhY2tDb250ZXh0LmlkID0gMTYwO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3V3cyBeXFwuXFwvdXdzXy4qJFxuLy8gbW9kdWxlIGlkID0gMTYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgV2ViU29ja2V0ID0gcmVxdWlyZSgnLi9saWIvd2Vic29ja2V0Jyk7XG5cbldlYlNvY2tldC5TZXJ2ZXIgPSByZXF1aXJlKCcuL2xpYi93ZWJzb2NrZXQtc2VydmVyJyk7XG5XZWJTb2NrZXQuUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2xpYi9yZWNlaXZlcicpO1xuV2ViU29ja2V0LlNlbmRlciA9IHJlcXVpcmUoJy4vbGliL3NlbmRlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3dzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaHR0cHNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJodHRwc1wiXG4vLyBtb2R1bGUgaWQgPSAxNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidGxzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidGxzXCJcbi8vIG1vZHVsZSBpZCA9IDE3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIFF1ZXVlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFF1ZXVlKSkge1xuICAgIHJldHVybiBuZXcgUXVldWUob3B0aW9ucyk7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5jb25jdXJyZW5jeSA9IG9wdGlvbnMuY29uY3VycmVuY3kgfHwgSW5maW5pdHk7XG4gIHRoaXMucGVuZGluZyA9IDA7XG4gIHRoaXMuam9icyA9IFtdO1xuICB0aGlzLmNicyA9IFtdO1xuICB0aGlzLl9kb25lID0gZG9uZS5iaW5kKHRoaXMpO1xufVxuXG52YXIgYXJyYXlBZGRNZXRob2RzID0gW1xuICAncHVzaCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZSdcbl07XG5cbmFycmF5QWRkTWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBRdWV1ZS5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtZXRob2RSZXN1bHQgPSBBcnJheS5wcm90b3R5cGVbbWV0aG9kXS5hcHBseSh0aGlzLmpvYnMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5fcnVuKCk7XG4gICAgcmV0dXJuIG1ldGhvZFJlc3VsdDtcbiAgfTtcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUXVldWUucHJvdG90eXBlLCAnbGVuZ3RoJywge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBlbmRpbmcgKyB0aGlzLmpvYnMubGVuZ3RoO1xuICB9XG59KTtcblxuUXVldWUucHJvdG90eXBlLl9ydW4gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucGVuZGluZyA9PT0gdGhpcy5jb25jdXJyZW5jeSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodGhpcy5qb2JzLmxlbmd0aCkge1xuICAgIHZhciBqb2IgPSB0aGlzLmpvYnMuc2hpZnQoKTtcbiAgICB0aGlzLnBlbmRpbmcrKztcbiAgICBqb2IodGhpcy5fZG9uZSk7XG4gICAgdGhpcy5fcnVuKCk7XG4gIH1cblxuICBpZiAodGhpcy5wZW5kaW5nID09PSAwKSB7XG4gICAgd2hpbGUgKHRoaXMuY2JzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdmFyIGNiID0gdGhpcy5jYnMucG9wKCk7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKTtcbiAgICB9XG4gIH1cbn07XG5cblF1ZXVlLnByb3RvdHlwZS5vbkRvbmUgPSBmdW5jdGlvbihjYikge1xuICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5jYnMucHVzaChjYik7XG4gICAgdGhpcy5fcnVuKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRvbmUoKSB7XG4gIHRoaXMucGVuZGluZy0tO1xuICB0aGlzLl9ydW4oKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBRdWV1ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2FzeW5jLWxpbWl0ZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBBIHJlZmVyZW5jZSB0byB0aGUgdGFyZ2V0IHRvIHdoaWNoIHRoZSBldmVudCB3YXMgZGlzcGF0Y2hlZFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgdGFyZ2V0KSB7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIG1lc3NhZ2UgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIE1lc3NhZ2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgTWVzc2FnZUV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcnxBcnJheUJ1ZmZlcnxCdWZmZXJbXSl9IGRhdGEgVGhlIHJlY2VpdmVkIGRhdGFcbiAgICogQHBhcmFtIHtXZWJTb2NrZXR9IHRhcmdldCBBIHJlZmVyZW5jZSB0byB0aGUgdGFyZ2V0IHRvIHdoaWNoIHRoZSBldmVudCB3YXMgZGlzcGF0Y2hlZFxuICAgKi9cbiAgY29uc3RydWN0b3IoZGF0YSwgdGFyZ2V0KSB7XG4gICAgc3VwZXIoJ21lc3NhZ2UnLCB0YXJnZXQpO1xuXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGNsb3NlIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDbG9zZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBDbG9zZUV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIHN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGJlaW5nIGNsb3NlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uIEEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGNsb3NpbmdcbiAgICogQHBhcmFtIHtXZWJTb2NrZXR9IHRhcmdldCBBIHJlZmVyZW5jZSB0byB0aGUgdGFyZ2V0IHRvIHdoaWNoIHRoZSBldmVudCB3YXMgZGlzcGF0Y2hlZFxuICAgKi9cbiAgY29uc3RydWN0b3IoY29kZSwgcmVhc29uLCB0YXJnZXQpIHtcbiAgICBzdXBlcignY2xvc2UnLCB0YXJnZXQpO1xuXG4gICAgdGhpcy53YXNDbGVhbiA9IHRhcmdldC5fY2xvc2VGcmFtZVJlY2VpdmVkICYmIHRhcmdldC5fY2xvc2VGcmFtZVNlbnQ7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBvcGVuIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBPcGVuRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYE9wZW5FdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViU29ja2V0fSB0YXJnZXQgQSByZWZlcmVuY2UgdG8gdGhlIHRhcmdldCB0byB3aGljaCB0aGUgZXZlbnQgd2FzIGRpc3BhdGNoZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRhcmdldCkge1xuICAgIHN1cGVyKCdvcGVuJywgdGFyZ2V0KTtcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBlcnJvciBldmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgRXJyb3JFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgRXJyb3JFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlcnJvciBUaGUgZXJyb3IgdGhhdCBnZW5lcmF0ZWQgdGhpcyBldmVudFxuICAgKiBAcGFyYW0ge1dlYlNvY2tldH0gdGFyZ2V0IEEgcmVmZXJlbmNlIHRvIHRoZSB0YXJnZXQgdG8gd2hpY2ggdGhlIGV2ZW50IHdhcyBkaXNwYXRjaGVkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlcnJvciwgdGFyZ2V0KSB7XG4gICAgc3VwZXIoJ2Vycm9yJywgdGFyZ2V0KTtcblxuICAgIHRoaXMubWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBwcm92aWRlcyBtZXRob2RzIGZvciBlbXVsYXRpbmcgdGhlIGBFdmVudFRhcmdldGAgaW50ZXJmYWNlLiBJdCdzIG5vdFxuICogbWVhbnQgdG8gYmUgdXNlZCBkaXJlY3RseS5cbiAqXG4gKiBAbWl4aW5cbiAqL1xuY29uc3QgRXZlbnRUYXJnZXQgPSB7XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhbiBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gYWRkXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZEV2ZW50TGlzdGVuZXIobWV0aG9kLCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHJldHVybjtcblxuICAgIGZ1bmN0aW9uIG9uTWVzc2FnZShkYXRhKSB7XG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIG5ldyBNZXNzYWdlRXZlbnQoZGF0YSwgdGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQ2xvc2UoY29kZSwgbWVzc2FnZSkge1xuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBuZXcgQ2xvc2VFdmVudChjb2RlLCBtZXNzYWdlLCB0aGlzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25FcnJvcihlcnJvcikge1xuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBuZXcgRXJyb3JFdmVudChlcnJvciwgdGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uT3BlbigpIHtcbiAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgbmV3IE9wZW5FdmVudCh0aGlzKSk7XG4gICAgfVxuXG4gICAgaWYgKG1ldGhvZCA9PT0gJ21lc3NhZ2UnKSB7XG4gICAgICBvbk1lc3NhZ2UuX2xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICB0aGlzLm9uKG1ldGhvZCwgb25NZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gJ2Nsb3NlJykge1xuICAgICAgb25DbG9zZS5fbGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgIHRoaXMub24obWV0aG9kLCBvbkNsb3NlKTtcbiAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gJ2Vycm9yJykge1xuICAgICAgb25FcnJvci5fbGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgIHRoaXMub24obWV0aG9kLCBvbkVycm9yKTtcbiAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gJ29wZW4nKSB7XG4gICAgICBvbk9wZW4uX2xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICB0aGlzLm9uKG1ldGhvZCwgb25PcGVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbihtZXRob2QsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byByZW1vdmVcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihtZXRob2QsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnMobWV0aG9kKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldID09PSBsaXN0ZW5lciB8fCBsaXN0ZW5lcnNbaV0uX2xpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKG1ldGhvZCwgbGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRUYXJnZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy93cy9saWIvZXZlbnQtdGFyZ2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3QgZXh0ZW5zaW9uID0gcmVxdWlyZSgnLi9leHRlbnNpb24nKTtcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIFdlYlNvY2tldCBzZXJ2ZXIuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldFNlcnZlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBgV2ViU29ja2V0U2VydmVyYCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmhvc3QgVGhlIGhvc3RuYW1lIHdoZXJlIHRvIGJpbmQgdGhlIHNlcnZlclxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wb3J0IFRoZSBwb3J0IHdoZXJlIHRvIGJpbmQgdGhlIHNlcnZlclxuICAgKiBAcGFyYW0ge2h0dHAuU2VydmVyfSBvcHRpb25zLnNlcnZlciBBIHByZS1jcmVhdGVkIEhUVFAvUyBzZXJ2ZXIgdG8gdXNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMudmVyaWZ5Q2xpZW50IEFuIGhvb2sgdG8gcmVqZWN0IGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzIEFuIGhvb2sgdG8gaGFuZGxlIHByb3RvY29sc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5wYXRoIEFjY2VwdCBvbmx5IGNvbm5lY3Rpb25zIG1hdGNoaW5nIHRoaXMgcGF0aFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMubm9TZXJ2ZXIgRW5hYmxlIG5vIHNlcnZlciBtb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5jbGllbnRUcmFja2luZyBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gdHJhY2sgY2xpZW50c1xuICAgKiBAcGFyYW0geyhCb29sZWFufE9iamVjdCl9IG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgRW5hYmxlL2Rpc2FibGUgcGVybWVzc2FnZS1kZWZsYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm1heFBheWxvYWQgVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIHNpemVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQSBsaXN0ZW5lciBmb3IgdGhlIGBsaXN0ZW5pbmdgIGV2ZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHtcbiAgICAgICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXG4gICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlOiBmYWxzZSxcbiAgICAgICAgaGFuZGxlUHJvdG9jb2xzOiBudWxsLFxuICAgICAgICBjbGllbnRUcmFja2luZzogdHJ1ZSxcbiAgICAgICAgdmVyaWZ5Q2xpZW50OiBudWxsLFxuICAgICAgICBub1NlcnZlcjogZmFsc2UsXG4gICAgICAgIGJhY2tsb2c6IG51bGwsIC8vIHVzZSBkZWZhdWx0ICg1MTEgYXMgaW1wbGVtZW50ZWQgaW4gbmV0LmpzKVxuICAgICAgICBzZXJ2ZXI6IG51bGwsXG4gICAgICAgIGhvc3Q6IG51bGwsXG4gICAgICAgIHBhdGg6IG51bGwsXG4gICAgICAgIHBvcnQ6IG51bGxcbiAgICAgIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcblxuICAgIGlmIChvcHRpb25zLnBvcnQgPT0gbnVsbCAmJiAhb3B0aW9ucy5zZXJ2ZXIgJiYgIW9wdGlvbnMubm9TZXJ2ZXIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdPbmUgb2YgdGhlIFwicG9ydFwiLCBcInNlcnZlclwiLCBvciBcIm5vU2VydmVyXCIgb3B0aW9ucyBtdXN0IGJlIHNwZWNpZmllZCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucG9ydCAhPSBudWxsKSB7XG4gICAgICB0aGlzLl9zZXJ2ZXIgPSBodHRwLmNyZWF0ZVNlcnZlcigocmVxLCByZXMpID0+IHtcbiAgICAgICAgY29uc3QgYm9keSA9IGh0dHAuU1RBVFVTX0NPREVTWzQyNl07XG5cbiAgICAgICAgcmVzLndyaXRlSGVhZCg0MjYsIHtcbiAgICAgICAgICAnQ29udGVudC1MZW5ndGgnOiBib2R5Lmxlbmd0aCxcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ3RleHQvcGxhaW4nXG4gICAgICAgIH0pO1xuICAgICAgICByZXMuZW5kKGJvZHkpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zZXJ2ZXIubGlzdGVuKFxuICAgICAgICBvcHRpb25zLnBvcnQsXG4gICAgICAgIG9wdGlvbnMuaG9zdCxcbiAgICAgICAgb3B0aW9ucy5iYWNrbG9nLFxuICAgICAgICBjYWxsYmFja1xuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2VydmVyKSB7XG4gICAgICB0aGlzLl9zZXJ2ZXIgPSBvcHRpb25zLnNlcnZlcjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc2VydmVyKSB7XG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSBhZGRMaXN0ZW5lcnModGhpcy5fc2VydmVyLCB7XG4gICAgICAgIGxpc3RlbmluZzogdGhpcy5lbWl0LmJpbmQodGhpcywgJ2xpc3RlbmluZycpLFxuICAgICAgICBlcnJvcjogdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Vycm9yJyksXG4gICAgICAgIHVwZ3JhZGU6IChyZXEsIHNvY2tldCwgaGVhZCkgPT4ge1xuICAgICAgICAgIHRoaXMuaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgKHdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3Rpb24nLCB3cywgcmVxKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPT09IHRydWUpIG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5jbGllbnRUcmFja2luZykgdGhpcy5jbGllbnRzID0gbmV3IFNldCgpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYm91bmQgYWRkcmVzcywgdGhlIGFkZHJlc3MgZmFtaWx5IG5hbWUsIGFuZCBwb3J0IG9mIHRoZSBzZXJ2ZXJcbiAgICogYXMgcmVwb3J0ZWQgYnkgdGhlIG9wZXJhdGluZyBzeXN0ZW0gaWYgbGlzdGVuaW5nIG9uIGFuIElQIHNvY2tldC5cbiAgICogSWYgdGhlIHNlcnZlciBpcyBsaXN0ZW5pbmcgb24gYSBwaXBlIG9yIFVOSVggZG9tYWluIHNvY2tldCwgdGhlIG5hbWUgaXNcbiAgICogcmV0dXJuZWQgYXMgYSBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4geyhPYmplY3R8U3RyaW5nfG51bGwpfSBUaGUgYWRkcmVzcyBvZiB0aGUgc2VydmVyXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZHJlc3MoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ub1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2VydmVyIGlzIG9wZXJhdGluZyBpbiBcIm5vU2VydmVyXCIgbW9kZScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fc2VydmVyKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5fc2VydmVyLmFkZHJlc3MoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZShjYikge1xuICAgIGlmIChjYikgdGhpcy5vbmNlKCdjbG9zZScsIGNiKTtcblxuICAgIC8vXG4gICAgLy8gVGVybWluYXRlIGFsbCBhc3NvY2lhdGVkIGNsaWVudHMuXG4gICAgLy9cbiAgICBpZiAodGhpcy5jbGllbnRzKSB7XG4gICAgICBmb3IgKGNvbnN0IGNsaWVudCBvZiB0aGlzLmNsaWVudHMpIGNsaWVudC50ZXJtaW5hdGUoKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZXJ2ZXIgPSB0aGlzLl9zZXJ2ZXI7XG5cbiAgICBpZiAoc2VydmVyKSB7XG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XG5cbiAgICAgIC8vXG4gICAgICAvLyBDbG9zZSB0aGUgaHR0cCBzZXJ2ZXIgaWYgaXQgd2FzIGludGVybmFsbHkgY3JlYXRlZC5cbiAgICAgIC8vXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBvcnQgIT0gbnVsbCkge1xuICAgICAgICBzZXJ2ZXIuY2xvc2UoKCkgPT4gdGhpcy5lbWl0KCdjbG9zZScpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWUgaWYgYSBnaXZlbiByZXF1ZXN0IHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoaXMgc2VydmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgUmVxdWVzdCBvYmplY3QgdG8gaW5zcGVjdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHJlcXVlc3QgaXMgdmFsaWQsIGVsc2UgYGZhbHNlYFxuICAgKiBAcHVibGljXG4gICAqL1xuICBzaG91bGRIYW5kbGUocmVxKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYXRoKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHJlcS51cmwuaW5kZXhPZignPycpO1xuICAgICAgY29uc3QgcGF0aG5hbWUgPSBpbmRleCAhPT0gLTEgPyByZXEudXJsLnNsaWNlKDAsIGluZGV4KSA6IHJlcS51cmw7XG5cbiAgICAgIGlmIChwYXRobmFtZSAhPT0gdGhpcy5vcHRpb25zLnBhdGgpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBIVFRQIFVwZ3JhZGUgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge25ldC5Tb2NrZXR9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGUgc2VydmVyIGFuZCBjbGllbnRcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQsIGNiKSB7XG4gICAgc29ja2V0Lm9uKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuXG4gICAgY29uc3QgdmVyc2lvbiA9ICtyZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC12ZXJzaW9uJ107XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuXG4gICAgaWYgKFxuICAgICAgcmVxLm1ldGhvZCAhPT0gJ0dFVCcgfHxcbiAgICAgIHJlcS5oZWFkZXJzLnVwZ3JhZGUudG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcgfHxcbiAgICAgICFyZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXknXSB8fFxuICAgICAgKHZlcnNpb24gIT09IDggJiYgdmVyc2lvbiAhPT0gMTMpIHx8XG4gICAgICAhdGhpcy5zaG91bGRIYW5kbGUocmVxKVxuICAgICkge1xuICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNDAwKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcbiAgICAgICAgdGhpcy5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlLFxuICAgICAgICB0cnVlLFxuICAgICAgICB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZFxuICAgICAgKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb2ZmZXJzID0gZXh0ZW5zaW9uLnBhcnNlKHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnXSk7XG5cbiAgICAgICAgaWYgKG9mZmVyc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xuICAgICAgICAgIGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPSBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgY2xpZW50IHZlcmlmaWNhdGlvbiBoYW5kbGVyLlxuICAgIC8vXG4gICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQpIHtcbiAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgIG9yaWdpbjpcbiAgICAgICAgICByZXEuaGVhZGVyc1tgJHt2ZXJzaW9uID09PSA4ID8gJ3NlYy13ZWJzb2NrZXQtb3JpZ2luJyA6ICdvcmlnaW4nfWBdLFxuICAgICAgICBzZWN1cmU6ICEhKHJlcS5jb25uZWN0aW9uLmF1dGhvcml6ZWQgfHwgcmVxLmNvbm5lY3Rpb24uZW5jcnlwdGVkKSxcbiAgICAgICAgcmVxXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudChpbmZvLCAodmVyaWZpZWQsIGNvZGUsIG1lc3NhZ2UsIGhlYWRlcnMpID0+IHtcbiAgICAgICAgICBpZiAoIXZlcmlmaWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlIHx8IDQwMSwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoZXh0ZW5zaW9ucywgcmVxLCBzb2NrZXQsIGhlYWQsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KGluZm8pKSByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA0MDEpO1xuICAgIH1cblxuICAgIHRoaXMuY29tcGxldGVVcGdyYWRlKGV4dGVuc2lvbnMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogVXBncmFkZSB0aGUgY29ubmVjdGlvbiB0byBXZWJTb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBhY2NlcHRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBUaGUgcmVxdWVzdCBvYmplY3RcbiAgICogQHBhcmFtIHtuZXQuU29ja2V0fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29tcGxldGVVcGdyYWRlKGV4dGVuc2lvbnMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIC8vXG4gICAgLy8gRGVzdHJveSB0aGUgc29ja2V0IGlmIHRoZSBjbGllbnQgaGFzIGFscmVhZHkgc2VudCBhIEZJTiBwYWNrZXQuXG4gICAgLy9cbiAgICBpZiAoIXNvY2tldC5yZWFkYWJsZSB8fCAhc29ja2V0LndyaXRhYmxlKSByZXR1cm4gc29ja2V0LmRlc3Ryb3koKTtcblxuICAgIGNvbnN0IGtleSA9IGNyeXB0b1xuICAgICAgLmNyZWF0ZUhhc2goJ3NoYTEnKVxuICAgICAgLnVwZGF0ZShyZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXknXSArIGNvbnN0YW50cy5HVUlELCAnYmluYXJ5JylcbiAgICAgIC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG4gICAgY29uc3QgaGVhZGVycyA9IFtcbiAgICAgICdIVFRQLzEuMSAxMDEgU3dpdGNoaW5nIFByb3RvY29scycsXG4gICAgICAnVXBncmFkZTogd2Vic29ja2V0JyxcbiAgICAgICdDb25uZWN0aW9uOiBVcGdyYWRlJyxcbiAgICAgIGBTZWMtV2ViU29ja2V0LUFjY2VwdDogJHtrZXl9YFxuICAgIF07XG5cbiAgICBjb25zdCB3cyA9IG5ldyBXZWJTb2NrZXQobnVsbCk7XG4gICAgdmFyIHByb3RvY29sID0gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnXTtcblxuICAgIGlmIChwcm90b2NvbCkge1xuICAgICAgcHJvdG9jb2wgPSBwcm90b2NvbC50cmltKCkuc3BsaXQoLyAqLCAqLyk7XG5cbiAgICAgIC8vXG4gICAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgcHJvdG9jb2wgc2VsZWN0aW9uIGhhbmRsZXIuXG4gICAgICAvL1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oYW5kbGVQcm90b2NvbHMpIHtcbiAgICAgICAgcHJvdG9jb2wgPSB0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzKHByb3RvY29sLCByZXEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvdG9jb2wgPSBwcm90b2NvbFswXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3RvY29sKSB7XG4gICAgICAgIGhlYWRlcnMucHVzaChgU2VjLVdlYlNvY2tldC1Qcm90b2NvbDogJHtwcm90b2NvbH1gKTtcbiAgICAgICAgd3MucHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgY29uc3QgcGFyYW1zID0gZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXS5wYXJhbXM7XG4gICAgICBjb25zdCB2YWx1ZSA9IGV4dGVuc2lvbi5mb3JtYXQoe1xuICAgICAgICBbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV06IFtwYXJhbXNdXG4gICAgICB9KTtcbiAgICAgIGhlYWRlcnMucHVzaChgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zOiAke3ZhbHVlfWApO1xuICAgICAgd3MuX2V4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gQWxsb3cgZXh0ZXJuYWwgbW9kaWZpY2F0aW9uL2luc3BlY3Rpb24gb2YgaGFuZHNoYWtlIGhlYWRlcnMuXG4gICAgLy9cbiAgICB0aGlzLmVtaXQoJ2hlYWRlcnMnLCBoZWFkZXJzLCByZXEpO1xuXG4gICAgc29ja2V0LndyaXRlKGhlYWRlcnMuY29uY2F0KCdcXHJcXG4nKS5qb2luKCdcXHJcXG4nKSk7XG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuXG4gICAgd3Muc2V0U29ja2V0KHNvY2tldCwgaGVhZCwgdGhpcy5vcHRpb25zLm1heFBheWxvYWQpO1xuXG4gICAgaWYgKHRoaXMuY2xpZW50cykge1xuICAgICAgdGhpcy5jbGllbnRzLmFkZCh3cyk7XG4gICAgICB3cy5vbignY2xvc2UnLCAoKSA9PiB0aGlzLmNsaWVudHMuZGVsZXRlKHdzKSk7XG4gICAgfVxuXG4gICAgY2Iod3MpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0U2VydmVyO1xuXG4vKipcbiAqIEFkZCBldmVudCBsaXN0ZW5lcnMgb24gYW4gYEV2ZW50RW1pdHRlcmAgdXNpbmcgYSBtYXAgb2YgPGV2ZW50LCBsaXN0ZW5lcj5cbiAqIHBhaXJzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBzZXJ2ZXIgVGhlIGV2ZW50IGVtaXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0LjxTdHJpbmcsIEZ1bmN0aW9uPn0gbWFwIFRoZSBsaXN0ZW5lcnMgdG8gYWRkXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgcmVtb3ZlIHRoZSBhZGRlZCBsaXN0ZW5lcnMgd2hlbiBjYWxsZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVycyhzZXJ2ZXIsIG1hcCkge1xuICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKG1hcCkpIHNlcnZlci5vbihldmVudCwgbWFwW2V2ZW50XSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKG1hcCkpIHtcbiAgICAgIHNlcnZlci5yZW1vdmVMaXN0ZW5lcihldmVudCwgbWFwW2V2ZW50XSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEVtaXQgYSBgJ2Nsb3NlJ2AgZXZlbnQgb24gYW4gYEV2ZW50RW1pdHRlcmAuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IHNlcnZlciBUaGUgZXZlbnQgZW1pdHRlclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW1pdENsb3NlKHNlcnZlcikge1xuICBzZXJ2ZXIuZW1pdCgnY2xvc2UnKTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgcHJlbWF0dXJlIHNvY2tldCBlcnJvcnMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FcnJvcigpIHtcbiAgdGhpcy5kZXN0cm95KCk7XG59XG5cbi8qKlxuICogQ2xvc2UgdGhlIGNvbm5lY3Rpb24gd2hlbiBwcmVjb25kaXRpb25zIGFyZSBub3QgZnVsZmlsbGVkLlxuICpcbiAqIEBwYXJhbSB7bmV0LlNvY2tldH0gc29ja2V0IFRoZSBzb2NrZXQgb2YgdGhlIHVwZ3JhZGUgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gVGhlIEhUVFAgcmVzcG9uc2UgYm9keVxuICogQHBhcmFtIHtPYmplY3R9IFtoZWFkZXJzXSBBZGRpdGlvbmFsIEhUVFAgcmVzcG9uc2UgaGVhZGVyc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSB7XG4gIGlmIChzb2NrZXQud3JpdGFibGUpIHtcbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCBodHRwLlNUQVRVU19DT0RFU1tjb2RlXTtcbiAgICBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHtcbiAgICAgICAgQ29ubmVjdGlvbjogJ2Nsb3NlJyxcbiAgICAgICAgJ0NvbnRlbnQtdHlwZSc6ICd0ZXh0L2h0bWwnLFxuICAgICAgICAnQ29udGVudC1MZW5ndGgnOiBCdWZmZXIuYnl0ZUxlbmd0aChtZXNzYWdlKVxuICAgICAgfSxcbiAgICAgIGhlYWRlcnNcbiAgICApO1xuXG4gICAgc29ja2V0LndyaXRlKFxuICAgICAgYEhUVFAvMS4xICR7Y29kZX0gJHtodHRwLlNUQVRVU19DT0RFU1tjb2RlXX1cXHJcXG5gICtcbiAgICAgICAgT2JqZWN0LmtleXMoaGVhZGVycylcbiAgICAgICAgICAubWFwKChoKSA9PiBgJHtofTogJHtoZWFkZXJzW2hdfWApXG4gICAgICAgICAgLmpvaW4oJ1xcclxcbicpICtcbiAgICAgICAgJ1xcclxcblxcclxcbicgK1xuICAgICAgICBtZXNzYWdlXG4gICAgKTtcbiAgfVxuXG4gIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcbiAgc29ja2V0LmRlc3Ryb3koKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQtc2VydmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XCJfYXJnc1wiOltbXCJzb2NrZXQuaW8tY2xpZW50QDIuMi4wXCIsXCJDOlxcXFx3b3Jrc3BhY2VcXFxcZ2FtZVxcXFxzZXJ2ZXJcIl1dLFwiX2Zyb21cIjpcInNvY2tldC5pby1jbGllbnRAMi4yLjBcIixcIl9pZFwiOlwic29ja2V0LmlvLWNsaWVudEAyLjIuMFwiLFwiX2luQnVuZGxlXCI6ZmFsc2UsXCJfaW50ZWdyaXR5XCI6XCJzaGE1MTItNTZacmtURGJkVExtQkl5ZkZZZXNnT3hzamNMbndBS29ONENpUHlUVmtNUWozelRVaDBRQXgzR2J2SXZMcEZFT3ZRV3U5Mnl5V0lDeEIwdTd3a1ZiWUE9PVwiLFwiX2xvY2F0aW9uXCI6XCIvc29ja2V0LmlvLWNsaWVudFwiLFwiX3BoYW50b21DaGlsZHJlblwiOntcIm1zXCI6XCIyLjAuMFwifSxcIl9yZXF1ZXN0ZWRcIjp7XCJ0eXBlXCI6XCJ2ZXJzaW9uXCIsXCJyZWdpc3RyeVwiOnRydWUsXCJyYXdcIjpcInNvY2tldC5pby1jbGllbnRAMi4yLjBcIixcIm5hbWVcIjpcInNvY2tldC5pby1jbGllbnRcIixcImVzY2FwZWROYW1lXCI6XCJzb2NrZXQuaW8tY2xpZW50XCIsXCJyYXdTcGVjXCI6XCIyLjIuMFwiLFwic2F2ZVNwZWNcIjpudWxsLFwiZmV0Y2hTcGVjXCI6XCIyLjIuMFwifSxcIl9yZXF1aXJlZEJ5XCI6W1wiL3NvY2tldC5pb1wiXSxcIl9yZXNvbHZlZFwiOlwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvc29ja2V0LmlvLWNsaWVudC8tL3NvY2tldC5pby1jbGllbnQtMi4yLjAudGd6XCIsXCJfc3BlY1wiOlwiMi4yLjBcIixcIl93aGVyZVwiOlwiQzpcXFxcd29ya3NwYWNlXFxcXGdhbWVcXFxcc2VydmVyXCIsXCJidWdzXCI6e1widXJsXCI6XCJodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9zb2NrZXQuaW8tY2xpZW50L2lzc3Vlc1wifSxcImNvbnRyaWJ1dG9yc1wiOlt7XCJuYW1lXCI6XCJHdWlsbGVybW8gUmF1Y2hcIixcImVtYWlsXCI6XCJyYXVjaGdAZ21haWwuY29tXCJ9LHtcIm5hbWVcIjpcIkFybm91dCBLYXplbWllclwiLFwiZW1haWxcIjpcImluZm9AM3JkLWVkZW4uY29tXCJ9LHtcIm5hbWVcIjpcIlZsYWRpbWlyIERyb25uaWtvdlwiLFwiZW1haWxcIjpcImRyb25uaWtvdkBnbWFpbC5jb21cIn0se1wibmFtZVwiOlwiRWluYXIgT3R0byBTdGFuZ3Zpa1wiLFwiZW1haWxcIjpcImVpbmFyb3NAZ21haWwuY29tXCJ9XSxcImRlcGVuZGVuY2llc1wiOntcImJhY2tvMlwiOlwiMS4wLjJcIixcImJhc2U2NC1hcnJheWJ1ZmZlclwiOlwiMC4xLjVcIixcImNvbXBvbmVudC1iaW5kXCI6XCIxLjAuMFwiLFwiY29tcG9uZW50LWVtaXR0ZXJcIjpcIjEuMi4xXCIsXCJkZWJ1Z1wiOlwifjMuMS4wXCIsXCJlbmdpbmUuaW8tY2xpZW50XCI6XCJ+My4zLjFcIixcImhhcy1iaW5hcnkyXCI6XCJ+MS4wLjJcIixcImhhcy1jb3JzXCI6XCIxLjEuMFwiLFwiaW5kZXhvZlwiOlwiMC4wLjFcIixcIm9iamVjdC1jb21wb25lbnRcIjpcIjAuMC4zXCIsXCJwYXJzZXFzXCI6XCIwLjAuNVwiLFwicGFyc2V1cmlcIjpcIjAuMC41XCIsXCJzb2NrZXQuaW8tcGFyc2VyXCI6XCJ+My4zLjBcIixcInRvLWFycmF5XCI6XCIwLjEuNFwifSxcImRlc2NyaXB0aW9uXCI6XCJbIVtCdWlsZCBTdGF0dXNdKGh0dHBzOi8vc2VjdXJlLnRyYXZpcy1jaS5vcmcvc29ja2V0aW8vc29ja2V0LmlvLWNsaWVudC5zdmc/YnJhbmNoPW1hc3RlcildKGh0dHA6Ly90cmF2aXMtY2kub3JnL3NvY2tldGlvL3NvY2tldC5pby1jbGllbnQpIFshW0RlcGVuZGVuY3kgU3RhdHVzXShodHRwczovL2RhdmlkLWRtLm9yZy9zb2NrZXRpby9zb2NrZXQuaW8tY2xpZW50LnN2ZyldKGh0dHBzOi8vZGF2aWQtZG0ub3JnL3NvY2tldGlvL3NvY2tldC5pby1jbGllbnQpIFshW2RldkRlcGVuZGVuY3kgU3RhdHVzXShodHRwczovL2RhdmlkLWRtLm9yZy9zb2NrZXRpby9zb2NrZXQuaW8tY2xpZW50L2Rldi1zdGF0dXMuc3ZnKV0oaHR0cHM6Ly9kYXZpZC1kbS5vcmcvc29ja2V0aW8vc29ja2V0LmlvLWNsaWVudCNpbmZvPWRldkRlcGVuZGVuY2llcykgWyFbTlBNIHZlcnNpb25dKGh0dHBzOi8vYmFkZ2UuZnVyeS5pby9qcy9zb2NrZXQuaW8tY2xpZW50LnN2ZyldKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3NvY2tldC5pby1jbGllbnQpICFbRG93bmxvYWRzXShodHRwOi8vaW1nLnNoaWVsZHMuaW8vbnBtL2RtL3NvY2tldC5pby1jbGllbnQuc3ZnP3N0eWxlPWZsYXQpIFshW10oaHR0cDovL3NsYWNrLnNvY2tldC5pby9iYWRnZS5zdmc/KV0oaHR0cDovL3NsYWNrLnNvY2tldC5pbylcIixcImRldkRlcGVuZGVuY2llc1wiOntcImJhYmVsLWNvcmVcIjpcIl42LjI0LjFcIixcImJhYmVsLWVzbGludFwiOlwiNC4xLjdcIixcImJhYmVsLWxvYWRlclwiOlwiNy4wLjBcIixcImJhYmVsLXByZXNldC1lczIwMTVcIjpcIjYuMjQuMVwiLFwiY29uY2F0LXN0cmVhbVwiOlwiXjEuNi4wXCIsXCJkZXJlcXVpcmVcIjpcIl4yLjAuNlwiLFwiZXNsaW50LWNvbmZpZy1zdGFuZGFyZFwiOlwiNC40LjBcIixcImVzbGludC1wbHVnaW4tc3RhbmRhcmRcIjpcIjEuMy4xXCIsXCJleHBlY3QuanNcIjpcIjAuMy4xXCIsXCJndWxwXCI6XCJeMy45LjFcIixcImd1bHAtZXNsaW50XCI6XCIxLjEuMVwiLFwiZ3VscC1maWxlXCI6XCJeMC4zLjBcIixcImd1bHAtaXN0YW5idWxcIjpcIl4xLjEuMVwiLFwiZ3VscC1tb2NoYVwiOlwiXjQuMy4xXCIsXCJndWxwLXRhc2stbGlzdGluZ1wiOlwiMS4wLjFcIixcImltcG9ydHMtbG9hZGVyXCI6XCJeMC43LjFcIixcImlzdGFuYnVsXCI6XCJeMC40LjVcIixcIm1vY2hhXCI6XCJeMy4zLjBcIixcInNvY2tldC5pb1wiOlwiMi4yLjBcIixcInNvY2tldC5pby1icm93c2Vyc1wiOlwiXjEuMC4wXCIsXCJzdHJpcC1sb2FkZXJcIjpcIjAuMS4yXCIsXCJ0ZXh0LWJsb2ItYnVpbGRlclwiOlwiMC4wLjFcIixcIndlYnBhY2stbWVyZ2VcIjpcIjQuMS4yXCIsXCJ3ZWJwYWNrLXN0cmVhbVwiOlwiMy4yLjBcIixcInp1dWxcIjpcIn4zLjExLjFcIixcInp1dWwtYnVpbGRlci13ZWJwYWNrXCI6XCJeMS4yLjBcIixcInp1dWwtbmdyb2tcIjpcIjQuMC4wXCJ9LFwiZmlsZXNcIjpbXCJsaWIvXCIsXCJkaXN0L1wiXSxcImhvbWVwYWdlXCI6XCJodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9zb2NrZXQuaW8tY2xpZW50I3JlYWRtZVwiLFwia2V5d29yZHNcIjpbXCJyZWFsdGltZVwiLFwiZnJhbWV3b3JrXCIsXCJ3ZWJzb2NrZXRcIixcInRjcFwiLFwiZXZlbnRzXCIsXCJjbGllbnRcIl0sXCJsaWNlbnNlXCI6XCJNSVRcIixcIm1haW5cIjpcIi4vbGliL2luZGV4XCIsXCJuYW1lXCI6XCJzb2NrZXQuaW8tY2xpZW50XCIsXCJyZXBvc2l0b3J5XCI6e1widHlwZVwiOlwiZ2l0XCIsXCJ1cmxcIjpcImdpdCtodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9zb2NrZXQuaW8tY2xpZW50LmdpdFwifSxcInNjcmlwdHNcIjp7XCJ0ZXN0XCI6XCJndWxwIHRlc3RcIn0sXCJ2ZXJzaW9uXCI6XCIyLjIuMFwifVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvcGFja2FnZS5qc29uXG4vLyBtb2R1bGUgaWQgPSAxNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pbzpjbGllbnQnKTtcbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsaWVudDtcblxuLyoqXG4gKiBDbGllbnQgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTZXJ2ZXJ9IHNlcnZlciBpbnN0YW5jZVxuICogQHBhcmFtIHtTb2NrZXR9IGNvbm5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIENsaWVudChzZXJ2ZXIsIGNvbm4pe1xuICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcbiAgdGhpcy5jb25uID0gY29ubjtcbiAgdGhpcy5lbmNvZGVyID0gc2VydmVyLmVuY29kZXI7XG4gIHRoaXMuZGVjb2RlciA9IG5ldyBzZXJ2ZXIucGFyc2VyLkRlY29kZXIoKTtcbiAgdGhpcy5pZCA9IGNvbm4uaWQ7XG4gIHRoaXMucmVxdWVzdCA9IGNvbm4ucmVxdWVzdDtcbiAgdGhpcy5zZXR1cCgpO1xuICB0aGlzLnNvY2tldHMgPSB7fTtcbiAgdGhpcy5uc3BzID0ge307XG4gIHRoaXMuY29ubmVjdEJ1ZmZlciA9IFtdO1xufVxuXG4vKipcbiAqIFNldHMgdXAgZXZlbnQgbGlzdGVuZXJzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNsaWVudC5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbigpe1xuICB0aGlzLm9uY2xvc2UgPSB0aGlzLm9uY2xvc2UuYmluZCh0aGlzKTtcbiAgdGhpcy5vbmRhdGEgPSB0aGlzLm9uZGF0YS5iaW5kKHRoaXMpO1xuICB0aGlzLm9uZXJyb3IgPSB0aGlzLm9uZXJyb3IuYmluZCh0aGlzKTtcbiAgdGhpcy5vbmRlY29kZWQgPSB0aGlzLm9uZGVjb2RlZC5iaW5kKHRoaXMpO1xuXG4gIHRoaXMuZGVjb2Rlci5vbignZGVjb2RlZCcsIHRoaXMub25kZWNvZGVkKTtcbiAgdGhpcy5jb25uLm9uKCdkYXRhJywgdGhpcy5vbmRhdGEpO1xuICB0aGlzLmNvbm4ub24oJ2Vycm9yJywgdGhpcy5vbmVycm9yKTtcbiAgdGhpcy5jb25uLm9uKCdjbG9zZScsIHRoaXMub25jbG9zZSk7XG59O1xuXG4vKipcbiAqIENvbm5lY3RzIGEgY2xpZW50IHRvIGEgbmFtZXNwYWNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWVzcGFjZVxuICogQHBhcmFtIHtPYmplY3R9IHF1ZXJ5IHRoZSBxdWVyeSBwYXJhbWV0ZXJzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5DbGllbnQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbihuYW1lLCBxdWVyeSl7XG4gIGlmICh0aGlzLnNlcnZlci5uc3BzW25hbWVdKSB7XG4gICAgZGVidWcoJ2Nvbm5lY3RpbmcgdG8gbmFtZXNwYWNlICVzJywgbmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuZG9Db25uZWN0KG5hbWUsIHF1ZXJ5KTtcbiAgfVxuXG4gIHRoaXMuc2VydmVyLmNoZWNrTmFtZXNwYWNlKG5hbWUsIHF1ZXJ5LCAoZHluYW1pY05zcCkgPT4ge1xuICAgIGlmIChkeW5hbWljTnNwKSB7XG4gICAgICBkZWJ1ZygnZHluYW1pYyBuYW1lc3BhY2UgJXMgd2FzIGNyZWF0ZWQnLCBkeW5hbWljTnNwLm5hbWUpO1xuICAgICAgdGhpcy5kb0Nvbm5lY3QobmFtZSwgcXVlcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnY3JlYXRpb24gb2YgbmFtZXNwYWNlICVzIHdhcyBkZW5pZWQnLCBuYW1lKTtcbiAgICAgIHRoaXMucGFja2V0KHsgdHlwZTogcGFyc2VyLkVSUk9SLCBuc3A6IG5hbWUsIGRhdGE6ICdJbnZhbGlkIG5hbWVzcGFjZScgfSk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQ29ubmVjdHMgYSBjbGllbnQgdG8gYSBuYW1lc3BhY2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge1N0cmluZ30gcXVlcnkgdGhlIHF1ZXJ5IHBhcmFtZXRlcnNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNsaWVudC5wcm90b3R5cGUuZG9Db25uZWN0ID0gZnVuY3Rpb24obmFtZSwgcXVlcnkpe1xuICB2YXIgbnNwID0gdGhpcy5zZXJ2ZXIub2YobmFtZSk7XG5cbiAgaWYgKCcvJyAhPSBuYW1lICYmICF0aGlzLm5zcHNbJy8nXSkge1xuICAgIHRoaXMuY29ubmVjdEJ1ZmZlci5wdXNoKG5hbWUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNvY2tldCA9IG5zcC5hZGQodGhpcywgcXVlcnksIGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5zb2NrZXRzW3NvY2tldC5pZF0gPSBzb2NrZXQ7XG4gICAgc2VsZi5uc3BzW25zcC5uYW1lXSA9IHNvY2tldDtcblxuICAgIGlmICgnLycgPT0gbnNwLm5hbWUgJiYgc2VsZi5jb25uZWN0QnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgIHNlbGYuY29ubmVjdEJ1ZmZlci5mb3JFYWNoKHNlbGYuY29ubmVjdCwgc2VsZik7XG4gICAgICBzZWxmLmNvbm5lY3RCdWZmZXIgPSBbXTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBEaXNjb25uZWN0cyBmcm9tIGFsbCBuYW1lc3BhY2VzIGFuZCBjbG9zZXMgdHJhbnNwb3J0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNsaWVudC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGZvciAodmFyIGlkIGluIHRoaXMuc29ja2V0cykge1xuICAgIGlmICh0aGlzLnNvY2tldHMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICB0aGlzLnNvY2tldHNbaWRdLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5zb2NrZXRzID0ge307XG4gIHRoaXMuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIHNvY2tldC4gQ2FsbGVkIGJ5IGVhY2ggYFNvY2tldGAuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ2xpZW50LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihzb2NrZXQpe1xuICBpZiAodGhpcy5zb2NrZXRzLmhhc093blByb3BlcnR5KHNvY2tldC5pZCkpIHtcbiAgICB2YXIgbnNwID0gdGhpcy5zb2NrZXRzW3NvY2tldC5pZF0ubnNwLm5hbWU7XG4gICAgZGVsZXRlIHRoaXMuc29ja2V0c1tzb2NrZXQuaWRdO1xuICAgIGRlbGV0ZSB0aGlzLm5zcHNbbnNwXTtcbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygnaWdub3JpbmcgcmVtb3ZlIGZvciAlcycsIHNvY2tldC5pZCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ2xpZW50LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIGlmICgnb3BlbicgPT0gdGhpcy5jb25uLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1ZygnZm9yY2luZyB0cmFuc3BvcnQgY2xvc2UnKTtcbiAgICB0aGlzLmNvbm4uY2xvc2UoKTtcbiAgICB0aGlzLm9uY2xvc2UoJ2ZvcmNlZCBzZXJ2ZXIgY2xvc2UnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXQgdG8gdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNsaWVudC5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBvcHRzKXtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyB0aGlzIHdyaXRlcyB0byB0aGUgYWN0dWFsIGNvbm5lY3Rpb25cbiAgZnVuY3Rpb24gd3JpdGVUb0VuZ2luZShlbmNvZGVkUGFja2V0cykge1xuICAgIGlmIChvcHRzLnZvbGF0aWxlICYmICFzZWxmLmNvbm4udHJhbnNwb3J0LndyaXRhYmxlKSByZXR1cm47XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkUGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgc2VsZi5jb25uLndyaXRlKGVuY29kZWRQYWNrZXRzW2ldLCB7IGNvbXByZXNzOiBvcHRzLmNvbXByZXNzIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmICgnb3BlbicgPT0gdGhpcy5jb25uLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnd3JpdGluZyBwYWNrZXQgJWonLCBwYWNrZXQpO1xuICAgIGlmICghb3B0cy5wcmVFbmNvZGVkKSB7IC8vIG5vdCBicm9hZGNhc3RpbmcsIG5lZWQgdG8gZW5jb2RlXG4gICAgICB0aGlzLmVuY29kZXIuZW5jb2RlKHBhY2tldCwgd3JpdGVUb0VuZ2luZSk7IC8vIGVuY29kZSwgdGhlbiB3cml0ZSByZXN1bHRzIHRvIGVuZ2luZVxuICAgIH0gZWxzZSB7IC8vIGEgYnJvYWRjYXN0IHByZS1lbmNvZGVzIGEgcGFja2V0XG4gICAgICB3cml0ZVRvRW5naW5lKHBhY2tldCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdpZ25vcmluZyBwYWNrZXQgd3JpdGUgJWonLCBwYWNrZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGluY29taW5nIHRyYW5zcG9ydCBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNsaWVudC5wcm90b3R5cGUub25kYXRhID0gZnVuY3Rpb24oZGF0YSl7XG4gIC8vIHRyeS9jYXRjaCBpcyBuZWVkZWQgZm9yIHByb3RvY29sIHZpb2xhdGlvbnMgKEdILTE4ODApXG4gIHRyeSB7XG4gICAgdGhpcy5kZWNvZGVyLmFkZChkYXRhKTtcbiAgfSBjYXRjaChlKSB7XG4gICAgdGhpcy5vbmVycm9yKGUpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNsaWVudC5wcm90b3R5cGUub25kZWNvZGVkID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIGlmIChwYXJzZXIuQ09OTkVDVCA9PSBwYWNrZXQudHlwZSkge1xuICAgIHRoaXMuY29ubmVjdCh1cmwucGFyc2UocGFja2V0Lm5zcCkucGF0aG5hbWUsIHVybC5wYXJzZShwYWNrZXQubnNwLCB0cnVlKS5xdWVyeSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNvY2tldCA9IHRoaXMubnNwc1twYWNrZXQubnNwXTtcbiAgICBpZiAoc29ja2V0KSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBzb2NrZXQub25wYWNrZXQocGFja2V0KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Zygnbm8gc29ja2V0IGZvciBuYW1lc3BhY2UgJXMnLCBwYWNrZXQubnNwKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlcyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZXJyIG9iamVjdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ2xpZW50LnByb3RvdHlwZS5vbmVycm9yID0gZnVuY3Rpb24oZXJyKXtcbiAgZm9yICh2YXIgaWQgaW4gdGhpcy5zb2NrZXRzKSB7XG4gICAgaWYgKHRoaXMuc29ja2V0cy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIHRoaXMuc29ja2V0c1tpZF0ub25lcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuICB0aGlzLmNvbm4uY2xvc2UoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb25cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNsaWVudC5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbil7XG4gIGRlYnVnKCdjbGllbnQgY2xvc2Ugd2l0aCByZWFzb24gJXMnLCByZWFzb24pO1xuXG4gIC8vIGlnbm9yZSBhIHBvdGVudGlhbCBzdWJzZXF1ZW50IGBjbG9zZWAgZXZlbnRcbiAgdGhpcy5kZXN0cm95KCk7XG5cbiAgLy8gYG5zcHNgIGFuZCBgc29ja2V0c2AgYXJlIGNsZWFuZWQgdXAgc2VhbWxlc3NseVxuICBmb3IgKHZhciBpZCBpbiB0aGlzLnNvY2tldHMpIHtcbiAgICBpZiAodGhpcy5zb2NrZXRzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgdGhpcy5zb2NrZXRzW2lkXS5vbmNsb3NlKHJlYXNvbik7XG4gICAgfVxuICB9XG4gIHRoaXMuc29ja2V0cyA9IHt9O1xuXG4gIHRoaXMuZGVjb2Rlci5kZXN0cm95KCk7IC8vIGNsZWFuIHVwIGRlY29kZXJcbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGV2ZW50IGxpc3RlbmVycy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5DbGllbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xuICB0aGlzLmNvbm4ucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCB0aGlzLm9uZGF0YSk7XG4gIHRoaXMuY29ubi5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCB0aGlzLm9uZXJyb3IpO1xuICB0aGlzLmNvbm4ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgdGhpcy5vbmNsb3NlKTtcbiAgdGhpcy5kZWNvZGVyLnJlbW92ZUxpc3RlbmVyKCdkZWNvZGVkJywgdGhpcy5vbmRlY29kZWQpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9saWIvY2xpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBEZXRlY3QgRWxlY3Ryb24gcmVuZGVyZXIgcHJvY2Vzcywgd2hpY2ggaXMgbm9kZSwgYnV0IHdlIHNob3VsZFxuICogdHJlYXQgYXMgYSBicm93c2VyLlxuICovXG5cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9icm93c2VyLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbm9kZS5qcycpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsXG4gICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJyxcbiAgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLFxuICAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsXG4gICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJyxcbiAgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLFxuICAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsXG4gICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJyxcbiAgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLFxuICAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsXG4gICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0dHkgPSByZXF1aXJlKCd0dHknKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIE5vZGUuanMgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmluaXQgPSBpbml0O1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbIDYsIDIsIDMsIDQsIDUsIDEgXTtcblxudHJ5IHtcbiAgdmFyIHN1cHBvcnRzQ29sb3IgPSByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpO1xuICBpZiAoc3VwcG9ydHNDb2xvciAmJiBzdXBwb3J0c0NvbG9yLmxldmVsID49IDIpIHtcbiAgICBleHBvcnRzLmNvbG9ycyA9IFtcbiAgICAgIDIwLCAyMSwgMjYsIDI3LCAzMiwgMzMsIDM4LCAzOSwgNDAsIDQxLCA0MiwgNDMsIDQ0LCA0NSwgNTYsIDU3LCA2MiwgNjMsIDY4LFxuICAgICAgNjksIDc0LCA3NSwgNzYsIDc3LCA3OCwgNzksIDgwLCA4MSwgOTIsIDkzLCA5OCwgOTksIDExMiwgMTEzLCAxMjgsIDEyOSwgMTM0LFxuICAgICAgMTM1LCAxNDgsIDE0OSwgMTYwLCAxNjEsIDE2MiwgMTYzLCAxNjQsIDE2NSwgMTY2LCAxNjcsIDE2OCwgMTY5LCAxNzAsIDE3MSxcbiAgICAgIDE3MiwgMTczLCAxNzgsIDE3OSwgMTg0LCAxODUsIDE5NiwgMTk3LCAxOTgsIDE5OSwgMjAwLCAyMDEsIDIwMiwgMjAzLCAyMDQsXG4gICAgICAyMDUsIDIwNiwgMjA3LCAyMDgsIDIwOSwgMjE0LCAyMTUsIDIyMCwgMjIxXG4gICAgXTtcbiAgfVxufSBjYXRjaCAoZXJyKSB7XG4gIC8vIHN3YWxsb3cgLSB3ZSBvbmx5IGNhcmUgaWYgYHN1cHBvcnRzLWNvbG9yYCBpcyBhdmFpbGFibGU7IGl0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbn1cblxuLyoqXG4gKiBCdWlsZCB1cCB0aGUgZGVmYXVsdCBgaW5zcGVjdE9wdHNgIG9iamVjdCBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKlxuICogICAkIERFQlVHX0NPTE9SUz1ubyBERUJVR19ERVBUSD0xMCBERUJVR19TSE9XX0hJRERFTj1lbmFibGVkIG5vZGUgc2NyaXB0LmpzXG4gKi9cblxuZXhwb3J0cy5pbnNwZWN0T3B0cyA9IE9iamVjdC5rZXlzKHByb2Nlc3MuZW52KS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gL15kZWJ1Z18vaS50ZXN0KGtleSk7XG59KS5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwga2V5KSB7XG4gIC8vIGNhbWVsLWNhc2VcbiAgdmFyIHByb3AgPSBrZXlcbiAgICAuc3Vic3RyaW5nKDYpXG4gICAgLnRvTG93ZXJDYXNlKClcbiAgICAucmVwbGFjZSgvXyhbYS16XSkvZywgZnVuY3Rpb24gKF8sIGspIHsgcmV0dXJuIGsudG9VcHBlckNhc2UoKSB9KTtcblxuICAvLyBjb2VyY2Ugc3RyaW5nIHZhbHVlIGludG8gSlMgdmFsdWVcbiAgdmFyIHZhbCA9IHByb2Nlc3MuZW52W2tleV07XG4gIGlmICgvXih5ZXN8b258dHJ1ZXxlbmFibGVkKSQvaS50ZXN0KHZhbCkpIHZhbCA9IHRydWU7XG4gIGVsc2UgaWYgKC9eKG5vfG9mZnxmYWxzZXxkaXNhYmxlZCkkL2kudGVzdCh2YWwpKSB2YWwgPSBmYWxzZTtcbiAgZWxzZSBpZiAodmFsID09PSAnbnVsbCcpIHZhbCA9IG51bGw7XG4gIGVsc2UgdmFsID0gTnVtYmVyKHZhbCk7XG5cbiAgb2JqW3Byb3BdID0gdmFsO1xuICByZXR1cm4gb2JqO1xufSwge30pO1xuXG4vKipcbiAqIElzIHN0ZG91dCBhIFRUWT8gQ29sb3JlZCBvdXRwdXQgaXMgZW5hYmxlZCB3aGVuIGB0cnVlYC5cbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIHJldHVybiAnY29sb3JzJyBpbiBleHBvcnRzLmluc3BlY3RPcHRzXG4gICAgPyBCb29sZWFuKGV4cG9ydHMuaW5zcGVjdE9wdHMuY29sb3JzKVxuICAgIDogdHR5LmlzYXR0eShwcm9jZXNzLnN0ZGVyci5mZCk7XG59XG5cbi8qKlxuICogTWFwICVvIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbCBvbiBhIHNpbmdsZSBsaW5lLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5vID0gZnVuY3Rpb24odikge1xuICB0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuICByZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpXG4gICAgLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnRyaW0oKVxuICAgIH0pLmpvaW4oJyAnKTtcbn07XG5cbi8qKlxuICogTWFwICVvIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbG93aW5nIG11bHRpcGxlIGxpbmVzIGlmIG5lZWRlZC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuTyA9IGZ1bmN0aW9uKHYpIHtcbiAgdGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcbiAgcmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKTtcbn07XG5cbi8qKlxuICogQWRkcyBBTlNJIGNvbG9yIGVzY2FwZSBjb2RlcyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciBuYW1lID0gdGhpcy5uYW1lc3BhY2U7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBpZiAodXNlQ29sb3JzKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNvbG9yO1xuICAgIHZhciBjb2xvckNvZGUgPSAnXFx1MDAxYlszJyArIChjIDwgOCA/IGMgOiAnODs1OycgKyBjKTtcbiAgICB2YXIgcHJlZml4ID0gJyAgJyArIGNvbG9yQ29kZSArICc7MW0nICsgbmFtZSArICcgJyArICdcXHUwMDFiWzBtJztcblxuICAgIGFyZ3NbMF0gPSBwcmVmaXggKyBhcmdzWzBdLnNwbGl0KCdcXG4nKS5qb2luKCdcXG4nICsgcHJlZml4KTtcbiAgICBhcmdzLnB1c2goY29sb3JDb2RlICsgJ20rJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKSArICdcXHUwMDFiWzBtJyk7XG4gIH0gZWxzZSB7XG4gICAgYXJnc1swXSA9IGdldERhdGUoKSArIG5hbWUgKyAnICcgKyBhcmdzWzBdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERhdGUoKSB7XG4gIGlmIChleHBvcnRzLmluc3BlY3RPcHRzLmhpZGVEYXRlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyAnICc7XG4gIH1cbn1cblxuLyoqXG4gKiBJbnZva2VzIGB1dGlsLmZvcm1hdCgpYCB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzIGFuZCB3cml0ZXMgdG8gc3RkZXJyLlxuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgcmV0dXJuIHByb2Nlc3Muc3RkZXJyLndyaXRlKHV0aWwuZm9ybWF0LmFwcGx5KHV0aWwsIGFyZ3VtZW50cykgKyAnXFxuJyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgLy8gSWYgeW91IHNldCBhIHByb2Nlc3MuZW52IGZpZWxkIHRvIG51bGwgb3IgdW5kZWZpbmVkLCBpdCBnZXRzIGNhc3QgdG8gdGhlXG4gICAgLy8gc3RyaW5nICdudWxsJyBvciAndW5kZWZpbmVkJy4gSnVzdCBkZWxldGUgaW5zdGVhZC5cbiAgICBkZWxldGUgcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5lbnYuREVCVUcgPSBuYW1lc3BhY2VzO1xuICB9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LkRFQlVHO1xufVxuXG4vKipcbiAqIEluaXQgbG9naWMgZm9yIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICpcbiAqIENyZWF0ZSBhIG5ldyBgaW5zcGVjdE9wdHNgIG9iamVjdCBpbiBjYXNlIGB1c2VDb2xvcnNgIGlzIHNldFxuICogZGlmZmVyZW50bHkgZm9yIGEgcGFydGljdWxhciBgZGVidWdgIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGluaXQgKGRlYnVnKSB7XG4gIGRlYnVnLmluc3BlY3RPcHRzID0ge307XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhleHBvcnRzLmluc3BlY3RPcHRzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVidWcuaW5zcGVjdE9wdHNba2V5c1tpXV0gPSBleHBvcnRzLmluc3BlY3RPcHRzW2tleXNbaV1dO1xuICB9XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBwcm9jZXNzLmVudi5ERUJVR2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMTgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG4vKipcclxuICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICovXHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xyXG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcclxuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcclxuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cclxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcclxuICAgIC5wdXNoKGZuKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgZnVuY3Rpb24gb24oKSB7XHJcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xyXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIG9uLmZuID0gZm47XHJcbiAgdGhpcy5vbihldmVudCwgb24pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgLy8gYWxsXHJcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xyXG5cclxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgdmFyIGNiO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XHJcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXHJcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblxyXG4gIGlmIChjYWxsYmFja3MpIHtcclxuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypnbG9iYWwgQmxvYixGaWxlKi9cblxuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG52YXIgaXNCdWYgPSByZXF1aXJlKCcuL2lzLWJ1ZmZlcicpO1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciB3aXRoTmF0aXZlQmxvYiA9IHR5cGVvZiBCbG9iID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgdG9TdHJpbmcuY2FsbChCbG9iKSA9PT0gJ1tvYmplY3QgQmxvYkNvbnN0cnVjdG9yXScpO1xudmFyIHdpdGhOYXRpdmVGaWxlID0gdHlwZW9mIEZpbGUgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBGaWxlICE9PSAndW5kZWZpbmVkJyAmJiB0b1N0cmluZy5jYWxsKEZpbGUpID09PSAnW29iamVjdCBGaWxlQ29uc3RydWN0b3JdJyk7XG5cbi8qKlxuICogUmVwbGFjZXMgZXZlcnkgQnVmZmVyIHwgQXJyYXlCdWZmZXIgaW4gcGFja2V0IHdpdGggYSBudW1iZXJlZCBwbGFjZWhvbGRlci5cbiAqIEFueXRoaW5nIHdpdGggYmxvYnMgb3IgZmlsZXMgc2hvdWxkIGJlIGZlZCB0aHJvdWdoIHJlbW92ZUJsb2JzIGJlZm9yZSBjb21pbmdcbiAqIGhlcmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIHNvY2tldC5pbyBldmVudCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBkZWNvbnN0cnVjdGVkIHBhY2tldCBhbmQgbGlzdCBvZiBidWZmZXJzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpIHtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgdmFyIHBhY2tldERhdGEgPSBwYWNrZXQuZGF0YTtcbiAgdmFyIHBhY2sgPSBwYWNrZXQ7XG4gIHBhY2suZGF0YSA9IF9kZWNvbnN0cnVjdFBhY2tldChwYWNrZXREYXRhLCBidWZmZXJzKTtcbiAgcGFjay5hdHRhY2htZW50cyA9IGJ1ZmZlcnMubGVuZ3RoOyAvLyBudW1iZXIgb2YgYmluYXJ5ICdhdHRhY2htZW50cydcbiAgcmV0dXJuIHtwYWNrZXQ6IHBhY2ssIGJ1ZmZlcnM6IGJ1ZmZlcnN9O1xufTtcblxuZnVuY3Rpb24gX2RlY29uc3RydWN0UGFja2V0KGRhdGEsIGJ1ZmZlcnMpIHtcbiAgaWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcblxuICBpZiAoaXNCdWYoZGF0YSkpIHtcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSB7IF9wbGFjZWhvbGRlcjogdHJ1ZSwgbnVtOiBidWZmZXJzLmxlbmd0aCB9O1xuICAgIGJ1ZmZlcnMucHVzaChkYXRhKTtcbiAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgIHZhciBuZXdEYXRhID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ld0RhdGFbaV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSwgYnVmZmVycyk7XG4gICAgfVxuICAgIHJldHVybiBuZXdEYXRhO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiAhKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgIHZhciBuZXdEYXRhID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgIG5ld0RhdGFba2V5XSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RGF0YTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBSZWNvbnN0cnVjdHMgYSBiaW5hcnkgcGFja2V0IGZyb20gaXRzIHBsYWNlaG9sZGVyIHBhY2tldCBhbmQgYnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBldmVudCBwYWNrZXQgd2l0aCBwbGFjZWhvbGRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlcnMgLSBiaW5hcnkgYnVmZmVycyB0byBwdXQgaW4gcGxhY2Vob2xkZXIgcG9zaXRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY29uc3RydWN0ZWQgcGFja2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucmVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGJ1ZmZlcnMpIHtcbiAgcGFja2V0LmRhdGEgPSBfcmVjb25zdHJ1Y3RQYWNrZXQocGFja2V0LmRhdGEsIGJ1ZmZlcnMpO1xuICBwYWNrZXQuYXR0YWNobWVudHMgPSB1bmRlZmluZWQ7IC8vIG5vIGxvbmdlciB1c2VmdWxcbiAgcmV0dXJuIHBhY2tldDtcbn07XG5cbmZ1bmN0aW9uIF9yZWNvbnN0cnVjdFBhY2tldChkYXRhLCBidWZmZXJzKSB7XG4gIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cbiAgaWYgKGRhdGEgJiYgZGF0YS5fcGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm4gYnVmZmVyc1tkYXRhLm51bV07IC8vIGFwcHJvcHJpYXRlIGJ1ZmZlciAoc2hvdWxkIGJlIG5hdHVyYWwgb3JkZXIgYW55d2F5KVxuICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGFbaV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSwgYnVmZmVycyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICBkYXRhW2tleV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldLCBidWZmZXJzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSByZW1vdmVzIEJsb2JzIG9yIEZpbGVzIGZyb20gZGF0YSB2aWFcbiAqIEZpbGVSZWFkZXIncyByZWFkQXNBcnJheUJ1ZmZlciBtZXRob2QuIFVzZWQgYmVmb3JlIGVuY29kaW5nXG4gKiBkYXRhIGFzIG1zZ3BhY2suIENhbGxzIGNhbGxiYWNrIHdpdGggdGhlIGJsb2JsZXNzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnJlbW92ZUJsb2JzID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gX3JlbW92ZUJsb2JzKG9iaiwgY3VyS2V5LCBjb250YWluaW5nT2JqZWN0KSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBvYmo7XG5cbiAgICAvLyBjb252ZXJ0IGFueSBibG9iXG4gICAgaWYgKCh3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAod2l0aE5hdGl2ZUZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICAgIHBlbmRpbmdCbG9icysrO1xuXG4gICAgICAvLyBhc3luYyBmaWxlcmVhZGVyXG4gICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyAvLyB0aGlzLnJlc3VsdCA9PSBhcnJheWJ1ZmZlclxuICAgICAgICBpZiAoY29udGFpbmluZ09iamVjdCkge1xuICAgICAgICAgIGNvbnRhaW5pbmdPYmplY3RbY3VyS2V5XSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJsb2JsZXNzRGF0YSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbm90aGluZyBwZW5kaW5nIGl0cyBjYWxsYmFjayB0aW1lXG4gICAgICAgIGlmKCEgLS1wZW5kaW5nQmxvYnMpIHtcbiAgICAgICAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKG9iaik7IC8vIGJsb2IgLT4gYXJyYXlidWZmZXJcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSkgeyAvLyBoYW5kbGUgYXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhaXNCdWYob2JqKSkgeyAvLyBhbmQgb2JqZWN0XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwZW5kaW5nQmxvYnMgPSAwO1xuICB2YXIgYmxvYmxlc3NEYXRhID0gZGF0YTtcbiAgX3JlbW92ZUJsb2JzKGJsb2JsZXNzRGF0YSk7XG4gIGlmICghcGVuZGluZ0Jsb2JzKSB7XG4gICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvYmluYXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAxODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCcjMDAwMENDJyxcblx0JyMwMDAwRkYnLFxuXHQnIzAwMzNDQycsXG5cdCcjMDAzM0ZGJyxcblx0JyMwMDY2Q0MnLFxuXHQnIzAwNjZGRicsXG5cdCcjMDA5OUNDJyxcblx0JyMwMDk5RkYnLFxuXHQnIzAwQ0MwMCcsXG5cdCcjMDBDQzMzJyxcblx0JyMwMENDNjYnLFxuXHQnIzAwQ0M5OScsXG5cdCcjMDBDQ0NDJyxcblx0JyMwMENDRkYnLFxuXHQnIzMzMDBDQycsXG5cdCcjMzMwMEZGJyxcblx0JyMzMzMzQ0MnLFxuXHQnIzMzMzNGRicsXG5cdCcjMzM2NkNDJyxcblx0JyMzMzY2RkYnLFxuXHQnIzMzOTlDQycsXG5cdCcjMzM5OUZGJyxcblx0JyMzM0NDMDAnLFxuXHQnIzMzQ0MzMycsXG5cdCcjMzNDQzY2Jyxcblx0JyMzM0NDOTknLFxuXHQnIzMzQ0NDQycsXG5cdCcjMzNDQ0ZGJyxcblx0JyM2NjAwQ0MnLFxuXHQnIzY2MDBGRicsXG5cdCcjNjYzM0NDJyxcblx0JyM2NjMzRkYnLFxuXHQnIzY2Q0MwMCcsXG5cdCcjNjZDQzMzJyxcblx0JyM5OTAwQ0MnLFxuXHQnIzk5MDBGRicsXG5cdCcjOTkzM0NDJyxcblx0JyM5OTMzRkYnLFxuXHQnIzk5Q0MwMCcsXG5cdCcjOTlDQzMzJyxcblx0JyNDQzAwMDAnLFxuXHQnI0NDMDAzMycsXG5cdCcjQ0MwMDY2Jyxcblx0JyNDQzAwOTknLFxuXHQnI0NDMDBDQycsXG5cdCcjQ0MwMEZGJyxcblx0JyNDQzMzMDAnLFxuXHQnI0NDMzMzMycsXG5cdCcjQ0MzMzY2Jyxcblx0JyNDQzMzOTknLFxuXHQnI0NDMzNDQycsXG5cdCcjQ0MzM0ZGJyxcblx0JyNDQzY2MDAnLFxuXHQnI0NDNjYzMycsXG5cdCcjQ0M5OTAwJyxcblx0JyNDQzk5MzMnLFxuXHQnI0NDQ0MwMCcsXG5cdCcjQ0NDQzMzJyxcblx0JyNGRjAwMDAnLFxuXHQnI0ZGMDAzMycsXG5cdCcjRkYwMDY2Jyxcblx0JyNGRjAwOTknLFxuXHQnI0ZGMDBDQycsXG5cdCcjRkYwMEZGJyxcblx0JyNGRjMzMDAnLFxuXHQnI0ZGMzMzMycsXG5cdCcjRkYzMzY2Jyxcblx0JyNGRjMzOTknLFxuXHQnI0ZGMzNDQycsXG5cdCcjRkYzM0ZGJyxcblx0JyNGRjY2MDAnLFxuXHQnI0ZGNjYzMycsXG5cdCcjRkY5OTAwJyxcblx0JyNGRjk5MzMnLFxuXHQnI0ZGQ0MwMCcsXG5cdCcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG5cdC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG5cdC8vIGV4cGxpY2l0bHlcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0Ly8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0cmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG5cdFx0Ly8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gSXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gbG9nKC4uLmFyZ3MpIHtcblx0Ly8gVGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcblx0Ly8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcblx0cmV0dXJuIHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0JyAmJlxuXHRcdGNvbnNvbGUubG9nICYmXG5cdFx0Y29uc29sZS5sb2coLi4uYXJncyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMTgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwtP1xcZD9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9ub2RlX21vZHVsZXMvbXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIE5vZGUuanMgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFs2LCAyLCAzLCA0LCA1LCAxXTtcblxudHJ5IHtcblx0Ly8gT3B0aW9uYWwgZGVwZW5kZW5jeSAoYXMgaW4sIGRvZXNuJ3QgbmVlZCB0byBiZSBpbnN0YWxsZWQsIE5PVCBsaWtlIG9wdGlvbmFsRGVwZW5kZW5jaWVzIGluIHBhY2thZ2UuanNvbilcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuXHRjb25zdCBzdXBwb3J0c0NvbG9yID0gcmVxdWlyZSgnc3VwcG9ydHMtY29sb3InKTtcblxuXHRpZiAoc3VwcG9ydHNDb2xvciAmJiAoc3VwcG9ydHNDb2xvci5zdGRlcnIgfHwgc3VwcG9ydHNDb2xvcikubGV2ZWwgPj0gMikge1xuXHRcdGV4cG9ydHMuY29sb3JzID0gW1xuXHRcdFx0MjAsXG5cdFx0XHQyMSxcblx0XHRcdDI2LFxuXHRcdFx0MjcsXG5cdFx0XHQzMixcblx0XHRcdDMzLFxuXHRcdFx0MzgsXG5cdFx0XHQzOSxcblx0XHRcdDQwLFxuXHRcdFx0NDEsXG5cdFx0XHQ0Mixcblx0XHRcdDQzLFxuXHRcdFx0NDQsXG5cdFx0XHQ0NSxcblx0XHRcdDU2LFxuXHRcdFx0NTcsXG5cdFx0XHQ2Mixcblx0XHRcdDYzLFxuXHRcdFx0NjgsXG5cdFx0XHQ2OSxcblx0XHRcdDc0LFxuXHRcdFx0NzUsXG5cdFx0XHQ3Nixcblx0XHRcdDc3LFxuXHRcdFx0NzgsXG5cdFx0XHQ3OSxcblx0XHRcdDgwLFxuXHRcdFx0ODEsXG5cdFx0XHQ5Mixcblx0XHRcdDkzLFxuXHRcdFx0OTgsXG5cdFx0XHQ5OSxcblx0XHRcdDExMixcblx0XHRcdDExMyxcblx0XHRcdDEyOCxcblx0XHRcdDEyOSxcblx0XHRcdDEzNCxcblx0XHRcdDEzNSxcblx0XHRcdDE0OCxcblx0XHRcdDE0OSxcblx0XHRcdDE2MCxcblx0XHRcdDE2MSxcblx0XHRcdDE2Mixcblx0XHRcdDE2Myxcblx0XHRcdDE2NCxcblx0XHRcdDE2NSxcblx0XHRcdDE2Nixcblx0XHRcdDE2Nyxcblx0XHRcdDE2OCxcblx0XHRcdDE2OSxcblx0XHRcdDE3MCxcblx0XHRcdDE3MSxcblx0XHRcdDE3Mixcblx0XHRcdDE3Myxcblx0XHRcdDE3OCxcblx0XHRcdDE3OSxcblx0XHRcdDE4NCxcblx0XHRcdDE4NSxcblx0XHRcdDE5Nixcblx0XHRcdDE5Nyxcblx0XHRcdDE5OCxcblx0XHRcdDE5OSxcblx0XHRcdDIwMCxcblx0XHRcdDIwMSxcblx0XHRcdDIwMixcblx0XHRcdDIwMyxcblx0XHRcdDIwNCxcblx0XHRcdDIwNSxcblx0XHRcdDIwNixcblx0XHRcdDIwNyxcblx0XHRcdDIwOCxcblx0XHRcdDIwOSxcblx0XHRcdDIxNCxcblx0XHRcdDIxNSxcblx0XHRcdDIyMCxcblx0XHRcdDIyMVxuXHRcdF07XG5cdH1cbn0gY2F0Y2ggKGVycm9yKSB7XG5cdC8vIFN3YWxsb3cgLSB3ZSBvbmx5IGNhcmUgaWYgYHN1cHBvcnRzLWNvbG9yYCBpcyBhdmFpbGFibGU7IGl0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbn1cblxuLyoqXG4gKiBCdWlsZCB1cCB0aGUgZGVmYXVsdCBgaW5zcGVjdE9wdHNgIG9iamVjdCBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKlxuICogICAkIERFQlVHX0NPTE9SUz1ubyBERUJVR19ERVBUSD0xMCBERUJVR19TSE9XX0hJRERFTj1lbmFibGVkIG5vZGUgc2NyaXB0LmpzXG4gKi9cblxuZXhwb3J0cy5pbnNwZWN0T3B0cyA9IE9iamVjdC5rZXlzKHByb2Nlc3MuZW52KS5maWx0ZXIoa2V5ID0+IHtcblx0cmV0dXJuIC9eZGVidWdfL2kudGVzdChrZXkpO1xufSkucmVkdWNlKChvYmosIGtleSkgPT4ge1xuXHQvLyBDYW1lbC1jYXNlXG5cdGNvbnN0IHByb3AgPSBrZXlcblx0XHQuc3Vic3RyaW5nKDYpXG5cdFx0LnRvTG93ZXJDYXNlKClcblx0XHQucmVwbGFjZSgvXyhbYS16XSkvZywgKF8sIGspID0+IHtcblx0XHRcdHJldHVybiBrLnRvVXBwZXJDYXNlKCk7XG5cdFx0fSk7XG5cblx0Ly8gQ29lcmNlIHN0cmluZyB2YWx1ZSBpbnRvIEpTIHZhbHVlXG5cdGxldCB2YWwgPSBwcm9jZXNzLmVudltrZXldO1xuXHRpZiAoL14oeWVzfG9ufHRydWV8ZW5hYmxlZCkkL2kudGVzdCh2YWwpKSB7XG5cdFx0dmFsID0gdHJ1ZTtcblx0fSBlbHNlIGlmICgvXihub3xvZmZ8ZmFsc2V8ZGlzYWJsZWQpJC9pLnRlc3QodmFsKSkge1xuXHRcdHZhbCA9IGZhbHNlO1xuXHR9IGVsc2UgaWYgKHZhbCA9PT0gJ251bGwnKSB7XG5cdFx0dmFsID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHR2YWwgPSBOdW1iZXIodmFsKTtcblx0fVxuXG5cdG9ialtwcm9wXSA9IHZhbDtcblx0cmV0dXJuIG9iajtcbn0sIHt9KTtcblxuLyoqXG4gKiBJcyBzdGRvdXQgYSBUVFk/IENvbG9yZWQgb3V0cHV0IGlzIGVuYWJsZWQgd2hlbiBgdHJ1ZWAuXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHRyZXR1cm4gJ2NvbG9ycycgaW4gZXhwb3J0cy5pbnNwZWN0T3B0cyA/XG5cdFx0Qm9vbGVhbihleHBvcnRzLmluc3BlY3RPcHRzLmNvbG9ycykgOlxuXHRcdHR0eS5pc2F0dHkocHJvY2Vzcy5zdGRlcnIuZmQpO1xufVxuXG4vKipcbiAqIEFkZHMgQU5TSSBjb2xvciBlc2NhcGUgY29kZXMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRjb25zdCB7bmFtZXNwYWNlOiBuYW1lLCB1c2VDb2xvcnN9ID0gdGhpcztcblxuXHRpZiAodXNlQ29sb3JzKSB7XG5cdFx0Y29uc3QgYyA9IHRoaXMuY29sb3I7XG5cdFx0Y29uc3QgY29sb3JDb2RlID0gJ1xcdTAwMUJbMycgKyAoYyA8IDggPyBjIDogJzg7NTsnICsgYyk7XG5cdFx0Y29uc3QgcHJlZml4ID0gYCAgJHtjb2xvckNvZGV9OzFtJHtuYW1lfSBcXHUwMDFCWzBtYDtcblxuXHRcdGFyZ3NbMF0gPSBwcmVmaXggKyBhcmdzWzBdLnNwbGl0KCdcXG4nKS5qb2luKCdcXG4nICsgcHJlZml4KTtcblx0XHRhcmdzLnB1c2goY29sb3JDb2RlICsgJ20rJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZikgKyAnXFx1MDAxQlswbScpO1xuXHR9IGVsc2Uge1xuXHRcdGFyZ3NbMF0gPSBnZXREYXRlKCkgKyBuYW1lICsgJyAnICsgYXJnc1swXTtcblx0fVxufVxuXG5mdW5jdGlvbiBnZXREYXRlKCkge1xuXHRpZiAoZXhwb3J0cy5pbnNwZWN0T3B0cy5oaWRlRGF0ZSkge1xuXHRcdHJldHVybiAnJztcblx0fVxuXHRyZXR1cm4gbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgJyAnO1xufVxuXG4vKipcbiAqIEludm9rZXMgYHV0aWwuZm9ybWF0KClgIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMgYW5kIHdyaXRlcyB0byBzdGRlcnIuXG4gKi9cblxuZnVuY3Rpb24gbG9nKC4uLmFyZ3MpIHtcblx0cmV0dXJuIHByb2Nlc3Muc3RkZXJyLndyaXRlKHV0aWwuZm9ybWF0KC4uLmFyZ3MpICsgJ1xcbicpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0cHJvY2Vzcy5lbnYuREVCVUcgPSBuYW1lc3BhY2VzO1xuXHR9IGVsc2Uge1xuXHRcdC8vIElmIHlvdSBzZXQgYSBwcm9jZXNzLmVudiBmaWVsZCB0byBudWxsIG9yIHVuZGVmaW5lZCwgaXQgZ2V0cyBjYXN0IHRvIHRoZVxuXHRcdC8vIHN0cmluZyAnbnVsbCcgb3IgJ3VuZGVmaW5lZCcuIEp1c3QgZGVsZXRlIGluc3RlYWQuXG5cdFx0ZGVsZXRlIHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcblx0cmV0dXJuIHByb2Nlc3MuZW52LkRFQlVHO1xufVxuXG4vKipcbiAqIEluaXQgbG9naWMgZm9yIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICpcbiAqIENyZWF0ZSBhIG5ldyBgaW5zcGVjdE9wdHNgIG9iamVjdCBpbiBjYXNlIGB1c2VDb2xvcnNgIGlzIHNldFxuICogZGlmZmVyZW50bHkgZm9yIGEgcGFydGljdWxhciBgZGVidWdgIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGluaXQoZGVidWcpIHtcblx0ZGVidWcuaW5zcGVjdE9wdHMgPSB7fTtcblxuXHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXhwb3J0cy5pbnNwZWN0T3B0cyk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdGRlYnVnLmluc3BlY3RPcHRzW2tleXNbaV1dID0gZXhwb3J0cy5pbnNwZWN0T3B0c1trZXlzW2ldXTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlbyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGwgb24gYSBzaW5nbGUgbGluZS5cbiAqL1xuXG5mb3JtYXR0ZXJzLm8gPSBmdW5jdGlvbiAodikge1xuXHR0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXHRyZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpXG5cdFx0LnJlcGxhY2UoL1xccypcXG5cXHMqL2csICcgJyk7XG59O1xuXG4vKipcbiAqIE1hcCAlTyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGxvd2luZyBtdWx0aXBsZSBsaW5lcyBpZiBuZWVkZWQuXG4gKi9cblxuZm9ybWF0dGVycy5PID0gZnVuY3Rpb24gKHYpIHtcblx0dGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblx0cmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAxODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIGhhc0JpbiA9IHJlcXVpcmUoJ2hhcy1iaW5hcnkyJyk7XG52YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW86c29ja2V0Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU29ja2V0O1xuXG4vKipcbiAqIEJsYWNrbGlzdGVkIGV2ZW50cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZXZlbnRzID0gW1xuICAnZXJyb3InLFxuICAnY29ubmVjdCcsXG4gICdkaXNjb25uZWN0JyxcbiAgJ2Rpc2Nvbm5lY3RpbmcnLFxuICAnbmV3TGlzdGVuZXInLFxuICAncmVtb3ZlTGlzdGVuZXInXG5dO1xuXG4vKipcbiAqIEZsYWdzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciBmbGFncyA9IFtcbiAgJ2pzb24nLFxuICAndm9sYXRpbGUnLFxuICAnYnJvYWRjYXN0JyxcbiAgJ2xvY2FsJ1xuXTtcblxuLyoqXG4gKiBgRXZlbnRFbWl0dGVyI2VtaXRgIHJlZmVyZW5jZS5cbiAqL1xuXG52YXIgZW1pdCA9IEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5cbi8qKlxuICogSW50ZXJmYWNlIHRvIGEgYENsaWVudGAgZm9yIGEgZ2l2ZW4gYE5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtOYW1lc3BhY2V9IG5zcFxuICogQHBhcmFtIHtDbGllbnR9IGNsaWVudFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQobnNwLCBjbGllbnQsIHF1ZXJ5KXtcbiAgdGhpcy5uc3AgPSBuc3A7XG4gIHRoaXMuc2VydmVyID0gbnNwLnNlcnZlcjtcbiAgdGhpcy5hZGFwdGVyID0gdGhpcy5uc3AuYWRhcHRlcjtcbiAgdGhpcy5pZCA9IG5zcC5uYW1lICE9PSAnLycgPyBuc3AubmFtZSArICcjJyArIGNsaWVudC5pZCA6IGNsaWVudC5pZDtcbiAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gIHRoaXMuY29ubiA9IGNsaWVudC5jb25uO1xuICB0aGlzLnJvb21zID0ge307XG4gIHRoaXMuYWNrcyA9IHt9O1xuICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuaGFuZHNoYWtlID0gdGhpcy5idWlsZEhhbmRzaGFrZShxdWVyeSk7XG4gIHRoaXMuZm5zID0gW107XG4gIHRoaXMuZmxhZ3MgPSB7fTtcbiAgdGhpcy5fcm9vbXMgPSBbXTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIGBFdmVudEVtaXR0ZXJgLlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuX19wcm90b19fID0gRW1pdHRlci5wcm90b3R5cGU7XG5cbi8qKlxuICogQXBwbHkgZmxhZ3MgZnJvbSBgU29ja2V0YC5cbiAqL1xuXG5mbGFncy5mb3JFYWNoKGZ1bmN0aW9uKGZsYWcpe1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU29ja2V0LnByb3RvdHlwZSwgZmxhZywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmZsYWdzW2ZsYWddID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG59KTtcblxuLyoqXG4gKiBgcmVxdWVzdGAgZW5naW5lLmlvIHNob3J0Y3V0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvY2tldC5wcm90b3R5cGUsICdyZXF1ZXN0Jywge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvbm4ucmVxdWVzdDtcbiAgfVxufSk7XG5cbi8qKlxuICogQnVpbGRzIHRoZSBgaGFuZHNoYWtlYCBCQyBvYmplY3RcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmJ1aWxkSGFuZHNoYWtlID0gZnVuY3Rpb24ocXVlcnkpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGZ1bmN0aW9uIGJ1aWxkUXVlcnkoKXtcbiAgICB2YXIgcmVxdWVzdFF1ZXJ5ID0gdXJsLnBhcnNlKHNlbGYucmVxdWVzdC51cmwsIHRydWUpLnF1ZXJ5O1xuICAgIC8vaWYgc29ja2V0LXNwZWNpZmljIHF1ZXJ5IGV4aXN0LCByZXBsYWNlIHF1ZXJ5IHN0cmluZ3MgaW4gcmVxdWVzdFF1ZXJ5XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHF1ZXJ5LCByZXF1ZXN0UXVlcnkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgaGVhZGVyczogdGhpcy5yZXF1ZXN0LmhlYWRlcnMsXG4gICAgdGltZTogKG5ldyBEYXRlKSArICcnLFxuICAgIGFkZHJlc3M6IHRoaXMuY29ubi5yZW1vdGVBZGRyZXNzLFxuICAgIHhkb21haW46ICEhdGhpcy5yZXF1ZXN0LmhlYWRlcnMub3JpZ2luLFxuICAgIHNlY3VyZTogISF0aGlzLnJlcXVlc3QuY29ubmVjdGlvbi5lbmNyeXB0ZWQsXG4gICAgaXNzdWVkOiArKG5ldyBEYXRlKSxcbiAgICB1cmw6IHRoaXMucmVxdWVzdC51cmwsXG4gICAgcXVlcnk6IGJ1aWxkUXVlcnkoKVxuICB9O1xufTtcblxuLyoqXG4gKiBFbWl0cyB0byB0aGlzIGNsaWVudC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXYpe1xuICBpZiAofmV4cG9ydHMuZXZlbnRzLmluZGV4T2YoZXYpKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICB2YXIgcGFja2V0ID0ge1xuICAgIHR5cGU6ICh0aGlzLmZsYWdzLmJpbmFyeSAhPT0gdW5kZWZpbmVkID8gdGhpcy5mbGFncy5iaW5hcnkgOiBoYXNCaW4oYXJncykpID8gcGFyc2VyLkJJTkFSWV9FVkVOVCA6IHBhcnNlci5FVkVOVCxcbiAgICBkYXRhOiBhcmdzXG4gIH07XG5cbiAgLy8gYWNjZXNzIGxhc3QgYXJndW1lbnQgdG8gc2VlIGlmIGl0J3MgYW4gQUNLIGNhbGxiYWNrXG4gIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHRoaXMuX3Jvb21zLmxlbmd0aCB8fCB0aGlzLmZsYWdzLmJyb2FkY2FzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsYmFja3MgYXJlIG5vdCBzdXBwb3J0ZWQgd2hlbiBicm9hZGNhc3RpbmcnKTtcbiAgICB9XG5cbiAgICBkZWJ1ZygnZW1pdHRpbmcgcGFja2V0IHdpdGggYWNrIGlkICVkJywgdGhpcy5uc3AuaWRzKTtcbiAgICB0aGlzLmFja3NbdGhpcy5uc3AuaWRzXSA9IGFyZ3MucG9wKCk7XG4gICAgcGFja2V0LmlkID0gdGhpcy5uc3AuaWRzKys7XG4gIH1cblxuICB2YXIgcm9vbXMgPSB0aGlzLl9yb29tcy5zbGljZSgwKTtcbiAgdmFyIGZsYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5mbGFncyk7XG5cbiAgLy8gcmVzZXQgZmxhZ3NcbiAgdGhpcy5fcm9vbXMgPSBbXTtcbiAgdGhpcy5mbGFncyA9IHt9O1xuXG4gIGlmIChyb29tcy5sZW5ndGggfHwgZmxhZ3MuYnJvYWRjYXN0KSB7XG4gICAgdGhpcy5hZGFwdGVyLmJyb2FkY2FzdChwYWNrZXQsIHtcbiAgICAgIGV4Y2VwdDogW3RoaXMuaWRdLFxuICAgICAgcm9vbXM6IHJvb21zLFxuICAgICAgZmxhZ3M6IGZsYWdzXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlzcGF0Y2ggcGFja2V0XG4gICAgdGhpcy5wYWNrZXQocGFja2V0LCBmbGFncyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRhcmdldHMgYSByb29tIHdoZW4gYnJvYWRjYXN0aW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS50byA9XG5Tb2NrZXQucHJvdG90eXBlLmluID0gZnVuY3Rpb24obmFtZSl7XG4gIGlmICghfnRoaXMuX3Jvb21zLmluZGV4T2YobmFtZSkpIHRoaXMuX3Jvb21zLnB1c2gobmFtZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kID1cblNvY2tldC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbigpe1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gIGFyZ3MudW5zaGlmdCgnbWVzc2FnZScpO1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIG9wdGlvbnNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBvcHRzKXtcbiAgcGFja2V0Lm5zcCA9IHRoaXMubnNwLm5hbWU7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBvcHRzLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdHMuY29tcHJlc3M7XG4gIHRoaXMuY2xpZW50LnBhY2tldChwYWNrZXQsIG9wdHMpO1xufTtcblxuLyoqXG4gKiBKb2lucyBhIHJvb20uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHJvb20gb3IgYXJyYXkgb2Ygcm9vbXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIG9wdGlvbmFsLCBjYWxsYmFja1xuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbihyb29tcywgZm4pe1xuICBkZWJ1Zygnam9pbmluZyByb29tICVzJywgcm9vbXMpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICghQXJyYXkuaXNBcnJheShyb29tcykpIHtcbiAgICByb29tcyA9IFtyb29tc107XG4gIH1cbiAgcm9vbXMgPSByb29tcy5maWx0ZXIoZnVuY3Rpb24gKHJvb20pIHtcbiAgICByZXR1cm4gIXNlbGYucm9vbXMuaGFzT3duUHJvcGVydHkocm9vbSk7XG4gIH0pO1xuICBpZiAoIXJvb21zLmxlbmd0aCkge1xuICAgIGZuICYmIGZuKG51bGwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMuYWRhcHRlci5hZGRBbGwodGhpcy5pZCwgcm9vbXMsIGZ1bmN0aW9uKGVycil7XG4gICAgaWYgKGVycikgcmV0dXJuIGZuICYmIGZuKGVycik7XG4gICAgZGVidWcoJ2pvaW5lZCByb29tICVzJywgcm9vbXMpO1xuICAgIHJvb21zLmZvckVhY2goZnVuY3Rpb24gKHJvb20pIHtcbiAgICAgIHNlbGYucm9vbXNbcm9vbV0gPSByb29tO1xuICAgIH0pO1xuICAgIGZuICYmIGZuKG51bGwpO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIExlYXZlcyBhIHJvb20uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJvb21cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIG9wdGlvbmFsLCBjYWxsYmFja1xuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmxlYXZlID0gZnVuY3Rpb24ocm9vbSwgZm4pe1xuICBkZWJ1ZygnbGVhdmUgcm9vbSAlcycsIHJvb20pO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuYWRhcHRlci5kZWwodGhpcy5pZCwgcm9vbSwgZnVuY3Rpb24oZXJyKXtcbiAgICBpZiAoZXJyKSByZXR1cm4gZm4gJiYgZm4oZXJyKTtcbiAgICBkZWJ1ZygnbGVmdCByb29tICVzJywgcm9vbSk7XG4gICAgZGVsZXRlIHNlbGYucm9vbXNbcm9vbV07XG4gICAgZm4gJiYgZm4obnVsbCk7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTGVhdmUgYWxsIHJvb21zLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUubGVhdmVBbGwgPSBmdW5jdGlvbigpe1xuICB0aGlzLmFkYXB0ZXIuZGVsQWxsKHRoaXMuaWQpO1xuICB0aGlzLnJvb21zID0ge307XG59O1xuXG4vKipcbiAqIENhbGxlZCBieSBgTmFtZXNwYWNlYCB1cG9uIHN1Y2Nlc3NmdWxcbiAqIG1pZGRsZXdhcmUgZXhlY3V0aW9uIChpZTogYXV0aG9yaXphdGlvbikuXG4gKiBTb2NrZXQgaXMgYWRkZWQgdG8gbmFtZXNwYWNlIGFycmF5IGJlZm9yZVxuICogY2FsbCB0byBqb2luLCBzbyBhZGFwdGVycyBjYW4gYWNjZXNzIGl0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25jb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3NvY2tldCBjb25uZWN0ZWQgLSB3cml0aW5nIHBhY2tldCcpO1xuICB0aGlzLm5zcC5jb25uZWN0ZWRbdGhpcy5pZF0gPSB0aGlzO1xuICB0aGlzLmpvaW4odGhpcy5pZCk7XG4gIHZhciBza2lwID0gdGhpcy5uc3AubmFtZSA9PT0gJy8nICYmIHRoaXMubnNwLmZucy5sZW5ndGggPT09IDA7XG4gIGlmIChza2lwKSB7XG4gICAgZGVidWcoJ3BhY2tldCBhbHJlYWR5IHNlbnQgaW4gaW5pdGlhbCBoYW5kc2hha2UnKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5DT05ORUNUIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGVhY2ggcGFja2V0LiBDYWxsZWQgYnkgYENsaWVudGAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbnBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIGRlYnVnKCdnb3QgcGFja2V0ICVqJywgcGFja2V0KTtcbiAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgIGNhc2UgcGFyc2VyLkVWRU5UOlxuICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5BQ0s6XG4gICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9BQ0s6XG4gICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkRJU0NPTk5FQ1Q6XG4gICAgICB0aGlzLm9uZGlzY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FUlJPUjpcbiAgICAgIHRoaXMub25lcnJvcihuZXcgRXJyb3IocGFja2V0LmRhdGEpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBldmVudCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCBvYmplY3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25ldmVudCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIHZhciBhcmdzID0gcGFja2V0LmRhdGEgfHwgW107XG4gIGRlYnVnKCdlbWl0dGluZyBldmVudCAlaicsIGFyZ3MpO1xuXG4gIGlmIChudWxsICE9IHBhY2tldC5pZCkge1xuICAgIGRlYnVnKCdhdHRhY2hpbmcgYWNrIGNhbGxiYWNrIHRvIGV2ZW50Jyk7XG4gICAgYXJncy5wdXNoKHRoaXMuYWNrKHBhY2tldC5pZCkpO1xuICB9XG5cbiAgdGhpcy5kaXNwYXRjaChhcmdzKTtcbn07XG5cbi8qKlxuICogUHJvZHVjZXMgYW4gYWNrIGNhbGxiYWNrIHRvIGVtaXQgd2l0aCBhbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaWQgcGFja2V0IGlkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmFjayA9IGZ1bmN0aW9uKGlkKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2VudCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAvLyBwcmV2ZW50IGRvdWJsZSBjYWxsYmFja3NcbiAgICBpZiAoc2VudCkgcmV0dXJuO1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBkZWJ1Zygnc2VuZGluZyBhY2sgJWonLCBhcmdzKTtcblxuICAgIHNlbGYucGFja2V0KHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHR5cGU6IGhhc0JpbihhcmdzKSA/IHBhcnNlci5CSU5BUllfQUNLIDogcGFyc2VyLkFDSyxcbiAgICAgIGRhdGE6IGFyZ3NcbiAgICB9KTtcblxuICAgIHNlbnQgPSB0cnVlO1xuICB9O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhY2sgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25hY2sgPSBmdW5jdGlvbihwYWNrZXQpe1xuICB2YXIgYWNrID0gdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBhY2spIHtcbiAgICBkZWJ1ZygnY2FsbGluZyBhY2sgJXMgd2l0aCAlaicsIHBhY2tldC5pZCwgcGFja2V0LmRhdGEpO1xuICAgIGFjay5hcHBseSh0aGlzLCBwYWNrZXQuZGF0YSk7XG4gICAgZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdiYWQgYWNrICVzJywgcGFja2V0LmlkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbGllbnQgZGlzY29ubmVjdCBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBkZWJ1ZygnZ290IGRpc2Nvbm5lY3QgcGFja2V0Jyk7XG4gIHRoaXMub25jbG9zZSgnY2xpZW50IG5hbWVzcGFjZSBkaXNjb25uZWN0Jyk7XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgYSBjbGllbnQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmVycm9yID0gZnVuY3Rpb24oZXJyKXtcbiAgaWYgKHRoaXMubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCkge1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoJ01pc3NpbmcgZXJyb3IgaGFuZGxlciBvbiBgc29ja2V0YC4nKTtcbiAgICBjb25zb2xlLmVycm9yKGVyci5zdGFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gY2xvc2luZy4gQ2FsbGVkIGJ5IGBDbGllbnRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb25cbiAqIEB0aHJvdyB7RXJyb3J9IG9wdGlvbmFsIGVycm9yIG9iamVjdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24ocmVhc29uKXtcbiAgaWYgKCF0aGlzLmNvbm5lY3RlZCkgcmV0dXJuIHRoaXM7XG4gIGRlYnVnKCdjbG9zaW5nIHNvY2tldCAtIHJlYXNvbiAlcycsIHJlYXNvbik7XG4gIHRoaXMuZW1pdCgnZGlzY29ubmVjdGluZycsIHJlYXNvbik7XG4gIHRoaXMubGVhdmVBbGwoKTtcbiAgdGhpcy5uc3AucmVtb3ZlKHRoaXMpO1xuICB0aGlzLmNsaWVudC5yZW1vdmUodGhpcyk7XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgZGVsZXRlIHRoaXMubnNwLmNvbm5lY3RlZFt0aGlzLmlkXTtcbiAgdGhpcy5lbWl0KCdkaXNjb25uZWN0JywgcmVhc29uKTtcbn07XG5cbi8qKlxuICogUHJvZHVjZXMgYW4gYGVycm9yYCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGVyciBlcnJvciBvYmplY3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbihlcnIpe1xuICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5FUlJPUiwgZGF0YTogZXJyIH0pO1xufTtcblxuLyoqXG4gKiBEaXNjb25uZWN0cyB0aGlzIGNsaWVudC5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNsb3NlIGlmIGB0cnVlYCwgY2xvc2VzIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb25cbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbihjbG9zZSl7XG4gIGlmICghdGhpcy5jb25uZWN0ZWQpIHJldHVybiB0aGlzO1xuICBpZiAoY2xvc2UpIHtcbiAgICB0aGlzLmNsaWVudC5kaXNjb25uZWN0KCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuRElTQ09OTkVDVCB9KTtcbiAgICB0aGlzLm9uY2xvc2UoJ3NlcnZlciBuYW1lc3BhY2UgZGlzY29ubmVjdCcpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY29tcHJlc3MgaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNvbXByZXNzID0gZnVuY3Rpb24oY29tcHJlc3Mpe1xuICB0aGlzLmZsYWdzLmNvbXByZXNzID0gY29tcHJlc3M7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBiaW5hcnkgZmxhZ1xuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gRW5jb2RlIGFzIGlmIGl0IGhhcyBiaW5hcnkgZGF0YSBpZiBgdHJ1ZWAsIEVuY29kZSBhcyBpZiBpdCBkb2VzbnQgaGF2ZSBiaW5hcnkgZGF0YSBpZiBgZmFsc2VgXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuIFNvY2tldC5wcm90b3R5cGUuYmluYXJ5ID0gZnVuY3Rpb24gKGJpbmFyeSkge1xuICAgdGhpcy5mbGFncy5iaW5hcnkgPSBiaW5hcnk7XG4gICByZXR1cm4gdGhpcztcbiB9O1xuXG4vKipcbiAqIERpc3BhdGNoIGluY29taW5nIGV2ZW50IHRvIHNvY2tldCBsaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZXZlbnQgdGhhdCB3aWxsIGdldCBlbWl0dGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24oZXZlbnQpe1xuICBkZWJ1ZygnZGlzcGF0Y2hpbmcgYW4gZXZlbnQgJWonLCBldmVudCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZnVuY3Rpb24gZGlzcGF0Y2hTb2NrZXQoZXJyKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpe1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gc2VsZi5lcnJvcihlcnIuZGF0YSB8fCBlcnIubWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBlbWl0LmFwcGx5KHNlbGYsIGV2ZW50KTtcbiAgICB9KTtcbiAgfVxuICB0aGlzLnJ1bihldmVudCwgZGlzcGF0Y2hTb2NrZXQpO1xufTtcblxuLyoqXG4gKiBTZXRzIHVwIHNvY2tldCBtaWRkbGV3YXJlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1pZGRsZXdhcmUgZnVuY3Rpb24gKGV2ZW50LCBuZXh0KVxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24oZm4pe1xuICB0aGlzLmZucy5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBtaWRkbGV3YXJlIGZvciBhbiBpbmNvbWluZyBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBldmVudCB0aGF0IHdpbGwgZ2V0IGVtaXR0ZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxhc3QgZm4gY2FsbCBpbiB0aGUgbWlkZGxld2FyZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblNvY2tldC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdmFyIGZucyA9IHRoaXMuZm5zLnNsaWNlKDApO1xuICBpZiAoIWZucy5sZW5ndGgpIHJldHVybiBmbihudWxsKTtcblxuICBmdW5jdGlvbiBydW4oaSl7XG4gICAgZm5zW2ldKGV2ZW50LCBmdW5jdGlvbihlcnIpe1xuICAgICAgLy8gdXBvbiBlcnJvciwgc2hvcnQtY2lyY3VpdFxuICAgICAgaWYgKGVycikgcmV0dXJuIGZuKGVycik7XG5cbiAgICAgIC8vIGlmIG5vIG1pZGRsZXdhcmUgbGVmdCwgc3VtbW9uIGNhbGxiYWNrXG4gICAgICBpZiAoIWZuc1tpICsgMV0pIHJldHVybiBmbihudWxsKTtcblxuICAgICAgLy8gZ28gb24gdG8gbmV4dFxuICAgICAgcnVuKGkgKyAxKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bigwKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vbGliL3NvY2tldC5qc1xuLy8gbW9kdWxlIGlkID0gMTg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgTmFtZXNwYWNlID0gcmVxdWlyZSgnLi9uYW1lc3BhY2UnKTtcblxubGV0IGNvdW50ID0gMDtcblxuY2xhc3MgUGFyZW50TmFtZXNwYWNlIGV4dGVuZHMgTmFtZXNwYWNlIHtcblxuICBjb25zdHJ1Y3RvcihzZXJ2ZXIpIHtcbiAgICBzdXBlcihzZXJ2ZXIsICcvXycgKyAoY291bnQrKykpO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgU2V0KCk7XG4gIH1cblxuICBpbml0QWRhcHRlcigpIHt9XG5cbiAgZW1pdCgpIHtcbiAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChuc3AgPT4ge1xuICAgICAgbnNwLnJvb21zID0gdGhpcy5yb29tcztcbiAgICAgIG5zcC5mbGFncyA9IHRoaXMuZmxhZ3M7XG4gICAgICBuc3AuZW1pdC5hcHBseShuc3AsIGFyZ3MpO1xuICAgIH0pO1xuICAgIHRoaXMucm9vbXMgPSBbXTtcbiAgICB0aGlzLmZsYWdzID0ge307XG4gIH1cblxuICBjcmVhdGVDaGlsZChuYW1lKSB7XG4gICAgY29uc3QgbmFtZXNwYWNlID0gbmV3IE5hbWVzcGFjZSh0aGlzLnNlcnZlciwgbmFtZSk7XG4gICAgbmFtZXNwYWNlLmZucyA9IHRoaXMuZm5zLnNsaWNlKDApO1xuICAgIHRoaXMubGlzdGVuZXJzKCdjb25uZWN0JykuZm9yRWFjaChsaXN0ZW5lciA9PiBuYW1lc3BhY2Uub24oJ2Nvbm5lY3QnLCBsaXN0ZW5lcikpO1xuICAgIHRoaXMubGlzdGVuZXJzKCdjb25uZWN0aW9uJykuZm9yRWFjaChsaXN0ZW5lciA9PiBuYW1lc3BhY2Uub24oJ2Nvbm5lY3Rpb24nLCBsaXN0ZW5lcikpO1xuICAgIHRoaXMuY2hpbGRyZW4uYWRkKG5hbWVzcGFjZSk7XG4gICAgdGhpcy5zZXJ2ZXIubnNwc1tuYW1lXSA9IG5hbWVzcGFjZTtcbiAgICByZXR1cm4gbmFtZXNwYWNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGFyZW50TmFtZXNwYWNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2xpYi9wYXJlbnQtbmFtZXNwYWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBBZGFwdGVyO1xuXG4vKipcbiAqIE1lbW9yeSBhZGFwdGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7TmFtZXNwYWNlfSBuc3BcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gQWRhcHRlcihuc3Ape1xuICB0aGlzLm5zcCA9IG5zcDtcbiAgdGhpcy5yb29tcyA9IHt9O1xuICB0aGlzLnNpZHMgPSB7fTtcbiAgdGhpcy5lbmNvZGVyID0gbnNwLnNlcnZlci5lbmNvZGVyO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gYEV2ZW50RW1pdHRlcmAuXG4gKi9cblxuQWRhcHRlci5wcm90b3R5cGUuX19wcm90b19fID0gRW1pdHRlci5wcm90b3R5cGU7XG5cbi8qKlxuICogQWRkcyBhIHNvY2tldCB0byBhIHJvb20uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNvY2tldCBpZFxuICogQHBhcmFtIHtTdHJpbmd9IHJvb20gbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWRhcHRlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oaWQsIHJvb20sIGZuKXtcbiAgcmV0dXJuIHRoaXMuYWRkQWxsKGlkLCBbIHJvb20gXSwgZm4pO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgc29ja2V0IHRvIGEgbGlzdCBvZiByb29tLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzb2NrZXQgaWRcbiAqIEBwYXJhbSB7U3RyaW5nfSByb29tc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWRhcHRlci5wcm90b3R5cGUuYWRkQWxsID0gZnVuY3Rpb24oaWQsIHJvb21zLCBmbil7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vbXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcm9vbSA9IHJvb21zW2ldO1xuICAgIHRoaXMuc2lkc1tpZF0gPSB0aGlzLnNpZHNbaWRdIHx8IHt9O1xuICAgIHRoaXMuc2lkc1tpZF1bcm9vbV0gPSB0cnVlO1xuICAgIHRoaXMucm9vbXNbcm9vbV0gPSB0aGlzLnJvb21zW3Jvb21dIHx8IFJvb20oKTtcbiAgICB0aGlzLnJvb21zW3Jvb21dLmFkZChpZCk7XG4gIH1cbiAgaWYgKGZuKSBwcm9jZXNzLm5leHRUaWNrKGZuLmJpbmQobnVsbCwgbnVsbCkpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgc29ja2V0IGZyb20gYSByb29tLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzb2NrZXQgaWRcbiAqIEBwYXJhbSB7U3RyaW5nfSByb29tIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFkYXB0ZXIucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uKGlkLCByb29tLCBmbil7XG4gIHRoaXMuc2lkc1tpZF0gPSB0aGlzLnNpZHNbaWRdIHx8IHt9O1xuICBkZWxldGUgdGhpcy5zaWRzW2lkXVtyb29tXTtcbiAgaWYgKHRoaXMucm9vbXMuaGFzT3duUHJvcGVydHkocm9vbSkpIHtcbiAgICB0aGlzLnJvb21zW3Jvb21dLmRlbChpZCk7XG4gICAgaWYgKHRoaXMucm9vbXNbcm9vbV0ubGVuZ3RoID09PSAwKSBkZWxldGUgdGhpcy5yb29tc1tyb29tXTtcbiAgfVxuXG4gIGlmIChmbikgcHJvY2Vzcy5uZXh0VGljayhmbi5iaW5kKG51bGwsIG51bGwpKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIHNvY2tldCBmcm9tIGFsbCByb29tcyBpdCdzIGpvaW5lZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc29ja2V0IGlkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZGFwdGVyLnByb3RvdHlwZS5kZWxBbGwgPSBmdW5jdGlvbihpZCwgZm4pe1xuICB2YXIgcm9vbXMgPSB0aGlzLnNpZHNbaWRdO1xuICBpZiAocm9vbXMpIHtcbiAgICBmb3IgKHZhciByb29tIGluIHJvb21zKSB7XG4gICAgICBpZiAodGhpcy5yb29tcy5oYXNPd25Qcm9wZXJ0eShyb29tKSkge1xuICAgICAgICB0aGlzLnJvb21zW3Jvb21dLmRlbChpZCk7XG4gICAgICAgIGlmICh0aGlzLnJvb21zW3Jvb21dLmxlbmd0aCA9PT0gMCkgZGVsZXRlIHRoaXMucm9vbXNbcm9vbV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlbGV0ZSB0aGlzLnNpZHNbaWRdO1xuXG4gIGlmIChmbikgcHJvY2Vzcy5uZXh0VGljayhmbi5iaW5kKG51bGwsIG51bGwpKTtcbn07XG5cbi8qKlxuICogQnJvYWRjYXN0cyBhIHBhY2tldC5cbiAqXG4gKiBPcHRpb25zOlxuICogIC0gYGZsYWdzYCB7T2JqZWN0fSBmbGFncyBmb3IgdGhpcyBwYWNrZXRcbiAqICAtIGBleGNlcHRgIHtBcnJheX0gc2lkcyB0aGF0IHNob3VsZCBiZSBleGNsdWRlZFxuICogIC0gYHJvb21zYCB7QXJyYXl9IGxpc3Qgb2Ygcm9vbXMgdG8gYnJvYWRjYXN0IHRvXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCBvYmplY3RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWRhcHRlci5wcm90b3R5cGUuYnJvYWRjYXN0ID0gZnVuY3Rpb24ocGFja2V0LCBvcHRzKXtcbiAgdmFyIHJvb21zID0gb3B0cy5yb29tcyB8fCBbXTtcbiAgdmFyIGV4Y2VwdCA9IG9wdHMuZXhjZXB0IHx8IFtdO1xuICB2YXIgZmxhZ3MgPSBvcHRzLmZsYWdzIHx8IHt9O1xuICB2YXIgcGFja2V0T3B0cyA9IHtcbiAgICBwcmVFbmNvZGVkOiB0cnVlLFxuICAgIHZvbGF0aWxlOiBmbGFncy52b2xhdGlsZSxcbiAgICBjb21wcmVzczogZmxhZ3MuY29tcHJlc3NcbiAgfTtcbiAgdmFyIGlkcyA9IHt9O1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzb2NrZXQ7XG5cbiAgcGFja2V0Lm5zcCA9IHRoaXMubnNwLm5hbWU7XG4gIHRoaXMuZW5jb2Rlci5lbmNvZGUocGFja2V0LCBmdW5jdGlvbihlbmNvZGVkUGFja2V0cykge1xuICAgIGlmIChyb29tcy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJvb20gPSBzZWxmLnJvb21zW3Jvb21zW2ldXTtcbiAgICAgICAgaWYgKCFyb29tKSBjb250aW51ZTtcbiAgICAgICAgdmFyIHNvY2tldHMgPSByb29tLnNvY2tldHM7XG4gICAgICAgIGZvciAodmFyIGlkIGluIHNvY2tldHMpIHtcbiAgICAgICAgICBpZiAoc29ja2V0cy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgIGlmIChpZHNbaWRdIHx8IH5leGNlcHQuaW5kZXhPZihpZCkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgc29ja2V0ID0gc2VsZi5uc3AuY29ubmVjdGVkW2lkXTtcbiAgICAgICAgICAgIGlmIChzb2NrZXQpIHtcbiAgICAgICAgICAgICAgc29ja2V0LnBhY2tldChlbmNvZGVkUGFja2V0cywgcGFja2V0T3B0cyk7XG4gICAgICAgICAgICAgIGlkc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpZCBpbiBzZWxmLnNpZHMpIHtcbiAgICAgICAgaWYgKHNlbGYuc2lkcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICBpZiAofmV4Y2VwdC5pbmRleE9mKGlkKSkgY29udGludWU7XG4gICAgICAgICAgc29ja2V0ID0gc2VsZi5uc3AuY29ubmVjdGVkW2lkXTtcbiAgICAgICAgICBpZiAoc29ja2V0KSBzb2NrZXQucGFja2V0KGVuY29kZWRQYWNrZXRzLCBwYWNrZXRPcHRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldHMgYSBsaXN0IG9mIGNsaWVudHMgYnkgc2lkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGV4cGxpY2l0IHNldCBvZiByb29tcyB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFkYXB0ZXIucHJvdG90eXBlLmNsaWVudHMgPSBmdW5jdGlvbihyb29tcywgZm4pe1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygcm9vbXMpe1xuICAgIGZuID0gcm9vbXM7XG4gICAgcm9vbXMgPSBudWxsO1xuICB9XG5cbiAgcm9vbXMgPSByb29tcyB8fCBbXTtcblxuICB2YXIgaWRzID0ge307XG4gIHZhciBzaWRzID0gW107XG4gIHZhciBzb2NrZXQ7XG5cbiAgaWYgKHJvb21zLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByb29tID0gdGhpcy5yb29tc1tyb29tc1tpXV07XG4gICAgICBpZiAoIXJvb20pIGNvbnRpbnVlO1xuICAgICAgdmFyIHNvY2tldHMgPSByb29tLnNvY2tldHM7XG4gICAgICBmb3IgKHZhciBpZCBpbiBzb2NrZXRzKSB7XG4gICAgICAgIGlmIChzb2NrZXRzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIGlmIChpZHNbaWRdKSBjb250aW51ZTtcbiAgICAgICAgICBzb2NrZXQgPSB0aGlzLm5zcC5jb25uZWN0ZWRbaWRdO1xuICAgICAgICAgIGlmIChzb2NrZXQpIHtcbiAgICAgICAgICAgIHNpZHMucHVzaChpZCk7XG4gICAgICAgICAgICBpZHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaWQgaW4gdGhpcy5zaWRzKSB7XG4gICAgICBpZiAodGhpcy5zaWRzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICBzb2NrZXQgPSB0aGlzLm5zcC5jb25uZWN0ZWRbaWRdO1xuICAgICAgICBpZiAoc29ja2V0KSBzaWRzLnB1c2goaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChmbikgcHJvY2Vzcy5uZXh0VGljayhmbi5iaW5kKG51bGwsIG51bGwsIHNpZHMpKTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBvZiByb29tcyBhIGdpdmVuIGNsaWVudCBoYXMgam9pbmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzb2NrZXQgaWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHB1YmxpY1xuICovXG5BZGFwdGVyLnByb3RvdHlwZS5jbGllbnRSb29tcyA9IGZ1bmN0aW9uKGlkLCBmbil7XG4gIHZhciByb29tcyA9IHRoaXMuc2lkc1tpZF07XG4gIGlmIChmbikgcHJvY2Vzcy5uZXh0VGljayhmbi5iaW5kKG51bGwsIG51bGwsIHJvb21zID8gT2JqZWN0LmtleXMocm9vbXMpIDogbnVsbCkpO1xufTtcblxuLyoqXG4qIFJvb20gY29uc3RydWN0b3IuXG4qXG4qIEBhcGkgcHJpdmF0ZVxuKi9cblxuZnVuY3Rpb24gUm9vbSgpe1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUm9vbSkpIHJldHVybiBuZXcgUm9vbSgpO1xuICB0aGlzLnNvY2tldHMgPSB7fTtcbiAgdGhpcy5sZW5ndGggPSAwO1xufVxuXG4vKipcbiAqIEFkZHMgYSBzb2NrZXQgdG8gYSByb29tLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzb2NrZXQgaWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJvb20ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGlkKXtcbiAgaWYgKCF0aGlzLnNvY2tldHMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgdGhpcy5zb2NrZXRzW2lkXSA9IHRydWU7XG4gICAgdGhpcy5sZW5ndGgrKztcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgc29ja2V0IGZyb20gYSByb29tLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzb2NrZXQgaWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJvb20ucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uKGlkKXtcbiAgaWYgKHRoaXMuc29ja2V0cy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICBkZWxldGUgdGhpcy5zb2NrZXRzW2lkXTtcbiAgICB0aGlzLmxlbmd0aC0tO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiB3ZWJwYWNrRW1wdHlDb250ZXh0KHJlcSkge1xuXHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInLlwiKTtcbn1cbndlYnBhY2tFbXB0eUNvbnRleHQua2V5cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH07XG53ZWJwYWNrRW1wdHlDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrRW1wdHlDb250ZXh0O1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrRW1wdHlDb250ZXh0O1xud2VicGFja0VtcHR5Q29udGV4dC5pZCA9IDE4OTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vbGliXG4vLyBtb2R1bGUgaWQgPSAxODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==